<goal>
 How can we make it so that the camera is kinda 
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── config.yml
    ├── package.json
    ├── public/
    │   ├── css/
    │   │   └── style.css
    │   ├── index.html
    │   ├── js/
    │   │   ├── bullet.js
    │   │   ├── effects.js
    │   │   ├── input.js
    │   │   ├── main.js
    │   │   ├── multiplayerManager.js
    │   │   ├── network.js
    │   │   ├── physics.js
    │   │   ├── player.js
    │   │   ├── playerModel.js
    │   │   ├── quickDraw.js
    │   │   ├── revolver.js
    │   │   ├── scene.js
    │   │   ├── smokeRingEffect.js
    │   │   ├── soundManager.js
    │   │   └── ui.js
    │   ├── models/
    │   │   ├── lowpolygun.glb
    │   │   ├── town.glb
    │   │   └── tpose.glb
    │   └── sounds/
    └── server.js

================================================
File: /config.yml
================================================
version: "3"
credentials-file: "C:\\Users\\erase\\.cloudflared\\5615d921-4c2e-4d70-affd-8696de48a673.json"

ingress:
  # This rule forwards all requests from the tunnel hostname to the local Express server.
  - hostname: tunnel.oneclickwaitlist.com
    path: /
    service: http://localhost:8080
    originRequest:
      connectTimeout: 10s
      noTLSVerify: true
      proxyAddress: ""
      proxyPort: 0
      proxyType: ""
      kernelSocketOptions:
        - mark: 0
        - keepalive: true
      wsTunneling: true
      http2Origin: false
      httpHostHeader: "tunnel.oneclickwaitlist.com"
      disableChunkedEncoding: false

  # Fallback rule: returns 503 if no other rule matches.
  - service: http_status:503

origincert: "C:\\Users\\erase\\.cloudflared\\cert.pem"


================================================
File: /package.json
================================================
{
  "name": "wild-western-shooter",
  "version": "1.0.0",
  "description": "A Three.js Wild Western Shooter game with a Node.js server.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.13.0",
    "ngrok": "^4.3.3",
    "cannon": "^0.6.2"
  }
}

================================================
File: /public/css/style.css
================================================
/* Add this at the top to ensure proper fullscreen */
*, *::before, *::after {
  box-sizing: border-box;
}

body, html {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: #000;
  font-family: 'Courier New', Courier, monospace;
  /* Ensure the canvas extends to the edge of the screen */
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #000;
}

canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100% !important;
  height: 100% !important;
  margin: 0;
  padding: 0;
  display: block;
  background-color: #000;
}

#ammo-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
}
#reload-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  display: none;
}
#reload-progress-container {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-progress-bar {
  height: 100%;
  width: 0%;
  background-color: #FF6B00;
  border-radius: 10px;
  transition: width 0.05s linear;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80px;
  height: 80px;
  display: none; /* Will be controlled by JavaScript */
  pointer-events: none;
  z-index: 100;
  will-change: transform, opacity;
}

#crosshair svg {
  width: 100%;
  height: 100%;
}

/* Corner group style and transforms */
.corner-group {
  transform-origin: 50px 50px;
  opacity: 0;
  will-change: transform, opacity;
}

/* Center dot animation */
#crosshair circle {
  opacity: 0;
  will-change: opacity;
  transition: opacity 250ms cubic-bezier(0.2, 0.8, 0.2, 1);
}

#crosshair.expand circle {
  opacity: 1;
  transition-delay: 0ms; /* Fade in first */
}

#crosshair.expanded circle {
  opacity: 1;
}

#crosshair.contract circle {
  opacity: 0;
  transition-delay: 0ms; /* Immediate fade out instead of delayed */
}

/* Top corner animations */
@keyframes expand-top {
  0% {
    transform: translate(0, 35px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-top {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(0, 35px) scale(0);
    opacity: 0;
  }
}

/* Bottom left corner animations */
@keyframes expand-bottom-left {
  0% {
    transform: translate(30px, -25px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-bottom-left {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(30px, -25px) scale(0);
    opacity: 0;
  }
}

/* Bottom right corner animations */
@keyframes expand-bottom-right {
  0% {
    transform: translate(-30px, -25px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-bottom-right {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-30px, -25px) scale(0);
    opacity: 0;
  }
}

/* Apply specific animations to each corner */
#crosshair.expand #top-corner {
  animation: expand-top 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.expand #bottom-left-corner {
  animation: expand-bottom-left 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.expand #bottom-right-corner {
  animation: expand-bottom-right 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #top-corner {
  animation: contract-top 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #bottom-left-corner {
  animation: contract-bottom-left 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #bottom-right-corner {
  animation: contract-bottom-right 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

/* Set expanded state */
#crosshair.expanded #top-corner,
#crosshair.expanded #bottom-left-corner,
#crosshair.expanded #bottom-right-corner {
  opacity: 1;
  transform: translate(0, 0) scale(1);
}

/* Make all elements animate with the same timing function */
#crosshair path,
#crosshair g,
#crosshair circle {
  transition-property: opacity, transform;
  transition-duration: 250ms;
  transition-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
}

/* Ensure elements fade out when contract class is present */
#crosshair.contract circle {
  opacity: 0;
  transition-delay: 0ms; /* Immediate fade out instead of delayed */
}

/* Make corner groups start contracting before center dot fades */
#crosshair.contract #top-corner {
  animation-delay: 50ms !important; /* Delay to start after dot begins fading */
}

#crosshair.contract #bottom-left-corner {
  animation-delay: 70ms !important; /* Slightly more delay */
}

#crosshair.contract #bottom-right-corner {
  animation-delay: 70ms !important; /* Slightly more delay */
}

/* Individual delays for staggered animation */
#top-corner {
  animation-delay: 50ms !important; /* Delayed after center dot appears */
}

#bottom-left-corner {
  animation-delay: 80ms !important; /* Delayed after center dot appears */
}

#bottom-right-corner {
  animation-delay: 80ms !important; /* Delayed after center dot appears */
}

/* SVG Line styles */
#crosshair line {
  stroke-linecap: round;
  transform-box: fill-box;
  transform-origin: center;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}

/* Remove the above styles and add these instead */
#crosshair path {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Force hardware acceleration for smoother animations */
#crosshair, #crosshair svg, #crosshair g, #crosshair path, #crosshair circle {
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  -webkit-perspective: 1000;
  perspective: 1000;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}

#fps-counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#player-count {
  position: absolute;
  top: 50px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#connection-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#network-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
  transition: opacity 1s;
}

/* Quick Draw game mode styles */
#quick-draw-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 48px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  z-index: 1000;
}

#draw-circle {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 300px;
  height: 300px;
  border-radius: 50%;
  border: 8px solid #FF0000;
  box-shadow: 0 0 20px #FF0000;
  opacity: 0;
  transition: transform 0.3s, opacity 0.3s;
  pointer-events: none;
  z-index: 999;
  display: none;
}

@keyframes portalPulse {
  0% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1); opacity: 0.8; }
}

@keyframes drawCircleAnim {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
  80% { transform: translate(-50%, -50%) scale(3); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(4); opacity: 0; }
}

/* Mobile optimized smoke ring effect */
@keyframes drawCircleAnimMobile {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
  80% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.5; }
  100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
}

/* Super lightweight mobile animation - even less GPU intensive */
@keyframes drawCircleAnimMobileLite {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.6; }
  50% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
  100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}

.portal-animation {
  animation: portalPulse 2s infinite ease-in-out;
}

.draw-circle-animation {
  animation: drawCircleAnim 0.3s ease-out forwards;
}

.draw-circle-animation-mobile {
  animation: drawCircleAnimMobileLite 0.2s ease-out forwards;
}

/* Mobile-specific smoke ring */
@media (max-width: 1024px), (pointer: coarse) {
  #draw-circle {
    width: 150px;
    height: 150px;
    border-width: 4px;
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
  }
}

/* Styling for Quick Draw countdown */
#quick-draw-countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 72px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.7);
  z-index: 1001;
}

/* Styling for winner/loser message */
.quick-draw-winner {
  color: #4CAF50 !important;
  text-shadow: 0 0 10px #4CAF50, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

.quick-draw-loser {
  color: #F44336 !important;
  text-shadow: 0 0 10px #F44336, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

/* Styling for gun locked warning */
.gun-locked-warning {
  color: #F44336 !important;
  font-size: 36px !important;
  animation: flashWarning 0.5s infinite alternate;
}

@keyframes flashWarning {
  0% { opacity: 0.7; }
  100% { opacity: 1; }
}

#quick-draw-status {
  position: absolute;
  top: 120px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 8px 12px;
  border-radius: 5px;
  transition: background-color 0.3s ease;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#portal-instructions {
  position: absolute;
  background-color: rgba(0,0,0,0.8);
  border: 2px solid #FF6B00;
  border-radius: 8px;
  padding: 15px;
  width: 400px;
  text-align: center;
  box-shadow: 0 0 15px rgba(255, 107, 0, 0.6);
  color: #EEEEEE;
  font-family: 'Courier New', Courier, monospace;
  z-index: 100;
  transition: opacity 0.3s ease;
}

#portal-instructions h2 {
  color: #FF6B00;
  font-family: 'Western', 'Courier New', Courier, monospace;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
  margin-bottom: 10px;
  font-size: 22px;
}

#portal-instructions p {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.4;
}

#portal-instructions ul {
  text-align: left;
  margin-top: 10px;
  padding-left: 20px;
  font-size: 14px;
  line-height: 1.5;
}

#portal-instructions li {
  margin-bottom: 5px;
  list-style-type: square;
}

/* Lobby display for showing which arena the player is in */
#lobby-indicator {
  position: absolute;
  top: 150px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(255, 107, 0, 0.7);
  padding: 8px 12px;
  border-radius: 5px;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  display: none;
}

/* Fix font loading */
@font-face {
  font-family: 'Western';
  src: local('Georgia'), local('Times New Roman');
  font-weight: bold;
  font-style: normal;
}

/* Health counter styling */
#health-counter {
  display: none; /* Hide the problematic right UI panel */
}

/* Damage indicator (added dynamically) */
#damage-indicator {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: red;
  font-size: 48px;
  font-weight: bold;
  opacity: 0;
  text-shadow: 2px 2px 4px #000000;
  transition: opacity 0.3s ease-in, opacity 0.5s ease-out;
  z-index: 1000;
  pointer-events: none;
}

/* Different damage types */
.damage-headshot {
  color: #FF0000 !important;
  font-size: 64px !important;
}

.damage-body {
  color: #FF4500 !important;
}

.damage-limb {
  color: #FFA500 !important;
}

/* Health bar (alternative to text) */
#health-bar-container {
  display: none; /* Hide the health bar container as well */
}

/* Hit marker */
.hit-marker {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(45deg);
  pointer-events: none;
}

.hit-marker::before,
.hit-marker::after {
  content: '';
  position: absolute;
  background-color: white;
}

.hit-marker::before {
  width: 2px;
  height: 16px;
  left: 7px;
  top: 0;
}

.hit-marker::after {
  width: 8px;
  height: 2px;
  top: 7px;
  left: 4px;
}

/* Headshot marker */
.hit-marker-headshot::before,
.hit-marker-headshot::after {
  background-color: red;
}

/* Mobile support styles */
#touch-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 999;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}

.mobile-button {
  position: fixed;
  width: 90px;  /* Increased size */
  height: 90px;  /* Increased size */
  background-color: rgba(0, 0, 0, 0.6);  /* Slightly more opaque */
  border: 3px solid rgba(255, 255, 255, 0.7);  /* More visible border */
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size: 36px;  /* Larger font */
  z-index: 1000;
  touch-action: none;
  display: none;
  pointer-events: auto !important;
}

#shoot-button {
  bottom: 160px;
  left: 100px;  /* Moved further right as requested */
}

#jump-button {
  bottom: 160px;
  right: 100px;  /* Moved further left as requested */
}

/* Simulate visible joystick areas */
.control-hint {
  position: fixed;
  width: 150px; /* Increased from 120px */
  height: 150px; /* Increased from 120px */
  border-radius: 50%;
  border: 2px dashed rgba(255, 255, 255, 0.3);
  z-index: 999;
  pointer-events: none;
  display: none;
  background-color: rgba(255, 255, 255, 0.1);
}

#left-control-hint {
  bottom: 30px;
  left: 30px;
}

#right-control-hint {
  bottom: 30px;
  right: 30px;
}

#orientation-message {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.9);
  color: white;
  display: none;
  justify-content: center;
  align-items: center;
  font-size: 24px;
  text-align: center;
  z-index: 2000;
}

/* Only show mobile controls on mobile devices */
@media (max-width: 1024px), (pointer: coarse) {
  .mobile-button {
    display: block;
  }
  
  .control-hint {
    display: block;
  }
  
  #ammo-counter, #health-counter {
    font-size: 16px;
    padding: 8px;
    z-index: 1001; /* Ensure they appear above the touch overlay */
    max-width: 80px;
    text-align: center;
  }
  
  #health-counter {
    top: 10px;
    right: 10px;
    width: auto;
    left: auto;
    background-color: rgba(0, 0, 0, 0.7);
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 3px;
  }
  
  /* Hide all info banners and instructions on mobile */
  #fps-counter, #player-count, #connection-status, #network-status, 
  #quick-draw-status, #lobby-indicator, #portal-instructions,
  #reload-message, #quick-draw-message, #quick-draw-countdown,
  #proper-shootout-instructions {
    display: none !important;
  }
  
  /* Make ammo and health more visible but compact */
  #ammo-counter {
    bottom: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    font-weight: bold;
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 3px;
  }
  
  /* Adjust UI for landscape orientation on mobile */
  @media (orientation: landscape) {
    .mobile-button {
      height: 80px;  /* Adjusted for landscape */
      width: 80px;   /* Adjusted for landscape */
      font-size: 32px;
    }
    
    #shoot-button {
      bottom: 150px; /* Move upward from 130px */
      left: 90px;
    }
    
    #jump-button {
      bottom: 150px; /* Move upward from 130px */
      right: 90px;
    }
    
    /* Control hints (joystick indicators) */
    .control-hint {
      width: 120px;
      height: 120px;
    }
    
    #left-control-hint {
      bottom: 20px;
      left: 20px;
    }
    
    #right-control-hint {
      bottom: 20px;
      right: 20px;
    }
    
    /* Ensure crosshair is visible */
    #crosshair {
      z-index: 1500;
    }
    
    /* Simplify health display to prevent overflow */
    #health-counter {
      padding: 3px 5px;
      font-size: 12px;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 3px;
    }
  }
}

/* Force landscape for mobile - fix vertical bar issue */
@media (max-width: 1024px) and (orientation: portrait) {
  #game-container {
    transform: rotate(90deg);
    transform-origin: left top;
    width: 100vh;
    height: 100vw;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
  }
  
  /* Fix for systems with notches/home indicators */
  body {
    background-color: #000;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
  }
  
  /* Full screen canvas with proper alignment */
  canvas {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
  }
  
  /* Additional fix for the orientation wrapper */
  #orientation-message {
    transform: rotate(-90deg);
    width: 100vw;
    height: 100vh;
  }
}

/* Meta viewport tag doesn't allow scaling on mobiles, so add touch control */
@media (max-width: 1024px) {
  body {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    overflow: hidden;
    background-color: #000;
    /* Ensure no whitespace around edges */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
  }
  
  /* Ensure full screen coverage */
  #game-container {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: #000;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
  }
  
  canvas {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    object-fit: cover;
  }
  
  /* Make sure controls are responsive to touch */
  .mobile-button {
    touch-action: none;
    -webkit-touch-callout: none;
  }
  
  /* Prevent all portal instructions from showing */
  #portal-instructions,
  #proper-shootout-instructions,
  div[class*="portal-instructions"] {
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }
}

/* For landscape orientation */
@media (orientation: landscape) {
  .control-hint {
    width: 120px;
    height: 120px;
  }
}

================================================
File: /public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Wild Western FPS" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>Wild Western FPS – Multiplayer</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    /* Ensure fullscreen with no white bars */
    *, *::before, *::after {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ammo-counter">Bullets: 6/6</div>
    <div id="health-counter">Health: 100</div>
    <div id="reload-message">Hold R to reload</div>
    <div id="reload-progress-container">
      <div id="reload-progress-bar"></div>
    </div>
    <div id="crosshair">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
        <!-- Top corner group -->
        <g id="top-corner" class="corner-group">
          <path d="M45,20 L50,15 L55,20" fill="none" stroke="rgba(255, 255, 255, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Bottom left corner group -->
        <g id="bottom-left-corner" class="corner-group">
          <path d="M20,75 L25,75 M20,75 L20,70" fill="none" stroke="rgba(255, 255, 255, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Bottom right corner group -->
        <g id="bottom-right-corner" class="corner-group">
          <path d="M75,75 L80,75 M80,75 L80,70" fill="none" stroke="rgba(255, 255, 255, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Center dot -->
        <circle cx="50" cy="50" r="3" fill="rgba(255, 255, 255, 0.8)" />
      </svg>
    </div>
    <div id="fps-counter">FPS: 0</div>
    <div id="player-count">Players: 1</div>
    <div id="connection-status"></div>
  </div>

  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader for loading the GLB gun model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Cannon.js for physics (non-ES module version) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <!-- Main JS as ES6 module -->
  <script type="module" src="js/main.js"></script>
</body>
</html>

================================================
File: /public/js/bullet.js
================================================
import { createImpactEffect } from './effects.js';

/**
 * A bullet class with client-side prediction and server validation.
 * It lets the server have final authority on collisions and hits.
 */
export class Bullet {
  /**
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Normalized direction vector
   * @param {string|number} bulletId - Optional server-assigned bullet ID (for remote bullets)
   */
  constructor(position, direction, bulletId = null) {
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xB8860B })
    );
    this.mesh.position.copy(position);

    this.direction = direction.clone();
    this.speed = 80; // speed units/second
    this.distanceTraveled = 0;
    this.maxDistance = 100;
    this.timeCreated = performance.now();

    // Remember previous position for continuous detection
    this.lastPosition = position.clone();

    // Track which player fired this bullet
    this.sourcePlayerId = null;
    
    // Anti-cheat: Server-assigned bulletId
    this.bulletId = bulletId;
    
    // Anti-cheat: Track whether this bullet is local (created by local player)
    this.isLocalBullet = true;
    
    // Add collision detection raycaster
    this.raycaster = new THREE.Raycaster(position.clone(), direction.clone(), 0, 0.1);
  }

  /**
   * Sets the player ID that fired this bullet.
   * @param {string|number} playerId - The ID of the player who fired the bullet.
   */
  setSourcePlayer(playerId) {
    this.sourcePlayerId = playerId;
    
    // Anti-cheat: Determine if this is a local bullet
    if (window.localPlayer) {
      this.isLocalBullet = Number(playerId) === Number(window.localPlayer.id);
    }
  }

  /**
   * Updates the bullet's movement & handles collisions with NPC or players.
   * Uses client-side prediction with server authority.
   * @param {number} deltaTime
   * @param {THREE.Group} npc
   * @param {THREE.Scene} scene
   * @param {Map<number, object>} allPlayers - Map of local + remote players.
   * @returns {Object} - Result of the update containing active state and hit info.
   */
  update(deltaTime, npc, scene, allPlayers) {
    // Previous position for boundary crossing detection
    this.lastPosition = this.mesh.position.clone();
    
    // FIRST CHECK: Before moving, check if bullet is already within arena but from an unauthorized player
    if (window.quickDraw && window.quickDraw.isPointInArena(this.mesh.position)) {
      const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
      const isPlayerInDuel = window.quickDraw && window.quickDraw.inDuel;
      const isOpponentBullet = window.quickDraw && 
                               window.quickDraw.duelOpponentId === Number(this.sourcePlayerId);
      
      // If bullet is inside arena but not from a duel player, destroy it immediately
      if (!(isPlayerInDuel && isLocalPlayerBullet) && !isOpponentBullet) {
        console.log("Destroying unauthorized bullet inside arena from player " + this.sourcePlayerId);
        createImpactEffect(this.mesh.position, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'arena', position: this.mesh.position } };
      }
    }
    
    // If we're still active, update bullet position and check for player hits
    this.lastPosition.copy(this.mesh.position);
    
    // Move the bullet
    const displacement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
    this.mesh.position.add(displacement);
    this.distanceTraveled += displacement.length();

    // Current bullet position
    const endPos = this.mesh.position.clone();
    
    // Check if crossing Quick Draw arena boundary using the physics system
    if (window.quickDraw && window.quickDraw.physics) {
      const physics = window.quickDraw.physics;
      
      // Check if bullet is crossing the arena boundary
      const bulletInArena = window.quickDraw.isPointInArena(endPos);
      const prevInArena = window.quickDraw.isPointInArena(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInArena !== prevInArena;
      
      // If the bullet is crossing the boundary
      if (bulletCrossingBoundary) {
        const playerInDuel = window.quickDraw.inDuel;
        const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
        
        // Case 1: Player in duel and their bullet trying to exit
        if (playerInDuel && isLocalPlayerBullet && !bulletInArena) {
          console.log("Bullet hit arena boundary (exiting) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 2: Player outside trying to shoot in
        if (!playerInDuel && isLocalPlayerBullet && bulletInArena) {
          console.log("Bullet from outside entering arena - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 3: Bullet from duel player hitting boundary from inside
        if (playerInDuel && !isLocalPlayerBullet && !bulletInArena) {
          console.log("Bullet from other duel player hitting boundary (exiting) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 4: Bullet from outside player hitting boundary from outside
        if (!playerInDuel && !isLocalPlayerBullet && bulletInArena) {
          console.log("Bullet from outside player hitting boundary (entering) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
      }
    }

    // Only check town boundary if not in QuickDraw duel
    if (!(window.quickDraw && window.quickDraw.inDuel)) {
      // Check town boundary
      if (!withinTownBoundary(endPos)) {
        // Show an impact effect on the invisible boundary
        createImpactEffect(endPos, this.direction, scene, 'ground');
        
        console.log("Bullet hit town boundary - destroying it");
        return { active: false, hit: { type: 'boundary', position: endPos } };
      }
    }

    // Anti-cheat: For local bullets, collision detection is only client-side prediction
    // For remote bullets, we rely on client-side collision for visual effects
    
    // 1) Check collision with NPC
    if (npc) {
      const npcBox = new THREE.Box3().setFromObject(npc);
      npcBox.expandByScalar(0.2);
      if (npcBox.containsPoint(endPos)) {
        createImpactEffect(endPos, this.direction, scene, 'npc');
        return { active: false, hit: { type: 'npc', target: npc } };
      }
    }

    // 2) Check collision with players
    if (allPlayers) {
      for (const [playerId, playerObj] of allPlayers.entries()) {
        // Skip bullet's owner by converting both IDs to numbers
        if (Number(playerId) === Number(this.sourcePlayerId)) continue;
        if (!playerObj || !playerObj.group) continue;

        // Prevent hits across arena boundary or between different game modes
        // Only allow hits if players are in compatible states:
        // 1. Both in the same QuickDraw duel
        // 2. Both in the regular town area (not in any game mode)
        
        const sourcePlayerId = Number(this.sourcePlayerId);
        const targetPlayerId = Number(playerId);
        
        // Check if source and target are in QuickDraw duel
        const bulletPlayerInDuel = window.quickDraw && window.quickDraw.inDuel;
        const targetPlayerInDuel = window.quickDraw && 
                                   window.quickDraw.duelOpponentId === targetPlayerId;
        
        // Make sure players are in the same game mode to allow hits
        const bothInDuel = bulletPlayerInDuel && targetPlayerInDuel;
        const bothInRegularTown = !bulletPlayerInDuel && !targetPlayerInDuel;
        
        if (!(bothInDuel || bothInRegularTown)) {
          continue; // Skip collision check if players are in different areas/modes
        }
        
        // Detect which hit zone was hit (head, body, limbs)
        const hitResult = this.checkPlayerHitZones(playerObj, endPos);
        
        if (hitResult.hit) {
          // Check that this isn't a hit on the local player's own model
          const isHitOnLocalPlayer = window.localPlayer && 
                                   Number(window.localPlayer.id) === Number(playerId);
          
          if (!isHitOnLocalPlayer) {
            // Create the impact effect
            createImpactEffect(endPos, this.direction, scene, 'player');
            
            // Play headshot sound if it was a headshot
            if (hitResult.zone === 'head' && window.localPlayer && window.localPlayer.soundManager) {
              window.localPlayer.soundManager.playSound("headshotmarker", 100);
            }
          } else {
            console.log("Prevented impact effect on local player's own model");
          }
          
          // Anti-cheat: For local bullets, send hit to server and let server decide
          if (this.isLocalBullet && window.networkManager) {
            window.networkManager.sendPlayerHit(playerId, {
              position: { x: endPos.x, y: endPos.y, z: endPos.z },
              sourcePlayerId: this.sourcePlayerId,
              hitZone: hitResult.zone, // Send the hit zone to the server
              damage: hitResult.damage // Send the damage amount to the server
            }, this.bulletId);
            
            // Quick Draw duels with better logging
            if (window.quickDraw && window.quickDraw.inDuel && 
                window.quickDraw.duelState === 'draw' && 
                Number(playerId) === Number(window.quickDraw.duelOpponentId) && 
                Number(this.sourcePlayerId) === Number(window.localPlayer.id)) {
                
                console.log(`Quick Draw hit detected! Player ${this.sourcePlayerId} hit player ${playerId} in the ${hitResult.zone} for ${hitResult.damage} damage`);
                
                // Send special Quick Draw hit notification with hit zone information
                window.networkManager.sendQuickDrawShoot(
                  playerId, 
                  window.quickDraw.activeArenaIndex,
                  hitResult.zone,
                  hitResult.damage
                );
            }
          }
          
          return { 
            active: false, 
            hit: { 
              type: 'player', 
              playerId, 
              bulletId: this.bulletId,
              zone: hitResult.zone,
              damage: hitResult.damage
            } 
          };
        }
      }
    }

    // 3) Check collision with ground
    if (this.mesh.position.y <= 0.1) {
      createImpactEffect(endPos, this.direction, scene, 'ground');
      return { active: false, hit: { type: 'ground', position: endPos } };
    }

    // 4) If bullet exceeded max distance, remove it.
    if (this.distanceTraveled >= this.maxDistance) {
      return { active: false, hit: null };
    }

    // Still active
    return { active: true, hit: null };
  }
  
  /**
   * Checks which part of the player model was hit and returns damage amount.
   * Implements hit zones for head, body, and limbs.
   * @param {object} playerObj - The player object to check
   * @param {THREE.Vector3} bulletPos - The bullet position
   * @returns {object} - Contains hit (boolean), zone (string), and damage (number)
   */
  checkPlayerHitZones(playerObj, bulletPos) {
    // Get player's base position for collision box
    // For local players (first-person), group.position is at eye-level so subtract 1.6
    // Remote players (third-person) have group.position at the base
    const playerPos = playerObj.group.position.clone();
    let baseY = playerPos.y;
    if (playerObj.camera) { // local player
      baseY = playerPos.y - 1.6;
    }
    
    // Define hit zone dimensions
    const headSize = 0.4; // Head is a smaller target
    const bodyWidth = 0.5;
    const bodyHeight = 0.9;
    const limbWidth = 0.2;
    const limbHeight = 0.6;
    
    // Calculate vertical positions of each zone
    // Using the adjusted values for better alignment
    const headBottom = baseY + 1.8 - headSize;
    const headTop = baseY + 1.8;
    const bodyBottom = baseY + 0.9;
    const bodyTop = baseY + 1.8 - headSize;
    const legBottom = baseY + 0.2;
    const legTop = baseY + 0.8;
    const armBottom = baseY + 0.8;
    const armTop = baseY + 1.4;
    
    // Create debug visualization if physics debug mode is enabled or global debug flag is set
    if ((window.physics && window.physics.debugMode) || window.showHitZoneDebug) {
      if (!playerObj._hitZoneDebug) {
        this.createHitZoneDebugBoxes(playerObj, {
          playerPos, baseY, 
          headSize, bodyWidth, bodyHeight, limbWidth, limbHeight,
          headBottom, headTop, bodyBottom, bodyTop, 
          legBottom, legTop, armBottom, armTop
        });
      }
    }
    
    // First do a quick test with the overall player bounding box
    const overallMin = new THREE.Vector3(
      playerPos.x - bodyWidth,
      baseY + 0.2, // Adjusted to match new bottom height
      playerPos.z - bodyWidth
    );
    const overallMax = new THREE.Vector3(
      playerPos.x + bodyWidth,
      baseY + 1.8, // Adjusted to match new top height
      playerPos.z + bodyWidth
    );
    const overallBox = new THREE.Box3(overallMin, overallMax);
    
    if (!overallBox.containsPoint(bulletPos)) {
      return { hit: false, zone: null, damage: 0 };
    }
    
    // Check head zone (highest damage)
    const headMin = new THREE.Vector3(
      playerPos.x - headSize/2,
      headBottom,
      playerPos.z - headSize/2
    );
    const headMax = new THREE.Vector3(
      playerPos.x + headSize/2,
      headTop,
      playerPos.z + headSize/2
    );
    const headBox = new THREE.Box3(headMin, headMax);
    
    if (headBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'head', damage: 100 };
    }
    
    // Check body zone (medium damage)
    const bodyMin = new THREE.Vector3(
      playerPos.x - bodyWidth/2,
      bodyBottom,
      playerPos.z - bodyWidth/2
    );
    const bodyMax = new THREE.Vector3(
      playerPos.x + bodyWidth/2,
      bodyTop,
      playerPos.z + bodyWidth/2
    );
    const bodyBox = new THREE.Box3(bodyMin, bodyMax);
    
    if (bodyBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'body', damage: 40 };
    }
    
    // Check arms (low damage, simplified to two boxes on sides)
    // Left arm
    const leftArmMin = new THREE.Vector3(
      playerPos.x - bodyWidth/2 - limbWidth,
      armBottom,
      playerPos.z - limbWidth/2
    );
    const leftArmMax = new THREE.Vector3(
      playerPos.x - bodyWidth/2,
      armTop,
      playerPos.z + limbWidth/2
    );
    const leftArmBox = new THREE.Box3(leftArmMin, leftArmMax);
    
    // Right arm
    const rightArmMin = new THREE.Vector3(
      playerPos.x + bodyWidth/2,
      armBottom,
      playerPos.z - limbWidth/2
    );
    const rightArmMax = new THREE.Vector3(
      playerPos.x + bodyWidth/2 + limbWidth,
      armTop,
      playerPos.z + limbWidth/2
    );
    const rightArmBox = new THREE.Box3(rightArmMin, rightArmMax);
    
    if (leftArmBox.containsPoint(bulletPos) || rightArmBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'limbs', damage: 20 };
    }
    
    // Check legs (low damage)
    // Left leg
    const leftLegMin = new THREE.Vector3(
      playerPos.x - bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    const leftLegMax = new THREE.Vector3(
      playerPos.x - bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    const leftLegBox = new THREE.Box3(leftLegMin, leftLegMax);
    
    // Right leg
    const rightLegMin = new THREE.Vector3(
      playerPos.x + bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    const rightLegMax = new THREE.Vector3(
      playerPos.x + bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    const rightLegBox = new THREE.Box3(rightLegMin, rightLegMax);
    
    if (leftLegBox.containsPoint(bulletPos) || rightLegBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'limbs', damage: 20 };
    }
    
    // If we reach here but hit the overall box, it's a glancing hit to the body
    return { hit: true, zone: 'body', damage: 40 };
  }
  
  /**
   * Creates visible debug boxes for hit zones when physics debug mode is enabled
   * @param {object} playerObj - The player object
   * @param {object} dims - Dimensions and positions for the hit zones
   */
  createHitZoneDebugBoxes(playerObj, dims) {
    // Only used in debug mode
    if (!window.scene) return;
    
    // Remove any existing debug boxes for this player
    if (playerObj._hitZoneDebug) {
      window.scene.remove(playerObj._hitZoneDebug);
      playerObj._hitZoneDebug.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    
    // Create a new group for hitbox visualization
    const hitZoneGroup = new THREE.Group();
    hitZoneGroup.name = "hitZoneDebug_" + playerObj.id;
    
    // Create helper function to make box helpers
    const createBoxHelper = (min, max, color) => {
      // Use BoxGeometry instead of Box3Helper for more reliable visual feedback
      const sizeX = max.x - min.x;
      const sizeY = max.y - min.y;
      const sizeZ = max.z - min.z;
      
      const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      // Position at the center of the box
      mesh.position.set(
        min.x + sizeX/2,
        min.y + sizeY/2,
        min.z + sizeZ/2
      );
      
      hitZoneGroup.add(mesh);
      return mesh;
    };
    
    // Calculate all zones relative to player position
    // Note: these are local to the player, not world positions
    
    // Head zone - red
    const headMin = new THREE.Vector3(
      -dims.headSize/2,
      dims.headBottom - dims.baseY,
      -dims.headSize/2
    );
    const headMax = new THREE.Vector3(
      dims.headSize/2,
      dims.headTop - dims.baseY,
      dims.headSize/2
    );
    const headHelper = createBoxHelper(headMin, headMax, 0xff0000);
    
    // Body zone - orange
    const bodyMin = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.bodyBottom - dims.baseY,
      -dims.bodyWidth/2
    );
    const bodyMax = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.bodyTop - dims.baseY,
      dims.bodyWidth/2
    );
    const bodyHelper = createBoxHelper(bodyMin, bodyMax, 0xff7700);
    
    // Left arm - yellow
    const leftArmMin = new THREE.Vector3(
      -dims.bodyWidth/2 - dims.limbWidth,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftArmMax = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftArmHelper = createBoxHelper(leftArmMin, leftArmMax, 0xffff00);
    
    // Right arm - green
    const rightArmMin = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightArmMax = new THREE.Vector3(
      dims.bodyWidth/2 + dims.limbWidth,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightArmHelper = createBoxHelper(rightArmMin, rightArmMax, 0x00ff00);
    
    // Left leg - blue
    const leftLegMin = new THREE.Vector3(
      -dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftLegMax = new THREE.Vector3(
      -dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftLegHelper = createBoxHelper(leftLegMin, leftLegMax, 0x0000ff);
    
    // Right leg - purple
    const rightLegMin = new THREE.Vector3(
      dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightLegMax = new THREE.Vector3(
      dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightLegHelper = createBoxHelper(rightLegMin, rightLegMax, 0x800080);
    
    // Add the hitzone group to the scene
    window.scene.add(hitZoneGroup);
    
    // Store reference to debug visualization group
    playerObj._hitZoneDebug = hitZoneGroup;
    
    // Update hitbox position immediately
    this.updateHitZoneDebugPosition(playerObj);

    // Add an update function to the player object
    if (!playerObj._updateHitZoneDebug) {
      const self = this;
      playerObj._updateHitZoneDebug = function() {
        if (this._hitZoneDebug) {
          self.updateHitZoneDebugPosition(this);
        }
      };
      
      // Modify the player's update function to include hitbox updates
      if (playerObj.update && typeof playerObj.update === 'function') {
        const originalUpdate = playerObj.update;
        playerObj.update = function(deltaTime) {
          // Call original update
          originalUpdate.call(this, deltaTime);
          // Update hit zone debug
          if (this._updateHitZoneDebug) {
            this._updateHitZoneDebug();
          }
        };
      }
    }
  }
  
  /**
   * Updates the position of a player's hit zone debug visualization
   * @param {object} playerObj - The player object
   */
  updateHitZoneDebugPosition(playerObj) {
    if (!playerObj || !playerObj._hitZoneDebug || !playerObj.group) return;
    
    const hitZoneDebug = playerObj._hitZoneDebug;
    const playerPos = playerObj.group.position.clone();
    
    // Adjust height based on whether this is a local (first-person) or remote player
    let baseY = playerPos.y;
    if (playerObj.camera) {
      // Local player's group position is at eye level, so subtract 1.6
      baseY = playerPos.y - 1.6;
    }
    
    // Position the debug group at the player's position
    hitZoneDebug.position.set(playerPos.x, baseY, playerPos.z);
    
    // Apply the player's rotation
    if (playerObj.group.rotation) {
      hitZoneDebug.rotation.y = playerObj.group.rotation.y;
    }
  }
  
  /**
   * Directly handles a server-reported impact for this bullet.
   * @param {string} hitType - Type of impact: 'player', 'npc', 'ground', 'boundary', 'arena'
   * @param {string|number|null} targetId - ID of hit target (for player hits)
   * @param {THREE.Vector3} position - Impact position
   * @param {THREE.Scene} scene - Scene to add effects to
   * @returns {Object} - Result object with active=false
   */
  handleServerImpact(hitType, targetId, position, scene) {
    // Create visual effect based on hit type
    if (position) {
      createImpactEffect(position, this.direction, scene, hitType);
      
      // Play headshot sound if the server reports it was a headshot
      if (hitType === 'player' && window.localPlayer && window.localPlayer.soundManager) {
        // If hitZone data is available and it's a headshot
        if (this.lastHitZone === 'head') {
          window.localPlayer.soundManager.playSound("headshotmarker", 100);
        }
      }
    } else {
      // If no position provided, use current bullet position
      createImpactEffect(this.mesh.position, this.direction, scene, hitType);
    }
    
    // Always deactivate the bullet
    return { active: false, hit: { type: hitType, targetId, position } };
  }
  
  /**
   * Sets the last hit zone information for this bullet (for server validation)
   * @param {string} zone - The hit zone ('head', 'body', 'limbs')
   */
  setLastHitZone(zone) {
    this.lastHitZone = zone;
  }
}

/**
 * Helper function to check if a position is within the town boundary
 * @param {THREE.Vector3} position - The position to check
 * @returns {boolean} - True if within boundary, false if outside
 */
function withinTownBoundary(position) {
  if (window.physics && typeof window.physics.isPointInTown === 'function') {
    return window.physics.isPointInTown(position);
  } else if (window.townDimensions) {
    // Fallback if physics isn't available but town dimensions are
    const width = window.townDimensions.width;
    const length = window.townDimensions.length;
    
    // Check if position is within town boundaries
    return (
      position.x >= -width / 2 && 
      position.x <= width / 2 && 
      position.z >= -length / 2 && 
      position.z <= length / 2
    );
  }
  
  // Default to true if we can't determine the boundary
  return true;
}

================================================
File: /public/js/effects.js
================================================
// Import the SmokeRingEffect class 
import { SmokeRingEffect } from './smokeRingEffect.js';

/**
 * Recursively disposes geometry and material for the given object.
 * @param {THREE.Object3D} object - The object to dispose.
 */
function disposeHierarchy(object) {
  object.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

/**
 * Helper for spring interpolation used in recoil recovery.
 * @param {number} start - The starting value.
 * @param {number} end - The target value.
 * @param {number} t - Normalized time.
 * @param {number} damping - Damping coefficient.
 * @param {number} frequency - Oscillation frequency.
 * @returns {number} - The interpolated value.
 */
function springInterpolation(start, end, t, damping, frequency) {
  const decay = Math.exp(-damping * t);
  return end + (start - end) * decay * (1 + (damping / frequency) * Math.sin(frequency * t));
}

/**
 * Creates a muzzle flash effect at the given position.
 * @param {THREE.Vector3} position - Effect position.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createMuzzleFlash(position, scene) {
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(position);
  scene.add(flashGroup);

  // Create just a single bright orange core for the muzzle flash
  const coreGeometry = new THREE.SphereGeometry(0.06, 8, 8);
  const coreMaterial = new THREE.MeshBasicMaterial({
    color: 0xFF6B00, // Bright orange
    transparent: true,
    opacity: 1
  });
  const core = new THREE.Mesh(coreGeometry, coreMaterial);
  // Make it slightly elongated in the x-direction (along the barrel)
  core.scale.x = 1.8;
  flashGroup.add(core);

  // Add a simple point light for illumination
  const flashLight = new THREE.PointLight(0xFF6B00, 1.5, 2);
  flashLight.position.set(0, 0, 0);
  flashGroup.add(flashLight);

  // Make the flash effect much shorter
  const duration = 60; // milliseconds (reduced from 100)
  const startTime = performance.now();

  function animateFlash(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      // Simple scale pulsation for more dramatic effect
      core.scale.x = 1.8 * (1 - progress * 0.5);
      
      // Quicker fade out
      const fadeOpacity = 1 - progress * 1.2; // Faster falloff
      coreMaterial.opacity = Math.max(0, fadeOpacity);
      
      // Light intensity follows the same curve
      flashLight.intensity = 1.5 * (1 - progress);
      
      requestAnimationFrame(animateFlash);
    } else {
      scene.remove(flashGroup);
      disposeHierarchy(flashGroup);
    }
  }
  requestAnimationFrame(animateFlash);
}

/**
 * Creates a smoke effect emanating from a given position.
 * @param {THREE.Vector3} position - Start position.
 * @param {THREE.Vector3} direction - Direction of smoke.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createSmokeEffect(position, direction, scene) {
  // Skip smoke effect on mobile devices
  if (window.isMobile) {
    return;
  }
  
  // Original smoke effect code for desktop
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(position);
  scene.add(smokeGroup);

  // Create a small group of smoke particles
  const numParticles = 5;
  const particles = [];

  for (let i = 0; i < numParticles; i++) {
    const particleGeometry = new THREE.IcosahedronGeometry(0.01 + Math.random() * 0.02, 0);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xCCCCCC,
      transparent: true,
      opacity: 0.7
    });
    
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    
    // Randomize initial position slightly around gun muzzle
    particle.position.set(
      (Math.random() - 0.5) * 0.04,
      (Math.random() - 0.5) * 0.04,
      (Math.random() - 0.5) * 0.04
    );
    
    // Calculate movement direction (mostly forward along shooting direction)
    const particleDir = direction.clone();
    particleDir.x += (Math.random() - 0.5) * 0.2;  // Add some randomness
    particleDir.y += (Math.random() - 0.5) * 0.2;
    particleDir.z += (Math.random() - 0.5) * 0.2;
    particleDir.normalize();
    
    // Store particle properties
    particles.push({
      mesh: particle,
      velocity: particleDir.multiplyScalar(0.5 + Math.random() * 0.5),
      life: 0,
      maxLife: 0.5 + Math.random() * 0.5
    });
    
    smokeGroup.add(particle);
  }
  
  // Animation loop for smoke particles
  let startTime = null;
  function animateSmoke(timestamp) {
    if (!startTime) startTime = timestamp;
    const elapsed = (timestamp - startTime) / 1000; // Convert to seconds
    
    let allDead = true;
    
    for (const particle of particles) {
      particle.life += 0.016; // Approximate time step
      
      if (particle.life < particle.maxLife) {
        allDead = false;
        
        // Move particle based on velocity
        particle.mesh.position.add(particle.velocity.clone().multiplyScalar(0.016));
        
        // Slow down over time (air resistance)
        particle.velocity.multiplyScalar(0.96);
        
        // Expand slightly
        const scale = 1 + particle.life * 3;
        particle.mesh.scale.set(scale, scale, scale);
        
        // Fade out
        const lifeRatio = particle.life / particle.maxLife;
        if (lifeRatio > 0.7) {
          particle.mesh.material.opacity = 0.7 * (1 - (lifeRatio - 0.7) / 0.3);
        }
      } else {
        // Hide particle when dead
        particle.mesh.visible = false;
      }
    }
    
    if (!allDead) {
      requestAnimationFrame(animateSmoke);
    } else {
      // Clean up when all particles are dead
      scene.remove(smokeGroup);
      particles.forEach(particle => {
        if (particle.mesh.material) particle.mesh.material.dispose();
        if (particle.mesh.geometry) particle.mesh.geometry.dispose();
      });
    }
  }
  
  requestAnimationFrame(animateSmoke);
}

/**
 * Creates an impact effect when a bullet hits a target.
 * Instead of a red disk, this new effect emits particles in the opposite direction
 * of the bullet's travel. When the bullet hits a body (player or NPC), the particles
 * are red (blood). When it hits the ground/solid, the particles are brown (splatter).
 *
 * The particle velocities have been reduced so that they stay near the impact point.
 *
 * Additionally, this function now plays an impact sound:
 * - If hitType is 'ground', "woodimpact.mp3" is played.
 * - If hitType is 'player', "fleshimpact.mp3" is played at the impact position.
 *
 * @param {THREE.Vector3} position - Impact position.
 * @param {THREE.Vector3} direction - Impact (bullet) direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 * @param {string} hitType - Type of impact: 'player', 'npc', or 'ground'.
 */
export function createImpactEffect(position, direction, scene, hitType) {
  const effectGroup = new THREE.Group();
  effectGroup.position.copy(position);
  scene.add(effectGroup);
  
  // Play impact sound based on hit type using positional audio
  if (window.localPlayer && window.localPlayer.soundManager) {
    if (hitType === 'ground') {
      window.localPlayer.soundManager.playSoundAt("woodimpact", position);
    } else if (hitType === 'player') {
      // Calculate distance to local player to avoid playing impact on own body
      const localPlayerPos = window.localPlayer.group.position;
      const distToLocalPlayer = Math.sqrt(
        Math.pow(position.x - localPlayerPos.x, 2) + 
        Math.pow(position.z - localPlayerPos.z, 2)
      );
      
      // Only play flesh impact if not too close to local player (prevents self-impacts)
      if (distToLocalPlayer > 0.5) {
        window.localPlayer.soundManager.playSoundAt("fleshimpact", position);
      }
    }
  }

  // Choose color: red for body impacts, brown for ground.
  const color = (hitType === 'ground') ? 0x8B4513 : 0xFF0000;

  const particleCount = 15;
  const particles = [];
  for (let i = 0; i < particleCount; i++) {
    const size = 0.03 * (0.8 + Math.random() * 0.4);
    const particleGeometry = new THREE.SphereGeometry(size, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 1
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    effectGroup.add(particle);
    // Use a reduced speed so particles stay close to the impact spot.
    const velocity = direction.clone().negate();
    const speed = 0.05 + Math.random() * 0.05;
    velocity.multiplyScalar(speed);
    velocity.x += (Math.random() - 0.5) * 0.05;
    velocity.y += (Math.random() - 0.5) * 0.05;
    velocity.z += (Math.random() - 0.5) * 0.05;
    particles.push({ mesh: particle, velocity: velocity, life: 30 + Math.floor(Math.random() * 20) });
  }

  const duration = 500; // in ms
  const startTime = performance.now();

  function animateEffect() {
    const elapsed = performance.now() - startTime;
    const t = elapsed / duration;
    for (const p of particles) {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.mesh.material.opacity = Math.max(1 - t, 0);
        if (hitType === 'ground') {
          p.velocity.y -= 0.005; // gravity effect on ground splatter
        }
        p.life--;
      }
    }
    if (elapsed < duration) {
      requestAnimationFrame(animateEffect);
    } else {
      scene.remove(effectGroup);
      effectGroup.traverse(child => {
        if (child.isMesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
  }
  requestAnimationFrame(animateEffect);
}

/**
 * Applies a realistic recoil effect.
 * @param {Player} player - The player instance.
 */
export function applyRecoil(player) {
  const originalAimOffset = player.aimOffset.clone();
  const originalFOV = player.camera.fov;
  const originalCameraPos = player.camera.position.clone();
  const originalRotation = player.camera.rotation.clone();

  // Initial recoil changes.
  player.camera.rotation.x -= 0.08;
  player.camera.rotation.z += 0.01;
  player.aimOffset.z += 0.4;
  player.aimOffset.y += 0.15;
  player.aimOffset.x += 0.05;
  player.camera.fov -= 5;
  player.camera.updateProjectionMatrix();

  const recoilSteps = [
    { time: 20, cameraX: -0.04, cameraZ: 0.005, offsetZ: 0.2, offsetY: 0.08, offsetX: 0.03 },
    { time: 40, cameraX: -0.06, cameraZ: 0.008, offsetZ: 0.3, offsetY: 0.12, offsetX: 0.04 },
    { time: 60, cameraX: -0.03, cameraZ: 0.006, offsetZ: 0.25, offsetY: 0.1, offsetX: 0.02 },
    { time: 80, cameraX: -0.02, cameraZ: 0.004, offsetZ: 0.18, offsetY: 0.07, offsetX: 0.01 },
    { time: 100, cameraX: -0.01, cameraZ: 0.002, offsetZ: 0.1, offsetY: 0.05, offsetX: 0.005 }
  ];

  recoilSteps.forEach(step => {
    setTimeout(() => {
      player.camera.rotation.x = originalRotation.x + step.cameraX;
      player.camera.rotation.z = originalRotation.z + step.cameraZ;
      player.aimOffset.z = originalAimOffset.z + step.offsetZ;
      player.aimOffset.y = originalAimOffset.y + step.offsetY;
      player.aimOffset.x = originalAimOffset.x + step.offsetX;
    }, step.time);
  });

  let shakeIntensity = 0.03;
  const shakeDecay = 0.9;
  const shakeInterval = setInterval(() => {
    if (shakeIntensity > 0.002) {
      player.camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
      player.camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity *= shakeDecay;
    } else {
      clearInterval(shakeInterval);
      player.camera.position.copy(originalCameraPos);
    }
  }, 16);

  let progress = 0;
  const duration = 400;
  const startTime = performance.now();

  function recoverFromRecoil(timestamp) {
    progress = (timestamp - startTime) / duration;
    if (progress < 1) {
      const t = progress * 4;
      player.camera.rotation.x = springInterpolation(
        player.camera.rotation.x,
        originalRotation.x,
        t,
        0.4,
        8
      );
      player.camera.rotation.z = springInterpolation(
        player.camera.rotation.z,
        originalRotation.z,
        t,
        0.4,
        8
      );
      player.aimOffset.x = springInterpolation(
        player.aimOffset.x,
        originalAimOffset.x,
        t,
        0.4,
        8
      );
      player.aimOffset.y = springInterpolation(
        player.aimOffset.y,
        originalAimOffset.y,
        t,
        0.4,
        8
      );
      player.aimOffset.z = springInterpolation(
        player.aimOffset.z,
        originalAimOffset.z,
        t,
        0.4,
        8
      );
      player.camera.fov = THREE.MathUtils.lerp(
        player.camera.fov,
        originalFOV,
        progress * 0.3
      );
      player.camera.updateProjectionMatrix();
      requestAnimationFrame(recoverFromRecoil);
    } else {
      player.camera.rotation.copy(originalRotation);
      player.aimOffset.copy(originalAimOffset);
      player.camera.fov = originalFOV;
      player.camera.updateProjectionMatrix();
      player.camera.position.copy(originalCameraPos);
    }
  }
  requestAnimationFrame(recoverFromRecoil);
}

/**
 * Enhanced shell ejection with realistic physics.
 * @param {Player} player - The player instance.
 * @param {THREE.Scene} scene - The scene to add the shell.
 * @param {SoundManager} soundManager - For playing sound effects.
 */
export function ejectShell(player, scene, soundManager) {
  const shellGroup = new THREE.Group();

  const shellGeometry = new THREE.CylinderGeometry(0.01, 0.015, 0.04, 8);
  const shellMaterial = new THREE.MeshStandardMaterial({
    color: 0xD4AF37,
    metalness: 0.8,
    roughness: 0.2
  });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shellGroup.add(shell);

  const primerGeometry = new THREE.CircleGeometry(0.006, 8);
  const primerMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0A0A0,
    metalness: 0.7,
    roughness: 0.3
  });
  const primer = new THREE.Mesh(primerGeometry, primerMaterial);
  primer.position.y = -0.02;
  primer.rotation.x = Math.PI / 2;
  shellGroup.add(primer);

  const shellStart = player.revolver.getBarrelTipWorldPosition();
  shellGroup.position.copy(shellStart);
  shellGroup.position.x += 0.05;
  shellGroup.position.y -= 0.02;
  scene.add(shellGroup);

  const physics = {
    velocity: new THREE.Vector3(
      0.8 + Math.random() * 0.4,
      0.5 + Math.random() * 0.3,
      (Math.random() - 0.5) * 0.2
    ),
    rotationSpeed: new THREE.Vector3(
      Math.random() * 0.2,
      Math.random() * 0.2,
      Math.random() * 0.2
    ),
    gravity: 0.015,
    drag: 0.99
  };

  const duration = 2000;
  const startTime = performance.now();

  function animateShell(timestamp) {
    const elapsed = timestamp - startTime;
    if (elapsed < duration) {
      shellGroup.position.x += physics.velocity.x * 0.016;
      shellGroup.position.y += physics.velocity.y * 0.016;
      shellGroup.position.z += physics.velocity.z * 0.016;
      physics.velocity.y -= physics.gravity;
      physics.velocity.multiplyScalar(physics.drag);
      shellGroup.rotation.x += physics.rotationSpeed.x;
      shellGroup.rotation.y += physics.rotationSpeed.y;
      shellGroup.rotation.z += physics.rotationSpeed.z;

      // Bounce logic on ground impact.
      if (shellGroup.position.y < 0.02 && physics.velocity.y < 0) {
        physics.velocity.y = -physics.velocity.y * 0.6;
        physics.velocity.x *= 0.8;
        physics.velocity.z *= 0.8;
        shellGroup.position.y = 0.02;
        physics.rotationSpeed.x = Math.random() * 0.4;
        physics.rotationSpeed.z = Math.random() * 0.4;
      }
      requestAnimationFrame(animateShell);
    } else {
      scene.remove(shellGroup);
      shellGeometry.dispose();
      shellMaterial.dispose();
      primerGeometry.dispose();
      primerMaterial.dispose();
    }
  }
  requestAnimationFrame(animateShell);
}

/**
 * Preloads the smoke effect by creating a disposable instance
 * This forces Three.js to compile shaders and cache necessary resources
 * @param {THREE.Scene} scene - The scene where the preloaded effect will be created
 */
export function preloadSmokeEffect(scene) {
  // Skip on mobile devices
  if (window.isMobile) {
    return;
  }
  
  // Create a dummy position and direction far below the scene
  const dummyPosition = new THREE.Vector3(0, -1000, 0);
  const dummyDirection = new THREE.Vector3(0, 1, 0);
  
  // Create a smoke group
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(dummyPosition);
  scene.add(smokeGroup);
  
  // Create particles with 0 opacity
  const numParticles = 5;
  const particles = [];
  
  for (let i = 0; i < numParticles; i++) {
    const particleGeometry = new THREE.IcosahedronGeometry(0.01 + Math.random() * 0.02, 0);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xCCCCCC,
      transparent: true,
      opacity: 0 // Make it invisible
    });
    
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    smokeGroup.add(particle);
    
    // Store particle properties
    particles.push({
      mesh: particle,
      velocity: dummyDirection.clone().multiplyScalar(0.5),
      life: 0,
      maxLife: 0.5
    });
  }
  
  // Remove and dispose after a short delay
  setTimeout(() => {
    // Clean up
    particles.forEach(p => {
      smokeGroup.remove(p.mesh);
      p.mesh.geometry.dispose();
      p.mesh.material.dispose();
    });
    scene.remove(smokeGroup);
  }, 100);
}

/**
 * Preloads the muzzle flash effect by creating an invisible instance
 * @param {THREE.Scene} scene - The scene to add the preloaded effect
 */
export function preloadMuzzleFlash(scene) {
  // Skip on mobile devices
  if (window.isMobile) {
    return;
  }
  
  // Create a dummy position far below the scene
  const dummyPosition = new THREE.Vector3(0, -1000, 0);
  
  // Create flash group
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(dummyPosition);
  scene.add(flashGroup);
  
  // Create core flash
  const flashGeometry = new THREE.IcosahedronGeometry(0.1, 0);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFF7D6,
    transparent: true,
    opacity: 0 // Make it invisible
  });
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  flashGroup.add(flash);
  
  // Remove and dispose after a short delay
  setTimeout(() => {
    scene.remove(flashGroup);
    flashGeometry.dispose();
    flashMaterial.dispose();
  }, 100);
}

// Export the SmokeRingEffect class
export { SmokeRingEffect };

================================================
File: /public/js/input.js
================================================
/**
 * Initializes game input (keyboard + mouse) and pointer lock.
 * @param {THREE.WebGLRenderer} renderer - The renderer instance.
 * @param {Player} player - The local Player instance (first-person).
 * @param {SoundManager} soundManager - The SoundManager for audio feedback.
 */

export function initInput(renderer, player, soundManager) {
  // Track if device is mobile
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Create touch controls for mobile
  if (isMobile) {
    createMobileControls(player, soundManager);
    
    // Hide all instruction elements on mobile
    hideInstructionsOnMobile();
  }
  
  // Request pointer lock on click (desktop only)
  document.body.addEventListener('click', () => {
    if (!isMobile && document.pointerLockElement !== renderer.domElement) {
      renderer.domElement.requestPointerLock();
    }
  });

  // Mouse look
  document.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === renderer.domElement) {
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;

      // Slightly lower sensitivity when aiming
      const sensitivity = player.isAiming ? 0.001 : 0.002;

      // Yaw
      player.group.rotation.y -= movementX * sensitivity;

      // Pitch (limit to avoid flipping)
      player.camera.rotation.x -= movementY * sensitivity;
      player.camera.rotation.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, player.camera.rotation.x)
      );
    }
  });

  // Keyboard down
  document.addEventListener('keydown', (event) => {
    switch (event.code) {
      case 'KeyW':
        player.moveForward = true;
        break;
      case 'KeyS':
        player.moveBackward = true;
        break;
      case 'KeyA':
        player.moveLeft = true;
        break;
      case 'KeyD':
        player.moveRight = true;
        break;
      case 'Space':
        if (player.canJump) {
          // If sprinting, jump higher
          player.velocity.y = player.isSprinting ? 15 : 10;
          player.canJump = false;
        }
        break;
      case 'KeyR':
        // Start reload
        player.startReload();
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Enable sprinting
        player.isSprinting = true;
        break;
      default:
        break;
    }
  });

  // Keyboard up
  document.addEventListener('keyup', (event) => {
    switch (event.code) {
      case 'KeyW':
        player.moveForward = false;
        break;
      case 'KeyS':
        player.moveBackward = false;
        break;
      case 'KeyA':
        player.moveLeft = false;
        break;
      case 'KeyD':
        player.moveRight = false;
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Disable sprinting
        player.isSprinting = false;
        break;
      default:
        break;
    }
  });

  // Mouse down
  document.addEventListener('mousedown', (event) => {
    // Right-click => Aim (only if canAim is true)
    if (event.button === 2 && player.canAim) {
      player.isAiming = true;
      player.revolver.group.visible = true;
      // Optionally show arms in first-person
      if (player.arms) {
        player.arms.setVisible(true);
      }
      
      // Show and prepare crosshair for animation
      const crosshair = document.getElementById('crosshair');
      if (crosshair) {
        // Reset any existing animation classes
        crosshair.classList.remove('contract', 'expand', 'expanded');
        crosshair.style.display = 'block';
        // Animation will be handled in updateAiming
      }

      if (soundManager) {
        soundManager.playSound("aimclick");
      }
    }
    // Left-click => Shoot (only if aiming)
    else if (event.button === 0) {
      if (player.revolver.group.visible && !player.isReloading) {
        player.shoot();
      }
    }
  });

  // Mouse up
  document.addEventListener('mouseup', (event) => {
    // Stop aiming on right-click release
    if (event.button === 2) {
      player.isAiming = false;
      player.revolver.group.visible = false;
      if (player.arms) {
        player.arms.setVisible(false);
      }
      
      // Play contraction animation before hiding crosshair
      const crosshair = document.getElementById('crosshair');
      if (crosshair) {
        // Reset any existing classes
        crosshair.classList.remove('expand', 'expanded');
        
        // Add contraction animation
        crosshair.classList.add('contract');
        
        // Hide crosshair after animation completes
        setTimeout(() => {
          crosshair.style.display = 'none';
          crosshair.classList.remove('contract');
        }, 250); // Match animation duration
      }
    }
  });

  // Prevent context menu on right-click
  document.addEventListener('contextmenu', (event) => {
    event.preventDefault();
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    player.camera.aspect = window.innerWidth / window.innerHeight;
    player.camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // Check for device orientation
    checkOrientation();
  });
  
  // Handle orientation change for mobile
  window.addEventListener('orientationchange', checkOrientation);
  
  // Initial orientation check
  checkOrientation();

  // Ensure fullscreen with no white bars
  ensureFullscreen();
  
  // Set up a resize listener to maintain fullscreen when orientation changes
  window.addEventListener('resize', ensureFullscreen);
}

/**
 * Hide all instruction elements and portals on mobile
 */
function hideInstructionsOnMobile() {
  // Hide all instruction elements
  const instructionElements = [
    document.getElementById('portal-instructions'),
    document.getElementById('proper-shootout-instructions'),
    document.getElementById('reload-message'),
    document.getElementById('quick-draw-message'),
    document.getElementById('quick-draw-countdown'),
    document.getElementById('health-counter'),
    document.getElementById('health-bar-container')
  ];
  
  // Hide each element if it exists
  instructionElements.forEach(element => {
    if (element) {
      element.style.display = 'none';
    }
  });
  
  // Create a mutation observer to catch any new instruction elements
  const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
      if (mutation.addedNodes && mutation.addedNodes.length > 0) {
        for (let i = 0; i < mutation.addedNodes.length; i++) {
          const node = mutation.addedNodes[i];
          if (node.nodeType === 1) { // Element node
            if (node.id && instructionElements.includes(node.id)) {
              node.style.display = 'none';
            } else if (node.className && node.className.includes('portal-instructions')) {
              node.style.display = 'none';
            }
          }
        }
      }
    });
  });
  
  // Start observing the document
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
}

/**
 * Create touch controls for mobile devices with improved handling
 * @param {Player} player - The Player instance
 * @param {SoundManager} soundManager - The SoundManager instance for audio feedback
 */
function createMobileControls(player, soundManager) {
  // Single large invisible overlay for touch input
  const touchOverlay = document.createElement('div');
  touchOverlay.id = 'touch-overlay';
  touchOverlay.style.position = 'fixed';
  touchOverlay.style.top = '0';
  touchOverlay.style.left = '0';
  touchOverlay.style.width = '100%';
  touchOverlay.style.height = '100%';
  touchOverlay.style.zIndex = '999';
  touchOverlay.style.touchAction = 'none'; // Prevents browser handling of touches
  touchOverlay.style.backgroundColor = 'transparent';
  document.body.appendChild(touchOverlay);
  
  // Create shoot button (left side)
  const shootButton = document.createElement('div');
  shootButton.id = 'shoot-button';
  shootButton.className = 'mobile-button';
  shootButton.innerText = '🔫';
  
  // Create jump button (right side)
  const jumpButton = document.createElement('div');
  jumpButton.id = 'jump-button';
  jumpButton.className = 'mobile-button';
  jumpButton.innerText = '↑';
  
  // Create visual joystick hint for left side
  const leftControlHint = document.createElement('div');
  leftControlHint.id = 'left-control-hint';
  leftControlHint.className = 'control-hint';
  leftControlHint.style.bottom = '30px';
  leftControlHint.style.left = '30px';
  
  // Create visual joystick hint for right side
  const rightControlHint = document.createElement('div');
  rightControlHint.id = 'right-control-hint';
  rightControlHint.className = 'control-hint';
  rightControlHint.style.bottom = '30px';
  rightControlHint.style.right = '30px';
  
  // Create orientation message
  const orientationMsg = document.createElement('div');
  orientationMsg.id = 'orientation-message';
  orientationMsg.innerText = 'Please rotate to landscape mode';
  
  // Add elements to document
  document.body.appendChild(shootButton);
  document.body.appendChild(jumpButton);
  document.body.appendChild(leftControlHint);
  document.body.appendChild(rightControlHint);
  document.body.appendChild(orientationMsg);
  
  // Variables to track touch state
  let leftSideTouchId = null;
  let rightSideTouchId = null;
  let leftStartPos = { x: 0, y: 0 };
  let rightStartPos = { x: 0, y: 0 };
  let rightTouchStartTime = 0;
  let screenWidth = window.innerWidth;
  
  // Constants for sensitivity
  const MOVE_THRESHOLD = 10; // Minimum movement in pixels before registering movement
  const MOVE_SENSITIVITY = 0.15;  // Movement speed multiplier
  const LOOK_SENSITIVITY = 0.25;   // Look speed multiplier - further increased for mobile
  
  // Initial state of player
  player.moveForward = false;
  player.moveBackward = false;
  player.moveLeft = false;
  player.moveRight = false;
  player.isAiming = false;
  
  // Monitor player bullets to auto-reload
  const originalShoot = player.shoot;
  player.shoot = function() {
    const result = originalShoot.apply(this, arguments);
    
    // Auto-reload when out of bullets on mobile
    if (this.bullets <= 0 && !this.isReloading) {
      this.startReload();
    }
    
    return result;
  };
  
  // Touch start handler
  touchOverlay.addEventListener('touchstart', (e) => {
    // Dismiss any instructions/info banner that might be visible
    const instructionsElement = document.getElementById('instructions');
    if (instructionsElement && instructionsElement.parentNode) {
      instructionsElement.parentNode.removeChild(instructionsElement);
    }
    
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Get the screen dimensions
      const screenHeight = window.innerHeight;
      
      // Define joystick areas - smaller hitboxes instead of full screen halves
      // Left joystick: Bottom left quarter of screen
      const leftJoystickArea = {
        x: 0,
        y: screenHeight * 0.4,
        width: screenWidth * 0.4,
        height: screenHeight * 0.6
      };
      
      // Right joystick: Bottom right quarter of screen
      const rightJoystickArea = {
        x: screenWidth * 0.6,
        y: screenHeight * 0.4,
        width: screenWidth * 0.4,
        height: screenHeight * 0.6
      };
      
      // Check if touch is in left joystick area
      if (x >= leftJoystickArea.x && 
          x <= leftJoystickArea.x + leftJoystickArea.width &&
          y >= leftJoystickArea.y && 
          y <= leftJoystickArea.y + leftJoystickArea.height) {
        
        if (leftSideTouchId === null) {
          leftSideTouchId = touch.identifier;
          leftStartPos.x = x;
          leftStartPos.y = y;
          
          // Visual feedback - highlight active control
          leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
          leftControlHint.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
        }
      } 
      // Check if touch is in right joystick area
      else if (x >= rightJoystickArea.x && 
               x <= rightJoystickArea.x + rightJoystickArea.width &&
               y >= rightJoystickArea.y && 
               y <= rightJoystickArea.y + rightJoystickArea.height) {
        
        if (rightSideTouchId === null) {
          rightSideTouchId = touch.identifier;
          rightStartPos.x = x;
          rightStartPos.y = y;
          rightTouchStartTime = Date.now();
          
          // Visual feedback - highlight active control
          rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
          rightControlHint.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
          
          // Start aiming immediately on touch
          player.isAiming = true;
          player.revolver.group.visible = true;
          if (player.arms) {
            player.arms.setVisible(true);
          }
          
          // Show and prepare crosshair for animation
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing animation classes
            crosshair.classList.remove('contract', 'expand', 'expanded');
            crosshair.style.display = 'block';
            // Animation will be handled in updateAiming
          }
          
          if (soundManager) {
            soundManager.playSound("aimclick");
          }
        }
      }
    }
    e.preventDefault();
  });
  
  // Touch move handler
  touchOverlay.addEventListener('touchmove', (e) => {
    // Dismiss any instructions/info banner that might be visible
    const instructionsElement = document.getElementById('instructions');
    if (instructionsElement && instructionsElement.parentNode) {
      instructionsElement.parentNode.removeChild(instructionsElement);
    }
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      
      // Handle left side touch (movement)
      if (touch.identifier === leftSideTouchId) {
        const deltaX = touch.clientX - leftStartPos.x;
        const deltaY = touch.clientY - leftStartPos.y;
        
        // Only apply movement if joystick is moved beyond threshold
        if (Math.abs(deltaX) > MOVE_THRESHOLD || Math.abs(deltaY) > MOVE_THRESHOLD) {
          // Forward/backward based on vertical movement
          player.moveForward = deltaY < -MOVE_THRESHOLD;
          player.moveBackward = deltaY > MOVE_THRESHOLD;
          
          // Left/right based on horizontal movement
          player.moveLeft = deltaX < -MOVE_THRESHOLD;
          player.moveRight = deltaX > MOVE_THRESHOLD;
        }
      }
      
      // Handle right side touch (looking)
      if (touch.identifier === rightSideTouchId) {
        const deltaX = touch.clientX - rightStartPos.x;
        const deltaY = touch.clientY - rightStartPos.y;
        
        // Apply camera rotation based on touch movement - increased sensitivity
        player.group.rotation.y -= deltaX * LOOK_SENSITIVITY * 0.01;
        player.camera.rotation.x -= deltaY * LOOK_SENSITIVITY * 0.01;
        
        // Limit vertical rotation to avoid flipping
        player.camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, player.camera.rotation.x)
        );
        
        // Update starting position to prevent continuous rotation
        rightStartPos.x = touch.clientX;
        rightStartPos.y = touch.clientY;
      }
    }
    e.preventDefault();
  });
  
  // Touch end handler
  touchOverlay.addEventListener('touchend', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      
      // Handle left side touch end
      if (touch.identifier === leftSideTouchId) {
        leftSideTouchId = null;
        
        // Reset movement flags
        player.moveForward = false;
        player.moveBackward = false;
        player.moveLeft = false;
        player.moveRight = false;
        
        // Reset visual feedback
        leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        leftControlHint.style.backgroundColor = 'transparent';
      }
      
      // Handle right side touch end
      if (touch.identifier === rightSideTouchId) {
        // Stop aiming but don't shoot
        player.isAiming = false;
        player.revolver.group.visible = false;
        if (player.arms) {
          player.arms.setVisible(false);
        }
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250); // Match animation duration
        }
        
        // Reset visual feedback
        rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        rightControlHint.style.backgroundColor = 'transparent';
        
        rightSideTouchId = null;
      }
    }
    e.preventDefault();
  });
  
  // Touch cancel handler (similar to touch end)
  touchOverlay.addEventListener('touchcancel', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      
      // Reset left side touch
      if (touch.identifier === leftSideTouchId) {
        leftSideTouchId = null;
        player.moveForward = false;
        player.moveBackward = false;
        player.moveLeft = false;
        player.moveRight = false;
        
        // Reset visual feedback
        leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        leftControlHint.style.backgroundColor = 'transparent';
      }
      
      // Reset right side touch
      if (touch.identifier === rightSideTouchId) {
        rightSideTouchId = null;
        player.isAiming = false;
        player.revolver.group.visible = false;
        if (player.arms) {
          player.arms.setVisible(false);
        }
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250); // Match animation duration
        }
        
        // Reset visual feedback
        rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        rightControlHint.style.backgroundColor = 'transparent';
      }
    }
    e.preventDefault();
  });
  
  // Shoot button handler
  shootButton.addEventListener('touchstart', (e) => {
    if (player.isAiming && !player.isReloading) {
      player.shoot();
    }
    e.preventDefault();
  });
  
  // Button event handlers  
  jumpButton.addEventListener('touchstart', (e) => {
    if (player.canJump) {
      player.velocity.y = player.isSprinting ? 15 : 10;
      player.canJump = false;
    }
    e.preventDefault();
  });
  
  // Handle window resize to update the screen width calculation
  window.addEventListener('resize', () => {
    screenWidth = window.innerWidth;
  });
  
  // Special handler for clicking on any instruction element to hide it
  document.addEventListener('touchstart', (e) => {
    const target = e.target;
    if (target.id === 'portal-instructions' || 
        target.id === 'proper-shootout-instructions' ||
        (target.parentElement && 
         (target.parentElement.id === 'portal-instructions' || 
          target.parentElement.id === 'proper-shootout-instructions'))) {
      
      // Hide the instruction element
      if (target.id) {
        document.getElementById(target.id).style.display = 'none';
      } else if (target.parentElement && target.parentElement.id) {
        document.getElementById(target.parentElement.id).style.display = 'none';
      }
      
      e.preventDefault();
      e.stopPropagation();
    }
  }, true);
}

/**
 * Check device orientation and display warning if not in landscape mode on mobile
 */
function checkOrientation() {
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  if (isMobile) {
    const orientationMsg = document.getElementById('orientation-message');
    
    // Check if we're in portrait mode
    if (window.innerHeight > window.innerWidth) {
      orientationMsg.style.display = 'flex';
    } else {
      orientationMsg.style.display = 'none';
    }
  }
}

// Function to update health display - modified to handle missing health counter
function updateHealthDisplay(health, maxHealth) {
  // Skip the health counter update since we removed it from the UI
  
  // Only update health bar if it exists
  const healthBar = document.getElementById('health-bar');
  if (healthBar) {
    const healthPercent = Math.max(0, health / maxHealth * 100);
    healthBar.style.width = `${healthPercent}%`;
    
    // Change color based on health level
    if (healthPercent > 66) {
      healthBar.style.backgroundColor = '#4CAF50'; // Green
    } else if (healthPercent > 33) {
      healthBar.style.backgroundColor = '#FFC107'; // Yellow
    } else {
      healthBar.style.backgroundColor = '#F44336'; // Red
    }
  }
}

function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0);
}

// This function ensures the game takes up the full screen space with no white bars
function ensureFullscreen() {
  // Set body and html to full viewport dimensions
  document.documentElement.style.width = '100%';
  document.documentElement.style.height = '100%';
  document.body.style.width = '100%';
  document.body.style.height = '100%';
  document.body.style.margin = '0';
  document.body.style.padding = '0';
  document.body.style.overflow = 'hidden';
  document.body.style.backgroundColor = '#000';
  document.body.style.position = 'fixed';
  
  // Set game container to full viewport
  const gameContainer = document.getElementById('game-container');
  if (gameContainer) {
    gameContainer.style.position = 'fixed';
    gameContainer.style.top = '0';
    gameContainer.style.left = '0';
    gameContainer.style.right = '0';
    gameContainer.style.bottom = '0';
    gameContainer.style.width = '100%';
    gameContainer.style.height = '100%';
    gameContainer.style.margin = '0';
    gameContainer.style.padding = '0';
    gameContainer.style.overflow = 'hidden';
    gameContainer.style.backgroundColor = '#000';
  }
  
  // Make sure canvas fills the screen
  const canvas = document.querySelector('canvas');
  if (canvas) {
    canvas.style.position = 'fixed';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.right = '0';
    canvas.style.bottom = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.margin = '0';
    canvas.style.padding = '0';
    canvas.style.display = 'block';
    canvas.style.backgroundColor = '#000';
    
    // iOS Safari specific fixes
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      // Fix for iOS notch and home indicator
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      
      // Prevent elastic scrolling
      document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, { passive: false });
      
      // Force scroll to top on resize/orientation change
      window.addEventListener('resize', () => {
        window.scrollTo(0, 0);
        document.body.style.height = window.innerHeight + 'px';
        canvas.style.height = window.innerHeight + 'px';
      });
      
      // Initial height fix
      setTimeout(() => {
        window.scrollTo(0, 0);
        document.body.style.height = window.innerHeight + 'px';
        canvas.style.height = window.innerHeight + 'px';
      }, 300);
    }
  }
}

/**
 * Create optimized smoke effect for mobile
 * @param {HTMLElement} drawCircle - The draw circle element
 */
function createOptimizedSmokeEffect(drawCircle) {
  if (isMobileDevice()) {
    // Completely disable the effect on mobile devices
    drawCircle.style.display = 'none';
    drawCircle.style.opacity = '0';
    // Remove any existing animation classes
    drawCircle.classList.remove('draw-circle-animation');
    drawCircle.classList.remove('draw-circle-animation-mobile');
  } else {
    // Desktop full version
    drawCircle.style.display = 'block';
    drawCircle.style.width = '300px';
    drawCircle.style.height = '300px';
    drawCircle.style.borderWidth = '8px';
    drawCircle.style.opacity = '1';
    drawCircle.style.boxShadow = '0 0 20px #FF0000';
    drawCircle.classList.add('draw-circle-animation');
  }
}

// Export the smoke effect function so it can be used in game logic
export { createOptimizedSmokeEffect };

================================================
File: /public/js/main.js
================================================
import { initScene, createNPC, updateNPC, updateFPS, scene } from './scene.js';
import { initInput } from './input.js';
import { SoundManager } from './soundManager.js';
import { Player } from './player.js';
import { networkManager } from './network.js';
import { MultiplayerManager } from './multiplayerManager.js';
import { Bullet } from './bullet.js';
import { createMuzzleFlash, createSmokeEffect, createImpactEffect, preloadMuzzleFlash, preloadSmokeEffect, SmokeRingEffect } from './effects.js';
import { QuickDraw } from './quickDraw.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { PhysicsSystem } from './physics.js';

// Check if device is mobile
function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0 || 
         /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
}

// Set global flag for mobile
window.isMobile = isMobileDevice();

// Keep track of all bullets in the game, both local and remote
let bullets = [];

// Anti-cheat: Map bullets by ID for server authority
let bulletMap = new Map(); // bulletId -> Bullet object

// We'll keep references to local player, remote players, and a combined map
let localPlayer;
let remotePlayers = new Map();  // (playerId => ThirdPersonModel)
let playersMap = new Map();     // Master map including local + remote

// Scenes, camera, etc.
let renderer, camera, npc;
let multiplayerManager;
let quickDraw;
let physics;
let lastTime = 0;

// Smoke ring effects
let smokeRings = [];
let maxSmokeRings = 10; // Limit to prevent performance issues

// Add a flag to track debug visualization mode
window.showHitZoneDebug = false;

function init() {
  try {
    const sceneSetup = initScene();
    camera = sceneSetup.camera;
    renderer = sceneSetup.renderer;

    const soundManager = new SoundManager();
    // Load shot sounds
    soundManager.loadSound("shot2", "sounds/shot2.mp3");
    soundManager.loadSound("shot3", "sounds/shot3.mp3");
    soundManager.loadSound("shot5", "sounds/shot5.mp3");
    soundManager.loadSound("aimclick", "sounds/aimclick.mp3");
    soundManager.loadSound("shellejection", "sounds/shellejection.mp3");
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    // Load the bell start sound for Quick Draw start signal
    soundManager.loadSound("bellstart", "sounds/bellstart.mp3");
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    soundManager.loadSound("fleshimpact", "sounds/fleshimpact.mp3");
    
    // Load footstep and jump sounds
    soundManager.loadSound("leftstep", "sounds/leftstep.mp3");
    soundManager.loadSound("rightstep", "sounds/rightstep.mp3");
    soundManager.loadSound("jump", "sounds/jump.mp3");
    
    // Load headshot marker sound
    soundManager.loadSound("headshotmarker", "sounds/headshotmarker.mp3");
    
    // Initialize physics system
    physics = new PhysicsSystem();
    window.physics = physics; // Make physics globally accessible

    // Create town boundary if dimensions are available
    if (window.townDimensions) {
      physics.createTownBoundary(
        window.townDimensions.width,
        window.townDimensions.length,
        5 // Height of the barrier
      );
    }
    
    // Preload all visual effects to prevent FPS drops on first use
    if (!window.isMobile) {
      console.log("Preloading visual effects...");
      // Preload muzzle flash effect
      preloadMuzzleFlash(scene);
      // Preload smoke effect
      preloadSmokeEffect(scene);
      
      // Initialize a smoke ring effect pool for reuse
      for (let i = 0; i < 3; i++) {
        const smokeRing = new SmokeRingEffect(scene);
        smokeRing.active = false;
        // Preload resources to prevent fps drop on first use
        smokeRing.preload();
        smokeRings.push(smokeRing);
      }
    }
    
    // Initialize multiplayer manager
    multiplayerManager = new MultiplayerManager(scene, soundManager, remotePlayers);

    // Initialize the local player
    localPlayer = new Player({
      scene,
      camera,
      soundManager,
      onShoot: handleLocalPlayerShoot  // callback for local shooting
    });
    // Make localPlayer globally accessible for hit updates.
    window.localPlayer = localPlayer;

    // Create an NPC target
    npc = createNPC(scene);

    // Initialize input
    initInput(renderer, localPlayer, soundManager);
    
    // Make scene globally accessible for physics visualization
    window.scene = scene;

    // Initialize Quick Draw game mode after the local player is created
    quickDraw = new QuickDraw(scene, localPlayer, networkManager, soundManager);
    
    // Share the main physics system with game modes
    quickDraw.physics = physics;
    
    // Debug toggle for physics visualization (press P)
    window.addEventListener('keydown', (event) => {
      if (event.code === 'KeyP') {
        if (physics) {
          const isDebugMode = !physics.debugMode;
          physics.setDebugMode(isDebugMode);
          console.log(`Physics debug mode: ${isDebugMode ? 'ENABLED' : 'DISABLED'}`);
          
          // Set the global debug flag
          window.showHitZoneDebug = isDebugMode;
          
          // If turning on debug mode, update hit zone debug for all existing players
          if (isDebugMode) {
            // Create debug boxes for remote players and local player with a delay
            // (to allow for physics debug state to be fully set)
            setTimeout(() => {
              // First trigger hit zone debugging on the local player
              if (localPlayer) {
                const dummyBullet = new Bullet(
                  new THREE.Vector3(0, 0, 0),
                  new THREE.Vector3(0, 1, 0)
                );
                dummyBullet.checkPlayerHitZones(localPlayer, new THREE.Vector3(0, 0, 0));
              }
              
              // Then create debug boxes for all remote players
              for (const [playerId, remotePlayer] of remotePlayers.entries()) {
                // Force a collision check to create debug boxes
                const dummyBullet = new Bullet(
                  new THREE.Vector3(0, 0, 0),
                  new THREE.Vector3(0, 1, 0)
                );
                dummyBullet.checkPlayerHitZones(remotePlayer, new THREE.Vector3(0, 0, 0));
              }
              
              console.log("Hit zone debug boxes created for all players");
            }, 50);
          }
        }
      }
    });
    
    // Make updateHealthUI globally accessible for the Quick Draw mode to use
    window.updateHealthUI = updateHealthUI;

    // Show connection status
    const networkStatus = document.createElement('div');
    networkStatus.id = 'network-status';
    networkStatus.textContent = 'Connecting...';
    document.getElementById('game-container').appendChild(networkStatus);

    // Update player count UI when server broadcasts the count.
    networkManager.onPlayerCount = (count) => {
      const playerCountEl = document.getElementById('player-count');
      if (playerCountEl) {
        playerCountEl.textContent = `Players: ${count}`;
      }
    };

    // Listen for network open/close
    networkManager.socket.addEventListener('open', () => {
      networkStatus.textContent = 'Connected';
      networkStatus.style.backgroundColor = 'rgba(0,128,0,0.5)';
      setTimeout(() => { networkStatus.style.opacity = '0'; }, 2000);
    });
    networkManager.socket.addEventListener('close', () => {
      networkStatus.textContent = 'Disconnected';
      networkStatus.style.backgroundColor = 'rgba(255,0,0,0.5)';
      networkStatus.style.opacity = '1';
    });

    // Listen for remote players shooting
    networkManager.onPlayerShoot = (playerId, bulletData, bulletId) => {
      handleRemotePlayerShoot(playerId, bulletData, bulletId);
    };

    // Anti-cheat: Listen for bullet impact notifications from server
    networkManager.onBulletImpact = (bulletId, hitType, targetId, position, hitZone) => {
      handleBulletImpact(bulletId, hitType, targetId, position, hitZone);
    };

    // Anti-cheat: Listen for position corrections from server
    networkManager.onPositionCorrection = (correctedPosition) => {
      if (localPlayer) {
        // Store the server position for reconciliation
        localPlayer.serverPosition = new THREE.Vector3(
          correctedPosition.x,
          correctedPosition.y,
          correctedPosition.z
        );
        localPlayer.isReconciling = true;
      }
    };
    
    // Anti-cheat: Listen for server-initiated respawn
    networkManager.onRespawn = (position, health, bullets) => {
      if (localPlayer) {
        // Set position
        localPlayer.group.position.copy(position);
        localPlayer.previousPosition.copy(position);
        
        // Update health and bullets
        localPlayer.health = health || 100;
        localPlayer.bullets = bullets || localPlayer.maxBullets;
        
        // Reset states
        localPlayer.isReloading = false;
        localPlayer.isAiming = false;
        localPlayer.velocity.y = 0;
        localPlayer.canAim = true;
        
        // Update UI
        updateHealthUI(localPlayer);
        updateAmmoUI(localPlayer);
      }
    };

    // Listen for updates to the remotePlayers map so we can refresh the master map
    multiplayerManager.onRemotePlayersUpdated = () => {
      updatePlayersMap();
      
      // If debug mode is on, make sure new players have hit zone debug boxes
      if (window.showHitZoneDebug && physics && physics.debugMode) {
        setTimeout(() => {
          if (physics.refreshHitZoneDebug && typeof physics.refreshHitZoneDebug === 'function') {
            physics.refreshHitZoneDebug();
          }
        }, 100);
      }
    };

    // Start the animation loop
    animate(0);
    showGameInstructions();
    
  } catch (error) {
    console.error('Initialization failed:', error);
  }
}

/**
 * The main animation loop.
 */
function animate(time) {
  requestAnimationFrame(animate);
  const deltaTime = (time - lastTime) / 1000;
  lastTime = time;

  // Update physics system
  if (physics) {
    physics.update(deltaTime);
  }

  // Update local player
  localPlayer.update(deltaTime);

  // Update NPC using the imported updateNPC function
  updateNPC(npc, deltaTime);

  // Update remote players (animations, movement interpolation, etc.)
  multiplayerManager.update(deltaTime);
  
  // Update Quick Draw game mode
  if (quickDraw) {
    quickDraw.update(deltaTime);
  }

  // Update smoke ring effects
  for (let i = smokeRings.length - 1; i >= 0; i--) {
    // If the smoke ring is inactive after update, we can remove it
    // But keep at least 3 in the pool for reuse
    if (!smokeRings[i].update(deltaTime) && smokeRings.length > 3) {
      smokeRings[i].dispose();
      smokeRings.splice(i, 1);
    }
  }

  // Update bullets (both local & remote)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    const result = bullet.update(deltaTime, npc, scene, playersMap);
    if (!result.active) {
      // If bullet hit something or traveled too far
      if (result.hit && result.hit.type === 'player') {
        console.log(`Bullet hit player ${result.hit.playerId} in the ${result.hit.zone || 'body'} for ${result.hit.damage || 'unknown'} damage`);
        
        // Set the last hit zone for server validation
        if (bullet.bulletId !== null && result.hit.zone) {
          bullet.setLastHitZone(result.hit.zone);
        }
      }
      scene.remove(bullet.mesh);
      bullets.splice(i, 1);
      
      // Anti-cheat: Remove from bullet map if it has an ID
      if (bullet.bulletId !== null) {
        bulletMap.delete(bullet.bulletId);
      }
    }
  }

  // Update FPS display
  updateFPS(renderer, camera, deltaTime);

  // Render
  renderer.render(scene, camera);
}

/**
 * Called whenever the local player fires.
 * Spawns a bullet locally and also notifies the server.
 * @param {THREE.Vector3} bulletStart 
 * @param {THREE.Vector3} shootDir 
 */
function handleLocalPlayerShoot(bulletStart, shootDir) {
  // Spawn bullet in our local game (client-side prediction)
  const bullet = spawnBullet(localPlayer.id, bulletStart, shootDir);

  // Send bullet data over network
  networkManager.sendShoot({
    position: {
      x: bulletStart.x,
      y: bulletStart.y,
      z: bulletStart.z
    },
    direction: {
      x: shootDir.x,
      y: shootDir.y,
      z: shootDir.z
    }
  });
  
  // Add this section to check for Quick Draw hit
  if (quickDraw && quickDraw.inDuel && quickDraw.duelState === 'draw' && quickDraw.duelOpponentId) {
    // We'll handle this in the bullet collision code instead
  }

  // Create smoke ring effect - only if not mobile
  if (!window.isMobile) {
    const availableSmokeRing = smokeRings.find(ring => !ring.active);
    if (availableSmokeRing) {
      availableSmokeRing.create(bulletStart.clone(), shootDir.clone());
    }
  }
}

/**
 * Called whenever a remote player fires (based on network data).
 * @param {number} playerId 
 * @param {Object} bulletData 
 * @param {string|number} bulletId - Server-assigned bullet ID
 */
function handleRemotePlayerShoot(playerId, bulletData, bulletId) {
  const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
  const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);

  spawnBullet(playerId, startPos, dir, bulletId);
}

/**
 * Handles a bullet impact notification from the server.
 * @param {string|number} bulletId - The bullet ID
 * @param {string} hitType - Type of impact (player, npc, ground, etc.)
 * @param {string|number|null} targetId - Target ID (for player hits)
 * @param {Object} position - Impact position {x, y, z}
 * @param {string} hitZone - Hit zone (head, body, limbs)
 */
function handleBulletImpact(bulletId, hitType, targetId, position, hitZone) {
  // Convert position to THREE.Vector3 if provided
  let impactPosition = null;
  if (position) {
    impactPosition = new THREE.Vector3(position.x, position.y, position.z);
  }
  
  // Find the bullet in our bullet map
  const bullet = bulletMap.get(bulletId);
  
  if (bullet) {
    // Store hit zone information for potential headshot sound
    if (hitZone) {
      bullet.setLastHitZone(hitZone);
    }
    
    // Create appropriate visual effect and deactivate bullet
    const result = bullet.handleServerImpact(hitType, targetId, impactPosition, scene);
    
    // Find and remove bullet from main array
    const bulletIndex = bullets.findIndex(b => b === bullet);
    if (bulletIndex !== -1) {
      scene.remove(bullet.mesh);
      bullets.splice(bulletIndex, 1);
    }
    
    // Remove from bullet map
    bulletMap.delete(bulletId);
  } else {
    console.log(`Bullet ${bulletId} not found for impact event`);
    
    // If we don't have the bullet object, still create visual effect at impact position
    if (impactPosition) {
      // Create a default direction vector (upward)
      const defaultDir = new THREE.Vector3(0, 1, 0);
      createImpactEffect(impactPosition, defaultDir, scene, hitType);
      
      // Play headshot sound if it was a headshot
      if (hitZone === 'head' && localPlayer && localPlayer.soundManager) {
        localPlayer.soundManager.playSound("headshotmarker", 100);
      }
    }
  }
}

/**
 * Actually spawns a bullet in the world, complete with muzzle flash, etc.
 * @param {string|number} sourcePlayerId 
 * @param {THREE.Vector3} position 
 * @param {THREE.Vector3} direction 
 * @param {string|number} bulletId - Optional server-assigned ID (for remote bullets)
 * @returns {Bullet} The created bullet object
 */
function spawnBullet(sourcePlayerId, position, direction, bulletId = null) {
  const bullet = new Bullet(position, direction, bulletId);
  bullet.setSourcePlayer(sourcePlayerId);
  bullets.push(bullet);
  scene.add(bullet.mesh);
  
  // Anti-cheat: Store bullet in map if it has a bulletId
  if (bulletId !== null) {
    bulletMap.set(bulletId, bullet);
  }

  // Visual effects
  createMuzzleFlash(position, scene);
  createSmokeEffect(position, direction, scene);
  
  // Only add smoke ring effects if not on mobile
  if (!window.isMobile) {
    // Add smoke ring effect
    let smokeRing = null;
    
    // Try to reuse an inactive smoke ring first
    for (let i = 0; i < smokeRings.length; i++) {
      if (!smokeRings[i].active) {
        smokeRing = smokeRings[i];
        break;
      }
    }
    
    // If no inactive smoke ring found, create a new one if under the limit
    if (!smokeRing && smokeRings.length < maxSmokeRings) {
      smokeRing = new SmokeRingEffect(scene);
      smokeRings.push(smokeRing);
    }
    
    // Activate the smoke ring
    if (smokeRing) {
      smokeRing.create(position, direction);
    }
  }

  // Sound: randomly choose one of the three shot sounds
  if (localPlayer.soundManager) {
    const shotSounds = ["shot2", "shot3", "shot5"];
    const randomIndex = Math.floor(Math.random() * shotSounds.length);
    const shotSound = shotSounds[randomIndex];
    localPlayer.soundManager.playSound(shotSound);
  }

  return bullet;
}

/**
 * Rebuilds a master map of all remote players.
 * This map is passed to bullet collision checks so bullets can hit any remote player.
 */
function updatePlayersMap() {
  playersMap.clear();
  // Only add remote players so that the local (shooter's) model isn't processed in bullet collisions.
  for (const [pid, remoteModel] of remotePlayers.entries()) {
    playersMap.set(pid, remoteModel);
  }
}


function showGameInstructions() {
  const instructions = document.createElement('div');
  instructions.id = 'instructions';
  instructions.style.position = 'absolute';
  instructions.style.top = '50%';
  instructions.style.left = '50%';
  instructions.style.transform = 'translate(-50%, -50%)';
  instructions.style.color = 'white';
  instructions.style.backgroundColor = 'rgba(0,0,0,0.7)';
  instructions.style.padding = '20px';
  instructions.style.borderRadius = '10px';
  instructions.style.maxWidth = '500px';
  instructions.style.textAlign = 'center';
  instructions.style.zIndex = '1000';
  
  instructions.innerHTML = `
    <h2>Wild Western Shooter - Multiplayer</h2>
    <p>WASD: Move</p>
    <p>Shift: Sprint</p>
    <p>Right-click: Aim</p>
    <p>Left-click (while aiming): Shoot</p>
    <p>R: Reload</p>
    <p>Space: Jump</p>
    <p>P: Toggle physics debug visualization</p>
    <p><strong>Touch anywhere to start</strong></p>
    <p><strong>New:</strong> Find the Quick Draw portal near spawn to duel other players!</p>
    <p><strong>Town Boundary:</strong> You must stay within the town limits and can only access the duel arena through the portal.</p>
    <p><strong>Hit Zones:</strong> Headshots deal 100 damage, body shots 40, and limb shots 20.</p>`;
  
  document.getElementById('game-container').appendChild(instructions);
  
  // Add a clear dismiss button for mobile
  const dismissButton = document.createElement('button');
  dismissButton.textContent = '✕';
  dismissButton.style.position = 'absolute';
  dismissButton.style.top = '10px';
  dismissButton.style.right = '10px';
  dismissButton.style.background = 'transparent';
  dismissButton.style.border = 'none';
  dismissButton.style.color = 'white';
  dismissButton.style.fontSize = '24px';
  dismissButton.style.cursor = 'pointer';
  dismissButton.style.zIndex = '1001';
  dismissButton.style.padding = '5px 10px';
  dismissButton.style.touchAction = 'manipulation';
  instructions.appendChild(dismissButton);
  
  // Global function to remove instructions
  window.removeInstructions = () => {
    if (instructions.parentNode) {
      instructions.parentNode.removeChild(instructions);
    }
  };
  
  // Make both the background and the button clickable/tappable to dismiss
  dismissButton.addEventListener('click', window.removeInstructions);
  dismissButton.addEventListener('touchstart', window.removeInstructions, {passive: false});
  instructions.addEventListener('click', window.removeInstructions);
  instructions.addEventListener('touchstart', window.removeInstructions, {passive: false});
  
  // Add global event listeners to dismiss on any interaction
  document.addEventListener('touchstart', window.removeInstructions, {once: true, passive: false});
  
  // Prevent instructions from blocking renderer initialization on mobile
  if (window.isMobile) {
    // Auto-dismiss after 10 seconds on mobile
    setTimeout(window.removeInstructions, 7000);
  }
}

// Handle window unload to cleanup game mode resources
window.addEventListener('beforeunload', () => {
  if (quickDraw) {
    quickDraw.cleanup();
  }
  
  if (physics) {
    physics.cleanup();
  }
  
  // Clean up smoke rings
  for (let i = 0; i < smokeRings.length; i++) {
    smokeRings[i].dispose();
  }
  smokeRings = [];
});

// Make Bullet constructor globally available for hit zone debug creation
window.Bullet = Bullet;

init();

================================================
File: /public/js/multiplayerManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';
import { networkManager } from './network.js';
import { updateHealthUI, showDamageIndicator } from './ui.js';

/**
 * Manages all remote players (their models, animations, etc.) but NOT bullets.
 * Bullets are now handled in main.js.
 */
export class MultiplayerManager {
  constructor(scene, soundManager, remotePlayersMap) {
    /**
     * @param remotePlayersMap {Map<number,ThirdPersonModel>}
     * A shared map that main.js also references. We'll update it here.
     */
    this.scene = scene;
    this.soundManager = soundManager;
    
    // This map is passed in from main.js; we mutate it
    this.remotePlayers = remotePlayersMap;

    // Callback that main.js uses to know we changed remotePlayers
    this.onRemotePlayersUpdated = null;

    this.localPlayerId = null;

    // Initialize network handlers
    this.initNetwork();
  }
  
  initNetwork() {
    // When we get the "init" message, set local player ID and add any existing players
    networkManager.onInit = (initData) => {
      this.localPlayerId = initData.id;
      console.log(`Local player initialized with ID: ${this.localPlayerId}`);

      // Add all existing players (these are remote from our POV)
      initData.players.forEach(playerData => {
        this.addPlayer(playerData.id, playerData);
      });
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerJoined = (playerData) => {
      if (playerData.id === this.localPlayerId) return; // skip ourself
      this.addPlayer(playerData.id, playerData);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerLeft = (playerId) => {
      this.removePlayer(playerId);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerUpdate = (playerId, updatedData) => {
      if (playerId === this.localPlayerId) return; // skip ourself
      const playerModel = this.remotePlayers.get(playerId);
      if (playerModel) {
        playerModel.update(updatedData);
      } else {
        // If we don't have this model yet, create it
        this.addPlayer(playerId, updatedData);
      }
    };

    // Anti-cheat: Player got hit (local player) - server validated
    networkManager.onPlayerHit = (sourceId, hitData, newHealth, hitZone) => {
      console.log(`I was hit by player ${sourceId} in the ${hitZone || 'body'}!`);
      this.showHitFeedback();
      
      // Play headshot sound if appropriate
      if (hitZone === 'head' && this.soundManager) {
        this.soundManager.playSound("headshotmarker", 100);
      }
      
      // Reduce local player's health (using value from server)
      if (window.localPlayer) {
        // Calculate damage based on the health difference or hit zone
        let damage = 20; // Default damage
        
        if (newHealth !== undefined) {
          // Calculate damage from previous health
          damage = window.localPlayer.health - newHealth;
          window.localPlayer.health = newHealth;
        } else {
          // Calculate damage based on hit zone if provided
          if (hitZone === 'head') {
            damage = 100;
          } else if (hitZone === 'body') {
            damage = 40;
          } else if (hitZone === 'limbs') {
            damage = 20;
          }
          
          // Apply damage
          window.localPlayer.takeDamage(damage, hitZone);
        }
        
        // Show damage indicator with proper hit zone
        if (typeof window.showDamageIndicator === 'function') {
          window.showDamageIndicator(damage, hitZone);
        }
        
        // Ensure health UI is updated
        if (typeof window.updateHealthUI === 'function') {
          window.updateHealthUI(window.localPlayer);
        }
      }
    };

    // Anti-cheat: Broadcast that some player was hit (server validated)
    networkManager.onPlayerHitBroadcast = (targetId, sourceId, hitPos, newHealth, hitZone) => {
      console.log(`Player ${targetId} was hit by ${sourceId} in the ${hitZone || 'body'}`);
      const tPlayer = this.remotePlayers.get(parseInt(targetId));
      if (tPlayer) {
        tPlayer.showHitFeedback();
        
        // Play headshot sound if appropriate
        if (hitZone === 'head' && this.soundManager) {
          this.soundManager.playSound("headshotmarker", 100);
        }
        
        // Calculate damage based on hit zone
        let damage = 20; // Default damage
        if (hitZone === 'head') {
          damage = 100;
        } else if (hitZone === 'body') {
          damage = 40;
        } else if (hitZone === 'limbs') {
          damage = 20;
        }
        
        // Update health directly from server value if provided
        if (newHealth !== undefined) {
          tPlayer.health = newHealth;
        } else {
          // Apply damage
          if (typeof tPlayer.takeDamage === 'function') {
            tPlayer.takeDamage(damage, hitZone);
          } else {
            // If takeDamage is not defined, manually update health
            tPlayer.health = Math.max((tPlayer.health || 100) - damage, 0);
          }
        }
        
        // Create a hit marker or effect at the hit position if available
        if (hitPos && window.scene) {
          this.createHitMarker(hitPos, hitZone);
        }
      }
    };
  }

  showHitFeedback() {
    // Flash the screen red briefly
    const hitOverlay = document.createElement('div');
    hitOverlay.style.position = 'absolute';
    hitOverlay.style.top = '0';
    hitOverlay.style.left = '0';
    hitOverlay.style.width = '100%';
    hitOverlay.style.height = '100%';
    hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    hitOverlay.style.pointerEvents = 'none';
    hitOverlay.style.transition = 'opacity 0.5s ease-out';
    hitOverlay.style.zIndex = '1000';
    document.body.appendChild(hitOverlay);
    
    setTimeout(() => {
      hitOverlay.style.opacity = '0';
      setTimeout(() => {
        if (hitOverlay.parentNode) {
          hitOverlay.parentNode.removeChild(hitOverlay);
        }
      }, 500);
    }, 100);

    // Optional hit sound
    if (this.soundManager) {
      this.soundManager.playSound("aimclick");
    }
  }

  /**
   * Creates a visual hit marker at the hit position
   * @param {Object} position - The hit position
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   */
  createHitMarker(position, hitZone) {
    // Only create if we have THREE.js and a scene
    if (!window.THREE || !window.scene) return;
    
    // Choose color based on hit zone
    let color = 0xFFFFFF; // Default white
    if (hitZone === 'head') {
      color = 0xFF0000; // Red for headshots
    } else if (hitZone === 'body') {
      color = 0xFF6600; // Orange for body shots
    } else if (hitZone === 'limbs') {
      color = 0xFFFF00; // Yellow for limb shots
    }
    
    // Create a particle system for the hit marker
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    
    // Create particles in a small sphere
    const particleCount = 10;
    const radius = 0.1;
    
    for (let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      
      vertices.push(x, y, z);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    
    const material = new THREE.PointsMaterial({
      color: color,
      size: 0.05,
      transparent: true,
      opacity: 1
    });
    
    const particles = new THREE.Points(geometry, material);
    particles.position.copy(position);
    window.scene.add(particles);
    
    // Animate the particles
    const startTime = performance.now();
    const duration = 500; // ms
    
    function animateParticles() {
      const elapsed = performance.now() - startTime;
      const progress = elapsed / duration;
      
      if (progress < 1) {
        // Expand particles
        particles.scale.set(1 + progress * 2, 1 + progress * 2, 1 + progress * 2);
        // Fade out
        material.opacity = 1 - progress;
        
        requestAnimationFrame(animateParticles);
      } else {
        // Clean up
        window.scene.remove(particles);
        geometry.dispose();
        material.dispose();
      }
    }
    
    requestAnimationFrame(animateParticles);
  }

  addPlayer(playerId, data) {
    console.log(`Adding remote player ${playerId}`);
    const model = new ThirdPersonModel(this.scene, playerId);
    model.update(data);
    this.remotePlayers.set(playerId, model);
  }

  removePlayer(playerId) {
    console.log(`Removing remote player ${playerId}`);
    const model = this.remotePlayers.get(playerId);
    if (model) {
      model.remove();
      this.remotePlayers.delete(playerId);
    }
  }

  update(deltaTime) {
    // Animate each remote player's walk cycle and smoothly update movement
    for (const [playerId, remoteModel] of this.remotePlayers.entries()) {
      if (remoteModel.isWalking) {
        remoteModel.animateWalk(deltaTime);
      } else {
        remoteModel.resetWalkAnimation();
      }
      remoteModel.animateMovement(deltaTime);
    }
  }

  notifyPlayersUpdated() {
    if (typeof this.onRemotePlayersUpdated === 'function') {
      this.onRemotePlayersUpdated();
    }
  }
}

================================================
File: /public/js/network.js
================================================
/**
 * NetworkManager class for WebSocket communication.
 * It provides event callbacks for multiplayer events and methods to send data.
 */
export class NetworkManager {
  constructor() {
    this.socket = null;
    this.playerId = null;
    this.otherPlayers = new Map(); // Maps playerId -> playerData from the server

    // Callbacks
    this.onInit = null;              // Called when we first receive 'init' from server
    this.onPlayerJoined = null;
    this.onPlayerLeft = null;
    this.onPlayerUpdate = null;
    this.onPlayerShoot = null;
    this.onPlayerCount = null;
    this.onPlayerHit = null;         // When this player is hit by someone
    this.onPlayerHitBroadcast = null;// When any player is hit
    this.onOpen = null;
    this.onClose = null;
    this.onError = null;

    // Anti-cheat callbacks
    this.onPositionCorrection = null;// When server corrects client position
    this.onBulletImpact = null;      // When a bullet hits something
    this.onRespawn = null;           // When player respawns

    // Automatic reconnect attempts
    this.connectionAttempts = 0;
    this.maxConnectionAttempts = 5;
    this.reconnectTimer = null;

    // Unique sessionId to prevent multiple tabs from colliding
    this.sessionId = this._generateSessionId();
    
    // Anti-cheat: Sequence number for message ordering
    this.sequenceNumber = 0;
    
    // Anti-cheat: Map to track outgoing messages that need nonces
    this.pendingMessages = new Map();
  }

  /**
   * Generates a unique-ish session ID to detect duplicate connections from the same tab.
   */
  _generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }
  
  /**
   * Generates a unique nonce for secure actions.
   * @returns {string} A unique nonce
   */
  _generateNonce() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2) + 
           Math.random().toString(36).substring(2);
  }

  /**
   * Initiates a connection to the WebSocket server.
   */
  connect() {
    this._cleanupSocket();

    // Determine correct ws:// or wss:// based on current protocol
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = `${protocol}${window.location.host}?sessionId=${this.sessionId}`;

    console.log('Attempting to connect to:', wsUrl);
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = (event) => {
      console.log('WebSocket connected');
      this.connectionAttempts = 0;
      if (typeof this.onOpen === 'function') {
        this.onOpen(event);
      }
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleMessage(message);
      } catch (err) {
        console.error('Error parsing server message:', err);
      }
    };

    this.socket.onclose = (event) => {
      console.log(`WebSocket closed: ${event.code} ${event.reason}`);
      if (typeof this.onClose === 'function') {
        this.onClose(event);
      }
      this._scheduleReconnect();
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      if (typeof this.onError === 'function') {
        this.onError(error);
      }
    };
  }

  /**
   * Clean up any existing WebSocket connection.
   */
  _cleanupSocket() {
    if (this.socket) {
      this.socket.onopen = null;
      this.socket.onmessage = null;
      this.socket.onclose = null;
      this.socket.onerror = null;
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close();
      }
      this.socket = null;
    }

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * Schedules a reconnect attempt if under max attempts.
   */
  _scheduleReconnect() {
    if (this.connectionAttempts < this.maxConnectionAttempts) {
      this.connectionAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
      console.log(`Reconnecting in ${(delay / 1000).toFixed(1)}s... (Attempt ${this.connectionAttempts}/${this.maxConnectionAttempts})`);
      
      this.reconnectTimer = setTimeout(() => {
        console.log(`Reconnecting now (Attempt ${this.connectionAttempts})...`);
        this.connect();
      }, delay);
    } else {
      console.error('Max reconnect attempts reached. Please refresh the page.');
    }
  }

  /**
   * Handles all messages from the server.
   * @param {Object} message The parsed JSON message object.
   */
  handleMessage(message) {
    switch (message.type) {
      // New connection initialization
      case 'init':
        this.playerId = message.id;
        console.log(`Assigned player ID: ${this.playerId}`);

        // If there's a callback
        if (typeof this.onInit === 'function') {
          this.onInit(message);
        }

        // Add known players
        message.players.forEach(player => {
          if (this.onPlayerJoined) {
            this.onPlayerJoined(player);
          }
          this.otherPlayers.set(player.id, player);
        });
        break;

      // Another player joined
      case 'playerJoined':
        console.log(`Player ${message.id} joined`);
        if (this.onPlayerJoined) {
          this.onPlayerJoined(message);
        }
        this.otherPlayers.set(message.id, {
          id: message.id,
          position: message.position,
          rotation: message.rotation,
          isAiming: false,
          isShooting: false,
          isReloading: false,
          quickDrawLobbyIndex: message.quickDrawLobbyIndex || -1
        });
        break;

      // Player left
      case 'playerLeft':
        console.log(`Player ${message.id} left`);
        if (this.onPlayerLeft) {
          this.onPlayerLeft(message.id);
        }
        this.otherPlayers.delete(message.id);
        break;

      // General player update (pos/rot/aiming/etc.)
      case 'playerUpdate':
        {
          const existing = this.otherPlayers.get(message.id);
          if (existing) {
            existing.position = message.position || existing.position;
            existing.rotation = message.rotation || existing.rotation;
            existing.isAiming =
              message.isAiming !== undefined ? message.isAiming : existing.isAiming;
            existing.isShooting =
              message.isShooting !== undefined ? message.isShooting : existing.isShooting;
            existing.isReloading =
              message.isReloading !== undefined ? message.isReloading : existing.isReloading;
            existing.quickDrawLobbyIndex =
              message.quickDrawLobbyIndex !== undefined ? message.quickDrawLobbyIndex : existing.quickDrawLobbyIndex;
            existing.health =
              message.health !== undefined ? message.health : existing.health;
          }
          if (this.onPlayerUpdate) {
            this.onPlayerUpdate(message.id, existing);
          }
        }
        break;

      // Remote player fired
      case 'playerShoot':
        if (this.onPlayerShoot) {
          this.onPlayerShoot(message.id, message.bulletData, message.bulletId);
        }
        break;

      // Current total player count
      case 'playerCount':
        if (this.onPlayerCount) {
          this.onPlayerCount(message.count);
        }
        break;

      // This client was hit by another player
      case 'hit':
        console.log(`I was hit by player ${message.sourceId} in the ${message.hitZone || 'body'} for ${message.hitData?.damage || 20} damage`);
        if (this.onPlayerHit) {
          this.onPlayerHit(message.sourceId, message.hitData, message.health, message.hitZone);
        }
        break;

      // A broadcast that someone was hit
      case 'playerHit':
        console.log(`Player ${message.targetId} was hit by player ${message.sourceId} in the ${message.hitZone || 'body'}`);
        if (this.onPlayerHitBroadcast) {
          this.onPlayerHitBroadcast(
            message.targetId,
            message.sourceId,
            message.hitPosition,
            message.health,
            message.hitZone,
            message.damage
          );
        }
        break;

      // Anti-cheat: Server correction of client position
      case 'positionCorrection':
        console.log(`Received position correction:`, message.position);
        if (this.onPositionCorrection) {
          this.onPositionCorrection(message.position);
        }
        break;
        
      // Anti-cheat: Bullet impact notification
      case 'bulletImpact':
        if (this.onBulletImpact) {
          this.onBulletImpact(
            message.bulletId, 
            message.hitType, 
            message.targetId, 
            message.position,
            message.hitZone
          );
        }
        break;
        
      // Anti-cheat: Player respawn notification
      case 'respawn':
        console.log(`Respawning at:`, message.position);
        if (this.onRespawn) {
          this.onRespawn(message.position, message.health, message.bullets);
        }
        break;

      // Generic error from server
      case 'error':
        console.error('Server error:', message.message);
        if (message.fatal) {
          this.connectionAttempts = this.maxConnectionAttempts; // block further reconnect
          alert(`Fatal error: ${message.message}`);
        }
        break;

      default:
        console.warn('Unhandled message:', message);
        break;
    }
  }

  /**
   * Sends local player position/rotation etc. to the server.
   * @param {Object} playerData - { position, rotation, isAiming, isReloading, isSprinting, quickDrawLobbyIndex }
   */
  sendUpdate(playerData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'update',
          sequenceNumber: this.sequenceNumber,
          ...playerData
        })
      );
    }
  }

  /**
   * Notifies server that we fired a bullet.
   * @param {Object} bulletData - { position: {x,y,z}, direction: {x,y,z} }
   */
  sendShoot(bulletData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'shoot',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          bulletData
        })
      );
    }
  }

  /**
   * Notifies server that we hit another player.
   * @param {number|string} hitPlayerId
   * @param {Object} hitData - { position: {x,y,z}, sourcePlayerId: ..., hitZone: 'head'|'body'|'limbs', damage: number }
   * @param {number|string} bulletId - Optional bulletId if known
   */
  sendPlayerHit(hitPlayerId, hitData, bulletId = null) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'playerHit',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          targetId: hitPlayerId,
          bulletId: bulletId,
          hitData
        })
      );
    }
  }
  
  /**
   * Notifies server that player is starting to reload.
   */
  sendReload() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'reload',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }
  
  /**
   * Sends a request to join a specific Quick Draw arena queue.
   * @param {number} arenaIndex - The arena index (0-4)
   */
  sendQuickDrawJoin(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawJoin',
          sequenceNumber: this.sequenceNumber,
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Sends a request to leave the Quick Draw queue.
   */
  sendQuickDrawLeave() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawLeave',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player is ready for a Quick Draw duel.
   * @param {number} arenaIndex - The arena index for the duel
   */
  sendQuickDrawReady(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawReady',
          sequenceNumber: this.sequenceNumber,
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player has shot their opponent in a Quick Draw duel.
   * @param {number|string} opponentId - The opponent's player ID
   * @param {number} arenaIndex - The arena index for the duel
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   * @param {number} damage - The damage amount
   */
  sendQuickDrawShoot(opponentId, arenaIndex, hitZone = 'body', damage = 40) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      console.log(`Sending Quick Draw hit notification to server: player ${this.playerId} hit player ${opponentId} in the ${hitZone} for ${damage} damage`);
      this.socket.send(JSON.stringify({
        type: 'quickDrawShoot',
        sequenceNumber: this.sequenceNumber,
        nonce: nonce,
        opponentId: opponentId,
        arenaIndex: arenaIndex,
        hitZone: hitZone,
        damage: damage
      }));
    }
  }

  /**
   * Closes the connection manually.
   */
  disconnect() {
    this._cleanupSocket();
    console.log('WebSocket connection manually closed');
  }
}

// Export a singleton instance
export const networkManager = new NetworkManager();
// Make it globally accessible
window.networkManager = networkManager;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  networkManager.disconnect();
});

================================================
File: /public/js/physics.js
================================================
/**
 * Physics system using cannon.js for collision detection and physics simulation.
 * Focused on creating invisible boundaries for the QuickDraw arenas and town.
 */
export class PhysicsSystem {
  constructor() {
    // Create a physics world with gravity
    this.world = new CANNON.World();
    this.world.gravity.set(0, -9.8, 0);
    
    // Set default contact material properties
    this.defaultMaterial = new CANNON.Material('default');
    const defaultContactMaterial = new CANNON.ContactMaterial(
      this.defaultMaterial,
      this.defaultMaterial,
      {
        friction: 0.3,
        restitution: 0.3 // Slightly bouncy
      }
    );
    this.world.addContactMaterial(defaultContactMaterial);
    this.world.defaultContactMaterial = defaultContactMaterial;
    
    // Collection of bodies
    this.bodies = [];
    
    // Debug helper for visualizing physics bodies
    this.debugMeshes = [];
    this.debugMode = false;
    
    // Track arena boundaries separately
    this.arenaBoundaryBodies = [];
    
    // Initialize ground
    this.initGround();
  }
  
  /**
   * Initialize the ground plane
   */
  initGround() {
    const groundBody = new CANNON.Body({
      mass: 0, // Static body
      shape: new CANNON.Plane(),
      material: this.defaultMaterial
    });
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be flat
    this.world.addBody(groundBody);
    this.bodies.push(groundBody);
  }
  
  /**
   * Creates an invisible boundary for the town to prevent players from leaving
   * @param {number} width - Width of the town
   * @param {number} length - Length of the town
   * @param {number} height - Height of the barrier
   * @returns {CANNON.Body} - The created physics body
   */
  createTownBoundary(width, length, height) {
    // First remove any existing town boundaries
    this.removeTownBoundary();
    
    // Create a physics body for the town boundary
    const boundaryBody = new CANNON.Body({
      mass: 0, // Static body
      material: this.defaultMaterial
    });
    
    // Add a box shape for each border
    const halfWidth = width / 2;
    const halfLength = length / 2;
    const borderThickness = 0.5;
    
    // Left border (negative X)
    const leftBorderShape = new CANNON.Box(new CANNON.Vec3(
      borderThickness / 2, 
      height / 2, 
      length / 2
    ));
    boundaryBody.addShape(
      leftBorderShape, 
      new CANNON.Vec3(-halfWidth, height / 2, 0)
    );
    
    // Right border (positive X)
    const rightBorderShape = new CANNON.Box(new CANNON.Vec3(
      borderThickness / 2, 
      height / 2, 
      length / 2
    ));
    boundaryBody.addShape(
      rightBorderShape, 
      new CANNON.Vec3(halfWidth, height / 2, 0)
    );
    
    // Front border (negative Z)
    const frontBorderShape = new CANNON.Box(new CANNON.Vec3(
      width / 2, 
      height / 2, 
      borderThickness / 2
    ));
    boundaryBody.addShape(
      frontBorderShape, 
      new CANNON.Vec3(0, height / 2, -halfLength)
    );
    
    // Back border (positive Z)
    const backBorderShape = new CANNON.Box(new CANNON.Vec3(
      width / 2, 
      height / 2, 
      borderThickness / 2
    ));
    boundaryBody.addShape(
      backBorderShape, 
      new CANNON.Vec3(0, height / 2, halfLength)
    );
    
    boundaryBody.townBoundary = true; // Tag this body as a town boundary
    boundaryBody.collisionFilterGroup = 2; // Group 2 for boundaries
    
    // Add the boundary body to the world
    this.world.addBody(boundaryBody);
    this.bodies.push(boundaryBody);
    
    // Create a reference to easily find this body later
    this.townBoundaryBody = boundaryBody;
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(boundaryBody);
    }
    
    console.log("Created town boundary with width", width, "and length", length);
    
    return boundaryBody;
  }
  
  /**
   * Removes the town boundary if it exists
   */
  removeTownBoundary() {
    if (this.townBoundaryBody) {
      this.world.removeBody(this.townBoundaryBody);
      
      // Remove from our bodies array
      const index = this.bodies.indexOf(this.townBoundaryBody);
      if (index !== -1) {
        this.bodies.splice(index, 1);
      }
      
      // Clear the reference
      this.townBoundaryBody = null;
      console.log("Removed town boundary");
    }
  }
  
  /**
   * Creates an invisible cylindrical boundary for a QuickDraw arena
   * @param {THREE.Vector3} center - Center position of the arena
   * @param {number} radius - Radius of the cylindrical arena
   * @param {number} height - Height of the cylindrical arena
   * @param {number} arenaIndex - Index of the arena (0-4)
   * @returns {CANNON.Body} - The created physics body
   */
  createQuickDrawArenaBoundary(center, radius, height, arenaIndex = 0) {
    // First remove any existing arena boundary for this index
    this.removeQuickDrawArenaBoundaryByIndex(arenaIndex);
    
    // Create a physics body for the arena boundary
    const arenaBody = new CANNON.Body({
      mass: 0, // Static body
      material: this.defaultMaterial
    });
    
    // Position at the center
    arenaBody.position.set(center.x, center.y + height/2, center.z);
    
    // Use a hollow cylinder (cylinder + inverted cylinder)
    // We make the walls a bit thick (0.5 units) to ensure reliable collision detection
    const wallThickness = 0.5;
    
    // Outer cylinder (pushing inward)
    const outerRadius = radius + wallThickness;
    const segments = 16; // Number of sides for the cylinder approximation
    
    // Create segments around the circle to approximate the cylinder
    for (let i = 0; i < segments; i++) {
      const angle1 = (i / segments) * Math.PI * 2;
      const angle2 = ((i + 1) / segments) * Math.PI * 2;
      
      const x1 = Math.cos(angle1) * radius;
      const z1 = Math.sin(angle1) * radius;
      const x2 = Math.cos(angle2) * radius;
      const z2 = Math.sin(angle2) * radius;
      
      // Calculate the position and orientation of this wall segment
      const segCenter = {
        x: (x1 + x2) / 2,
        z: (z1 + z2) / 2
      };
      
      const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
      
      // Create a box shape for this wall segment
      const halfExtents = new CANNON.Vec3(length/2, height/2, wallThickness/2);
      const wallShape = new CANNON.Box(halfExtents);
      
      // Get the angle to rotate this wall segment
      const rotationY = Math.atan2(z2 - z1, x2 - x1) + Math.PI/2;
      
      // Add the shape to the body with the appropriate offset and rotation
      const offset = new CANNON.Vec3(segCenter.x, 0, segCenter.z);
      const quaternion = new CANNON.Quaternion();
      quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
      
      arenaBody.addShape(wallShape, offset, quaternion);
    }
    
    // Bottom circle to prevent falling through
    const bottomShape = new CANNON.Cylinder(radius, radius, wallThickness, segments);
    const bottomOffset = new CANNON.Vec3(0, -height/2, 0);
    const bottomQuaternion = new CANNON.Quaternion();
    bottomQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    arenaBody.addShape(bottomShape, bottomOffset, bottomQuaternion);
    
    arenaBody.arenaBoundary = true; // Tag this body as an arena boundary
    arenaBody.arenaIndex = arenaIndex; // Store which arena this belongs to
    arenaBody.collisionFilterGroup = 2; // Group 2 for arena boundaries
    
    // Add the arena body to the world
    this.world.addBody(arenaBody);
    this.bodies.push(arenaBody);
    
    // Store in our array of arena boundaries
    this.arenaBoundaryBodies[arenaIndex] = arenaBody;
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(arenaBody);
    }
    
    console.log(`Created QuickDraw arena boundary ${arenaIndex + 1} at`, center, "with radius", radius, "and height", height);
    
    return arenaBody;
  }
  
  /**
   * Removes a QuickDraw arena boundary for a specific arena index
   * @param {number} arenaIndex - The index of the arena (0-4)
   */
  removeQuickDrawArenaBoundaryByIndex(arenaIndex) {
    if (this.arenaBoundaryBodies[arenaIndex]) {
      this.world.removeBody(this.arenaBoundaryBodies[arenaIndex]);
      
      // Remove from our bodies array
      const index = this.bodies.indexOf(this.arenaBoundaryBodies[arenaIndex]);
      if (index !== -1) {
        this.bodies.splice(index, 1);
      }
      
      // Clear the reference in our arena boundaries array
      this.arenaBoundaryBodies[arenaIndex] = null;
      console.log(`Removed QuickDraw arena boundary ${arenaIndex + 1}`);
    }
  }
  
  /**
   * Removes the QuickDraw arena boundary (legacy method for backward compatibility)
   */
  removeQuickDrawArenaBoundary() {
    // Remove all arena boundaries
    for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
      this.removeQuickDrawArenaBoundaryByIndex(i);
    }
  }
  
  /**
   * Create a physics body for a player
   * @param {THREE.Vector3} position - Initial position
   * @param {number} radius - Player collision radius
   * @param {number} height - Player height
   * @returns {CANNON.Body} - The created physics body
   */
  createPlayerBody(position, radius = 0.3, height = 1.8) {
    // Create a capsule shape (cylinder with spheres at ends)
    const playerBody = new CANNON.Body({
      mass: 70, // Player mass in kg
      material: this.defaultMaterial,
      fixedRotation: true, // Don't rotate the player when colliding
      linearDamping: 0.9 // Add some damping to prevent excessive sliding
    });
    
    // Use a cylinder for the body
    playerBody.addShape(new CANNON.Cylinder(radius, radius, height, 8));
    
    // Position the player body
    playerBody.position.set(position.x, position.y, position.z);
    
    // Add to world
    this.world.addBody(playerBody);
    this.bodies.push(playerBody);
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(playerBody);
    }
    
    return playerBody;
  }
  
  /**
   * Checks if a point is inside any active arena boundary
   * @param {THREE.Vector3} point - The point to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInArenaBoundary(point) {
    // Check all arena boundaries
    for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
      if (this.isPointInSpecificArenaBoundary(point, i)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Checks if a point is inside a specific arena boundary
   * @param {THREE.Vector3} point - The point to check
   * @param {number} arenaIndex - The arena index to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInSpecificArenaBoundary(point, arenaIndex) {
    // If no arena boundary exists for this index, return false
    if (!this.arenaBoundaryBodies[arenaIndex]) return false;
    
    // Get arena position
    const arenaPos = this.arenaBoundaryBodies[arenaIndex].position;
    const pointVec = new CANNON.Vec3(point.x, point.y, point.z);
    
    // Calculate horizontal distance (ignoring Y) from arena center
    const dx = pointVec.x - arenaPos.x;
    const dz = pointVec.z - arenaPos.z;
    const horizontalDist = Math.sqrt(dx * dx + dz * dz);
    
    // Get the radius - assuming 15 is the standard radius for all arenas
    const radius = 15;
    
    // Check if point is inside the cylinder horizontally
    return horizontalDist < radius;
  }

  /**
   * Checks if a point is inside the town boundary
   * @param {THREE.Vector3} point - The point to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInTown(point) {
    // If no town boundary exists, return true (no restriction)
    if (!window.townDimensions) return true;
    
    // Get town dimensions
    const width = window.townDimensions.width;
    const length = window.townDimensions.length;
    
    // Check if the point is within the town boundaries
    return (
      point.x > -width / 2 && 
      point.x < width / 2 && 
      point.z > -length / 2 && 
      point.z < length / 2
    );
  }
  
  /**
   * Creates a debug mesh to visualize a physics body
   * @param {CANNON.Body} body - The physics body to visualize
   */
  createDebugMesh(body) {
    // Only used in debug mode
    if (!this.debugMode) return;
    
    // For each shape in the body, create a wireframe mesh
    body.shapes.forEach((shape, i) => {
      let geometry;
      let mesh;
      
      // Get the shape's offset and orientation
      const offset = body.shapeOffsets[i];
      const orientation = body.shapeOrientations[i];
      
      // Create different geometries based on shape type
      if (shape instanceof CANNON.Box) {
        geometry = new THREE.BoxGeometry(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        mesh.quaternion.set(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
      }
      else if (shape instanceof CANNON.Sphere) {
        geometry = new THREE.SphereGeometry(shape.radius, 16, 16);
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset
        mesh.position.set(offset.x, offset.y, offset.z);
      }
      else if (shape instanceof CANNON.Cylinder) {
        geometry = new THREE.CylinderGeometry(
          shape.radiusTop,
          shape.radiusBottom,
          shape.height,
          shape.numSegments
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Rotate to match cannon.js cylinders
        mesh.rotation.x = Math.PI / 2;
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        const quat = new THREE.Quaternion(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
        mesh.quaternion.multiply(quat);
      }
      
      if (mesh) {
        // Add to the body's group
        const group = new THREE.Group();
        group.add(mesh);
        
        // Store reference for updating
        this.debugMeshes.push({
          mesh: group,
          body: body
        });
        
        // Add to scene
        window.scene.add(group);
      }
    });
  }
  
  /**
   * Update the physics world
   * @param {number} deltaTime - Time step in seconds
   */
  update(deltaTime) {
    // Limit delta time to prevent large jumps
    const timeStep = Math.min(deltaTime, 0.1);
    
    // Update physics world
    this.world.step(timeStep);
    
    // Update debug meshes if in debug mode
    if (this.debugMode) {
      this.updateDebugMeshes();
    }
  }
  
  /**
   * Update debug mesh positions to match their physics bodies
   */
  updateDebugMeshes() {
    if (!this.debugMode) return;
    
    this.debugMeshes.forEach(item => {
      // Update position
      item.mesh.position.set(
        item.body.position.x,
        item.body.position.y,
        item.body.position.z
      );
      
      // Update orientation
      item.mesh.quaternion.set(
        item.body.quaternion.x,
        item.body.quaternion.y,
        item.body.quaternion.z,
        item.body.quaternion.w
      );
    });
  }
  
  /**
   * Enables or disables debug visualization
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  setDebugMode(enabled) {
    // Store previous debug mode to detect changes
    const previousDebugMode = this.debugMode;
    this.debugMode = enabled;
    
    // If enabling and we weren't previously in debug mode
    if (enabled && !previousDebugMode) {
      // Create meshes for existing physics bodies
      this.bodies.forEach(body => {
        this.createDebugMesh(body);
      });
      
      // Set a global flag to signal hit zone debug should be created
      window.showHitZoneDebug = true;
      
      console.log("Physics debug mode enabled - hit zones visible");
    }
    // If disabling and we were previously in debug mode
    else if (!enabled && previousDebugMode) {
      // Remove all physics debug meshes
      this.debugMeshes.forEach(item => {
        if (item.mesh && window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
      this.debugMeshes = [];
      
      // Remove any hit zone debug visualizations
      this.cleanupHitZoneDebug();
      
      // Clear the global flag for hit zone debugging
      window.showHitZoneDebug = false;
      
      console.log("Physics debug mode disabled - hit zones hidden");
    }
  }
  
  /**
   * Clean up hit zone debug visualizations
   */
  cleanupHitZoneDebug() {
    // Find and remove all hit zone debug objects
    if (window.scene) {
      const hitZoneObjects = [];
      window.scene.traverse(obj => {
        if (obj.name && obj.name.startsWith("hitZoneDebug_")) {
          hitZoneObjects.push(obj);
        }
      });
      
      // Remove each hit zone debug object
      hitZoneObjects.forEach(obj => {
        window.scene.remove(obj);
        // Clean up materials and geometries
        obj.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      });
      
      if (hitZoneObjects.length > 0) {
        console.log(`Removed ${hitZoneObjects.length} hit zone debug visualizations`);
      }
    }
    
    // Clear player hit zone debug references
    // Find all player objects
    if (window.localPlayer) {
      window.localPlayer._hitZoneDebug = null;
    }
    // Remote players
    if (window.remotePlayers) {
      window.remotePlayers.forEach(player => {
        if (player) {
          player._hitZoneDebug = null;
        }
      });
    }
  }
  
  /**
   * Refreshes hit zone debug visualizations when debug mode is active
   */
  refreshHitZoneDebug() {
    console.log("Refreshing hit zone debug visualizations");
    
    // Don't do anything if debug mode isn't enabled
    if (!this.debugMode) return;
    
    // Create debug boxes for all existing player models
    if (window.playersMap) {
      for (const [playerId, playerModel] of window.playersMap) {
        const dummyBullet = new Bullet(
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 1, 0)
        );
        dummyBullet.checkPlayerHitZones(playerModel, new THREE.Vector3(0, 0, 0));
      }
    }
  }
  
  /**
   * Cleans up all physics resources
   */
  cleanup() {
    // Remove all bodies
    this.bodies.forEach(body => {
      this.world.removeBody(body);
    });
    
    // Remove all debug meshes
    if (this.debugMode) {
      this.debugMeshes.forEach(item => {
        if (window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
    }
    
    // Clean up hit zone debug visualizations
    this.cleanupHitZoneDebug();
    
    this.bodies = [];
    this.debugMeshes = [];
    this.arenaBoundaryBodies = [];
  }
}

================================================
File: /public/js/player.js
================================================
import { Revolver } from './revolver.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { applyRecoil, ejectShell } from './effects.js';
import { networkManager } from './network.js';
import { ThirdPersonModel } from './playerModel.js';

/**
 * The local Player class (first-person).
 */
export class Player {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene
   * @param {THREE.PerspectiveCamera} config.camera
   * @param {SoundManager} config.soundManager
   * @param {Function} config.onShoot - A callback function called when the player fires a bullet.
   */
  constructor({ scene, camera, soundManager, onShoot }) {
    this.scene = scene;
    this.camera = camera;
    this.soundManager = soundManager;
    this.onShootCallback = onShoot;

    this.group = new THREE.Group();
    
    // Start at a random spawn point in the town street
    this.spawnPlayerRandomly();
    
    this.scene.add(this.group);
    this.camera.position.set(0, 0, 0);
    this.group.add(this.camera);

    // Add first-person body model
    this.createFirstPersonBody();

    this.id = null; // will be set by networkManager.onInit
    this.velocity = new THREE.Vector3();
    this.canJump = false;

    // Movement flags
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    
    // Movement control flags
    this.canMove = true; // Whether player can move at all
    this.forceLockMovement = false; // Complete movement override (quickdraw mode)
    
    // Sprinting flag - new addition
    this.isSprinting = false;
    this.normalSpeed = 5; // Default movement speed
    this.sprintSpeed = 12; // Faster sprint speed
    this.sprintJumpBoost = 1.5; // Jump boost factor when sprinting

    // Aiming
    this.isAiming = false;
    this.defaultFOV = 75;
    this.aimFOV = 65;
    
    // Camera effects for sprinting - with smoothing parameters
    this.defaultCameraHeight = 0;
    this.bobPhase = 0; // Phase accumulator for bob effect
    this.bobIntensity = 0; // Current intensity of bobbing (interpolates)
    this.targetBobIntensity = 0; // Target bobbing intensity
    this.bobTransitionSpeed = 3; // Speed of transition to new bob intensity
    
    // Gun
    this.revolver = new Revolver();
    this.holsterOffset = new THREE.Vector3(0.6, -0.5, -0.8);
    this.aimOffset = new THREE.Vector3(0.3, -0.3, -0.5);
    this.currentGunOffset = this.holsterOffset.clone();
    this.camera.add(this.revolver.group);

    // FOV transition smoothing
    this.currentFOV = this.defaultFOV;
    this.targetFOV = this.defaultFOV;
    this.fovTransitionSpeed = 5; // Speed of FOV transitions

    // Reload
    this.isReloading = false;
    this.reloadTime = 4000; // Changed from 2000ms to 4000ms (4 seconds)
    this.reloadProgress = 0;
    this.bullets = 6;
    this.maxBullets = 6;
    this.canShoot = true;

    // Health
    this.health = 100;

    // Networking
    this.lastNetworkUpdate = 0;
    this.networkUpdateInterval = 33; // ~30 fps updates, balanced between responsiveness and bandwidth

    // Quick Draw mode
    this.canAim = true; // Whether the player is allowed to aim (used by Quick Draw)
    
    // Store previous position to detect collision with arena boundary
    this.previousPosition = new THREE.Vector3();

    // Quick Draw lobby information
    this.quickDrawLobbyIndex = -1; // -1 means not in a lobby
    
    // Anti-cheat: Server reconciliation
    this.serverPosition = new THREE.Vector3();
    this.isReconciling = false;
    this.reconciliationLerpFactor = 0.3; // How quickly to move to server position

    // Footstep sound system
    this.lastFootstepTime = 0; // Time of last footstep sound
    this.footstepInterval = 0.5; // Base interval in seconds between steps
    this.isLeftFoot = true; // Track which foot is next
    this.isMovingLastFrame = false; // Track if player was moving in the last frame
    this.isJumping = false; // Track jumping state
    
    // Hit zones for damage calculations
    this.hitZones = {
      head: { damage: 100 },
      body: { damage: 40 },
      limbs: { damage: 20 }
    };
    
    // Initialize network & UI
    this.initNetworking();
    updateAmmoUI(this);
    updateHealthUI(this);
  }

  /**
   * Spawn the player at a random position along the main street
   */
  spawnPlayerRandomly() {
    // Default position if town dimensions aren't available
    let spawnX = 0;
    let spawnY = 1.6;
    let spawnZ = 0;

    // If town dimensions are available, use them for spawn positioning
    if (window.townDimensions) {
      const streetWidth = window.townDimensions.streetWidth;
      const townLength = window.townDimensions.length;
      
      // Random position within the street area
      spawnX = (Math.random() - 0.5) * streetWidth * 0.8; // 80% of street width to avoid edges
      spawnZ = (Math.random() - 0.5) * townLength * 0.8; // 80% of town length
    }

    this.group.position.set(spawnX, spawnY, spawnZ);
    
    // Random rotation (facing any direction)
    this.group.rotation.y = Math.random() * Math.PI * 2;
    
    console.log(`Player spawned at: X=${spawnX.toFixed(2)}, Z=${spawnZ.toFixed(2)}`);
  }

  initNetworking() {
    // Start the WebSocket
    networkManager.connect();

    networkManager.onInit = (initData) => {
      this.id = initData.id;
      console.log(`Local player initialized with ID: ${this.id}`);
    };
    
    // Anti-cheat: Handle position corrections from server
    networkManager.onPositionCorrection = (correctedPosition) => {
      console.log("Received position correction from server");
      
      // Instead of constant reconciliation, we'll use a "rubber-banding" approach
      // Save server position and current client position
      this.serverPosition = new THREE.Vector3(
        correctedPosition.x,
        correctedPosition.y,
        correctedPosition.z
      );
      
      // Only apply corrections when player is not actively moving
      // This prevents teleports during active gameplay
      if (!this.isMoving()) {
        // Immediate reposition when not moving
        this.group.position.copy(this.serverPosition);
        this.previousPosition.copy(this.serverPosition);
        console.log("Applied immediate position correction (not moving)");
      } else {
        // Mark for gradual correction if moving
        this.isReconciling = true;
        // Use a very subtle correction that's almost unnoticeable
        this.reconciliationLerpFactor = 0.05;
      }
    };
    
    // Anti-cheat: Handle respawn from server
    networkManager.onRespawn = (position, health, bullets) => {
      console.log("Server-initiated respawn");
      
      // Set position
      this.group.position.copy(position);
      this.previousPosition.copy(position);
      
      // Update health and bullets
      this.health = health || 100;
      this.bullets = bullets || this.maxBullets;
      
      // Reset states
      this.isReloading = false;
      this.isAiming = false;
      this.velocity.y = 0;
      this.canAim = true;
      
      // Update UI
      updateHealthUI(this);
      updateAmmoUI(this);
    };
  }

  update(deltaTime) {
    // Store previous position before movement for collision detection
    this.previousPosition.copy(this.group.position);
    
    // Anti-cheat: Handle server reconciliation
    if (this.isReconciling) {
      // Calculate distance to server position
      const distance = this.group.position.distanceTo(this.serverPosition);
      
      // Only apply reconciliation if significant deviation exists
      if (distance > 0.1) {
        // For large corrections, blend gradually
        this.group.position.lerp(this.serverPosition, this.reconciliationLerpFactor);
      } else {
        // Close enough, stop reconciling
        this.isReconciling = false;
      }
    }
    
    // Smoothly interpolate the gun offset & FOV
    const targetOffset = this.isAiming && this.canAim ? this.aimOffset : this.holsterOffset;
    this.currentGunOffset.lerp(targetOffset, 0.1);
    this.revolver.group.position.copy(this.currentGunOffset);

    // Adjust FOV based on sprinting and aiming with smoother transitions
    if (this.isAiming && this.canAim) {
      this.targetFOV = this.aimFOV;
    } else if (this.isSprinting && this.isMoving() && !window.quickDraw?.inDuel) {
      // FOV effect when sprinting, but not in QuickDraw duel
      this.targetFOV = this.defaultFOV + 7; // Less extreme FOV increase (was 10)
    } else {
      this.targetFOV = this.defaultFOV;
    }
    
    // Smooth FOV transition
    this.currentFOV = THREE.MathUtils.lerp(
      this.currentFOV, 
      this.targetFOV, 
      deltaTime * this.fovTransitionSpeed
    );
    this.camera.fov = this.currentFOV;
    this.camera.updateProjectionMatrix();
    
    // Update first-person body model if it exists
    if (this.fpBody) {
      // Update body animation based on movement
      if (this.isMoving()) {
        this.fpBody.isWalking = true;
        this.fpBody.animateWalk(deltaTime);
      } else {
        this.fpBody.isWalking = false;
        this.fpBody.resetWalkAnimation();
      }
      
      // Update body pose based on aiming
      if (this.isAiming) {
        this.fpBody.setAimingPose();
      } else {
        this.fpBody.setNormalPose();
      }
    }

    // Handle head bob effect when moving - with improvements
    this.updateHeadBob(deltaTime);

    // Gravity
    this.velocity.y -= 20 * deltaTime;
    
    // Check if player is jumping
    const wasOnGround = this.canJump;
    const isJumping = this.velocity.y > 0 && !this.canJump;
    
    // Store the previous jumping state to detect when we first start jumping
    const wasJumping = this.isJumping || false;
    this.isJumping = isJumping;
    
    this.group.position.y += this.velocity.y * deltaTime;
    if (this.group.position.y < 1.6) {
      // Player landed
      if (this.velocity.y < -3 && !wasOnGround) {
        // Play landing sound if falling fast enough
        if (this.soundManager) {
          // Use regular footstep sound for landing, but play it directly for reliability
          this.soundManager.playSound("leftstep", 0, 1.2);
        }
      }
      
      this.velocity.y = 0;
      this.group.position.y = 1.6;
      this.canJump = true;
      this.isJumping = false;
    }

    // Process movement
    this.move(deltaTime);
    
    // Footstep sounds logic based on movement
    const positionBeforeMovement = this.previousPosition.clone();
    this.updateFootstepSounds(deltaTime, positionBeforeMovement);
    
    // Handle jump sound - only play when we first start jumping (not previously jumping)
    if (isJumping && !wasJumping && this.soundManager) {
      this.soundManager.playSound("jump", 300); // Play jump sound with 300ms cooldown
    }

    // Send periodic network updates
    const now = performance.now();
    if (now - this.lastNetworkUpdate > this.networkUpdateInterval) {
      this.lastNetworkUpdate = now;
      this.sendNetworkUpdate();
    }

    // Update camera bob (only if on ground)
    if (this.canJump) {
      this.updateHeadBob(deltaTime);
    }
    
    // Update aiming effects including crosshair
    this.updateAiming(deltaTime);
  }

  /**
   * Process player movement based on input - can be overridden to disable movement
   * @param {number} deltaTime - Time elapsed since last frame
   */
  move(deltaTime) {
    // Skip movement if force locked (used by quickdraw)
    if (this.forceLockMovement || !this.canMove) {
      return;
    }
    
    // Movement - now with sprint capability
    const moveSpeed = this.getMoveSpeed();
    const forward = new THREE.Vector3();
    this.camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
    
    // Calculate new position based on movement input
    const newPosition = this.group.position.clone();
    
    if (this.moveForward) newPosition.add(forward.clone().multiplyScalar(moveSpeed * deltaTime));
    if (this.moveBackward) newPosition.add(forward.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveLeft) newPosition.add(right.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveRight) newPosition.add(right.clone().multiplyScalar(moveSpeed * deltaTime));

    // Check for boundary collisions before applying the new position
    const canMove = this.checkBoundaryCollision(newPosition);
    
    if (canMove) {
      this.group.position.copy(newPosition);
    } else {
      // If can't move to the new position, try to slide along the boundary
      // This gives a better feeling than just stopping
      if (this.moveForward || this.moveBackward) {
        const slideX = this.group.position.clone();
        slideX.x = newPosition.x;
        if (this.checkBoundaryCollision(slideX)) {
          this.group.position.copy(slideX);
        }
      }
      
      if (this.moveLeft || this.moveRight) {
        const slideZ = this.group.position.clone();
        slideZ.z = newPosition.z;
        if (this.checkBoundaryCollision(slideZ)) {
          this.group.position.copy(slideZ);
        }
      }
    }
  }

  /**
   * Update footstep sounds based on movement
   * @param {number} deltaTime - Time elapsed since last frame
   * @param {THREE.Vector3} previousPosition - Position before movement this frame
   */
  updateFootstepSounds(deltaTime, previousPosition) {
    // Only play footstep sounds if we're on the ground and actually moving
    const isMovingNow = this.isMoving() && this.canJump;
    
    // Calculate how far we've moved this frame
    const distanceMoved = this.group.position.distanceTo(previousPosition);
    
    // Skip if not moving or not on ground
    if (!isMovingNow || distanceMoved < 0.001) {
      this.isMovingLastFrame = false;
      return;
    }
    
    // Calculate the appropriate footstep interval based on speed
    let currentInterval = this.footstepInterval;
    if (this.isSprinting) {
      currentInterval = 0.3; // Faster steps when sprinting
    } else {
      currentInterval = 0.5; // Normal walking pace
    }
    
    // Accumulate time since last footstep
    this.lastFootstepTime += deltaTime;
    
    // Check if it's time for a footstep sound
    if (this.lastFootstepTime >= currentInterval) {
      // Reset the timer, with a small random variation for naturalness
      this.lastFootstepTime = -0.05 + Math.random() * 0.1;
      
      // Determine which foot and play the appropriate sound
      if (this.soundManager) {
        // Temporary debug log
        console.log(`Playing ${this.isLeftFoot ? 'left' : 'right'} footstep`);
        
        // Use direct sound play instead of positional audio for now
        this.soundManager.playSound(
          this.isLeftFoot ? 'leftstep' : 'rightstep',
          0, // No cooldown
          this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
        );
        
        // Try positional audio as fallback
        try {
          this.soundManager.playSoundAt(
            this.isLeftFoot ? 'leftstep' : 'rightstep',
            this.group.position,
            0, // No cooldown
            this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
          );
        } catch (err) {
          console.log("Fallback to positional audio failed:", err);
        }
      }
      
      // Switch feet for next step
      this.isLeftFoot = !this.isLeftFoot;
    }
    
    this.isMovingLastFrame = true;
  }

  /**
   * Updates camera head bobbing effect for walking/running with much smoother transitions
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateHeadBob(deltaTime) {
    // Update target bobbing intensity based on movement
    if (this.isMoving() && this.canJump) {
      // Very subtle bobbing values
      this.targetBobIntensity = this.isSprinting ? 0.02 : 0.01;
    } else {
      this.targetBobIntensity = 0;
    }
    
    // Smoothly transition bob intensity
    this.bobIntensity = THREE.MathUtils.lerp(
      this.bobIntensity,
      this.targetBobIntensity,
      Math.min(1, deltaTime * this.bobTransitionSpeed)
    );
    
    // Only calculate bob if intensity is significant
    if (this.bobIntensity > 0.001) {
      // Update phase at a speed proportional to movement
      // Use different frequencies for vertical and horizontal to create more natural movement
      this.bobPhase += deltaTime * (this.isSprinting ? 10 : 6);
      
      // Calculate vertical and horizontal components
      const verticalBob = Math.sin(this.bobPhase * 2) * this.bobIntensity;
      // Much smaller horizontal component
      const horizontalBob = Math.cos(this.bobPhase) * this.bobIntensity * 0.3;
      
      // Apply to camera position smoothly
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight + verticalBob,
        Math.min(1, deltaTime * 8)
      );
      
      // Extremely subtle horizontal movement
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        horizontalBob,
        Math.min(1, deltaTime * 3)
      );
    } else {
      // Smoothly return to default position when not moving
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight,
        Math.min(1, deltaTime * 4)
      );
      
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        0,
        Math.min(1, deltaTime * 3)
      );
    }
  }

  /**
   * Returns the current movement speed based on sprint state and location
   * @returns {number} The current movement speed
   */
  getMoveSpeed() {
    // Disable sprinting in QuickDraw duels
    if (window.quickDraw && window.quickDraw.inDuel) {
      return this.normalSpeed;
    }
    
    // Apply sprint speed if sprint key is pressed
    return this.isSprinting ? this.sprintSpeed : this.normalSpeed;
  }
  
  /**
   * Checks if the player is currently moving
   * @returns {boolean} True if any movement key is pressed
   */
  isMoving() {
    return this.moveForward || this.moveBackward || this.moveLeft || this.moveRight;
  }

  /**
   * Check if a position is valid regarding boundaries
   * @param {THREE.Vector3} position - The position to check
   * @returns {boolean} - True if the position is valid
   */
  checkBoundaryCollision(position) {
    // First check Quick Draw arena boundary
    if (window.quickDraw) {
      const inArena = window.quickDraw.isPointInArena(position);
      const wasInArena = window.quickDraw.isPointInArena(this.previousPosition);
      
      // If player is in a duel, they must stay inside
      if (window.quickDraw.inDuel && !inArena && wasInArena) {
        return false; // Can't leave arena during duel
      }
      
      // If player is not in a duel, they must stay outside
      if (!window.quickDraw.inDuel && inArena && !wasInArena) {
        return false; // Can't enter arena from outside (except via the portal)
      }
    }
    
    // Check Proper Shootout map boundary
    if (window.properShootout && window.properShootout.inLobby) {
      // If in Proper Shootout, only check those boundaries and ignore town boundaries
      return window.properShootout.isPointInMap(position);
    }
    
    // Check town boundary
    if (window.physics && typeof window.physics.isPointInTown === 'function') {
      if (!window.physics.isPointInTown(position)) {
        return false; // Can't leave town
      }
    } else if (window.townDimensions) {
      // Fallback if physics isn't available but town dimensions are
      const width = window.townDimensions.width;
      const length = window.townDimensions.length;
      
      if (
        position.x < -width / 2 || 
        position.x > width / 2 || 
        position.z < -length / 2 || 
        position.z > length / 2
      ) {
        return false; // Can't leave town
      }
    }
    
    return true; // No collision
  }

  /**
   * Send position/rotation updates to the server.
   */
  sendNetworkUpdate() {
    if (this.id == null) return;
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    networkManager.sendUpdate({
      position: {
        x: this.group.position.x,
        y: this.group.position.y,
        z: this.group.position.z
      },
      rotation: {
        y: this.group.rotation.y
      },
      isAiming: this.isAiming,
      isReloading: this.isReloading,
      isSprinting: this.isSprinting,
      health: this.health,
      quickDrawLobbyIndex: this.quickDrawLobbyIndex
    });
  }

  shoot() {
    if (this.bullets <= 0 || !this.canShoot || this.isReloading) {
      // No bullets or can't shoot
      if (this.bullets === 0) {
        const reloadMessage = document.getElementById('reload-message');
        if (reloadMessage) reloadMessage.style.display = 'block';
      }
      return;
    }
    // Actually shoot
    this.bullets--;
    updateAmmoUI(this);

    this.canShoot = false;
    setTimeout(() => { this.canShoot = true; }, 250);

    // Find bullet spawn
    const bulletStart = this.revolver.getBarrelTipWorldPosition();
    const shootDir = new THREE.Vector3();
    this.camera.getWorldDirection(shootDir);

    // Slight random spread
    shootDir.x += (Math.random() - 0.5) * 0.02;
    shootDir.y += (Math.random() - 0.5) * 0.02;
    shootDir.z += (Math.random() - 0.5) * 0.02;
    shootDir.normalize();

    // Recoil effect
    applyRecoil(this);

    // Call the callback to spawn bullet in main.js
    if (typeof this.onShootCallback === 'function') {
      this.onShootCallback(bulletStart, shootDir);
    }

    // If out of bullets, show reload hint
    if (this.bullets === 0) {
      const reloadMessage = document.getElementById('reload-message');
      if (reloadMessage) {
        reloadMessage.style.display = 'block';
      }
    }
  }

  /**
   * Called when the player takes damage.
   * @param {number} amount - Damage amount.
   * @param {string} hitZone - Hit zone ('head', 'body', 'limbs')
   */
  takeDamage(amount, hitZone) {
    const previousHealth = this.health;
    this.health = Math.max(this.health - amount, 0);
    console.log(`Player ${this.id} took ${amount} damage in the ${hitZone || 'body'}. Health is now ${this.health}`);
    
    // Show damage indicator with damage amount and hit zone
    if (typeof window.showDamageIndicator === 'function') {
      window.showDamageIndicator(amount, hitZone);
    }
    
    // Update health UI
    updateHealthUI(this);
    
    // Add screen flash effect based on damage amount
    this.showDamageEffect(amount);
    
    // If health reached zero, handle death
    if (previousHealth > 0 && this.health === 0) {
      console.log('Game Over');
      // Respawn after a delay
      setTimeout(() => {
        this.respawn();
      }, 1500);
    }
  }

  /**
   * Shows a screen flash effect when taking damage
   * @param {number} amount - The damage amount
   */
  showDamageEffect(amount) {
    // Create a full-screen flash effect
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    flash.style.opacity = '0';
    flash.style.transition = 'opacity 0.1s ease-in, opacity 0.4s ease-out';
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '900';
    document.getElementById('game-container').appendChild(flash);
    
    // Adjust intensity based on damage
    const intensity = Math.min(amount / 100, 0.8);
    flash.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;
    
    // Show and fade out
    setTimeout(() => {
      flash.style.opacity = '1';
      setTimeout(() => {
        flash.style.opacity = '0';
        setTimeout(() => {
          if (flash.parentNode) {
            flash.parentNode.removeChild(flash);
          }
        }, 400);
      }, 100);
    }, 0);
  }

  /**
   * Respawn the player after death
   */
  respawn() {
    // Reset health
    this.health = 100;
    updateHealthUI(this);
    
    // Spawn at a random position
    this.spawnPlayerRandomly();
    
    // Reset weapon state
    this.bullets = this.maxBullets;
    this.isReloading = false;
    this.canAim = true;
    this.isAiming = false;
    updateAmmoUI(this);
    
    // Reset vertical velocity
    this.velocity.y = 0;
    
    // Reset first-person body if it exists
    if (this.fpBody) {
      this.fpBody.isWalking = false;
      this.fpBody.resetWalkAnimation();
    }
    
    // Reset Quick Draw lobby information
    this.quickDrawLobbyIndex = -1;
    
    console.log('Player respawned');
  }

  startReload() {
    if (this.isReloading || this.bullets >= this.maxBullets) return;

    this.isReloading = true;
    this.reloadProgress = 0;
    const reloadMessage = document.getElementById('reload-message');
    const reloadProgressContainer = document.getElementById('reload-progress-container');
    if (reloadMessage) reloadMessage.style.display = 'none';
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'block';

    if (this.soundManager) {
      this.soundManager.playSound("shellejection");
      this.soundManager.playSound("reloading");
    }

    // Eject shells sequentially
    for (let i = 0; i < this.maxBullets - this.bullets; i++) {
      setTimeout(() => {
        ejectShell(this, this.scene, this.soundManager);
      }, i * 200);
    }
    
    // Anti-cheat: Notify server about reload start
    networkManager.sendReload();

    const startTime = performance.now();
    const updateReload = (currentTime) => {
      const elapsed = currentTime - startTime;
      this.reloadProgress = Math.min((elapsed / this.reloadTime) * 100, 100);
      const reloadProgressBar = document.getElementById('reload-progress-bar');
      if (reloadProgressBar) {
        reloadProgressBar.style.width = this.reloadProgress + '%';
      }
      if (elapsed < this.reloadTime) {
        requestAnimationFrame(updateReload);
      } else {
        this.completeReload();
      }
    };
    requestAnimationFrame(updateReload);
  }

  completeReload() {
    this.bullets = this.maxBullets;
    updateAmmoUI(this);

    const reloadProgressContainer = document.getElementById('reload-progress-container');
    const reloadProgressBar = document.getElementById('reload-progress-bar');
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
    if (reloadProgressBar) reloadProgressBar.style.width = '0%';
    
    this.isReloading = false;
    this.sendNetworkUpdate(); // let others know
  }
  
  /**
   * Set the Quick Draw lobby index for this player
   * @param {number} index - The lobby index (0-4) or -1 for none
   */
  setQuickDrawLobby(index) {
    this.quickDrawLobbyIndex = index;
    
    // Update UI indicator
    const lobbyIndicator = document.getElementById('lobby-indicator');
    if (lobbyIndicator) {
      if (index >= 0) {
        lobbyIndicator.textContent = `Arena ${index + 1}`;
        lobbyIndicator.style.display = 'block';
      } else {
        lobbyIndicator.style.display = 'none';
      }
    }
    
    // Send update to server
    this.sendNetworkUpdate();
  }

  /**
   * Updates aiming effects including crosshair animation
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateAiming(deltaTime) {
    // Crosshair animation if aiming
    const crosshair = document.getElementById('crosshair');
    if (crosshair && this.isAiming) {
      // Add subtle size adjustment based on player movement
      const isMoving = this.isMoving();
      const movementFactor = isMoving ? 1.0 + (this.velocity.length() * 0.005) : 1.0;
      
      // Calculate scaled size based on movement (further reduced from 60 to 40)
      const size = 40 * movementFactor;
      crosshair.style.width = `${size}px`;
      crosshair.style.height = `${size}px`;
      
      // Set opacity based on movement
      const opacity = isMoving ? 0.7 : 0.8;
      
      // Update all SVG elements with the appropriate color
      const strokeColor = this.health < 30 
        ? `rgba(255, ${Math.floor(255 * (this.health/30))}, ${Math.floor(255 * (this.health/60))}, ${opacity})`
        : `rgba(255, 255, 255, ${opacity})`;
      
      // Apply color to all SVG paths and circle
      const pathElements = crosshair.querySelectorAll('path');
      pathElements.forEach(el => {
        el.setAttribute('stroke', strokeColor);
      });
      
      const circleElement = crosshair.querySelector('circle');
      if (circleElement) {
        circleElement.setAttribute('fill', strokeColor);
      }
      
      // Apply expansion animation class if not already applied
      if (!crosshair.classList.contains('expand') && !crosshair.classList.contains('expanded')) {
        crosshair.classList.add('expand');
        
        // After animation completes, mark as expanded
        setTimeout(() => {
          crosshair.classList.remove('expand');
          crosshair.classList.add('expanded');
        }, 250); // Match animation duration
      }
    }
  }

  /**
   * Creates a body model for first-person view so the player can see their own body when looking down.
   */
  createFirstPersonBody() {
    // Create a third-person model instance but position it for first-person view
    this.fpBody = new ThirdPersonModel(this.scene, 'self');
    
    // Remove the model from the scene initially (we'll add it to the camera)
    this.scene.remove(this.fpBody.group);
    
    // Position the model slightly below and in front of the camera
    this.fpBody.group.position.set(0, -1.6, 0);
    
    // Add to camera to move with player view
    this.camera.add(this.fpBody.group);
    
    // Rotate the body to face forward from player's perspective
    this.fpBody.group.rotation.y = Math.PI;
  }
}

================================================
File: /public/js/playerModel.js
================================================
// /public/js/playerModel.js
import { Revolver } from './revolver.js';

/**
 * The third-person model used to represent remote players
 * (and possibly the local player in others' view).
 */
export class ThirdPersonModel {
  constructor(scene, playerId) {
    this.scene = scene;
    this.playerId = playerId;
    this.group = new THREE.Group();

    this.collisionBox = new THREE.Box3();
    this.hitboxSize = { width: 0.6, height: 1.8, depth: 0.6 };

    // Health
    this.health = 100;

    // Target position/rotation for smooth interpolation.
    this.targetPosition = this.group.position.clone();
    this.targetRotation = this.group.rotation.y;

    // Load the T-pose model
    this.loadTposeModel();
    scene.add(this.group);

    this.walkCycle = 0;
    this.isWalking = false;
    this.lastPosition = new THREE.Vector3();

    // To track active hit feedback timeout.
    this.hitFeedbackTimeout = null;
  }

  loadTposeModel() {
    // Create loader instance
    const loader = new THREE.GLTFLoader();
    
    // Load the tpose.glb model
    loader.load('models/tpose.glb', (gltf) => {
      this.tposeModel = gltf.scene;
      
      // User indicated the model is offset Y by half its size downwards by default
      // So we need to raise it up to compensate
      this.tposeModel.position.set(0, 0.9, 0); // Raise it by 0.9 units
      
      // Set an appropriate scale for the model
      this.tposeModel.scale.set(0.8, 0.8, 0.8);
      
      // Add the model to the group
      this.group.add(this.tposeModel);
      
      // Debug info
      console.log('T-pose model loaded successfully');
      
      // Look through the model to set up meshes correctly
      this.tposeModel.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          child.userData.isPlayerMesh = true;
        }
      });
      
      // Add revolver to the model's hand
      this.addRevolver();
    }, 
    undefined,
    (error) => {
      console.error('Error loading tpose.glb model:', error);
    });
  }

  /**
   * Adds the normal revolver model to the model's left hand.
   */
  addRevolver() {
    this.revolver = new Revolver();
    
    // Initialize rotations for aim states
    this.revolverDefaultRotation = new THREE.Euler(-Math.PI / -1.5, Math.PI, 0);
    this.revolverAimingRotation = new THREE.Euler(-Math.PI / 0.7, Math.PI, 0);
    
    // Find a suitable attachment point for the gun
    let handAttachment = this.tposeModel;
    
    // Position and rotate the gun
    this.revolver.group.position.set(0.1, 0, 0.1);
    this.revolver.group.rotation.set(0, Math.PI / 2, 0);
    this.revolver.group.scale.set(0.5, 0.5, 0.5);
    
    // Attach the gun to the model
    handAttachment.add(this.revolver.group);
    this.revolver.group.visible = true;
  }

  updateCollisionBox() {
    const halfWidth = this.hitboxSize.width / 2;
    const halfDepth = this.hitboxSize.depth / 2;

    this.collisionBox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - halfWidth,
        this.group.position.y,
        this.group.position.z - halfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + halfWidth,
        this.group.position.y + this.hitboxSize.height,
        this.group.position.z + halfDepth
      )
    ]);
  }

  /**
   * Smoothly updates the model's position and rotation toward target values.
   * @param {number} deltaTime - Time elapsed since last frame.
   */
  animateMovement(deltaTime) {
    // Interpolate position and rotation for smooth remote movement
    this.group.position.lerp(this.targetPosition, 0.1);
    this.group.rotation.y = THREE.MathUtils.lerp(this.group.rotation.y, this.targetRotation, 0.1);
    this.updateCollisionBox();
    
    // Ensure the proper Y offset for the T-pose model is maintained
    if (this.tposeModel && this.tposeModel.position) {
      if (!this.isWalking) {
        this.tposeModel.position.y = 0.9;
      }
    }
  }

  /**
   * Updates the third-person model using data received from the server.
   * @param {Object} playerData
   */
  update(playerData) {
    if (!playerData) return;
    
    // Update target position from network data (shifting from eye-level to model base)
    if (playerData.position) {
      // Standard eye-level to base offset
      const yOffset = 1.6;
      
      const newPos = new THREE.Vector3(
        playerData.position.x,
        playerData.position.y - yOffset,
        playerData.position.z
      );
      this.targetPosition.copy(newPos);

      // Check if walking based on movement
      this.isWalking = newPos.distanceTo(this.lastPosition) > 0.01;
      this.lastPosition.copy(newPos);
    }

    // Update target rotation with a 180° offset for proper facing
    if (playerData.rotation && playerData.rotation.y !== undefined) {
      this.targetRotation = playerData.rotation.y + Math.PI;
    }

    // Set pose based on whether the player is aiming
    if (playerData.isAiming) {
      this.setAimingPose();
    } else {
      this.setNormalPose();
    }

    // Update health if provided
    if (playerData.health !== undefined) {
      this.health = playerData.health;
    }
  }

  /**
   * Sets the model's pose for aiming.
   */
  setAimingPose() {
    if (this.revolver && this.revolver.group && this.revolverAimingRotation) {
      this.revolver.group.rotation.copy(this.revolverAimingRotation);
    }
  }

  /**
   * Sets the model's pose for normal (non-aiming) state.
   */
  setNormalPose() {
    if (this.revolver && this.revolver.group && this.revolverDefaultRotation) {
      this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    }
  }

  /**
   * Plays a reload animation.
   * This is now empty but kept for interface compatibility.
   */
  playReloadAnimation() {
    // Animation has been removed but keeping the function as an interface
    // Shell ejection is handled elsewhere (in effects.js)
    return;
  }

  /**
   * Animates the walk cycle.
   * @param {number} deltaTime
   */
  animateWalk(deltaTime) {
    if (!this.isWalking) return;
    
    this.walkCycle += deltaTime * 5;
    
    // Simple animation for the tpose model - just a slight up/down bob
    if (this.tposeModel && this.tposeModel.position) {
      const bobAmount = Math.sin(this.walkCycle) * 0.05;
      this.tposeModel.position.y = 0.9 + bobAmount;
    }
  }

  /**
   * Resets the walk animation.
   */
  resetWalkAnimation() {
    if (this.tposeModel && this.tposeModel.position) {
      this.tposeModel.position.y = 0.9; // Reset to the base Y offset
    }
  }

  /**
   * Removes the model from the scene (e.g. on player disconnect).
   * Fully disposes geometry and material.
   */
  remove() {
    this.scene.remove(this.group);
    this.group.traverse(child => {
      if (child.isMesh) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  }

  /**
   * Provides visual feedback (temporary red flash) when the model is hit.
   */
  showHitFeedback() {
    // Clear any existing hit feedback timeout.
    if (this.hitFeedbackTimeout) {
      clearTimeout(this.hitFeedbackTimeout);
    }
    // Traverse the model and replace each mesh's material with a red flash.
    this.group.traverse(child => {
      if (child.isMesh && child.material) {
        // Store the original material in userData if not already stored.
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        child.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        child.material.needsUpdate = true;
      }
    });
    // After 200ms, restore the original materials.
    this.hitFeedbackTimeout = setTimeout(() => {
      this.group.traverse(child => {
        if (child.isMesh && child.userData.originalMaterial) {
          child.material.dispose();
          child.material = child.userData.originalMaterial;
          child.material.needsUpdate = true;
          delete child.userData.originalMaterial;
        }
      });
      this.hitFeedbackTimeout = null;
    }, 200);
  }

  /**
   * Reduces health when hit.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Remote player ${this.playerId} took ${amount} damage. Health: ${this.health}`);
  }
}

================================================
File: /public/js/quickDraw.js
================================================
/**
 * Quick Draw game mode implementation
 * Players face off in a wild west duel where they must wait for the "draw" signal
 * before pulling their revolvers and shooting at each other.
 * Now with direct player-to-player challenges directly on the town map.
 */

import { PhysicsSystem } from './physics.js';
import { createOptimizedSmokeEffect } from './input.js';

export class QuickDraw {
    constructor(scene, localPlayer, networkManager, soundManager) {
        this.scene = scene;
        this.localPlayer = localPlayer;
        this.networkManager = networkManager;
        this.soundManager = soundManager;
        
        // Detect mobile devices if not already set
        if (window.isMobileDevice === undefined) {
            window.isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Initialize mouse tracking for right-click detection
        if (!window.mouseDown) {
            window.mouseDown = { left: false, right: false };
            
            document.addEventListener('mousedown', (event) => {
                if (event.button === 0) {
                    window.mouseDown.left = true;
                } else if (event.button === 2) {
                    window.mouseDown.right = true;
                }
            });
            
            document.addEventListener('mouseup', (event) => {
                if (event.button === 0) {
                    window.mouseDown.left = false;
                } else if (event.button === 2) {
                    window.mouseDown.right = false;
                }
            });
            
            // Also track when pointer leaves window
            document.addEventListener('pointerleave', () => {
                window.mouseDown.left = false;
                window.mouseDown.right = false;
            });
        }
        
        // Game state
        this.inLobby = false;
        this.inDuel = false;
        this.duelOpponentId = null;
        this.duelState = 'none'; // 'none', 'ready', 'countdown', 'draw'
        this.gunLocked = false;
        this.originalCanAim = true;
        // Record the time (in ms) until which the gun remains locked
        this.penaltyEndTime = 0;
        
        // Direct challenge system
        this.playerProximityRadius = 5; // 5 units radius for challenge detection
        this.nearbyPlayers = new Map(); // Map of nearby player IDs to their data
        this.challengePromptActive = false; // Whether the challenge prompt is active
        this.pendingChallenge = null; // Store info about pending challenge
        this.challengeAccepted = false; // Whether a challenge has been accepted
        this.challengeUIVisible = false; // Whether challenge UI is visible
        
        // Initialize physics system for collision detection
        this.physics = new PhysicsSystem();
        
        // Initialize the network handlers and challenge UI
        this.initNetworkHandlers();
        this.createUI();
        this.createChallengeUI();

        // Make this instance globally accessible for network handlers
        window.quickDraw = this;
    }
    
    /**
     * Create UI elements for Quick Draw game mode.
     */
    createUI() {
        // Text overlay for messages
        this.messageOverlay = document.createElement('div');
        this.messageOverlay.id = 'quick-draw-message';
        this.messageOverlay.style.position = 'absolute';
        this.messageOverlay.style.top = '50%';
        this.messageOverlay.style.left = '50%';
        this.messageOverlay.style.transform = 'translate(-50%, -50%)';
        this.messageOverlay.style.color = 'white';
        this.messageOverlay.style.fontSize = '48px';
        this.messageOverlay.style.fontWeight = 'bold';
        this.messageOverlay.style.textAlign = 'center';
        this.messageOverlay.style.display = 'none';
        this.messageOverlay.style.fontFamily = 'Western, Arial, sans-serif';
        this.messageOverlay.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
        this.messageOverlay.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(this.messageOverlay);
        
        // Draw circle animation
        this.drawCircle = document.createElement('div');
        this.drawCircle.id = 'draw-circle';
        this.drawCircle.style.position = 'absolute';
        this.drawCircle.style.top = '50%';
        this.drawCircle.style.left = '50%';
        this.drawCircle.style.transform = 'translate(-50%, -50%) scale(0)';
        this.drawCircle.style.width = '600px';
        this.drawCircle.style.height = '600px';
        this.drawCircle.style.borderRadius = '50%';
        this.drawCircle.style.border = '8px solid #FF0000';
        this.drawCircle.style.boxShadow = '0 0 20px #FF0000';
        this.drawCircle.style.opacity = '0';
        this.drawCircle.style.transition = 'transform 0.3s, opacity 0.3s';
        this.drawCircle.style.pointerEvents = 'none';
        this.drawCircle.style.zIndex = '999';
        this.drawCircle.style.display = 'none';
        document.getElementById('game-container').appendChild(this.drawCircle);
        
        // Add status indicator
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.id = 'quick-draw-status';
        this.statusIndicator.style.position = 'absolute';
        this.statusIndicator.style.top = '120px';
        this.statusIndicator.style.left = '20px';
        this.statusIndicator.style.color = 'white';
        this.statusIndicator.style.fontSize = '16px';
        this.statusIndicator.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.statusIndicator.style.padding = '5px';
        this.statusIndicator.style.borderRadius = '5px';
        this.statusIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.statusIndicator);
        
        // Health bar container
        this.healthBarContainer = document.createElement('div');
        this.healthBarContainer.id = 'health-bar-container';
        this.healthBarContainer.style.position = 'absolute';
        this.healthBarContainer.style.top = '20px';
        this.healthBarContainer.style.left = '50%';
        this.healthBarContainer.style.transform = 'translateX(-50%)';
        this.healthBarContainer.style.width = '300px';
        this.healthBarContainer.style.height = '30px';
        this.healthBarContainer.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.healthBarContainer.style.borderRadius = '5px';
        this.healthBarContainer.style.padding = '5px';
        this.healthBarContainer.style.display = 'none';
        this.healthBarContainer.style.zIndex = '1000';
        
        // Health bar
        this.healthBar = document.createElement('div');
        this.healthBar.id = 'health-bar';
        this.healthBar.style.width = '100%';
        this.healthBar.style.height = '100%';
        this.healthBar.style.backgroundColor = '#00FF00';
        this.healthBar.style.borderRadius = '3px';
        this.healthBar.style.transition = 'width 0.3s ease-in-out';
        
        // Health text
        this.healthText = document.createElement('div');
        this.healthText.id = 'health-text';
        this.healthText.style.position = 'absolute';
        this.healthText.style.top = '50%';
        this.healthText.style.left = '50%';
        this.healthText.style.transform = 'translate(-50%, -50%)';
        this.healthText.style.color = 'white';
        this.healthText.style.fontSize = '14px';
        this.healthText.style.fontWeight = 'bold';
        this.healthText.style.textShadow = '1px 1px 2px black';
        this.healthText.textContent = '100 HP';
        
        // Assemble health bar
        this.healthBarContainer.appendChild(this.healthBar);
        this.healthBarContainer.appendChild(this.healthText);
        document.getElementById('game-container').appendChild(this.healthBarContainer);
    }
    
    /**
     * Create UI elements specific to the direct challenge system
     */
    createChallengeUI() {
        // Challenge prompt - shown when near another player
        this.challengePrompt = document.createElement('div');
        this.challengePrompt.id = 'quick-draw-challenge-prompt';
        this.challengePrompt.style.position = 'absolute';
        this.challengePrompt.style.top = '75%';
        this.challengePrompt.style.left = '50%';
        this.challengePrompt.style.transform = 'translate(-50%, -50%)';
        this.challengePrompt.style.color = 'white';
        this.challengePrompt.style.fontSize = '24px';
        this.challengePrompt.style.fontWeight = 'bold';
        this.challengePrompt.style.textAlign = 'center';
        this.challengePrompt.style.padding = '15px 20px';
        this.challengePrompt.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        this.challengePrompt.style.borderRadius = '10px';
        this.challengePrompt.style.display = 'none';
        this.challengePrompt.style.zIndex = '1000';
        this.challengePrompt.textContent = 'Press E to challenge to a Quick Draw duel';
        document.getElementById('game-container').appendChild(this.challengePrompt);
        
        // Challenge invitation - shown when receiving a challenge
        this.challengeInvitation = document.createElement('div');
        this.challengeInvitation.id = 'quick-draw-invitation';
        this.challengeInvitation.style.position = 'absolute';
        this.challengeInvitation.style.top = '40%';
        this.challengeInvitation.style.left = '50%';
        this.challengeInvitation.style.transform = 'translate(-50%, -50%)';
        this.challengeInvitation.style.color = 'white';
        this.challengeInvitation.style.fontSize = '28px';
        this.challengeInvitation.style.fontWeight = 'bold';
        this.challengeInvitation.style.textAlign = 'center';
        this.challengeInvitation.style.padding = '20px 25px';
        this.challengeInvitation.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
        this.challengeInvitation.style.borderRadius = '10px';
        this.challengeInvitation.style.border = '2px solid #FF6B00';
        this.challengeInvitation.style.boxShadow = '0 0 15px rgba(255, 107, 0, 0.7)';
        this.challengeInvitation.style.display = 'none';
        this.challengeInvitation.style.zIndex = '1100';
        this.challengeInvitation.innerHTML = `
            <div style="margin-bottom: 15px">Player X challenges you to a Quick Draw duel!</div>
            <div style="display: flex; justify-content: space-around; margin-top: 10px;">
                <div style="background-color: #4CAF50; padding: 10px 20px; border-radius: 5px;">Press Enter to accept</div>
                <div style="background-color: #F44336; padding: 10px 20px; border-radius: 5px;">Press T to decline</div>
            </div>
        `;
        document.getElementById('game-container').appendChild(this.challengeInvitation);
        
        // Add keyboard event listener for challenge interactions
        document.addEventListener('keydown', (event) => this.handleChallengeKeypress(event));
    }
    
    /**
     * Handle keypresses for the challenge system
     * @param {KeyboardEvent} event - The keyboard event
     */
    handleChallengeKeypress(event) {
        // Skip if not in game or if player is in lobby/duel
        if (!this.localPlayer || this.inLobby || this.inDuel) return;
        
        switch (event.code) {
            case 'KeyE':
                // Send challenge when near a player
                if (this.challengePromptActive) {
                    this.sendChallenge();
                }
                break;
                
            case 'Enter':
                // Accept invitation
                if (this.pendingChallenge) {
                    this.acceptChallenge();
                }
                break;
                
            case 'KeyT':
                // Decline invitation
                if (this.pendingChallenge) {
                    this.declineChallenge();
                }
                break;
        }
    }
    
    /**
     * Initialize network handlers for Quick Draw game mode.
     */
    initNetworkHandlers() {
        // Methods for direct challenges
        this.networkManager.sendQuickDrawChallenge = (targetPlayerId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawChallenge',
                    targetPlayerId: targetPlayerId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawAccept = (challengerId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawAccept',
                    challengerId: challengerId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawDecline = (challengerId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawDecline',
                    challengerId: challengerId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawShoot = (opponentId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                console.log(`Sending Quick Draw hit notification to server: player ${this.localPlayer.id} hit player ${opponentId}`);
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawShoot',
                    opponentId: opponentId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawReady = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawReady'
                }));
            }
        };
        
        // Hook into the existing socket onmessage handler
        const originalOnMessage = this.networkManager.socket.onmessage;
        this.networkManager.socket.onmessage = (event) => {
            // Call original handler
            if (originalOnMessage) {
                originalOnMessage(event);
            }
            
            try {
                const message = JSON.parse(event.data);
                
                // Handle Quick Draw specific messages
                switch (message.type) {
                    case 'quickDrawMatch':
                        this.handleMatchFound(message);
                        break;
                    case 'quickDrawReady':
                        this.showReadyMessage();
                        break;
                    case 'quickDrawCountdown':
                        this.startDuelCountdown();
                        break;
                    case 'quickDrawDraw':
                        this.triggerDraw();
                        break;
                    case 'quickDrawEnd':
                        this.endDuel(message.winnerId);
                        break;
                    case 'playerHealthUpdate':
                        if (this.inDuel) {
                            // Update own health if it's us
                            if (message.playerId === this.localPlayer.id) {
                                this.updateHealthBar(message.health);
                                
                                // Show hit feedback if damaged
                                if (message.damage > 0) {
                                    this.showHitFeedback(message.damage);
                                }
                            }
                            // Update opponent's health if needed (could be extended for UI)
                            else if (message.playerId === this.duelOpponentId) {
                                // Could update opponent health bar if we had one
                            }
                        }
                        break;
                    // Challenge system message handlers
                    case 'quickDrawChallengeReceived':
                        this.handleChallengeReceived(message);
                        break;
                    case 'quickDrawChallengeAccepted':
                        this.handleChallengeAccepted(message);
                        break;
                    case 'quickDrawChallengeDeclined':
                        this.handleChallengeDeclined(message);
                        break;
                    // Debug visualization handler
                    case 'debugBoxVisualization':
                        this.createDebugBoxVisualization(message.box, message.color, message.duration);
                        break;
                }
            } catch (err) {
                console.error('Error parsing Quick Draw message:', err);
            }
        };
    }

    /**
     * Updates the list of nearby players for challenge feature
     */
    updateNearbyPlayers() {
        // Skip if in duel or lobby already
        if (this.inDuel || this.inLobby || this.pendingChallenge) return;
        
        const playerPos = this.localPlayer.group.position.clone();
        this.nearbyPlayers.clear();
        this.challengePromptActive = false;
        
        // Check if any other players are within the challenge radius
        if (this.networkManager && this.networkManager.otherPlayers) {
            for (const [playerId, playerData] of this.networkManager.otherPlayers) {
                // Skip players who are in a quick draw already or don't have position
                if (!playerData.position || playerData.quickDrawLobbyIndex >= 0 || 
                    playerData.inQuickDrawDuel) continue;
                
                // Calculate distance to player
                const otherPos = new THREE.Vector3(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                
                const distance = playerPos.distanceTo(otherPos);
                
                // If within challenge radius, add to nearby players
                if (distance <= this.playerProximityRadius) {
                    this.nearbyPlayers.set(playerId, {
                        id: playerId,
                        distance: distance,
                        position: otherPos
                    });
                    
                    this.challengePromptActive = true;
                }
            }
        }
        
        // Update UI based on nearby players
        this.updateChallengeUI();
    }

    /**
     * Updates the challenge UI based on nearby players
     */
    updateChallengeUI() {
        if (!this.challengePrompt) return;
        
        // Show/hide challenge prompt based on whether there are nearby players
        if (this.challengePromptActive && !this.challengeUIVisible) {
            this.challengePrompt.style.display = 'block';
            this.challengeUIVisible = true;
        } else if (!this.challengePromptActive && this.challengeUIVisible) {
            this.challengePrompt.style.display = 'none';
            this.challengeUIVisible = false;
        }
    }

    /**
     * Send a challenge to the nearest player
     */
    sendChallenge() {
        if (this.nearbyPlayers.size === 0) return;
        
        // Find the nearest player
        let nearestPlayerId = null;
        let nearestDistance = Infinity;
        
        for (const [playerId, data] of this.nearbyPlayers) {
            if (data.distance < nearestDistance) {
                nearestDistance = data.distance;
                nearestPlayerId = playerId;
            }
        }
        
        if (nearestPlayerId) {
            // Hide the challenge prompt
            this.challengePrompt.style.display = 'none';
            this.challengeUIVisible = false;
            
            // Show "Challenge sent" message
            this.showMessage('Challenge sent!', 2000);
            
            // Send challenge to server
            this.networkManager.sendQuickDrawChallenge(nearestPlayerId);
            
            console.log(`Quick Draw challenge sent to player ${nearestPlayerId}`);
        }
    }

    /**
     * Handle receiving a challenge from another player
     * @param {Object} message - The challenge message
     */
    handleChallengeReceived(message) {
        if (this.inDuel || this.inLobby) {
            // Automatically decline if already in a duel or lobby
            this.networkManager.sendQuickDrawDecline(message.challengerId);
            return;
        }
        
        // Store the pending challenge
        this.pendingChallenge = {
            challengerId: message.challengerId,
            challengerPosition: message.challengerPosition
        };
        
        // Show the challenge invitation
        this.challengeInvitation.innerHTML = `
            <div style="margin-bottom: 15px">Player ${message.challengerId} challenges you to a Quick Draw duel!</div>
            <div style="display: flex; justify-content: space-around; margin-top: 10px;">
                <div style="background-color: #4CAF50; padding: 10px 20px; border-radius: 5px;">Press Enter to accept</div>
                <div style="background-color: #F44336; padding: 10px 20px; border-radius: 5px;">Press T to decline</div>
            </div>
        `;
        this.challengeInvitation.style.display = 'block';
        
        // Play notification sound
        if (this.soundManager) {
            this.soundManager.playSound("bellstart");
        }
        
        console.log(`Received Quick Draw challenge from player ${message.challengerId}`);
    }

    /**
     * Accept a pending challenge
     */
    acceptChallenge() {
        if (!this.pendingChallenge) return;
        
        // Hide the invitation
        this.challengeInvitation.style.display = 'none';
        
        // Send acceptance to server
        this.networkManager.sendQuickDrawAccept(this.pendingChallenge.challengerId);
        
        // Show message
        this.showMessage('Challenge accepted!', 1000);
        
        console.log(`Accepted Quick Draw challenge from player ${this.pendingChallenge.challengerId}`);
        
        // Wait for server to respond with match details
        // Challenge will be cleared when match is found
    }

    /**
     * Decline a pending challenge
     */
    declineChallenge() {
        if (!this.pendingChallenge) return;
        
        // Hide the invitation
        this.challengeInvitation.style.display = 'none';
        
        // Send decline to server
        this.networkManager.sendQuickDrawDecline(this.pendingChallenge.challengerId);
        
        // Clear the pending challenge
        this.pendingChallenge = null;
        
        console.log('Declined Quick Draw challenge');
    }

    /**
     * Handle challenge accepted by other player
     * @param {Object} message - The acceptance message
     */
    handleChallengeAccepted(message) {
        // Show message
        this.showMessage('Challenge accepted!', 1000);
        
        console.log(`Player ${message.targetId} accepted your Quick Draw challenge`);
        
        // Wait for server to respond with match details
    }

    /**
     * Handle challenge declined by other player
     * @param {Object} message - The decline message
     */
    handleChallengeDeclined(message) {
        // Show message
        this.showMessage('Challenge declined', 2000);
        
        console.log(`Player ${message.targetId} declined your Quick Draw challenge`);
    }

    /**
     * Show the "READY?" message with enhanced typography.
     */
    showReadyMessage() {
        this.duelState = 'ready';
        this.updateStatusIndicator();
        
        // For iOS/Safari and mobile devices - create a fixed fullscreen message
        if (window.isMobileDevice || /iPad|iPhone|iPod/.test(navigator.userAgent)) {
            // Create iOS-friendly fullscreen overlay for READY message
            const readyOverlay = document.createElement('div');
            readyOverlay.style.position = 'fixed';
            readyOverlay.style.top = '0';
            readyOverlay.style.left = '0';
            readyOverlay.style.width = '100%';
            readyOverlay.style.height = '100%';
            readyOverlay.style.display = 'flex';
            readyOverlay.style.alignItems = 'center';
            readyOverlay.style.justifyContent = 'center';
            readyOverlay.style.backgroundColor = 'rgba(255, 193, 7, 0.3)';
            readyOverlay.style.zIndex = '9999';
            
            // Create text element inside the overlay
            const readyText = document.createElement('div');
            readyText.textContent = 'READY?';
            readyText.style.fontSize = '120px';
            readyText.style.fontWeight = 'bold';
            readyText.style.fontFamily = 'Arial, sans-serif';
            readyText.style.color = 'white';
            readyText.style.textShadow = '0 0 20px #FFC107, 0 0 40px #FFC107';
            
            readyOverlay.appendChild(readyText);
            document.body.appendChild(readyOverlay);
            
            // Use a simple animation for better visibility
            setTimeout(() => {
                readyText.style.transition = 'transform 0.2s ease-in-out';
                readyText.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    readyText.style.transform = 'scale(1)';
                }, 200);
            }, 100);
            
            // Remove overlay after 1 second
            setTimeout(() => {
                if (readyOverlay.parentNode) {
                    readyOverlay.parentNode.removeChild(readyOverlay);
                }
            }, 1000);
        }
        
        // Also show in standard message overlay as backup
        this.messageOverlay.textContent = 'READY?';
        this.messageOverlay.style.display = 'block';
        
        // Enhanced styling for desktop
        this.messageOverlay.style.fontSize = '64px';
        this.messageOverlay.style.color = '#FFFFFF';
        
        // Use a slight scale animation
        this.messageOverlay.style.transition = 'transform 0.2s ease-in-out';
        this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // Trigger animation
        setTimeout(() => {
            this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1.1)';
            setTimeout(() => {
                this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 200);
        }, 10);
        
        // Hide after 1 second
        setTimeout(() => {
            this.hideMessage();
        }, 1000);
    }

    /**
     * Start the countdown phase of the duel.
     */
    startDuelCountdown() {
        this.duelState = 'countdown';
        this.updateStatusIndicator();
        this.hideMessage();
        
        // Explicitly disable aiming during countdown
        this.localPlayer.canAim = false;
        
        console.log('Duel countdown started - waiting for draw signal');
    }

    /**
     * Trigger the "DRAW!" signal with just the expanding circle.
     */
    triggerDraw() {
        this.duelState = 'draw';
        this.updateStatusIndicator();
        
        // Enable aiming if not penalized
        if (this.penaltyEndTime <= Date.now()) {
            this.localPlayer.canAim = true;
        }
        
        // Play gun draw sound
        if (this.soundManager) {
            this.soundManager.playSound("draw", 1.0);
        }
        
        // Show the DRAW! message
        if (window.isMobileDevice || /iPad|iPhone|iPod/.test(navigator.userAgent)) {
            // Create iOS-friendly fullscreen overlay for DRAW message
            const drawOverlay = document.createElement('div');
            drawOverlay.style.position = 'fixed';
            drawOverlay.style.top = '0';
            drawOverlay.style.left = '0';
            drawOverlay.style.width = '100%';
            drawOverlay.style.height = '100%';
            drawOverlay.style.display = 'flex';
            drawOverlay.style.alignItems = 'center';
            drawOverlay.style.justifyContent = 'center';
            drawOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.2)';
            drawOverlay.style.zIndex = '9999';
            
            // Create text element inside the overlay
            const drawText = document.createElement('div');
            drawText.textContent = 'DRAW!';
            drawText.style.fontSize = '150px';
            drawText.style.fontWeight = 'bold';
            drawText.style.fontFamily = 'Western, Arial, sans-serif';
            drawText.style.color = 'white';
            drawText.style.textShadow = '0 0 30px #FF0000, 0 0 60px #FF0000';
            
            drawOverlay.appendChild(drawText);
            document.body.appendChild(drawOverlay);
            
            // Use a simple animation for better visibility
            setTimeout(() => {
                drawText.style.transition = 'transform 0.1s ease-in-out';
                drawText.style.transform = 'scale(1.3)';
                setTimeout(() => {
                    drawText.style.transform = 'scale(1)';
                }, 100);
            }, 50);
            
            // Remove overlay after 1 second
            setTimeout(() => {
                if (drawOverlay.parentNode) {
                    drawOverlay.parentNode.removeChild(drawOverlay);
                }
            }, 1000);
        }
        
        // Show in standard message overlay as backup
        this.messageOverlay.textContent = 'DRAW!';
        this.messageOverlay.style.display = 'block';
        this.messageOverlay.style.fontSize = '72px';
        this.messageOverlay.style.color = '#FF0000';
        this.messageOverlay.style.textShadow = '0 0 20px #FF0000';
        
        // Animate message
        this.messageOverlay.style.transition = 'transform 0.1s ease-in-out';
        this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        setTimeout(() => {
            this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1.2)';
            setTimeout(() => {
                this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 100);
        }, 10);
        
        // Hide message after 1 second
        setTimeout(() => {
            this.hideMessage();
        }, 1000);
        
        // Animate the draw circle
        this.drawCircle.style.display = 'block';
        this.drawCircle.style.opacity = '0';
        this.drawCircle.style.transform = 'translate(-50%, -50%) scale(0)';
        
        // Start animation after a short delay
        setTimeout(() => {
            this.drawCircle.style.opacity = '1';
            this.drawCircle.style.transform = 'translate(-50%, -50%) scale(1)';
            
            // Fade out and hide after animation
            setTimeout(() => {
                this.drawCircle.style.opacity = '0';
                
                // Hide after fade out
                setTimeout(() => {
                    this.drawCircle.style.display = 'none';
                }, 300);
            }, 800);
        }, 10);
    }

    /**
     * Update method called from main animation loop.
     */
    update(deltaTime) {
        // Skip if player not initialized
        if (!this.localPlayer || !this.localPlayer.group) return;
        
        // Update nearby players for challenges
        this.updateNearbyPlayers();
        
        // Update status indicator
        this.updateStatusIndicator();
        
        // If penalized, keep gun locked until penalty expires
        if (this.penaltyEndTime > 0) {
            if (Date.now() < this.penaltyEndTime) {
                // Keep gun locked
                this.localPlayer.canAim = false;
            } else {
                // Penalty expired, unlock gun if in draw phase
                if (this.duelState === 'draw') {
                    this.localPlayer.canAim = true;
                }
                
                // Clear penalty
                this.penaltyEndTime = 0;
            }
        }
        
        // Check for early draw (using mouse down) during countdown
        if (this.duelState === 'countdown' && !this.penaltyEndTime) {
            if ((window.mouseDown && (window.mouseDown.left || window.mouseDown.right)) || this.localPlayer.isAiming) {
                this.penalizeEarlyDraw();
            }
        }
    }

    /**
     * Updates the Quick Draw status indicator.
     */
    updateStatusIndicator() {
        if (!this.statusIndicator) return;
        
        // Show/hide based on duel state
        if (this.inDuel || this.inLobby) {
            this.statusIndicator.style.display = 'block';
            let statusText = '';
            
            if (this.inLobby) {
                statusText = 'Quick Draw: Waiting for players...';
            } else if (this.inDuel) {
                switch (this.duelState) {
                    case 'ready':
                        statusText = 'Quick Draw: Get ready!';
                        break;
                    case 'countdown':
                        statusText = 'Quick Draw: Wait for the signal!';
                        break;
                    case 'draw':
                        statusText = 'Quick Draw: DRAW!';
                        break;
                    default:
                        statusText = 'Quick Draw: Duel in progress';
                }
            }
            
            this.statusIndicator.textContent = statusText;
        } else {
            this.statusIndicator.style.display = 'none';
        }
    }

    /**
     * Handle match found notification from server.
     */
    handleMatchFound(message) {
        this.inDuel = true;
        this.inLobby = false;
        this.duelOpponentId = message.opponentId;
        this.duelState = 'none';
        this.pendingChallenge = null;
        
        // Store original player movement and aiming states
        this.originalCanAim = this.localPlayer.canAim;
        this.originalCanMove = this.localPlayer.canMove;
        
        // Store original position to return after the duel
        this.originalPosition = {
            x: this.localPlayer.group.position.x,
            y: this.localPlayer.group.position.y,
            z: this.localPlayer.group.position.z
        };
        this.originalRotation = this.localPlayer.group.rotation.y;
        
        // Disable player movement and aiming during the duel
        this.localPlayer.canAim = false;
        this.localPlayer.canMove = false;
        
        // Force-lock player movement to prevent any accidental movement
        if (message.movementLocked === true) {
            // Completely block any movement input
            this.localPlayer.forceLockMovement = true;
            
            // Backup original move method and replace with empty function
            if (!this.localPlayer._origMove) {
                this.localPlayer._origMove = this.localPlayer.move;
                this.localPlayer.move = () => {}; // No-op function
            }
        }
        
        console.log(`Quick Draw match found! Your opponent is player ${message.opponentId}`);
        
        // Teleport player to the start position
        if (message.startPosition) {
            // First move to new position
            this.localPlayer.group.position.set(
                message.startPosition.x,
                message.startPosition.y,
                message.startPosition.z
            );
            
            // Set rotation to face the opponent
            if (message.startRotation !== undefined) {
                // Apply the exact rotation from the server
                console.log(`Setting player rotation to: ${message.startRotation.toFixed(4)} radians (${(message.startRotation * 180 / Math.PI).toFixed(1)}°)`);
                
                // In THREE.js, rotation.y represents rotation around the Y-axis (in radians)
                // The server calculates this angle to make players face each other
                this.localPlayer.group.rotation.y = message.startRotation;
                
                // Debug visualization - draw a direction arrow for 5 seconds
                this.showFacingDirection(message.startPosition, message.startRotation);
            }
        }
        
        // Show health bar with full health
        this.updateHealthBar(100);
        this.healthBarContainer.style.display = 'block';
        
        // Update status indicator and show match found message
        this.updateStatusIndicator();
        this.showMessage(`Duel vs. Player ${message.opponentId}`, 2000);
        
        // Mark as ready after showing message
        setTimeout(() => {
            this.networkManager.sendQuickDrawReady();
        }, 2000);
    }
    
    /**
     * Show a temporary arrow indicating which way the player is facing
     * @param {Object} position - The player position
     * @param {number} rotation - The player rotation in radians
     */
    showFacingDirection(position, rotation) {
        // Create a group to hold all debug objects
        const debugGroup = new THREE.Group();
        
        // Create direction arrow with more visibility
        const arrowLength = 8; // Longer arrow
        const arrowGeometry = new THREE.ConeGeometry(0.5, arrowLength, 8);
        const arrowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00FF00,
            transparent: true,
            opacity: 0.8
        });
        const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
        
        // Position the arrow at player position, slightly above ground
        arrow.position.set(0, 2, 0); // Local position within group
        
        // Rotate arrow to match player rotation
        // By default, the cone points up along Y axis, so we need to rotate it to point along Z axis first
        arrow.rotation.x = Math.PI / 2;
        
        // Add line showing forward direction
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xFFFF00,
            linewidth: 3
        });
        const linePoints = [];
        linePoints.push(new THREE.Vector3(0, 0.5, 0));
        linePoints.push(new THREE.Vector3(0, 0.5, arrowLength * 1.2)); // Slightly longer than arrow
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        
        // Create text label showing rotation angle
        const textCanvas = document.createElement('canvas');
        textCanvas.width = 256;
        textCanvas.height = 128;
        const context = textCanvas.getContext('2d');
        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
        context.fillRect(0, 0, textCanvas.width, textCanvas.height);
        context.font = 'bold 24px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Calculate angle in degrees for display
        const angleDegrees = (rotation * 180 / Math.PI).toFixed(1);
        context.fillText(`Rotation: ${angleDegrees}°`, textCanvas.width / 2, textCanvas.height / 2);
        
        const texture = new THREE.CanvasTexture(textCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(5, 2.5, 1);
        sprite.position.set(0, 4, 0); // Position above arrow
        
        // Add all elements to the debug group
        debugGroup.add(arrow);
        debugGroup.add(line);
        debugGroup.add(sprite);
        
        // Position and rotate the entire group
        debugGroup.position.copy(position);
        debugGroup.rotation.y = rotation;
        
        // Add to scene
        this.scene.add(debugGroup);
        
        // Add temporary sphere at player position as reference
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xFF0000,
            transparent: true,
            opacity: 0.6
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(position.x, position.y + 0.5, position.z);
        this.scene.add(sphere);
        
        // Create a label for "Player Position"
        const posCanvas = document.createElement('canvas');
        posCanvas.width = 256;
        posCanvas.height = 64;
        const posContext = posCanvas.getContext('2d');
        posContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
        posContext.fillRect(0, 0, posCanvas.width, posCanvas.height);
        posContext.font = 'bold 20px Arial';
        posContext.fillStyle = 'white';
        posContext.textAlign = 'center';
        posContext.textBaseline = 'middle';
        posContext.fillText('Player Position', posCanvas.width / 2, posCanvas.height / 2);
        
        const posTexture = new THREE.CanvasTexture(posCanvas);
        const posMaterial = new THREE.SpriteMaterial({
            map: posTexture,
            transparent: true
        });
        const posSprite = new THREE.Sprite(posMaterial);
        posSprite.scale.set(4, 1, 1);
        posSprite.position.set(position.x, position.y + 1.5, position.z);
        this.scene.add(posSprite);
        
        console.log(`Debug direction arrow created at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}) with rotation ${rotation.toFixed(4)} rad (${angleDegrees}°)`);
        
        // Remove after 5 seconds
        setTimeout(() => {
            this.scene.remove(debugGroup);
            this.scene.remove(sphere);
            this.scene.remove(posSprite);
        }, 5000);
    }
    
    /**
     * Updates the health bar with the current health value
     * @param {number} health - Health value (0-100)
     */
    updateHealthBar(health) {
        // Ensure health is within valid range
        health = Math.max(0, Math.min(100, health));
        
        // Update health bar width
        this.healthBar.style.width = `${health}%`;
        
        // Update color based on health amount
        if (health > 60) {
            this.healthBar.style.backgroundColor = '#00FF00'; // Green
        } else if (health > 30) {
            this.healthBar.style.backgroundColor = '#FFA500'; // Orange
        } else {
            this.healthBar.style.backgroundColor = '#FF0000'; // Red
        }
        
        // Update text
        this.healthText.textContent = `${health} HP`;
    }

    /**
     * Apply a penalty with dramatic red flashing warning.
     * Once triggered, records a penalty end time so that gun drawing remains locked
     * for a full 3 seconds even if the "DRAW!" signal comes.
     */
    penalizeEarlyDraw() {
        // Lock gun for 3 seconds
        this.penaltyEndTime = Date.now() + 3000;
        this.localPlayer.canAim = false;
        
        // Show the penalty message
        this.showMessage('TOO EARLY! Penalty!', 2000);
        
        // Create a flashing red overlay for penalty
        const penaltyOverlay = document.createElement('div');
        penaltyOverlay.style.position = 'absolute';
        penaltyOverlay.style.top = '0';
        penaltyOverlay.style.left = '0';
        penaltyOverlay.style.width = '100%';
        penaltyOverlay.style.height = '100%';
        penaltyOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        penaltyOverlay.style.zIndex = '999';
        penaltyOverlay.style.animation = 'penalty-flash 0.5s 3';
        
        // Add animation style
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes penalty-flash {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Add to game container and remove after penalty
        document.getElementById('game-container').appendChild(penaltyOverlay);
        
        // Play penalty sound
        if (this.soundManager) {
            this.soundManager.playSound("wrong", 0.7);
        }
        
        // Remove overlay after penalty animation
        setTimeout(() => {
            if (penaltyOverlay.parentNode) {
                penaltyOverlay.parentNode.removeChild(penaltyOverlay);
            }
        }, 1500);
    }

    /**
     * End the duel with enhanced win/lose UI effects.
     */
    endDuel(winnerId) {
        // Update state
        this.duelState = 'none';
        
        // Determine if player won or lost
        const playerWon = winnerId === this.localPlayer.id;
        
        // For iOS/Safari and mobile devices - create a fixed fullscreen overlay
        if (window.isMobileDevice || /iPad|iPhone|iPod/.test(navigator.userAgent)) {
            // Create iOS-friendly fullscreen overlay
            const resultOverlay = document.createElement('div');
            resultOverlay.style.position = 'fixed';
            resultOverlay.style.top = '0';
            resultOverlay.style.left = '0';
            resultOverlay.style.width = '100%';
            resultOverlay.style.height = '100%';
            resultOverlay.style.display = 'flex';
            resultOverlay.style.alignItems = 'center';
            resultOverlay.style.justifyContent = 'center';
            resultOverlay.style.backgroundColor = playerWon ? 'rgba(0, 128, 0, 0.4)' : 'rgba(128, 0, 0, 0.4)';
            resultOverlay.style.zIndex = '9999';
            
            // Create text element inside the overlay
            const resultText = document.createElement('div');
            resultText.textContent = playerWon ? 'VICTORY!' : 'DEFEAT';
            resultText.style.fontSize = '130px';
            resultText.style.fontWeight = 'bold';
            resultText.style.fontFamily = 'Western, Arial, sans-serif';
            resultText.style.color = 'white';
            resultText.style.textShadow = playerWon 
                ? '0 0 30px #00FF00, 0 0 60px #00FF00' 
                : '0 0 30px #FF0000, 0 0 60px #FF0000';
            
            resultOverlay.appendChild(resultText);
            document.body.appendChild(resultOverlay);
            
            // Use a simple animation for better visibility
            setTimeout(() => {
                resultText.style.transition = 'transform 0.3s ease-in-out';
                resultText.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    resultText.style.transform = 'scale(1)';
                }, 300);
            }, 100);
            
            // Remove overlay after 3 seconds
            setTimeout(() => {
                if (resultOverlay.parentNode) {
                    resultOverlay.parentNode.removeChild(resultOverlay);
                }
            }, 3000);
        }
        
        // Show in standard message overlay as backup
        this.messageOverlay.textContent = playerWon ? 'VICTORY!' : 'DEFEAT';
        this.messageOverlay.style.display = 'block';
        this.messageOverlay.style.fontSize = '72px';
        this.messageOverlay.style.color = playerWon ? '#00FF00' : '#FF0000';
        this.messageOverlay.style.textShadow = playerWon 
            ? '0 0 20px #00FF00' 
            : '0 0 20px #FF0000';
        
        // Animate message
        this.messageOverlay.style.transition = 'transform 0.2s ease-in-out';
        this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        setTimeout(() => {
            this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1.3)';
            setTimeout(() => {
                this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 200);
        }, 10);
        
        // Play victory/defeat sound
        if (this.soundManager) {
            if (playerWon) {
                this.soundManager.playSound("victory", 0.7);
            } else {
                this.soundManager.playSound("defeat", 0.7);
            }
        }
        
        // Hide message after 3 seconds
        setTimeout(() => {
            this.hideMessage();
            
            // Reset player state
            this.inDuel = false;
            this.duelOpponentId = null;
            
            // Hide health bar
            this.healthBarContainer.style.display = 'none';
            
            // Restore original movement methods if they were force-locked
            if (this.localPlayer._origMove) {
                this.localPlayer.move = this.localPlayer._origMove;
                this.localPlayer._origMove = null;
                this.localPlayer.forceLockMovement = false;
            }
            
            // Restore original movement and aiming states
            this.localPlayer.canAim = this.originalCanAim;
            this.localPlayer.canMove = this.originalCanMove;
            
            // Return to original position
            if (this.originalPosition) {
                this.localPlayer.group.position.set(
                    this.originalPosition.x,
                    this.originalPosition.y,
                    this.originalPosition.z
                );
                this.localPlayer.group.rotation.y = this.originalRotation;
            }
            
            // Update UI
            this.updateStatusIndicator();
            
        }, 3000);
    }

    /**
     * Helper to show a message in the center of the screen.
     */
    showMessage(message, duration = 0) {
        this.messageOverlay.textContent = message;
        this.messageOverlay.style.display = 'block';
        
        if (duration > 0) {
            setTimeout(() => {
                this.hideMessage();
            }, duration);
        }
    }

    /**
     * Hide the message overlay.
     */
    hideMessage() {
        this.messageOverlay.style.display = 'none';
    }

    /**
     * Cleanup resources.
     */
    cleanup() {
        // Clean up physics
        if (this.physics) {
            this.physics.cleanup();
        }
        
        // Remove UI elements
        if (this.messageOverlay && this.messageOverlay.parentNode) {
            this.messageOverlay.parentNode.removeChild(this.messageOverlay);
        }
        
        if (this.drawCircle && this.drawCircle.parentNode) {
            this.drawCircle.parentNode.removeChild(this.drawCircle);
        }
        
        if (this.statusIndicator && this.statusIndicator.parentNode) {
            this.statusIndicator.parentNode.removeChild(this.statusIndicator);
        }
        
        if (this.healthBarContainer && this.healthBarContainer.parentNode) {
            this.healthBarContainer.parentNode.removeChild(this.healthBarContainer);
        }
        
        // Clear timers
        if (this.countdownTimer) clearTimeout(this.countdownTimer);
        if (this.drawTimer) clearTimeout(this.drawTimer);
        if (this.penaltyTimer) clearTimeout(this.penaltyTimer);
        
        // Remove challenge UI elements
        if (this.challengePrompt && this.challengePrompt.parentNode) {
            this.challengePrompt.parentNode.removeChild(this.challengePrompt);
        }
        
        if (this.challengeInvitation && this.challengeInvitation.parentNode) {
            this.challengeInvitation.parentNode.removeChild(this.challengeInvitation);
        }
    }
    
    /**
     * Checks if a point is within the active arena.
     * This is a compatibility method for player.js boundary checks.
     * Now that we're using direct challenges on the map, this always returns true.
     * @param {THREE.Vector3} position - The position to check
     * @param {number} arenaIndex - The arena index
     * @returns {boolean} - True, since there are no arena boundaries to enforce
     */
    isPointInArena(position, arenaIndex) {
        // Since we're not using arenas anymore, always return true
        // to prevent boundary collision detection from restricting movement
        return true;
    }

    /**
     * Show feedback when player is hit during a duel
     * @param {number} damage - The amount of damage taken
     */
    showHitFeedback(damage) {
        // Create flash effect for hit feedback
        const hitOverlay = document.createElement('div');
        hitOverlay.style.position = 'absolute';
        hitOverlay.style.top = '0';
        hitOverlay.style.left = '0';
        hitOverlay.style.width = '100%';
        hitOverlay.style.height = '100%';
        hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        hitOverlay.style.pointerEvents = 'none';
        hitOverlay.style.zIndex = '999';
        hitOverlay.style.animation = 'hit-flash 0.2s ease-out';
        
        // Add animation style
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes hit-flash {
                0% { opacity: 0.7; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Add to game container
        document.getElementById('game-container').appendChild(hitOverlay);
        
        // Remove overlay after animation
        setTimeout(() => {
            if (hitOverlay.parentNode) {
                hitOverlay.parentNode.removeChild(hitOverlay);
            }
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        }, 200);
        
        // Show damage number
        if (damage > 0) {
            const damageText = document.createElement('div');
            damageText.textContent = `-${damage}`;
            damageText.style.position = 'absolute';
            damageText.style.top = '30%';
            damageText.style.left = '50%';
            damageText.style.transform = 'translate(-50%, -50%)';
            damageText.style.color = '#FF4444';
            damageText.style.fontSize = '32px';
            damageText.style.fontWeight = 'bold';
            damageText.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.7)';
            damageText.style.pointerEvents = 'none';
            damageText.style.zIndex = '1100';
            damageText.style.opacity = '1';
            damageText.style.transition = 'opacity 1s, transform 1s';
            
            document.getElementById('game-container').appendChild(damageText);
            
            // Animate and remove after animation
            setTimeout(() => {
                damageText.style.opacity = '0';
                damageText.style.transform = 'translate(-50%, -100%)';
                
                setTimeout(() => {
                    if (damageText.parentNode) {
                        damageText.parentNode.removeChild(damageText);
                    }
                }, 1000);
            }, 50);
        }
        
        // Play hit sound
        if (this.soundManager) {
            this.soundManager.playSound("hurt", 0.7);
        }
    }

    /**
     * Create a debug box visualization based on the received message
     * @param {Object} box - The box dimensions and position
     * @param {number} color - The color of the box as a hex integer
     * @param {number} duration - The duration of the visualization in milliseconds
     */
    createDebugBoxVisualization(box, color, duration) {
        console.log('Received debug box visualization data:', box);
        
        // Remove any existing debug box
        if (this.debugBox) {
            this.scene.remove(this.debugBox);
            this.debugBox = null;
        }
        
        if (this.debugBoxLabel) {
            this.scene.remove(this.debugBoxLabel);
            this.debugBoxLabel = null;
        }
        
        // Create a new box geometry
        const geometry = new THREE.BoxGeometry(box.width, box.height, box.length);
        
        // Create a semi-transparent material with wireframe effect
        const material = new THREE.MeshBasicMaterial({
            color: color || 0xFF0000,
            transparent: true,
            opacity: 0.25,
            wireframe: false,
            side: THREE.DoubleSide
        });
        
        // Create wireframe material for clearer boundaries
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            wireframe: true,
            transparent: true,
            opacity: 0.5
        });
        
        // Create the mesh and add to scene
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(box.x, box.y, box.z);
        
        // Create the wireframe mesh
        const wireframe = new THREE.Mesh(geometry, wireframeMaterial);
        wireframe.position.set(box.x, box.y, box.z);
        
        // Create a group to hold both meshes
        this.debugBox = new THREE.Group();
        this.debugBox.add(mesh);
        this.debugBox.add(wireframe);
        
        // Add to scene
        this.scene.add(this.debugBox);
        
        // Add text label "Duel Area"
        this.addDebugBoxLabel(box);
        
        // Keep reference to the box data for toggling visibility
        this.duelAreaBox = box;
        
        // Update visibility based on current debug mode
        this.updateDebugBoxVisibility();
        
        // Add a method to the physics system to toggle our debug box
        if (window.physics) {
            const originalSetDebugMode = window.physics.setDebugMode;
            window.physics.setDebugMode = (enabled) => {
                // Call the original method
                originalSetDebugMode.call(window.physics, enabled);
                
                // Update our debug box visibility
                if (this.updateDebugBoxVisibility) {
                    this.updateDebugBoxVisibility();
                }
            };
        }
    }

    /**
     * Updates the visibility of the debug box based on physics.debugMode
     */
    updateDebugBoxVisibility() {
        const isDebugMode = window.physics && window.physics.debugMode;
        
        // Update debug box visibility
        if (this.debugBox) {
            this.debugBox.visible = isDebugMode;
        }
        
        // Update debug label visibility
        if (this.debugBoxLabel) {
            this.debugBoxLabel.visible = isDebugMode;
        }
    }

    /**
     * Add a text label above the debug box
     * @param {Object} box - The box dimensions and position
     */
    addDebugBoxLabel(box) {
        // Create a canvas for the text
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 128;
        const context = canvas.getContext('2d');
        
        // Set background transparent
        context.fillStyle = 'rgba(0, 0, 0, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw text
        context.font = 'bold 48px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText('Duel Area', canvas.width / 2, canvas.height / 2);
        
        // Create texture from canvas
        const texture = new THREE.CanvasTexture(canvas);
        
        // Create sprite material
        const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
        });
        
        // Create sprite
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(10, 5, 1); // Adjust size as needed
        sprite.position.set(box.x, box.y + 5, box.z); // Position above the box
        
        this.debugBoxLabel = sprite;
        this.scene.add(sprite);
    }
}

================================================
File: /public/js/revolver.js
================================================
/**
 * A simple Revolver class that loads a low-poly gun model (GLB) for first-person view.
 */
export class Revolver {
  constructor() {
    this.group = new THREE.Group();

    // Internal flag to log the barrel lookup only once.
    this._barrelLogged = false;
    // This will be our anchor attached to the barrel, used for muzzle flash and bullet spawn.
    this.muzzleFlashAnchor = null;

    // Use GLTFLoader to load the .glb gun model
    const loader = new THREE.GLTFLoader();
    loader.load(
      'models/lowpolygun.glb',
      (gltf) => {
        const gunModel = gltf.scene;
        gunModel.scale.set(0.5, 0.5, 0.5);
        gunModel.position.set(0, 0, 0);
        // Flip the model 180° so it points forward
        gunModel.rotation.set(0, Math.PI, 0);

        // Optional: log all child names for debugging purposes
        // gunModel.traverse(child => console.log(child.name));

        this.group.add(gunModel);
        this.gunModel = gunModel;

        // Attempt to find the barrel by its name in the imported model
        const barrel = gunModel.getObjectByName("Magnum_Barrel_Magnum_mat_0");
        if (!this._barrelLogged) {
          if (barrel) {
            console.log('Revolver barrel found: "Magnum_Barrel_Magnum_mat_0".');
          } else {
            console.warn('Revolver barrel "Magnum_Barrel_Magnum_mat_0" not found. Muzzle flash anchor will not be attached.');
          }
          this._barrelLogged = true;
        }
        if (barrel) {
          // Create a muzzle flash anchor and attach it to the barrel.
          this.muzzleFlashAnchor = new THREE.Object3D();
          // Set an upward offset on the anchor (adjust as necessary)
          this.muzzleFlashAnchor.position.set(-2, 8, -10);
          barrel.add(this.muzzleFlashAnchor);
          console.log('Muzzle flash anchor attached to barrel.');
        }
      },
      undefined,
      (error) => {
        console.error('Error loading revolver model:', error);
      }
    );

    // Initially hidden until the player aims
    this.group.visible = false;
  }

  /**
   * Returns the world position of the gun barrel tip.
   * If a muzzle flash anchor was attached to the barrel, its world position is returned,
   * ensuring that the emission point remains fixed relative to the barrel.
   * Otherwise, it falls back to a default local offset relative to the revolver group.
   *
   * @returns {THREE.Vector3} The world position for spawning bullets and muzzle flash effects.
   */
  getBarrelTipWorldPosition() {
    if (this.muzzleFlashAnchor) {
      const worldPos = new THREE.Vector3();
      this.muzzleFlashAnchor.getWorldPosition(worldPos);
      return worldPos;
    }
    // Fallback: use a default local offset relative to the revolver group
    return this.group.localToWorld(new THREE.Vector3(0, 0, -0.7));
  }
}


================================================
File: /public/js/scene.js
================================================
// /public/js/scene.js
export let scene;

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {Object} - Contains the camera and renderer.
 */
export function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 10, 100); // Reduced fog distance for smaller world

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // Set output encoding for consistent lighting and color reproduction.
  renderer.outputEncoding = THREE.sRGBEncoding;

  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) {
    throw new Error("Game container not found in HTML.");
  }
  gameContainer.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(1, 1, 0.5).normalize();
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);

  // Create the western town instead of just a ground plane
  createWesternTown();

  return { camera, renderer };
}

/**
 * Creates a western town with a main street and buildings
 */
function createWesternTown() {
  // Town dimensions
  const TOWN_WIDTH = 60;  // Width of the town (X-axis)
  const TOWN_LENGTH = 100; // Length of the town (Z-axis)
  const STREET_WIDTH = 15; // Width of the main street

  // Create the ground (smaller than the original 1000x1000)
  const groundGeometry = new THREE.PlaneGeometry(TOWN_WIDTH, TOWN_LENGTH);
  const groundMaterial = new THREE.MeshStandardMaterial({
    color: 0xCD853F, // Sandy color
    roughness: 0.8,
    metalness: 0.2
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Create the main street
  const streetGeometry = new THREE.PlaneGeometry(STREET_WIDTH, TOWN_LENGTH);
  const streetMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0522D, // Brown street
    roughness: 0.9,
    metalness: 0.1
  });
  const street = new THREE.Mesh(streetGeometry, streetMaterial);
  street.rotation.x = -Math.PI / 2;
  street.position.y = 0.01; // Slightly above ground to prevent z-fighting
  street.receiveShadow = true;
  scene.add(street);

  // Add buildings on both sides of the street
  const buildingCount = 5; // Number of buildings on each side
  const buildingSpacing = TOWN_LENGTH / (buildingCount + 1);
  
  // Left side buildings (negative X)
  for (let i = 1; i <= buildingCount; i++) {
    const offset = i * buildingSpacing - TOWN_LENGTH / 2 + buildingSpacing / 2;
    createWesternBuilding(-STREET_WIDTH / 2 - 5, 0, offset);
  }
  
  // Right side buildings (positive X)
  for (let i = 1; i <= buildingCount; i++) {
    const offset = i * buildingSpacing - TOWN_LENGTH / 2 + buildingSpacing / 2;
    createWesternBuilding(STREET_WIDTH / 2 + 5, 0, offset);
  }

  // Create a visible border around the town
  createTownBorder(TOWN_WIDTH, TOWN_LENGTH);
  
  // Store these values in a global variable for access in other files
  window.townDimensions = {
    width: TOWN_WIDTH,
    length: TOWN_LENGTH,
    streetWidth: STREET_WIDTH
  };
}

/**
 * Creates a simple western-style building
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} z - Z position
 */
function createWesternBuilding(x, y, z) {
  // Randomize building dimensions
  const width = 8 + Math.random() * 4;
  const height = 5 + Math.random() * 3;
  const depth = 6 + Math.random() * 4;
  
  const buildingGroup = new THREE.Group();
  
  // Building body
  const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
  const buildingMaterial = new THREE.MeshStandardMaterial({
    color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, // Brown variations
    roughness: 0.8,
    metalness: 0.2
  });
  const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
  building.position.set(0, height / 2, 0);
  building.castShadow = true;
  building.receiveShadow = true;
  buildingGroup.add(building);
  
  // Roof (simple triangular prism)
  const roofHeight = 2;
  const roofGeometry = new THREE.BufferGeometry();
  
  const vertices = new Float32Array([
    // Front triangle
    -width/2, height, -depth/2,
    width/2, height, -depth/2,
    0, height + roofHeight, -depth/2,
    
    // Back triangle
    -width/2, height, depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, depth/2,
    
    // Left side
    -width/2, height, -depth/2,
    -width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2,
    
    // Right side
    width/2, height, -depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2
  ]);
  
  const indices = [
    // Front triangle
    0, 1, 2,
    
    // Back triangle
    3, 5, 4,
    
    // Left side
    6, 8, 7,
    7, 8, 9,
    
    // Right side
    10, 11, 12,
    11, 13, 12
  ];
  
  roofGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  roofGeometry.setIndex(indices);
  roofGeometry.computeVertexNormals();
  
  const roofMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Dark brown
    roughness: 0.9,
    metalness: 0.1
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.castShadow = true;
  buildingGroup.add(roof);
  
  // Door
  const doorWidth = 1.5;
  const doorHeight = 3;
  const doorGeometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
  const doorMaterial = new THREE.MeshStandardMaterial({
    color: 0x4d2600, // Dark brown
    roughness: 0.8,
    metalness: 0.2
  });
  const door = new THREE.Mesh(doorGeometry, doorMaterial);
  door.position.set(0, doorHeight / 2, depth / 2 + 0.01);
  buildingGroup.add(door);
  
  // Windows (1-3 random windows)
  const windowCount = 1 + Math.floor(Math.random() * 3);
  for (let i = 0; i < windowCount; i++) {
    const windowWidth = 1;
    const windowHeight = 1;
    const windowGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
    const windowMaterial = new THREE.MeshStandardMaterial({
      color: 0xECF0F1, // White-ish
      roughness: 0.4,
      metalness: 0.6
    });
    const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
    
    // Position windows randomly on the front face
    let wxPos = -width / 3 + i * width / 3;
    if (windowCount === 1) wxPos = 0;
    
    windowMesh.position.set(
      wxPos,
      height / 2 + 0.5,
      depth / 2 + 0.01
    );
    buildingGroup.add(windowMesh);
  }
  
  // Position the whole building
  buildingGroup.position.set(x, y, z);
  
  // Rotate the building to face the street
  if (x < 0) {
    buildingGroup.rotation.y = Math.PI / 2;
  } else {
    buildingGroup.rotation.y = -Math.PI / 2;
  }
  
  scene.add(buildingGroup);
}

/**
 * Creates a visible border around the town
 * @param {number} width - Width of the town
 * @param {number} length - Length of the town
 */
function createTownBorder(width, length) {
  const borderHeight = 0.5;
  const borderWidth = 0.5;
  
  // Border material
  const borderMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Brown
    roughness: 0.8,
    metalness: 0.2
  });
  
  // Create four border segments
  const createBorderSegment = (x, z, sizeX, sizeZ) => {
    const geometry = new THREE.BoxGeometry(sizeX, borderHeight, sizeZ);
    const border = new THREE.Mesh(geometry, borderMaterial);
    border.position.set(x, borderHeight / 2, z);
    border.castShadow = true;
    border.receiveShadow = true;
    scene.add(border);
    return border;
  };
  
  // Left border (negative X)
  const leftBorder = createBorderSegment(-width / 2, 0, borderWidth, length);
  
  // Right border (positive X)
  const rightBorder = createBorderSegment(width / 2, 0, borderWidth, length);
  
  // Front border (negative Z)
  const frontBorder = createBorderSegment(0, -length / 2, width, borderWidth);
  
  // Back border (positive Z)
  const backBorder = createBorderSegment(0, length / 2, width, borderWidth);
  
  // Store border references in a global variable
  window.townBorders = {
    left: leftBorder,
    right: rightBorder,
    front: frontBorder,
    back: backBorder,
    width: width,
    length: length,
    height: borderHeight
  };
}

/**
 * Creates a simple NPC target.
 * @param {THREE.Scene} scene - The scene to add the NPC.
 * @returns {THREE.Group} - The NPC group.
 */
export function createNPC(scene) {
  const npcGroup = new THREE.Group();
  const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.9;
  npcGroup.add(body);
  const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
  const headMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 1.8;
  npcGroup.add(head);
  const hatGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8);
  const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const hat = new THREE.Mesh(hatGeometry, hatMaterial);
  hat.position.y = 2.0;
  npcGroup.add(hat);

  // Position the NPC within the town instead of at (0, 0, -10)
  if (window.townDimensions) {
    // Place NPC at a random position in the town
    const x = (Math.random() - 0.5) * window.townDimensions.streetWidth * 0.8;
    const z = -window.townDimensions.length * 0.3; // Towards the front of the town
    npcGroup.position.set(x, 0, z);
  } else {
    // Default position as fallback
    npcGroup.position.set(0, 0, -10);
  }
  
  scene.add(npcGroup);
  return npcGroup;
}

/**
 * Updates the NPC's position.
 * @param {THREE.Group} npc - The NPC group.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateNPC(npc, deltaTime) {
  if (npc) {
    npc.userData.direction = npc.userData.direction || 1;
    
    // Adjust the movement range to be appropriate for the town size
    const movementRange = window.townDimensions ? 
      window.townDimensions.streetWidth * 0.4 : // 40% of street width if town exists
      15; // Original value as fallback
    
    npc.position.x += npc.userData.direction * 2 * deltaTime;
    
    if (npc.position.x > movementRange) {
      npc.userData.direction = -1;
      npc.rotation.y = Math.PI / 2;
    } else if (npc.position.x < -movementRange) {
      npc.userData.direction = 1;
      npc.rotation.y = -Math.PI / 2;
    }
  }
}

/**
 * Updates the FPS counter.
 * @param {THREE.WebGLRenderer} renderer - The renderer.
 * @param {THREE.Camera} camera - The camera.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateFPS(renderer, camera, deltaTime) {
  const fpsCounter = document.getElementById('fps-counter');
  if (fpsCounter) {
    const currentFPS = deltaTime > 0 ? Math.round(1 / deltaTime) : 0;
    fpsCounter.textContent = `FPS: ${currentFPS}`;
  }
}

================================================
File: /public/js/smokeRingEffect.js
================================================
/**
 * Smoke Ring Effect implementation for the Western Shooter game
 * Creates a stylized low-poly smoke ring when firing
 * Optimized for performance to reduce frame drops
 */
export class SmokeRingEffect {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.scene.add(this.group);
        
        this.puffs = [];
        this.active = false;
        
        // Use an object pool for particles to reduce GC
        this.particlePool = [];
        this.materialsPool = [];
        
        // Create shared geometries that will be reused - MUCH LARGER BASE GEOMETRY
        this.puffGeometry = new THREE.IcosahedronGeometry(0.2, 0); // Increased from 0.05
        this.muzzleGeometry = new THREE.IcosahedronGeometry(0.25, 0); // Increased from 0.06
    }
    
    /**
     * Preload all resources needed for the smoke ring effect
     * Call this during initialization to avoid FPS drops on first use
     */
    preload() {
        // Create and cache particles
        const numToPreload = 25; // Slightly more than used in a single effect
        
        for (let i = 0; i < numToPreload; i++) {
            // Create standard particles
            this._getParticle(false);
            
            // Create a few muzzle particles too
            if (i < 5) {
                this._getParticle(true);
            }
        }
        
        // Make them all invisible and return to pool
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        
        // Create a dummy smoke ring to warm up all the logic
        this._createSmokeRing();
        
        // Reset everything
        this.puffs = [];
        
        return this; // For chaining
    }
    
    /**
     * Create a smoke ring effect at the specified position and direction
     * @param {THREE.Vector3} position - The position to create the smoke ring
     * @param {THREE.Vector3} direction - The direction the weapon is firing
     */
    create(position, direction) {
        // Reuse particles instead of removing them
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        this.puffs = [];
        
        // Position the smoke ring at the muzzle
        this.group.position.copy(position);
        this.group.lookAt(position.clone().add(direction));
        
        // Create the smoke ring effect
        this._createSmokeRing();
        
        this.active = true;
    }
    
    /**
     * Get a particle mesh from the pool or create a new one
     * @param {boolean} isMuzzle - Whether this is a muzzle blast particle
     * @returns {THREE.Mesh} - The particle mesh
     * @private
     */
    _getParticle(isMuzzle = false) {
        if (this.particlePool.length > 0) {
            const mesh = this.particlePool.pop();
            mesh.visible = true;
            return mesh;
        }
        
        // Create new material with proper settings
        const material = new THREE.MeshPhongMaterial({
            color: 0xCCCCCC,
            flatShading: true,
            shininess: 0,
            transparent: true,
            depthWrite: false
        });
        
        this.materialsPool.push(material);
        
        // Create new mesh with the proper geometry
        const geometry = isMuzzle ? this.muzzleGeometry : this.puffGeometry;
        const mesh = new THREE.Mesh(geometry, material);
        this.group.add(mesh);
        return mesh;
    }
    
    /**
     * Create a smoke ring with proper radial particles
     * @private
     */
    _createSmokeRing() {
        // Keep just a handful of puffs with better size distribution
        const numRingParticles = 5; // 5 total puffs for outer ring
        const initialRingRadius = 0.35; // Reduced from 0.5 for less spread
        
        // Number of small inner puffs
        const numInnerPuffs = 3; // Add small puffs in the inner area
        const innerRingRadius = 0.18; // Reduced from 0.25 for less spread
        
        // Pre-determine which particles will be the large ones (1 or 2 max)
        const largeParticleIndices = [];
        const numLargeParticles = Math.random() < 0.5 ? 1 : 2; // Either 1 or 2 large particles
        
        while (largeParticleIndices.length < numLargeParticles) {
            const idx = Math.floor(Math.random() * numRingParticles);
            if (!largeParticleIndices.includes(idx)) {
                largeParticleIndices.push(idx);
            }
        }
        
        // Create outer ring puffs (larger ones)
        for (let i = 0; i < numRingParticles; i++) {
            // Much wider distribution around the circle
            // More randomness in angle placement for less uniform pattern
            const angle = (i / numRingParticles) * Math.PI * 2 + (Math.random() - 0.5) * 0.7;
            
            // Less radius spread for tighter dispersion
            const radiusVariation = initialRingRadius * (0.8 + Math.random() * 0.8); // Reduced from 1.0 + random * 1.2
            
            // Get a particle from the pool or create a new one
            const puffMesh = this._getParticle(false);
            
            // Compute normals for flat shading
            if (puffMesh.geometry.attributes.normal) {
                puffMesh.geometry.computeVertexNormals();
            }
            
            // All particles initially start near the origin (gun position)
            // They'll move to their final positions quickly during the first frames
            puffMesh.position.x = Math.cos(angle) * 0.05; // Start close to center
            puffMesh.position.y = Math.sin(angle) * 0.05; // Start close to center
            puffMesh.position.z = 0.01; // Start very close to gun
            
            // Target positions for quick interpolation - closer to gun
            const targetX = Math.cos(angle) * radiusVariation;
            const targetY = Math.sin(angle) * radiusVariation;
            const targetZ = 0.05 + Math.random() * 0.2; // Reduced from 0.3 for less z-spread
            
            // Fixed random rotation for initial appearance - don't animate rotation later
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Determine size based on whether this is one of the pre-selected large particles
            let baseSize;
            if (largeParticleIndices.includes(i)) {
                // This is one of the 1-2 large particles
                baseSize = 1.4 + Math.random() * 0.8; // 1.4-2.2 size
            } else {
                // Regular smaller particles
                baseSize = 0.6 + Math.random() * 0.4; // 0.6-1.0 size
            }
            
            // Start with a very small scale (originating from gun)
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            // Slower outward speed for less spread
            const outwardSpeed = largeParticleIndices.includes(i) ? 
                1.0 + Math.random() * 0.6 : // Reduced from 1.5 + random * 0.8 
                0.9 + Math.random() * 0.7;  // Reduced from 1.4 + random * 1.0
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: largeParticleIndices.includes(i) ?
                    1.0 + Math.random() * 1.2 : // Longer lifespan for larger clouds
                    0.7 + Math.random() * 0.5,  // Shorter for smaller clouds
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    largeParticleIndices.includes(i) ?
                        0.01 + Math.random() * 0.1 : // Less vertical for big clouds
                        0.05 + Math.random() * 0.2   // Reduced from 0.25 for less upward movement
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize, // Store the initial size for reference
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete
                initialExpansionSpeed: largeParticleIndices.includes(i) ?
                    30 + Math.random() * 15 : // Much faster expansion for large particles
                    20 + Math.random() * 10   // Fast expansion for other particles
            });
        }
        
        // Create inner core small puffs
        for (let i = 0; i < numInnerPuffs; i++) {
            // Distribute small puffs randomly in the inner area
            const angle = Math.random() * Math.PI * 2;
            
            // Use smaller radius for inner puffs with less spread
            const radiusVariation = innerRingRadius * (0.5 + Math.random() * 0.7); // Reduced from 0.6 + random * 1.0
            
            // Get a particle from the pool or create a new one
            const puffMesh = this._getParticle(false);
            
            // Compute normals for flat shading
            if (puffMesh.geometry.attributes.normal) {
                puffMesh.geometry.computeVertexNormals();
            }
            
            // Start at the origin (gun position)
            puffMesh.position.x = Math.cos(angle) * 0.03;
            puffMesh.position.y = Math.sin(angle) * 0.03;
            puffMesh.position.z = 0.01;
            
            // Target positions for quick interpolation - closer to gun
            const targetX = Math.cos(angle) * radiusVariation;
            const targetY = Math.sin(angle) * radiusVariation;
            const targetZ = 0.02 + Math.random() * 0.1; // Reduced from 0.15 for less z-spread
            
            // Fixed random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Small size for inner puffs
            const baseSize = 0.2 + Math.random() * 0.2; // 0.2-0.4 size
            
            // Start very small
            puffMesh.scale.set(0.03, 0.03, 0.03);
            
            // Slower outward speed for less spread
            const outwardSpeed = 0.6 + Math.random() * 0.6; // Reduced from 0.9 + random * 0.8
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.5 + Math.random() * 0.4, // Shorter lifespan for small inner puffs
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    0.03 + Math.random() * 0.09 // Reduced from 0.12 for less upward movement
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize,
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete
                initialExpansionSpeed: 25 + Math.random() * 10 // Fast expansion speed
            });
        }
        
        // Original muzzle blast particles for visual fidelity
        for (let i = 0; i < 1; i++) {
            const puffMesh = this._getParticle(true);
            
            // Position very close to origin with minimal spread
            const smallOffset = 0.03; // Start even closer to gun
            puffMesh.position.set(
                (Math.random() - 0.5) * smallOffset,
                (Math.random() - 0.5) * smallOffset,
                0
            );
            
            // Target positions - muzzle particles expand in place - closer to gun
            const targetX = (Math.random() - 0.5) * 0.08; // Reduced from 0.12
            const targetY = (Math.random() - 0.5) * 0.08; // Reduced from 0.12
            const targetZ = 0.02 + Math.random() * 0.02; // Reduced from 0.03
            
            // Fixed random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Moderate muzzle particles
            const baseSize = 0.6 + Math.random() * 0.2; // 0.6-0.8 size
            
            // Start extremely small
            puffMesh.scale.set(0.01, 0.01, 0.01);
            
            // Random outward direction with slower speed
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.9 + Math.random() * 0.6; // Reduced from 1.3 + random * 0.8
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.6 + Math.random() * 0.3,
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    0.15 + Math.random() * 0.2 // Reduced from 0.2 + random * 0.3
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize,
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete  
                initialExpansionSpeed: 20 + Math.random() * 10 // Very fast expansion for muzzle flash
            });
        }
    }
    
    /**
     * Update the smoke ring effect
     * @param {number} deltaTime - Time elapsed since last frame
     * @returns {boolean} - Whether the effect is still active
     */
    update(deltaTime) {
        if (!this.active) return false;
        
        let allExpired = true;
        
        // Limit delta time to avoid large jumps that cause performance issues
        const clampedDelta = Math.min(deltaTime, 0.05);
        
        for (let i = 0; i < this.puffs.length; i++) {
            const puff = this.puffs[i];
            puff.age += clampedDelta;
            
            if (puff.age < puff.lifespan) {
                allExpired = false;
                
                // Calculate life ratio
                const lifeRatio = puff.age / puff.lifespan;
                
                // Fast initial position interpolation (first ~50ms - even faster)
                if (!puff.initialExpansionDone) {
                    // Check if we're still in the initial fast expansion phase (now only 50ms)
                    const initialPhaseComplete = puff.age > 0.05; // Reduced from 100ms to 50ms
                    
                    if (initialPhaseComplete) {
                        // Mark initial expansion as done
                        puff.initialExpansionDone = true;
                        
                        // Set position to target to ensure we reached it
                        puff.mesh.position.copy(puff.targetPos);
                    } else {
                        // Very fast interpolation toward target position
                        const lerpFactor = clampedDelta * puff.initialExpansionSpeed;
                        
                        puff.mesh.position.x += (puff.targetPos.x - puff.mesh.position.x) * lerpFactor;
                        puff.mesh.position.y += (puff.targetPos.y - puff.mesh.position.y) * lerpFactor;
                        puff.mesh.position.z += (puff.targetPos.z - puff.mesh.position.z) * lerpFactor;
                        
                        // Quickly scale up to initial size
                        const targetScale = puff.initialSize * 0.9; // Target 90% of final size initially
                        const currentScale = puff.mesh.scale.x;
                        const newScale = currentScale + (targetScale - currentScale) * lerpFactor;
                        puff.mesh.scale.set(newScale, newScale, newScale);
                    }
                } else {
                    // Normal movement after initial expansion
                    const positionX = puff.mesh.position.x + puff.velocity.x * clampedDelta;
                    const positionY = puff.mesh.position.y + puff.velocity.y * clampedDelta;
                    const positionZ = puff.mesh.position.z + puff.velocity.z * clampedDelta;
                    puff.mesh.position.set(positionX, positionY, positionZ);
                
                    // Scale curve for visual fidelity after initial expansion - REDUCE MAX SCALE
                    let scaleFactor;
                    
                    if (lifeRatio < 0.2) {
                        // Quick growth phase - 0 to 0.2 - REDUCE PEAK
                        scaleFactor = 0.9 + (lifeRatio / 0.2) * 0.2; // Start from 90% to 110% (down from 130%)
                    } else if (lifeRatio < 0.7) {
                        // Maintain size with slight growth - 0.2 to 0.7 - REDUCE PEAK
                        scaleFactor = 1.1 + (lifeRatio - 0.2) * 0.1; // 110% to 120% (down from 130% to 150%)
                    } else {
                        // Shrink phase - 0.7 to 1.0
                        scaleFactor = 1.2 - (lifeRatio - 0.7) * (1.2 / 0.3); // Shrink from 120% to 0%
                    }
                    
                    // Apply scale based on the initial size to maintain relative proportions
                    const scale = puff.initialSize * scaleFactor;
                    puff.mesh.scale.set(scale, scale, scale);
                }
                
                // Handle transparency in final phase
                if (lifeRatio > 0.7) {
                    const opacity = 1 - ((lifeRatio - 0.7) / 0.3);
                    puff.mesh.material.opacity = opacity;
                } else {
                    // Reset opacity for particles not in final phase
                    puff.mesh.material.opacity = 1.0;
                }
                
                // Almost no drag to allow particles to travel much further
                const dragFactor = lifeRatio < 0.5 ? 0.995 : 0.99;
                puff.velocity.multiplyScalar(dragFactor);
            } else {
                // Add expired puffs back to the pool instead of making them invisible
                puff.mesh.visible = false;
                this.particlePool.push(puff.mesh);
            }
        }
        
        // If all puffs have expired, clean up and set active to false
        if (allExpired) {
            this.puffs = [];
            this.active = false;
            return false;
        }
        
        return true;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        // Clean up all meshes and properly dispose materials
        while(this.group.children.length > 0) {
            const mesh = this.group.children[0];
            this.group.remove(mesh);
        }
        
        // Clear the particle pool
        this.particlePool = [];
        this.puffs = [];
        
        // Dispose of all materials in the pool
        for (let i = 0; i < this.materialsPool.length; i++) {
            if (this.materialsPool[i]) {
                this.materialsPool[i].dispose();
            }
        }
        this.materialsPool = [];
        
        // Dispose of shared geometries
        if (this.puffGeometry) this.puffGeometry.dispose();
        if (this.muzzleGeometry) this.muzzleGeometry.dispose();
        
        // Remove group from scene
        if (this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
}

================================================
File: /public/js/soundManager.js
================================================
export class SoundManager {
  constructor() {
    // For non-positional playback
    this.sounds = {};
    // For positional playback using Web Audio API
    this.buffers = {};
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // For footstep optimization - preload audio nodes for footsteps
    this.footstepSources = {
      left: [],
      right: []
    };
    this.footstepPoolSize = 3; // Number of audio nodes to cycle through
    this.currentFootstepIndex = 0;
    
    // For sound cooldowns (prevent sound spam)
    this.soundCooldowns = {};
  }
  
  /**
   * Loads an audio file and caches it.
   * Loads both as an HTMLAudioElement (for simple playback)
   * and as an AudioBuffer (for positional audio).
   * @param {string} name - Sound key.
   * @param {string} url - Audio file URL.
   */
  loadSound(name, url) {
    try {
      // Load using HTMLAudioElement for non-positional playback
      const audio = new Audio();
      audio.src = url;
      audio.load();
      this.sounds[name] = audio;
      
      console.log(`Loaded sound "${name}" as HTMLAudioElement from ${url}`);
    } catch (error) {
      console.error(`Error loading sound "${name}" from ${url}:`, error);
    }
    
    // Also load using fetch for positional audio
    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network response failed for sound ${name}: ${response.status} ${response.statusText}`);
        }
        return response.arrayBuffer();
      })
      .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        this.buffers[name] = audioBuffer;
        console.log(`Loaded sound "${name}" as AudioBuffer from ${url}`);
        
        // Preload footstep sources if this is a footstep sound
        if (name === 'leftstep' || name === 'rightstep') {
          const footType = name === 'leftstep' ? 'left' : 'right';
          console.log(`Preloading ${footType} footstep sources`);
          // Create a pool of audio sources for footsteps
          for (let i = 0; i < this.footstepPoolSize; i++) {
            this.footstepSources[footType][i] = {
              source: null,
              gainNode: this.audioContext.createGain(),
              panner: this.audioContext.createPanner()
            };
            
            // Set up the audio chain
            this.footstepSources[footType][i].gainNode.connect(this.audioContext.destination);
            this.footstepSources[footType][i].panner.connect(this.footstepSources[footType][i].gainNode);
            
            // Configure panner for 3D audio
            this.footstepSources[footType][i].panner.panningModel = 'HRTF';
            this.footstepSources[footType][i].panner.distanceModel = 'inverse';
            this.footstepSources[footType][i].panner.refDistance = 1;
            this.footstepSources[footType][i].panner.maxDistance = 10000;
            this.footstepSources[footType][i].panner.rolloffFactor = 1;
          }
        }
      })
      .catch(error => {
        console.error(`Error loading sound buffer "${name}" from ${url}:`, error);
      });
  }
  
  /**
   * Plays a cached sound by cloning the HTMLAudioElement.
   * @param {string} name - Sound key.
   * @param {number} cooldown - Optional cooldown in milliseconds to prevent rapid repetition.
   * @param {number} volume - Optional volume multiplier (0-1)
   */
  playSound(name, cooldown = 0, volume = 1.0) {
    if (this.sounds[name]) {
      // Check cooldown if specified
      if (cooldown > 0) {
        const now = Date.now();
        if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
          // Still in cooldown period
          return;
        }
        this.soundCooldowns[name] = now;
      }
      
      const audioClone = this.sounds[name].cloneNode();
      // Apply volume adjustment
      audioClone.volume = Math.max(0, Math.min(1, volume));
      
      audioClone.play().catch(error => {
        console.error(`Error playing sound "${name}":`, error);
      });
    } else {
      console.error(`Sound "${name}" not found in cache.`);
    }
  }
  
  /**
   * Plays a sound at a given 3D position using the Web Audio API.
   * @param {string} name - Sound key.
   * @param {THREE.Vector3} position - 3D position for the sound.
   * @param {number} cooldown - Optional cooldown in milliseconds.
   * @param {number} volume - Optional volume multiplier.
   */
  playSoundAt(name, position, cooldown = 0, volume = 1.0) {
    if (!this.buffers[name]) {
      console.error(`Positional sound "${name}" not found in buffers.`);
      return;
    }
    
    // Check cooldown if specified
    if (cooldown > 0) {
      const now = Date.now();
      if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
        // Still in cooldown period
        return;
      }
      this.soundCooldowns[name] = now;
    }
    
    try {
      const source = this.audioContext.createBufferSource();
      source.buffer = this.buffers[name];
      
      const panner = this.audioContext.createPanner();
      panner.panningModel = 'HRTF';
      panner.distanceModel = 'inverse';
      panner.refDistance = 1;
      panner.maxDistance = 10000;
      panner.rolloffFactor = 1;
      panner.coneInnerAngle = 360;
      panner.coneOuterAngle = 0;
      panner.coneOuterGain = 0;
      panner.setPosition(position.x, position.y, position.z);
      
      // Add volume control gain node
      const gainNode = this.audioContext.createGain();
      gainNode.gain.value = volume;
      
      source.connect(panner);
      panner.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      source.start(0);
    } catch (error) {
      console.error(`Error playing positional sound "${name}":`, error);
    }
  }
  
  /**
   * Efficiently plays footstep sounds by reusing audio nodes.
   * Optimized for frequent calls during walking.
   * @param {string} foot - 'left' or 'right' to determine which sound to play.
   * @param {THREE.Vector3} position - 3D position for the sound.
   * @param {number} volume - Volume multiplier based on movement speed.
   */
  playFootstep(foot, position, volume = 1.0) {
    const footType = foot === 'left' ? 'left' : 'right';
    const soundName = foot === 'left' ? 'leftstep' : 'rightstep';
    
    if (!this.buffers[soundName]) {
      console.error(`Footstep sound "${soundName}" not found in buffers.`);
      return;
    }
    
    try {
      // Get the next footstep source from the pool
      const sourceObj = this.footstepSources[footType][this.currentFootstepIndex];
      this.currentFootstepIndex = (this.currentFootstepIndex + 1) % this.footstepPoolSize;
      
      // If there's an existing source playing, stop it
      if (sourceObj.source !== null) {
        try {
          sourceObj.source.stop();
        } catch (e) {
          // Ignore errors if the source was already stopped
        }
      }
      
      // Create a new source
      sourceObj.source = this.audioContext.createBufferSource();
      sourceObj.source.buffer = this.buffers[soundName];
      
      // Update position and volume
      sourceObj.panner.setPosition(position.x, position.y, position.z);
      sourceObj.gainNode.gain.value = volume;
      
      // Connect and play
      sourceObj.source.connect(sourceObj.panner);
      sourceObj.source.start(0);
    } catch (error) {
      console.error(`Error playing footstep sound "${soundName}":`, error);
    }
  }
  
  /**
   * Plays a sequence: after sound1 ends, sound2 plays.
   * @param {string} sound1 - First sound key.
   * @param {string} sound2 - Second sound key.
   */
  playSoundSequence(sound1, sound2) {
    if (this.sounds[sound1]) {
      const audioClone = this.sounds[sound1].cloneNode();
      audioClone.play().then(() => {
        audioClone.addEventListener('ended', () => {
          this.playSound(sound2);
        });
      }).catch(error => {
        console.error(`Error playing sound "${sound1}":`, error);
      });
    } else {
      console.error(`Sound "${sound1}" not found in cache.`);
    }
  }
}

================================================
File: /public/js/ui.js
================================================
/**
 * Updates the ammo counter in the UI.
 * @param {Player} player - The player instance.
 */
export function updateAmmoUI(player) {
  const ammoCounter = document.getElementById('ammo-counter');
  if (ammoCounter && player) {
    ammoCounter.textContent = `Bullets: ${player.bullets}/${player.maxBullets}`;
  }
}

/**
* Updates the health counter in the UI.
* @param {Player|ThirdPersonModel} player - The player instance.
*/
export function updateHealthUI(player) {
  const healthCounter = document.getElementById('health-counter');
  if (healthCounter && player) {
    const healthText = `Health: ${player.health}`;
    healthCounter.textContent = healthText;
    
    // Add visual indication of health level
    if (player.health > 75) {
      healthCounter.style.color = '#4CAF50'; // Green for good health
    } else if (player.health > 30) {
      healthCounter.style.color = '#FFC107'; // Yellow/amber for medium health
    } else {
      healthCounter.style.color = '#F44336'; // Red for low health
    }
  }
}

/**
* Creates a temporary damage indicator overlay when player takes damage.
* @param {number} damage - The amount of damage taken.
* @param {string} hitZone - The hit zone ('head', 'body', 'limbs').
*/
export function showDamageIndicator(damage, hitZone) {
  // Create damage indicator element if it doesn't exist
  let damageIndicator = document.getElementById('damage-indicator');
  if (!damageIndicator) {
      damageIndicator = document.createElement('div');
      damageIndicator.id = 'damage-indicator';
      damageIndicator.style.position = 'absolute';
      damageIndicator.style.top = '40%';
      damageIndicator.style.left = '50%';
      damageIndicator.style.transform = 'translate(-50%, -50%)';
      damageIndicator.style.color = 'red';
      damageIndicator.style.fontSize = '48px';
      damageIndicator.style.fontWeight = 'bold';
      damageIndicator.style.opacity = '0';
      damageIndicator.style.textShadow = '2px 2px 4px #000000';
      damageIndicator.style.transition = 'opacity 0.3s ease-in, opacity 0.5s ease-out';
      damageIndicator.style.zIndex = '1000';
      damageIndicator.style.pointerEvents = 'none';
      document.getElementById('game-container').appendChild(damageIndicator);
  }
  
  // Set text based on hit zone
  let hitText = `-${damage}`;
  if (hitZone) {
      switch (hitZone) {
          case 'head':
              hitText += ' HEADSHOT!';
              break;
          case 'body':
              hitText += ' (Body Shot)';
              break;
          case 'limbs':
              hitText += ' (Limb Shot)';
              break;
      }
  }
  
  // Display damage indicator
  damageIndicator.textContent = hitText;
  damageIndicator.style.opacity = '1';
  
  // Set color based on damage
  if (damage >= 100) {
      damageIndicator.style.color = '#FF0000'; // Bright red for headshots
      damageIndicator.style.fontSize = '64px';
  } else if (damage >= 40) {
      damageIndicator.style.color = '#FF4500'; // Orange-red for body shots
  } else {
      damageIndicator.style.color = '#FFA500'; // Orange for limb shots
  }
  
  // Fade out after a delay
  setTimeout(() => {
      damageIndicator.style.opacity = '0';
  }, 800);
}

/**
* Updates all UI elements related to player status.
* @param {Player} player - The player instance.
*/
export function updatePlayerUI(player) {
  updateAmmoUI(player);
  updateHealthUI(player);
}

================================================
File: /server.js
================================================
// server.js
console.log("Starting server initialization...");
const express = require('express');
console.log("Express loaded");
const http = require('http');
console.log("HTTP loaded");
const WebSocket = require('ws');
console.log("WebSocket loaded");
const url = require('url');
console.log("URL loaded");
const app = express();
console.log("Express app created");

// Port default 8080 to match your previous Cloudflare Tunnel config
const PORT = process.env.PORT || 8080;
console.log("Port set to", PORT);

// Serve static files from "public"
app.use(express.static('public'));
console.log("Static file serving configured");

const server = http.createServer(app);
console.log("HTTP server created");
const wss = new WebSocket.Server({ server, clientTracking: true });
console.log("WebSocket server created");

// Track connected players
const players = new Map();    // playerId -> { ws, sessionId, position, rotation, health, ... }
const sessions = new Set();   // tracks sessionIds to prevent duplicate connections
let nextPlayerId = 1;
console.log("Player tracking variables initialized");

// Position history tracking to reduce unnecessary corrections
const playerPositionHistory = new Map(); // playerId -> array of recent positions
const POSITION_HISTORY_SIZE = 10; // Number of positions to track per player
const CORRECTION_COOLDOWN = 5000; // Minimum ms between position corrections
console.log("Position history tracking initialized");

// Track Quick Draw game mode queues and active duels
// Support for 5 concurrent lobbies
const MAX_ARENAS = 5;
const quickDrawQueues = Array(MAX_ARENAS).fill(null).map(() => []);  // Array of queues for each arena
const quickDrawDuels = new Map(); // Map of duelId -> { player1Id, player2Id, state, arenaIndex, ... }
console.log("Quick Draw game mode variables initialized");

// Anti-cheat: Game physics constants
const GAME_CONSTANTS = {
  // Weapon constraints
  BULLET_SPEED: 80,           // Bullet speed units/second
  MAX_BULLET_DISTANCE: 100,   // Maximum distance a bullet can travel
  WEAPON_COOLDOWN: 250,       // Minimum time between shots in ms
  RELOAD_TIME: 4000,          // Time required to reload in ms
  DAMAGE_PER_HIT: 20,         // Health points reduced per hit
  // Town boundaries
  TOWN_WIDTH: 60,             // Width of the town
  TOWN_LENGTH: 100,           // Length of the town
  // Physics update rate
  PHYSICS_UPDATE_INTERVAL: 16 // ms (approx 60fps)
};

// Anti-cheat: Active bullets map
const activeBullets = new Map(); // bulletId -> {sourcePlayerId, position, direction, timeCreated, etc}
let nextBulletId = 1;

// Anti-cheat: Timeout tracking (for rate limiting and cooldowns)
const playerTimeouts = new Map(); // playerId -> { lastShot, lastReload, lastTeleport, etc }

// Anti-cheat: Nonce tracking (for anti-replay protection)
const playerNonces = new Map(); // playerId -> Set of used nonces
const playerSequences = new Map(); // playerId -> last sequence number

// On new connection
wss.on('connection', (ws, req) => {
  // Parse sessionId from query string
  const parameters = url.parse(req.url, true).query;
  const sessionId = parameters.sessionId;

  // If we already have this sessionId, reject as duplicate
  if (sessionId && sessions.has(sessionId)) {
    console.log(`Rejecting duplicate connection with sessionId: ${sessionId}`);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Duplicate connection detected',
      fatal: true
    }));
    return ws.close(1008, 'Duplicate connection');
  }

  if (sessionId) {
    sessions.add(sessionId);
  }

  const playerId = nextPlayerId++;
  console.log(`Player ${playerId} connected (sessionId: ${sessionId || 'none'})`);

  // Create initial player data with health and QuickDraw info
  players.set(playerId, {
    ws,
    sessionId,
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { y: 0 },
    isAiming: false,
    isShooting: false,
    isReloading: false,
    health: 100,
    lastActivity: Date.now(),
    quickDrawLobbyIndex: -1, // -1 means not in any lobby
    inQuickDrawQueue: false,
    inQuickDrawDuel: false,
    quickDrawDuelId: null,
    // Additional player state
    bullets: 6,
    maxBullets: 6,
    lastUpdateTime: Date.now()
  });

  // Anti-cheat: Initialize timeout tracking
  playerTimeouts.set(playerId, {
    lastShot: 0,
    lastMovement: 0,
    lastReload: 0,
    lastPositionUpdate: 0,
    lastPositionCorrection: 0,
    reloadStartTime: 0,
    isReloading: false
  });

  // Anti-cheat: Initialize nonce/sequence tracking
  playerNonces.set(playerId, new Set());
  playerSequences.set(playerId, 0);

  // Send init data to this client (their ID + existing players)
  ws.send(JSON.stringify({
    type: 'init',
    id: playerId,
    players: Array.from(players.entries())
      .filter(([pid]) => pid !== playerId)
      .map(([pid, p]) => ({
        id: pid,
        position: p.position,
        rotation: p.rotation,
        isAiming: p.isAiming,
        isShooting: p.isShooting,
        isReloading: p.isReloading,
        health: p.health,
        quickDrawLobbyIndex: p.quickDrawLobbyIndex
      }))
  }));

  // Notify others that a new player joined
  broadcastToOthers(playerId, {
    type: 'playerJoined',
    id: playerId,
    position: players.get(playerId).position,
    rotation: players.get(playerId).rotation,
    health: players.get(playerId).health,
    quickDrawLobbyIndex: players.get(playerId).quickDrawLobbyIndex
  });

  // Handle incoming messages
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);

      // Update lastActivity
      const player = players.get(playerId);
      if (!player) return;
      
      player.lastActivity = Date.now();

      // Anti-cheat: Sequence number validation
      if (data.sequenceNumber !== undefined) {
        const lastSequence = playerSequences.get(playerId) || 0;
        
        // Reject if sequence number is not greater than the last one
        if (data.sequenceNumber <= lastSequence) {
          console.log(`Rejecting message with old sequence number: ${data.sequenceNumber} (last: ${lastSequence})`);
          return sendErrorToPlayer(playerId, "Invalid sequence number", false);
        }
        
        // Update the last sequence number
        playerSequences.set(playerId, data.sequenceNumber);
      }

      // Anti-cheat: Nonce validation for critical actions
      if ((data.type === 'shoot' || data.type === 'playerHit') && data.nonce) {
        const playerNonceSet = playerNonces.get(playerId);
        
        // Check if nonce has been used before
        if (playerNonceSet && playerNonceSet.has(data.nonce)) {
          console.log(`Rejecting repeated nonce: ${data.nonce} from player ${playerId}`);
          return sendErrorToPlayer(playerId, "Duplicate nonce detected", false);
        }
        
        // Store the nonce
        if (playerNonceSet) {
          playerNonceSet.add(data.nonce);
          
          // Limit nonce set size to prevent memory issues
          if (playerNonceSet.size > 1000) {
            // Keep only the most recent 500 nonces
            const nonceArray = Array.from(playerNonceSet);
            const newNonceSet = new Set(nonceArray.slice(nonceArray.length - 500));
            playerNonces.set(playerId, newNonceSet);
          }
        }
      }

      switch (data.type) {
        case 'update':
          handlePlayerUpdate(playerId, data);
          break;

        case 'shoot':
          handlePlayerShoot(playerId, data);
          break;

        case 'playerHit':
          handlePlayerHit(playerId, data);
          break;

        case 'reload':
          handlePlayerReload(playerId, data);
          break;

        case 'ping':
          // respond
          ws.send(JSON.stringify({ type: 'pong' }));
          break;
          
        case 'quickDrawJoin':
          handleQuickDrawJoin(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawLeave':
          handleQuickDrawLeave(playerId);
          break;
          
        case 'quickDrawReady':
          handleQuickDrawReady(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawShoot':
          // Pass the hit zone and damage if provided
          handleQuickDrawShoot(
            playerId, 
            data.opponentId, 
            data.arenaIndex, 
            data.hitZone || 'body', 
            data.damage || 40
          );
          break;
          
        // Add new handlers for direct challenge system
        case 'quickDrawChallenge':
          handleQuickDrawChallenge(playerId, data.targetPlayerId);
          break;
          
        case 'quickDrawAccept':
          handleQuickDrawAcceptChallenge(playerId, data.challengerId);
          break;
          
        case 'quickDrawDecline':
          handleQuickDrawDeclineChallenge(playerId, data.challengerId);
          break;

        default:
          break;
      }
    } catch (err) {
      console.error('Error processing message:', err);
    }
  });

  // On close
  ws.on('close', () => {
    cleanupPlayer(playerId);
  });

  // On error
  ws.on('error', (err) => {
    console.error(`WebSocket error for player ${playerId}:`, err);
    cleanupPlayer(playerId);
  });

  // Update the global player count UI
  updatePlayerCount();
});

// Handle player updates - removed speed/position validation
function handlePlayerUpdate(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Basic rate limit for position updates only
  if (now - timeouts.lastPositionUpdate < 16) { // Max 60 updates per second
    return; // Silently ignore too frequent updates
  }
  timeouts.lastPositionUpdate = now;
  
  // Update player data
  if (data.position) {
    player.position = data.position;
  }
  
  // Update other player properties
  player.rotation = data.rotation || player.rotation;
  player.isAiming = data.isAiming !== undefined ? data.isAiming : player.isAiming;
  player.isReloading = data.isReloading !== undefined ? data.isReloading : player.isReloading;
  
  // Update QuickDraw lobby index if provided
  if (data.quickDrawLobbyIndex !== undefined) {
    player.quickDrawLobbyIndex = data.quickDrawLobbyIndex;
  }
  
  if (data.isSprinting !== undefined) {
    player.isSprinting = data.isSprinting;
  }
  
  // Broadcast valid update to others
  broadcastToOthers(playerId, {
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    rotation: player.rotation,
    isAiming: player.isAiming,
    isShooting: player.isShooting,
    isReloading: player.isReloading,
    health: player.health,
    quickDrawLobbyIndex: player.quickDrawLobbyIndex
  });
}

// Anti-cheat: Handle player shooting with validation and server-side trajectory
function handlePlayerShoot(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Check if player has bullets
  if (player.bullets <= 0) {
    return sendErrorToPlayer(playerId, "Cannot shoot: out of ammo", false);
  }
  
  // Anti-cheat: Check if player is reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Cannot shoot while reloading", false);
  }
  
  // Anti-cheat: Enforce weapon cooldown
  if (now - timeouts.lastShot < GAME_CONSTANTS.WEAPON_COOLDOWN) {
    console.log(`Rate limit exceeded: Player ${playerId} attempted to shoot too quickly`);
    return sendErrorToPlayer(playerId, "Shooting too fast", false);
  }
  
  // Quick Draw gun lock validation
  if (player.inQuickDrawDuel && player.quickDrawDuelId) {
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel && duel.state !== 'draw') {
      return sendErrorToPlayer(playerId, "Cannot shoot before draw signal", false);
    }
  }
  
  // Validate bullet data
  if (!data.bulletData || !data.bulletData.position || !data.bulletData.direction) {
    return sendErrorToPlayer(playerId, "Invalid bullet data", false);
  }
  
  // Validate bullet direction (must be normalized)
  const direction = data.bulletData.direction;
  const dirMagnitude = Math.sqrt(direction.x*direction.x + direction.y*direction.y + direction.z*direction.z);
  
  if (Math.abs(dirMagnitude - 1) > 0.01) {
    console.log(`Invalid bullet direction: not normalized for player ${playerId} (magnitude: ${dirMagnitude.toFixed(2)})`);
    
    // Normalize the direction
    direction.x /= dirMagnitude;
    direction.y /= dirMagnitude;
    direction.z /= dirMagnitude;
  }
  
  // All validations passed, decrement bullet count
  player.bullets--;
  
  // Update lastShot timestamp
  timeouts.lastShot = now;
  
  // Create a server-side bullet
  const bulletId = nextBulletId++;
  
  const bullet = {
    id: bulletId,
    sourcePlayerId: playerId,
    position: data.bulletData.position,
    direction: direction,
    distanceTraveled: 0,
    maxDistance: GAME_CONSTANTS.MAX_BULLET_DISTANCE,
    speed: GAME_CONSTANTS.BULLET_SPEED,
    timeCreated: now,
    active: true
  };
  
  // Add to active bullets
  activeBullets.set(bulletId, bullet);
  
  // Notify clients of the shot
  broadcastToAll({
    type: 'playerShoot',
    id: playerId,
    bulletId: bulletId,
    bulletData: {
      position: data.bulletData.position,
      direction: direction
    }
  });
  
  // Update the player's shooting state
  player.isShooting = true;
  
  // Reset shooting state after a short delay
  setTimeout(() => {
    if (players.has(playerId)) {
      players.get(playerId).isShooting = false;
    }
  }, 100);
}

// Anti-cheat: Handle player reload with validation
function handlePlayerReload(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Check if player is already reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Already reloading", false);
  }
  
  // Check if player has full ammo
  if (player.bullets >= player.maxBullets) {
    return sendErrorToPlayer(playerId, "Ammo already full", false);
  }
  
  // Start reload process
  player.isReloading = true;
  timeouts.isReloading = true;
  timeouts.reloadStartTime = now;
  
  // Notify all players about reload start
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    isReloading: true
  });
  
  // Schedule reload completion
  setTimeout(() => {
    if (!players.has(playerId)) return;
    
    const timeouts = playerTimeouts.get(playerId);
    if (!timeouts) return;
    
    // Check if player is still reloading (could have been cancelled)
    if (timeouts.isReloading) {
      const player = players.get(playerId);
      
      // Complete reload
      player.bullets = player.maxBullets;
      player.isReloading = false;
      timeouts.isReloading = false;
      
      // Notify all players about reload completion
      broadcastToAll({
        type: 'playerUpdate',
        id: playerId,
        isReloading: false,
        bullets: player.maxBullets
      });
    }
  }, GAME_CONSTANTS.RELOAD_TIME);
}

// Anti-cheat: Handle player hit validation
function handlePlayerHit(playerId, data) {
  if (!data.targetId) return;
  
  const targetId = parseInt(data.targetId);
  const sourcePlayer = players.get(playerId);
  const targetPlayer = players.get(targetId);
  
  if (!sourcePlayer || !targetPlayer) return;
  
  // Validate that players are in compatible game modes
  const sourceInQuickDraw = sourcePlayer.inQuickDrawDuel;
  const targetInQuickDraw = targetPlayer.inQuickDrawDuel;
  
  // Verify that players are either both in QuickDraw or both in regular mode
  const bothInQuickDraw = sourceInQuickDraw && targetInQuickDraw && 
                         sourcePlayer.quickDrawDuelId === targetPlayer.quickDrawDuelId;
  const bothInRegularMode = !sourceInQuickDraw && !targetInQuickDraw;
  
  if (!(bothInQuickDraw || bothInRegularMode)) {
    console.log(`Rejecting hit claim from player ${playerId} on ${targetId}: incompatible game modes`);
    console.log(`Source: QuickDraw=${sourceInQuickDraw}`);
    console.log(`Target: QuickDraw=${targetInQuickDraw}`);
    return sendErrorToPlayer(playerId, "Invalid hit: players in different game modes", false);
  }
  
  // Get hit data
  const hitZone = data.hitData && data.hitData.hitZone ? data.hitData.hitZone : 'body';
  const damage = data.hitData && data.hitData.damage ? data.hitData.damage : 40;
  
  // Validate hit zone and damage
  let finalDamage = damage;
  if (hitZone === 'head') {
    finalDamage = 100; // Headshot is always lethal
  } else if (hitZone === 'body') {
    finalDamage = 40; // Body shot deals 40 damage
  } else if (hitZone === 'limbs') {
    finalDamage = 20; // Limb shot deals 20 damage
  }
  
  // Apply hit effects: reduce health
  targetPlayer.health = Math.max(targetPlayer.health - finalDamage, 0);
  
  // Inform the target
  if (targetPlayer.ws.readyState === WebSocket.OPEN) {
    targetPlayer.ws.send(JSON.stringify({
      type: 'hit',
      sourceId: playerId,
      hitData: data.hitData,
      health: targetPlayer.health,
      hitZone: hitZone
    }));
  }
  
  // Broadcast the hit to everyone
  broadcastToAll({
    type: 'playerHit',
    targetId: targetId,
    sourceId: playerId,
    hitPosition: data.hitData ? data.hitData.position : null,
    health: targetPlayer.health,
    bulletId: data.bulletId,
    hitZone: hitZone,
    damage: finalDamage
  });
  
  // Check for player death
  if (targetPlayer.health <= 0) {
    handlePlayerDeath(targetId, playerId);
  }
}

// Anti-cheat: Bullet-player collision detection
function isPlayerHitByBullet(player, bullet) {
  // Calculate player hitbox (simple cylinder)
  const playerRadius = 0.6;  // Increased horizontal radius to match client's bodyWidth
  const playerHeight = 2.0;  // vertical height
  
  // Calculate distance from bullet to player (horizontal only)
  const dx = bullet.position.x - player.position.x;
  const dz = bullet.position.z - player.position.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  // Check if bullet is within player's horizontal radius
  if (horizontalDist > playerRadius) {
    return false;
  }
  
  // Check if bullet is within player's vertical bounds
  const bulletY = bullet.position.y;
  const playerBottom = player.position.y - 1.6; // Adjust based on your coordinate system
  const playerTop = playerBottom + playerHeight;
  
  // Add some tolerance to vertical bounds
  const tolerance = 0.2;
  if (bulletY < playerBottom - tolerance || bulletY > playerTop + tolerance) {
    return false;
  }
  
  // Bullet is inside player's hitbox
  return true;
}

// Anti-cheat: Handle player death
function handlePlayerDeath(playerId, killedById) {
  const player = players.get(playerId);
  if (!player) return;
  
  console.log(`Player ${playerId} was killed by player ${killedById}`);
  
  // If player is in Quick Draw duel, end the duel
  if (player.inQuickDrawDuel && player.quickDrawDuelId) {
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel) {
      endQuickDrawDuel(player.quickDrawDuelId, killedById);
    }
  }
  
  // Respawn the player
  respawnPlayer(playerId);
}

// Anti-cheat: Respawn a player
function respawnPlayer(playerId) {
  const player = players.get(playerId);
  if (!player) return;
  
  // Reset player state
  player.health = 100;
  player.bullets = player.maxBullets;
  player.isReloading = false;
  player.isAiming = false;
  player.isShooting = false;
  
  // Generate random spawn position within town
  const spawnX = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_WIDTH * 0.8;
  const spawnY = 1.6;
  const spawnZ = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_LENGTH * 0.8;
  
  // Set spawn position
  player.position = { x: spawnX, y: spawnY, z: spawnZ };
  
  // Reset QuickDraw-related state if not in a duel
  if (!player.inQuickDrawDuel) {
    player.quickDrawLobbyIndex = -1;
  }
  
  // Notify the player they're respawning
  if (player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'respawn',
      position: player.position,
      health: player.health,
      bullets: player.bullets
    }));
  }
  
  // Broadcast the respawn to all players
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    health: player.health,
    isReloading: false,
    isAiming: false
  });
}

// Anti-cheat: Check if position is within town boundaries
function isPositionInTown(position) {
  return (
    position.x >= -GAME_CONSTANTS.TOWN_WIDTH / 2 &&
    position.x <= GAME_CONSTANTS.TOWN_WIDTH / 2 &&
    position.z >= -GAME_CONSTANTS.TOWN_LENGTH / 2 &&
    position.z <= GAME_CONSTANTS.TOWN_LENGTH / 2
  );
}

// Anti-cheat: Check if position is in arena
function isPositionInArena(position, arenaIndex) {
  // Define arena positions and radius
  const arenaRadius = 15;
  
  // Calculate arena center position based on index
  const spacingX = 50;
  const baseZ = GAME_CONSTANTS.TOWN_LENGTH + 50;
  
  const offsetX = (arenaIndex - 2) * spacingX; // Center on zero, spread outward
  const arenaCenter = { x: offsetX, y: 0, z: baseZ };
  
  // Check if point is inside arena (horizontally)
  const dx = position.x - arenaCenter.x;
  const dz = position.z - arenaCenter.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  return horizontalDist < arenaRadius;
}

// Anti-cheat: Send position correction to player
function sendPositionCorrection(playerId, correctPosition) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  const now = Date.now();
  const timeouts = playerTimeouts.get(playerId);
  
  // Skip if we've recently sent a correction
  if (timeouts && timeouts.lastPositionCorrection && 
      now - timeouts.lastPositionCorrection < CORRECTION_COOLDOWN) {
    return;
  }
  
  // Calculate distance between current position and correction
  const currentPos = player.position;
  const distance = Math.sqrt(
    Math.pow(currentPos.x - correctPosition.x, 2) +
    Math.pow(currentPos.y - correctPosition.y, 2) +
    Math.pow(currentPos.z - correctPosition.z, 2)
  );
  
  // Only send significant corrections (>5 units) to avoid unnecessary resets
  if (distance > 5) {
    console.log(`Sending position correction to player ${playerId}, distance: ${distance.toFixed(2)}`);
    
    // Update last correction time
    if (timeouts) {
      timeouts.lastPositionCorrection = now;
    }
    
    player.ws.send(JSON.stringify({
      type: 'positionCorrection',
      position: correctPosition
    }));
  }
}

// Anti-cheat: Send error message to player
function sendErrorToPlayer(playerId, message, fatal = false) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  player.ws.send(JSON.stringify({
    type: 'error',
    message: message,
    fatal: fatal
  }));
}

// Cleanup a disconnected or stale player
function cleanupPlayer(playerId) {
  const player = players.get(playerId);
  if (player) {
    console.log(`Player ${playerId} disconnected`);
    if (player.sessionId) {
      sessions.delete(player.sessionId);
    }
    
    // Quick Draw cleanup
    if (player.inQuickDrawQueue && player.quickDrawLobbyIndex >= 0) {
      // Remove from the appropriate queue
      const queueIndex = player.quickDrawLobbyIndex;
      if (queueIndex >= 0 && queueIndex < MAX_ARENAS) {
        const queue = quickDrawQueues[queueIndex];
        const index = queue.indexOf(playerId);
        if (index !== -1) {
          queue.splice(index, 1);
        }
      }
    }
    
    if (player.inQuickDrawDuel && player.quickDrawDuelId) {
      // End any active duel
      const duel = quickDrawDuels.get(player.quickDrawDuelId);
      if (duel) {
        // The other player wins by default
        const winnerId = duel.player1Id === playerId ? duel.player2Id : duel.player1Id;
        endQuickDrawDuel(player.quickDrawDuelId, winnerId);
      }
    }
    
    players.delete(playerId);
    
    // Anti-cheat: Clean up associated data
    playerTimeouts.delete(playerId);
    playerNonces.delete(playerId);
    playerSequences.delete(playerId);

    // Notify all that the player left
    broadcastToAll({
      type: 'playerLeft',
      id: playerId
    });

    updatePlayerCount();
  }
}

// Broadcast a "playerCount" update to all
function updatePlayerCount() {
  broadcastToAll({
    type: 'playerCount',
    count: players.size
  });
}

// Broadcast to all except a given playerId
function broadcastToOthers(excludeId, data) {
  for (const [pid, pl] of players.entries()) {
    if (pid === excludeId) continue;
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Broadcast to all players
function broadcastToAll(data) {
  for (const [pid, pl] of players.entries()) {
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

/**
 * Handle a player joining a specific Quick Draw queue.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index to join (0-4)
 */
function handleQuickDrawJoin(playerId, arenaIndex) {
  // Validate arena index
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    console.error(`Invalid arena index: ${arenaIndex}`);
    return;
  }
  
  console.log(`Player ${playerId} joined Quick Draw queue for arena ${arenaIndex + 1}`);
  const playerData = players.get(playerId);
  
  if (!playerData || playerData.inQuickDrawQueue || playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  // Add to the specific queue
  quickDrawQueues[arenaIndex].push(playerId);
  
  // Update player state
  playerData.inQuickDrawQueue = true;
  playerData.quickDrawLobbyIndex = arenaIndex;
  
  // Notify the player and everyone else
  if (playerData.ws.readyState === WebSocket.OPEN) {
    playerData.ws.send(JSON.stringify({
      type: 'joinedQuickDrawQueue',
      arenaIndex: arenaIndex
    }));
  }
  
  // Broadcast to all players
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    quickDrawLobbyIndex: arenaIndex
  });
  
  // Check if we can now start a duel
  checkQuickDrawQueue(arenaIndex);
}

/**
 * Handle a player leaving the Quick Draw queue.
 * @param {number} playerId - The player's ID
 */
function handleQuickDrawLeave(playerId) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawQueue) {
    return; // Invalid state
  }
  
  // Get the arena index
  const arenaIndex = playerData.quickDrawLobbyIndex;
  if (arenaIndex >= 0 && arenaIndex < MAX_ARENAS) {
    console.log(`Player ${playerId} left Quick Draw queue for arena ${arenaIndex + 1}`);
    
    // Remove from appropriate queue
    const index = quickDrawQueues[arenaIndex].indexOf(playerId);
    if (index !== -1) {
      quickDrawQueues[arenaIndex].splice(index, 1);
    }
  }
  
  // Reset player state
  playerData.inQuickDrawQueue = false;
  playerData.quickDrawLobbyIndex = -1;
}

/**
 * Check if we have enough players in a specific Quick Draw queue to start a match.
 * @param {number} arenaIndex - The arena index to check
 */
function checkQuickDrawQueue(arenaIndex) {
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    return; // Invalid arena index
  }
  
  const queue = quickDrawQueues[arenaIndex];
  
  if (queue.length < 2) {
    return; // Not enough players in this queue
  }
  
  // Get the two players who have been waiting the longest
  const player1Id = queue.shift();
  const player2Id = queue.shift();
  
  // Make sure both players are still connected
  const player1 = players.get(player1Id);
  const player2 = players.get(player2Id);
  
  if (!player1 || !player2) {
    // Put the valid player back in the queue
    if (player1) queue.push(player1Id);
    if (player2) queue.push(player2Id);
    return;
  }
  
  // Create a new duel
  const duelId = `duel_${arenaIndex}_${player1Id}_${player2Id}`;
  quickDrawDuels.set(duelId, {
    id: duelId,
    arenaIndex: arenaIndex,
    player1Id,
    player2Id,
    state: 'starting',
    startTime: Date.now()
  });
  
  // Mark players as in a duel
  player1.inQuickDrawQueue = false;
  player1.inQuickDrawDuel = true;
  player1.quickDrawDuelId = duelId;
  
  player2.inQuickDrawQueue = false;
  player2.inQuickDrawDuel = true;
  player2.quickDrawDuelId = duelId;
  
  // Reset player health to full at the start of the duel
  player1.health = 100;
  player2.health = 100;
  
  // Notify players of the match
  player1.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player2Id,
    position: 'left', // Player 1 spawns on the left
    arenaIndex: arenaIndex
  }));
  
  player2.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player1Id,
    position: 'right', // Player 2 spawns on the right
    arenaIndex: arenaIndex
  }));
  
  console.log(`Started Quick Draw duel ${duelId} between players ${player1Id} and ${player2Id} in arena ${arenaIndex + 1}`);
}

/**
 * Handle a player being ready in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index for the duel
 */
function handleQuickDrawReady(playerId, arenaIndex) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  const duelId = playerData.quickDrawDuelId;
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  // Verify arena index matches
  if (arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
    console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
    return;
  }
  
  // Mark this player as ready
  if (duel.player1Id === playerId) {
    duel.player1Ready = true;
  } else if (duel.player2Id === playerId) {
    duel.player2Ready = true;
  }
  
  // If both players are ready, start the duel sequence
  if (duel.player1Ready && duel.player2Ready) {
    startQuickDrawDuel(duelId);
  }
}

/**
 * Start the Quick Draw duel sequence.
 * @param {string} duelId - The duel ID
 */
function startQuickDrawDuel(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'ready';
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Show "READY?" message to both players
  player1.ws.send(JSON.stringify({ type: 'quickDrawReady' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawReady' }));
  
  // After 1 second, start the countdown
  setTimeout(() => {
    if (quickDrawDuels.has(duelId)) {
      duel.state = 'countdown';
      player1.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
      player2.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
      
      // Set a random time for the draw signal (1-8 seconds)
      const drawTime = 1000 + Math.floor(Math.random() * 7000);
      duel.drawTimeout = setTimeout(() => {
        if (quickDrawDuels.has(duelId)) {
          sendDrawSignal(duelId);
        }
      }, drawTime);
    }
  }, 1000);
}

/**
 * Send the "DRAW!" signal to both players.
 * @param {string} duelId - The duel ID
 */
function sendDrawSignal(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'draw';
  duel.drawTime = Date.now();
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Send draw signal to both players
  player1.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  
  console.log(`Draw signal sent for duel ${duelId} in arena ${duel.arenaIndex + 1}`);
}

/**
 * Handle a player shooting in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} targetId - The target player's ID
 * @param {number} arenaIndex - The arena index for the duel (optional for direct duels)
 * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
 * @param {number} damage - The damage amount
 */
function handleQuickDrawShoot(playerId, targetId, arenaIndex, hitZone = 'body', damage = 40) {
    playerId = Number(playerId);
    targetId = Number(targetId);
    
    console.log(`Quick Draw shoot: Player ${playerId} shot player ${targetId} (${hitZone}, ${damage} damage)`);
    
    const playerData = players.get(playerId);
    
    if (!playerData || !playerData.inQuickDrawDuel) {
        console.log(`Quick Draw shoot rejected: Player ${playerId} not in a duel`);
        return; // Invalid state
    }
    
    const duelId = playerData.quickDrawDuelId;
    const duel = quickDrawDuels.get(duelId);
    
    if (!duel) {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not found`);
        return; // Invalid duel
    }
    
    // For direct duels, no arena index check is needed
    if (!duel.isDirect && arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
        console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
        return;
    }
    
    // Verify that the target is the opponent in this duel
    if ((duel.player1Id === playerId && duel.player2Id !== targetId) ||
        (duel.player2Id === playerId && duel.player1Id !== targetId)) {
        console.log(`Quick Draw shoot rejected: Target ${targetId} is not the opponent in duel ${duelId}`);
        return;
    }
    
    // Verify the duel is in the 'draw' state
    if (duel.state !== 'draw') {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not in 'draw' state (${duel.state})`);
        return;
    }
    
    // Calculate reaction time
    const reactionTime = Date.now() - duel.drawTime;
    
    // Calculate damage based on hit zone
    let finalDamage = damage;
    if (hitZone === 'head') {
        finalDamage = 100; // One-shot kill for headshots
    } else if (hitZone === 'limbs') {
        finalDamage = Math.round(damage * 0.6); // Reduced damage for limb shots
    }
    
    // Apply damage to target
    const targetPlayer = players.get(targetId);
    if (!targetPlayer) {
        return;
    }
    
    targetPlayer.health = Math.max(0, targetPlayer.health - finalDamage);
    
    // Send health update to both players
    if (targetPlayer.ws && targetPlayer.ws.readyState === WebSocket.OPEN) {
        targetPlayer.ws.send(JSON.stringify({
            type: 'playerHealthUpdate',
            playerId: targetId,
            health: targetPlayer.health,
            damage: finalDamage,
            hitBy: playerId
        }));
    }
    
    if (playerData.ws && playerData.ws.readyState === WebSocket.OPEN) {
        playerData.ws.send(JSON.stringify({
            type: 'playerHealthUpdate',
            playerId: targetId, 
            health: targetPlayer.health,
            damage: finalDamage,
            hitBy: playerId
        }));
    }
    
    console.log(`Player ${targetId} hit for ${finalDamage} damage, health now ${targetPlayer.health}`);
    
    // Check if target is dead (0 health)
    if (targetPlayer.health <= 0) {
        // End the duel with shooter as winner
        endQuickDrawDuel(duelId, playerId);
    }
}

/**
 * End a Quick Draw duel and notify players of the result.
 * @param {string} duelId - The duel ID
 * @param {number} winnerId - The winner's player ID (if any)
 */
function endQuickDrawDuel(duelId, winnerId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  console.log(`Ending Quick Draw duel ${duelId} with winner: ${winnerId || 'none'}`);
  
  // Clear any pending timeouts
  if (duel.drawTimeout) {
    clearTimeout(duel.drawTimeout);
  }
  
  // Get the players
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  // Update player states
  if (player1) {
    player1.inQuickDrawDuel = false;
    player1.quickDrawDuelId = null;
    
    // Notify player 1 of the result and restore position
    player1.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId,
      returnPosition: player1.preQuickDrawPosition
    }));
    
    // If player 1 lost, set their health to 0
    if (winnerId && winnerId !== duel.player1Id) {
      player1.health = 0;
    }
  }
  
  if (player2) {
    player2.inQuickDrawDuel = false;
    player2.quickDrawDuelId = null;
    
    // Notify player 2 of the result and restore position
    player2.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId,
      returnPosition: player2.preQuickDrawPosition
    }));
    
    // If player 2 lost, set their health to 0
    if (winnerId && winnerId !== duel.player2Id) {
      player2.health = 0;
    }
  }
  
  // Remove the duel
  quickDrawDuels.delete(duelId);
}

/**
 * Handle a player challenging another player to a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} targetPlayerId - The target player's ID
 */
function handleQuickDrawChallenge(playerId, targetPlayerId) {
  const player = players.get(playerId);
  const targetPlayer = players.get(targetPlayerId);
  
  if (!player || !targetPlayer) {
    return; // Invalid players
  }
  
  if (player.inQuickDrawQueue || player.inQuickDrawDuel) {
    return; // Challenger can't be in another game mode
  }
  
  if (targetPlayer.inQuickDrawQueue || targetPlayer.inQuickDrawDuel) {
    return; // Target can't be in another game mode
  }
  
  console.log(`Player ${playerId} challenged player ${targetPlayerId} to a Quick Draw duel`);
  
  // Send challenge to target player
  targetPlayer.ws.send(JSON.stringify({
    type: 'quickDrawChallengeReceived',
    challengerId: playerId,
    challengerPosition: player.position
  }));
}

/**
 * Generate random positions on the main street for a Quick Draw duel.
 * This ensures players spawn in the open street and not inside buildings.
 * @returns {Object} An object containing two positions and their facing rotations
 */
function generateQuickDrawStreetPositions() {
  // Define the street strip boundaries (narrow middle strip of town)
  const streetMinX = -8;   // Much narrower X bounds (middle strip only)
  const streetMaxX = 8;
  const streetMinZ = -30;  // Keep Z bounds the same
  const streetMaxZ = 30;
  const yPosition = 1.0;   // Standard ground level
  
  // Generate a random position within the street bounds
  const midX = streetMinX + Math.random() * (streetMaxX - streetMinX);
  const midZ = streetMinZ + Math.random() * (streetMaxZ - streetMinZ);
  
  // Generate a random normalized direction vector
  const angle = Math.random() * Math.PI * 2;
  const dirX = Math.cos(angle);
  const dirZ = Math.sin(angle);
  
  // Create two positions 10 meters apart along this direction
  const position1 = {
    x: midX - dirX * 5, // 5 meters in one direction from midpoint
    y: yPosition,
    z: midZ - dirZ * 5
  };
  
  const position2 = {
    x: midX + dirX * 5, // 5 meters in the opposite direction
    y: yPosition,
    z: midZ + dirZ * 5
  };
  
  // Calculate the vector from player1 to player2
  const dx = position2.x - position1.x;
  const dz = position2.z - position1.z;
  
  // Calculate angle from positive Z axis (which is the "forward" direction in THREE.js)
  // Add Math.PI (180 degrees) to make players FACE each other instead of facing away
  const rotation1 = Math.atan2(dx, dz) + Math.PI;
  
  // For player2, we need to calculate the angle from the positive Z axis to the vector pointing to player1
  // This is the opposite direction, so we use negative dx and dz, plus 180 degrees correction
  const rotation2 = Math.atan2(-dx, -dz) + Math.PI;
  
  // Log explicit debug information with degree conversion
  console.log(`[DEBUG] Duel positions:`);
  console.log(`  Player1: (${position1.x.toFixed(2)}, ${position1.z.toFixed(2)}) facing ${rotation1.toFixed(4)} radians (${(rotation1 * 180 / Math.PI).toFixed(1)}°)`);
  console.log(`  Player2: (${position2.x.toFixed(2)}, ${position2.z.toFixed(2)}) facing ${rotation2.toFixed(4)} radians (${(rotation2 * 180 / Math.PI).toFixed(1)}°)`);
  console.log(`  Direction vector: (${dx.toFixed(2)}, ${dz.toFixed(2)}), length: ${Math.sqrt(dx*dx + dz*dz).toFixed(2)}`);
  
  // Debug visualization - create boundary boxes visible to clients
  const boxWidth = streetMaxX - streetMinX;
  const boxLength = streetMaxZ - streetMinZ;
  
  // Send debug visualization data to all players for temporary rendering
  broadcastToAll({
    type: 'debugBoxVisualization',
    box: {
      x: (streetMinX + streetMaxX) / 2, // center X
      y: yPosition,                     // ground level
      z: (streetMinZ + streetMaxZ) / 2, // center Z
      width: boxWidth,
      height: 0.1,                      // thin box
      length: boxLength
    },
    color: 0xFF0000,  // red color
    duration: 30000   // 30 seconds display time
  });
  
  return {
    position1: position1,
    position2: position2,
    rotation1: rotation1,
    rotation2: rotation2
  };
}

/**
 * Handle a player accepting a Quick Draw challenge
 * @param {number} playerId - The accepting player's ID
 * @param {number} challengerId - The challenging player's ID
 */
function handleQuickDrawAcceptChallenge(playerId, challengerId) {
  const player = players.get(playerId);
  const challenger = players.get(challengerId);
  
  if (!player || !challenger) {
    return; // Invalid players
  }
  
  if (player.inQuickDrawQueue || player.inQuickDrawDuel ||
      challenger.inQuickDrawQueue || challenger.inQuickDrawDuel) {
    return; // Players can't be in another game mode
  }
  
  console.log(`Player ${playerId} accepted a Quick Draw challenge from player ${challengerId}`);
  
  // Notify challenger that the challenge was accepted
  challenger.ws.send(JSON.stringify({
    type: 'quickDrawChallengeAccepted',
    targetId: playerId
  }));
  
  // Generate controlled street positions for the duel
  const spawnPositions = generateQuickDrawStreetPositions();
  
  // Create a new duel
  const duelId = `duel_direct_${challengerId}_${playerId}`;
  quickDrawDuels.set(duelId, {
    id: duelId,
    player1Id: challengerId,
    player2Id: playerId,
    state: 'starting',
    startTime: Date.now(),
    isDirect: true
  });
  
  // Mark players as in a duel
  challenger.inQuickDrawQueue = false;
  challenger.inQuickDrawDuel = true;
  challenger.quickDrawDuelId = duelId;
  
  player.inQuickDrawQueue = false;
  player.inQuickDrawDuel = true;
  player.quickDrawDuelId = duelId;
  
  // Reset player health to full at the start of the duel
  challenger.health = 100;
  player.health = 100;
  
  // Store original positions to return players after the duel
  challenger.preQuickDrawPosition = { ...challenger.position };
  player.preQuickDrawPosition = { ...player.position };
  
  // Notify players of the match
  challenger.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: playerId,
    isDirect: true,
    startPosition: spawnPositions.position1,
    startRotation: spawnPositions.rotation1,
    movementLocked: true
  }));
  
  player.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: challengerId,
    isDirect: true,
    startPosition: spawnPositions.position2,
    startRotation: spawnPositions.rotation2,
    movementLocked: true
  }));
  
  console.log(`Started direct Quick Draw duel ${duelId} between players ${challengerId} and ${playerId}`);
}

/**
 * Handle a player declining a Quick Draw challenge
 * @param {number} playerId - The declining player's ID
 * @param {number} challengerId - The challenging player's ID
 */
function handleQuickDrawDeclineChallenge(playerId, challengerId) {
  const player = players.get(playerId);
  const challenger = players.get(challengerId);
  
  if (!player || !challenger) {
    return; // Invalid players
  }
  
  console.log(`Player ${playerId} declined a Quick Draw challenge from player ${challengerId}`);
  
  // Notify challenger that the challenge was declined
  challenger.ws.send(JSON.stringify({
    type: 'quickDrawChallengeDeclined',
    targetId: playerId
  }));
}

// Anti-cheat: Server-side bullet physics update
function updateBullets() {
  const now = Date.now();
  
  // Update each active bullet
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) continue;
    
    // Calculate time since last update
    const deltaTime = (now - bullet.timeCreated) / 1000;
    
    // Calculate new position
    const distanceThisFrame = bullet.speed * deltaTime;
    bullet.position.x += bullet.direction.x * distanceThisFrame;
    bullet.position.y += bullet.direction.y * distanceThisFrame;
    bullet.position.z += bullet.direction.z * distanceThisFrame;
    
    // Update total distance traveled
    bullet.distanceTraveled += distanceThisFrame;
    
    // Check if bullet has traveled too far
    if (bullet.distanceTraveled >= bullet.maxDistance) {
      bullet.active = false;
      continue;
    }
  }
  
  // Clean up inactive bullets
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) {
      activeBullets.delete(bulletId);
    }
  }
}

// Heartbeat to remove stale connections
const HEARTBEAT_INTERVAL = 30000; // 30s
const CONNECTION_TIMEOUT = 60000; // 60s

setInterval(() => {
  const now = Date.now();
  for (const [id, player] of players.entries()) {
    if (now - player.lastActivity > CONNECTION_TIMEOUT) {
      console.log(`Removing stale connection for player ${id}`);
      if (player.ws.readyState === WebSocket.OPEN) {
        player.ws.close(1000, 'Connection timeout');
      }
      cleanupPlayer(id);
    } else if (player.ws.readyState === WebSocket.OPEN) {
      // keep alive
      player.ws.send(JSON.stringify({ type: 'ping' }));
    }
  }
}, HEARTBEAT_INTERVAL);

// Anti-cheat: Run physics update loop
setInterval(updateBullets, GAME_CONSTANTS.PHYSICS_UPDATE_INTERVAL);

// Start server
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Server shutting down...');
  
  // End all Quick Draw duels
  for (const duelId of quickDrawDuels.keys()) {
    endQuickDrawDuel(duelId, null);
  }
  
  for (const [id, player] of players.entries()) {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.close(1000, 'Server shutting down');
    }
  }
  server.close(() => {
    console.log('Server shutdown complete.');
    process.exit(0);
  });
});
    </codebase>
</context>

<goal>
 
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── config.yml
    ├── package.json
    ├── public/
    │   ├── css/
    │   │   └── style.css
    │   ├── index.html
    │   ├── js/
    │   │   ├── bullet.js
    │   │   ├── effects.js
    │   │   ├── input.js
    │   │   ├── main.js
    │   │   ├── multiplayerManager.js
    │   │   ├── network.js
    │   │   ├── physics.js
    │   │   ├── player.js
    │   │   ├── playerModel.js
    │   │   ├── properShootout.js
    │   │   ├── quickDraw.js
    │   │   ├── revolver.js
    │   │   ├── scene.js
    │   │   ├── smokeRingEffect.js
    │   │   ├── soundManager.js
    │   │   └── ui.js
    │   ├── models/
    │   │   └── lowpolygun.glb
    │   └── sounds/
    └── server.js

================================================
File: /config.yml
================================================
version: "3"
credentials-file: "C:\\Users\\erase\\.cloudflared\\5615d921-4c2e-4d70-affd-8696de48a673.json"

ingress:
  # This rule forwards all requests from the tunnel hostname to the local Express server.
  - hostname: tunnel.oneclickwaitlist.com
    path: /
    service: http://localhost:8080
    originRequest:
      connectTimeout: 10s
      noTLSVerify: true
      proxyAddress: ""
      proxyPort: 0
      proxyType: ""
      kernelSocketOptions:
        - mark: 0
        - keepalive: true
      wsTunneling: true
      http2Origin: false
      httpHostHeader: "tunnel.oneclickwaitlist.com"
      disableChunkedEncoding: false

  # Fallback rule: returns 503 if no other rule matches.
  - service: http_status:503

origincert: "C:\\Users\\erase\\.cloudflared\\cert.pem"


================================================
File: /package.json
================================================
{
  "name": "wild-western-shooter",
  "version": "1.0.0",
  "description": "A Three.js Wild Western Shooter game with a Node.js server.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.13.0",
    "ngrok": "^4.3.3",
    "cannon": "^0.6.2"
  }
}

================================================
File: /public/css/style.css
================================================
body {
  margin: 0;
  overflow: hidden;
  font-family: 'Courier New', Courier, monospace;
}
#game-container {
  position: relative;
  width: 100vw;
  height: 100vh;
}
#ammo-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
}
#reload-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  display: none;
}
#reload-progress-container {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-progress-bar {
  height: 100%;
  width: 0%;
  background-color: #FF6B00;
  border-radius: 10px;
  transition: width 0.05s linear;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border: 2px solid white;
  border-radius: 50%;
  display: none; /* Always keep it hidden to make the game more realistic */
}
#crosshair::before,
#crosshair::after {
  content: '';
  position: absolute;
  background-color: white;
}
#crosshair::before {
  width: 2px;
  height: 10px;
  top: 5px;
  left: 9px;
}
#crosshair::after {
  width: 10px;
  height: 2px;
  top: 9px;
  left: 5px;
}
#fps-counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#player-count {
  position: absolute;
  top: 50px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#connection-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#network-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
  transition: opacity 1s;
}

/* Quick Draw game mode styles */
#quick-draw-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 48px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  z-index: 1000;
}

#draw-circle {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 300px;
  height: 300px;
  border-radius: 50%;
  border: 8px solid #FF0000;
  box-shadow: 0 0 20px #FF0000;
  opacity: 0;
  transition: transform 0.3s, opacity 0.3s;
  pointer-events: none;
  z-index: 999;
  display: none;
}

@keyframes portalPulse {
  0% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1); opacity: 0.8; }
}

@keyframes drawCircleAnim {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
  80% { transform: translate(-50%, -50%) scale(3); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(4); opacity: 0; }
}

.portal-animation {
  animation: portalPulse 2s infinite ease-in-out;
}

.draw-circle-animation {
  animation: drawCircleAnim 0.3s ease-out forwards;
}

/* Styling for Quick Draw countdown */
#quick-draw-countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 72px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.7);
  z-index: 1001;
}

/* Styling for winner/loser message */
.quick-draw-winner {
  color: #4CAF50 !important;
  text-shadow: 0 0 10px #4CAF50, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

.quick-draw-loser {
  color: #F44336 !important;
  text-shadow: 0 0 10px #F44336, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

/* Styling for gun locked warning */
.gun-locked-warning {
  color: #F44336 !important;
  font-size: 36px !important;
  animation: flashWarning 0.5s infinite alternate;
}

@keyframes flashWarning {
  0% { opacity: 0.7; }
  100% { opacity: 1; }
}

#quick-draw-status {
  position: absolute;
  top: 120px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 8px 12px;
  border-radius: 5px;
  transition: background-color 0.3s ease;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#portal-instructions {
  position: absolute;
  background-color: rgba(0,0,0,0.8);
  border: 2px solid #FF6B00;
  border-radius: 8px;
  padding: 15px;
  width: 400px;
  text-align: center;
  box-shadow: 0 0 15px rgba(255, 107, 0, 0.6);
  color: #EEEEEE;
  font-family: 'Courier New', Courier, monospace;
  z-index: 100;
  transition: opacity 0.3s ease;
}

#portal-instructions h2 {
  color: #FF6B00;
  font-family: 'Western', 'Courier New', Courier, monospace;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
  margin-bottom: 10px;
  font-size: 22px;
}

#portal-instructions p {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.4;
}

#portal-instructions ul {
  text-align: left;
  margin-top: 10px;
  padding-left: 20px;
  font-size: 14px;
  line-height: 1.5;
}

#portal-instructions li {
  margin-bottom: 5px;
  list-style-type: square;
}

/* Lobby display for showing which arena the player is in */
#lobby-indicator {
  position: absolute;
  top: 150px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(255, 107, 0, 0.7);
  padding: 8px 12px;
  border-radius: 5px;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  display: none;
}

/* Fix font loading */
@font-face {
  font-family: 'Western';
  src: local('Georgia'), local('Times New Roman');
  font-weight: bold;
  font-style: normal;
}

/* Health counter styling */
#health-counter {
  position: absolute;
  bottom: 50px;
  right: 20px;
  color: #4CAF50;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  transition: color 0.3s ease;
}

/* Damage indicator (added dynamically) */
#damage-indicator {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: red;
  font-size: 48px;
  font-weight: bold;
  opacity: 0;
  text-shadow: 2px 2px 4px #000000;
  transition: opacity 0.3s ease-in, opacity 0.5s ease-out;
  z-index: 1000;
  pointer-events: none;
}

/* Different damage types */
.damage-headshot {
  color: #FF0000 !important;
  font-size: 64px !important;
}

.damage-body {
  color: #FF4500 !important;
}

.damage-limb {
  color: #FFA500 !important;
}

/* Health bar (alternative to text) */
#health-bar-container {
  position: absolute;
  bottom: 85px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
}

#health-bar {
  height: 100%;
  width: 100%;
  background-color: #4CAF50;
  border-radius: 10px;
  transition: width 0.3s ease, background-color 0.3s ease;
}

/* Hit marker */
.hit-marker {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(45deg);
  pointer-events: none;
}

.hit-marker::before,
.hit-marker::after {
  content: '';
  position: absolute;
  background-color: white;
}

.hit-marker::before {
  width: 2px;
  height: 16px;
  left: 7px;
  top: 0;
}

.hit-marker::after {
  width: 16px;
  height: 2px;
  left: 0;
  top: 7px;
}

/* Headshot marker */
.hit-marker-headshot::before,
.hit-marker-headshot::after {
  background-color: red;
}

================================================
File: /public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wild Western FPS – Multiplayer</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div id="game-container">
    <div id="ammo-counter">Bullets: 6/6</div>
    <div id="health-counter">Health: 100</div>
    <div id="reload-message">Hold R to reload</div>
    <div id="reload-progress-container">
      <div id="reload-progress-bar"></div>
    </div>
    <div id="crosshair"></div>
    <div id="fps-counter">FPS: 0</div>
    <div id="player-count">Players: 1</div>
    <div id="connection-status"></div>
  </div>

  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader for loading the GLB gun model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Cannon.js for physics (non-ES module version) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <!-- Main JS as ES6 module -->
  <script type="module" src="js/main.js"></script>
</body>
</html>

================================================
File: /public/js/bullet.js
================================================
import { createImpactEffect } from './effects.js';

/**
 * A bullet class with client-side prediction and server validation.
 * It lets the server have final authority on collisions and hits.
 */
export class Bullet {
  /**
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Normalized direction vector
   * @param {string|number} bulletId - Optional server-assigned bullet ID (for remote bullets)
   */
  constructor(position, direction, bulletId = null) {
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xB8860B })
    );
    this.mesh.position.copy(position);

    this.direction = direction.clone();
    this.speed = 80; // speed units/second
    this.distanceTraveled = 0;
    this.maxDistance = 100;
    this.timeCreated = performance.now();

    // Remember previous position for continuous detection
    this.lastPosition = position.clone();

    // Track which player fired this bullet
    this.sourcePlayerId = null;
    
    // Anti-cheat: Server-assigned bulletId
    this.bulletId = bulletId;
    
    // Anti-cheat: Track whether this bullet is local (created by local player)
    this.isLocalBullet = true;
    
    // Add collision detection raycaster
    this.raycaster = new THREE.Raycaster(position.clone(), direction.clone(), 0, 0.1);
  }

  /**
   * Sets the player ID that fired this bullet.
   * @param {string|number} playerId - The ID of the player who fired the bullet.
   */
  setSourcePlayer(playerId) {
    this.sourcePlayerId = playerId;
    
    // Anti-cheat: Determine if this is a local bullet
    if (window.localPlayer) {
      this.isLocalBullet = Number(playerId) === Number(window.localPlayer.id);
    }
  }

  /**
   * Updates the bullet's movement & handles collisions with NPC or players.
   * Uses client-side prediction with server authority.
   * @param {number} deltaTime
   * @param {THREE.Group} npc
   * @param {THREE.Scene} scene
   * @param {Map<number, object>} allPlayers - Map of local + remote players.
   * @returns {Object} - Result of the update containing active state and hit info.
   */
  update(deltaTime, npc, scene, allPlayers) {
    // Previous position for boundary crossing detection
    this.lastPosition = this.mesh.position.clone();
    
    // FIRST CHECK: Before moving, check if bullet is already within arena but from an unauthorized player
    if (window.quickDraw && window.quickDraw.isPointInArena(this.mesh.position)) {
      const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
      const isPlayerInDuel = window.quickDraw && window.quickDraw.inDuel;
      const isOpponentBullet = window.quickDraw && 
                               window.quickDraw.duelOpponentId === Number(this.sourcePlayerId);
      
      // If bullet is inside arena but not from a duel player, destroy it immediately
      if (!(isPlayerInDuel && isLocalPlayerBullet) && !isOpponentBullet) {
        console.log("Destroying unauthorized bullet inside arena from player " + this.sourcePlayerId);
        createImpactEffect(this.mesh.position, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'arena', position: this.mesh.position } };
      }
    }
    
    // Similar check for Proper Shootout - only allow bullets from players in the same shootout match
    if (window.properShootout && window.properShootout.inLobby && window.properShootout.isPointInMap(this.mesh.position)) {
      const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
      const isPlayerInShootout = window.properShootout && window.properShootout.inLobby;
      
      // If bullet is inside shootout map but player is not in shootout, destroy it
      if (!isPlayerInShootout && isLocalPlayerBullet) {
        console.log("Destroying unauthorized bullet inside shootout map from player " + this.sourcePlayerId);
        createImpactEffect(this.mesh.position, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'boundary', position: this.mesh.position } };
      }
    }
    
    // Move the bullet
    const displacement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
    this.mesh.position.add(displacement);
    this.distanceTraveled += displacement.length();

    // Current bullet position
    const endPos = this.mesh.position.clone();
    
    // Check if crossing Quick Draw arena boundary using the physics system
    if (window.quickDraw && window.quickDraw.physics) {
      const physics = window.quickDraw.physics;
      
      // Check if bullet is crossing the arena boundary
      const bulletInArena = window.quickDraw.isPointInArena(endPos);
      const prevInArena = window.quickDraw.isPointInArena(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInArena !== prevInArena;
      
      // If the bullet is crossing the boundary
      if (bulletCrossingBoundary) {
        const playerInDuel = window.quickDraw.inDuel;
        const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
        
        // Case 1: Player in duel and their bullet trying to exit
        if (playerInDuel && isLocalPlayerBullet && !bulletInArena) {
          console.log("Bullet hit arena boundary (exiting) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 2: Player outside trying to shoot in
        if (!playerInDuel && isLocalPlayerBullet && bulletInArena) {
          console.log("Bullet from outside entering arena - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 3: Bullet from duel player hitting boundary from inside
        if (playerInDuel && !isLocalPlayerBullet && !bulletInArena) {
          console.log("Bullet from other duel player hitting boundary (exiting) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 4: Bullet from outside player hitting boundary from outside
        if (!playerInDuel && !isLocalPlayerBullet && bulletInArena) {
          console.log("Bullet from outside player hitting boundary (entering) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
      }
    }

    // Check for Proper Shootout map boundary
    if (window.properShootout && window.properShootout.inLobby) {
      const bulletInMap = window.properShootout.isPointInMap(endPos);
      const prevInMap = window.properShootout.isPointInMap(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInMap !== prevInMap;
      
      // If the bullet is crossing the boundary from inside to outside, destroy it
      if (bulletCrossingBoundary && !bulletInMap) {
        console.log("Bullet hit Proper Shootout map boundary - destroying it");
        createImpactEffect(endPos, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'boundary', position: endPos } };
      }
    }
    // Only check town boundary if not in Proper Shootout
    else if (window.physics && typeof window.physics.isPointInTown === 'function') {
      const bulletInTown = window.physics.isPointInTown(endPos);
      const prevInTown = window.physics.isPointInTown(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInTown !== prevInTown;
      
      // If the bullet is crossing the boundary, destroy it
      if (bulletCrossingBoundary) {
        console.log("Bullet hit town boundary - destroying it");
        createImpactEffect(endPos, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'boundary', position: endPos } };
      }
    } else if (window.townDimensions) {
      // Fallback if physics isn't available but town dimensions are
      const width = window.townDimensions.width;
      const length = window.townDimensions.length;
      
      // Check if bullet is outside town boundary
      if (
        endPos.x < -width / 2 || 
        endPos.x > width / 2 || 
        endPos.z < -length / 2 || 
        endPos.z > length / 2
      ) {
        console.log("Bullet hit town boundary - destroying it");
        createImpactEffect(endPos, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'boundary', position: endPos } };
      }
    }

    // Anti-cheat: For local bullets, collision detection is only client-side prediction
    // For remote bullets, we rely on client-side collision for visual effects
    
    // 1) Check collision with NPC
    if (npc) {
      const npcBox = new THREE.Box3().setFromObject(npc);
      npcBox.expandByScalar(0.2);
      if (npcBox.containsPoint(endPos)) {
        createImpactEffect(endPos, this.direction, scene, 'npc');
        return { active: false, hit: { type: 'npc', target: npc } };
      }
    }

    // 2) Check collision with players
    if (allPlayers) {
      for (const [playerId, playerObj] of allPlayers.entries()) {
        // Skip bullet's owner by converting both IDs to numbers
        if (Number(playerId) === Number(this.sourcePlayerId)) continue;
        if (!playerObj || !playerObj.group) continue;

        // Prevent hits across arena boundary or between different game modes
        // Only allow hits if players are in compatible states:
        // 1. Both in the same QuickDraw duel
        // 2. Both in the same Proper Shootout match
        // 3. Both in the regular town area (not in any game mode)
        
        const sourcePlayerId = Number(this.sourcePlayerId);
        const targetPlayerId = Number(playerId);
        
        // Check if source and target are in QuickDraw duel
        const bulletPlayerInDuel = window.quickDraw && window.quickDraw.inDuel;
        const targetPlayerInDuel = window.quickDraw && 
                                   window.quickDraw.duelOpponentId === targetPlayerId;
        
        // Check if source and target are in Proper Shootout
        const bulletPlayerInShootout = window.properShootout && window.properShootout.inLobby;
        const targetPlayerInShootout = window.properShootout && 
                                      window.localPlayer && 
                                      window.localPlayer.id !== targetPlayerId; // Any non-local player in shootout mode
        
        // Make sure players are in the same game mode to allow hits
        const bothInDuel = bulletPlayerInDuel && targetPlayerInDuel;
        const bothInShootout = bulletPlayerInShootout && targetPlayerInShootout;
        const bothInRegularTown = !bulletPlayerInDuel && !bulletPlayerInShootout && 
                                 !targetPlayerInDuel && !targetPlayerInShootout;
        
        if (!(bothInDuel || bothInShootout || bothInRegularTown)) {
          continue; // Skip collision check if players are in different areas/modes
        }
        
        // Detect which hit zone was hit (head, body, limbs)
        const hitResult = this.checkPlayerHitZones(playerObj, endPos);
        
        if (hitResult.hit) {
          // Check that this isn't a hit on the local player's own model
          const isHitOnLocalPlayer = window.localPlayer && 
                                   Number(window.localPlayer.id) === Number(playerId);
          
          if (!isHitOnLocalPlayer) {
            // Create the impact effect
            createImpactEffect(endPos, this.direction, scene, 'player');
            
            // Play headshot sound if it was a headshot
            if (hitResult.zone === 'head' && window.localPlayer && window.localPlayer.soundManager) {
              window.localPlayer.soundManager.playSound("headshotmarker", 100);
            }
          } else {
            console.log("Prevented impact effect on local player's own model");
          }
          
          // Anti-cheat: For local bullets, send hit to server and let server decide
          if (this.isLocalBullet && window.networkManager) {
            window.networkManager.sendPlayerHit(playerId, {
              position: { x: endPos.x, y: endPos.y, z: endPos.z },
              sourcePlayerId: this.sourcePlayerId,
              hitZone: hitResult.zone, // Send the hit zone to the server
              damage: hitResult.damage // Send the damage amount to the server
            }, this.bulletId);
            
            // Quick Draw duels with better logging
            if (window.quickDraw && window.quickDraw.inDuel && 
                window.quickDraw.duelState === 'draw' && 
                Number(playerId) === Number(window.quickDraw.duelOpponentId) && 
                Number(this.sourcePlayerId) === Number(window.localPlayer.id)) {
                
                console.log(`Quick Draw hit detected! Player ${this.sourcePlayerId} hit player ${playerId} in the ${hitResult.zone} for ${hitResult.damage} damage`);
                
                // Send special Quick Draw hit notification with hit zone information
                window.networkManager.sendQuickDrawShoot(
                  playerId, 
                  window.quickDraw.activeArenaIndex,
                  hitResult.zone,
                  hitResult.damage
                );
            }
          }
          
          return { 
            active: false, 
            hit: { 
              type: 'player', 
              playerId, 
              bulletId: this.bulletId,
              zone: hitResult.zone,
              damage: hitResult.damage
            } 
          };
        }
      }
    }

    // 3) Check collision with ground
    if (this.mesh.position.y <= 0.1) {
      createImpactEffect(endPos, this.direction, scene, 'ground');
      return { active: false, hit: { type: 'ground', position: endPos } };
    }

    // 4) If bullet exceeded max distance, remove it.
    if (this.distanceTraveled >= this.maxDistance) {
      return { active: false, hit: null };
    }

    // Still active
    return { active: true, hit: null };
  }
  
  /**
   * Checks which part of the player model was hit and returns damage amount.
   * Implements hit zones for head, body, and limbs.
   * @param {object} playerObj - The player object to check
   * @param {THREE.Vector3} bulletPos - The bullet position
   * @returns {object} - Contains hit (boolean), zone (string), and damage (number)
   */
  checkPlayerHitZones(playerObj, bulletPos) {
    // Get player's base position for collision box
    // For local players (first-person), group.position is at eye-level so subtract 1.6
    // Remote players (third-person) have group.position at the base
    const playerPos = playerObj.group.position.clone();
    let baseY = playerPos.y;
    if (playerObj.camera) { // local player
      baseY = playerPos.y - 1.6;
    }
    
    // Define hit zone dimensions
    const headSize = 0.4; // Head is a smaller target
    const bodyWidth = 0.5;
    const bodyHeight = 0.9;
    const limbWidth = 0.2;
    const limbHeight = 0.6;
    
    // Calculate vertical positions of each zone
    // Using the adjusted values for better alignment
    const headBottom = baseY + 1.8 - headSize;
    const headTop = baseY + 1.8;
    const bodyBottom = baseY + 0.9;
    const bodyTop = baseY + 1.8 - headSize;
    const legBottom = baseY + 0.2;
    const legTop = baseY + 0.8;
    const armBottom = baseY + 0.8;
    const armTop = baseY + 1.4;
    
    // Create debug visualization if physics debug mode is enabled or global debug flag is set
    if ((window.physics && window.physics.debugMode) || window.showHitZoneDebug) {
      if (!playerObj._hitZoneDebug) {
        this.createHitZoneDebugBoxes(playerObj, {
          playerPos, baseY, 
          headSize, bodyWidth, bodyHeight, limbWidth, limbHeight,
          headBottom, headTop, bodyBottom, bodyTop, 
          legBottom, legTop, armBottom, armTop
        });
      }
    }
    
    // First do a quick test with the overall player bounding box
    const overallMin = new THREE.Vector3(
      playerPos.x - bodyWidth,
      baseY + 0.2, // Adjusted to match new bottom height
      playerPos.z - bodyWidth
    );
    const overallMax = new THREE.Vector3(
      playerPos.x + bodyWidth,
      baseY + 1.8, // Adjusted to match new top height
      playerPos.z + bodyWidth
    );
    const overallBox = new THREE.Box3(overallMin, overallMax);
    
    if (!overallBox.containsPoint(bulletPos)) {
      return { hit: false, zone: null, damage: 0 };
    }
    
    // Check head zone (highest damage)
    const headMin = new THREE.Vector3(
      playerPos.x - headSize/2,
      headBottom,
      playerPos.z - headSize/2
    );
    const headMax = new THREE.Vector3(
      playerPos.x + headSize/2,
      headTop,
      playerPos.z + headSize/2
    );
    const headBox = new THREE.Box3(headMin, headMax);
    
    if (headBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'head', damage: 100 };
    }
    
    // Check body zone (medium damage)
    const bodyMin = new THREE.Vector3(
      playerPos.x - bodyWidth/2,
      bodyBottom,
      playerPos.z - bodyWidth/2
    );
    const bodyMax = new THREE.Vector3(
      playerPos.x + bodyWidth/2,
      bodyTop,
      playerPos.z + bodyWidth/2
    );
    const bodyBox = new THREE.Box3(bodyMin, bodyMax);
    
    if (bodyBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'body', damage: 40 };
    }
    
    // Check arms (low damage, simplified to two boxes on sides)
    // Left arm
    const leftArmMin = new THREE.Vector3(
      playerPos.x - bodyWidth/2 - limbWidth,
      armBottom,
      playerPos.z - limbWidth/2
    );
    const leftArmMax = new THREE.Vector3(
      playerPos.x - bodyWidth/2,
      armTop,
      playerPos.z + limbWidth/2
    );
    const leftArmBox = new THREE.Box3(leftArmMin, leftArmMax);
    
    // Right arm
    const rightArmMin = new THREE.Vector3(
      playerPos.x + bodyWidth/2,
      armBottom,
      playerPos.z - limbWidth/2
    );
    const rightArmMax = new THREE.Vector3(
      playerPos.x + bodyWidth/2 + limbWidth,
      armTop,
      playerPos.z + limbWidth/2
    );
    const rightArmBox = new THREE.Box3(rightArmMin, rightArmMax);
    
    if (leftArmBox.containsPoint(bulletPos) || rightArmBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'limbs', damage: 20 };
    }
    
    // Check legs (low damage)
    // Left leg
    const leftLegMin = new THREE.Vector3(
      playerPos.x - bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    const leftLegMax = new THREE.Vector3(
      playerPos.x - bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    const leftLegBox = new THREE.Box3(leftLegMin, leftLegMax);
    
    // Right leg
    const rightLegMin = new THREE.Vector3(
      playerPos.x + bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    const rightLegMax = new THREE.Vector3(
      playerPos.x + bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    const rightLegBox = new THREE.Box3(rightLegMin, rightLegMax);
    
    if (leftLegBox.containsPoint(bulletPos) || rightLegBox.containsPoint(bulletPos)) {
      return { hit: true, zone: 'limbs', damage: 20 };
    }
    
    // If we reach here but hit the overall box, it's a glancing hit to the body
    return { hit: true, zone: 'body', damage: 40 };
  }
  
  /**
   * Creates visible debug boxes for hit zones when physics debug mode is enabled
   * @param {object} playerObj - The player object
   * @param {object} dims - Dimensions and positions for the hit zones
   */
  createHitZoneDebugBoxes(playerObj, dims) {
    // Only used in debug mode
    if (!window.scene) return;
    
    // Remove any existing debug boxes for this player
    if (playerObj._hitZoneDebug) {
      window.scene.remove(playerObj._hitZoneDebug);
      playerObj._hitZoneDebug.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    
    // Create a new group for hitbox visualization
    const hitZoneGroup = new THREE.Group();
    hitZoneGroup.name = "hitZoneDebug_" + playerObj.id;
    
    // Create helper function to make box helpers
    const createBoxHelper = (min, max, color) => {
      // Use BoxGeometry instead of Box3Helper for more reliable visual feedback
      const sizeX = max.x - min.x;
      const sizeY = max.y - min.y;
      const sizeZ = max.z - min.z;
      
      const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      // Position at the center of the box
      mesh.position.set(
        min.x + sizeX/2,
        min.y + sizeY/2,
        min.z + sizeZ/2
      );
      
      hitZoneGroup.add(mesh);
      return mesh;
    };
    
    // Calculate all zones relative to player position
    // Note: these are local to the player, not world positions
    
    // Head zone - red
    const headMin = new THREE.Vector3(
      -dims.headSize/2,
      dims.headBottom - dims.baseY,
      -dims.headSize/2
    );
    const headMax = new THREE.Vector3(
      dims.headSize/2,
      dims.headTop - dims.baseY,
      dims.headSize/2
    );
    const headHelper = createBoxHelper(headMin, headMax, 0xff0000);
    
    // Body zone - orange
    const bodyMin = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.bodyBottom - dims.baseY,
      -dims.bodyWidth/2
    );
    const bodyMax = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.bodyTop - dims.baseY,
      dims.bodyWidth/2
    );
    const bodyHelper = createBoxHelper(bodyMin, bodyMax, 0xff7700);
    
    // Left arm - yellow
    const leftArmMin = new THREE.Vector3(
      -dims.bodyWidth/2 - dims.limbWidth,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftArmMax = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftArmHelper = createBoxHelper(leftArmMin, leftArmMax, 0xffff00);
    
    // Right arm - green
    const rightArmMin = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightArmMax = new THREE.Vector3(
      dims.bodyWidth/2 + dims.limbWidth,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightArmHelper = createBoxHelper(rightArmMin, rightArmMax, 0x00ff00);
    
    // Left leg - blue
    const leftLegMin = new THREE.Vector3(
      -dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftLegMax = new THREE.Vector3(
      -dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftLegHelper = createBoxHelper(leftLegMin, leftLegMax, 0x0000ff);
    
    // Right leg - purple
    const rightLegMin = new THREE.Vector3(
      dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightLegMax = new THREE.Vector3(
      dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightLegHelper = createBoxHelper(rightLegMin, rightLegMax, 0x800080);
    
    // Add the hitzone group to the scene
    window.scene.add(hitZoneGroup);
    
    // Store reference to debug visualization group
    playerObj._hitZoneDebug = hitZoneGroup;
    
    // Update hitbox position immediately
    this.updateHitZoneDebugPosition(playerObj);

    // Add an update function to the player object
    if (!playerObj._updateHitZoneDebug) {
      const self = this;
      playerObj._updateHitZoneDebug = function() {
        if (this._hitZoneDebug) {
          self.updateHitZoneDebugPosition(this);
        }
      };
      
      // Modify the player's update function to include hitbox updates
      if (playerObj.update && typeof playerObj.update === 'function') {
        const originalUpdate = playerObj.update;
        playerObj.update = function(deltaTime) {
          // Call original update
          originalUpdate.call(this, deltaTime);
          // Update hit zone debug
          if (this._updateHitZoneDebug) {
            this._updateHitZoneDebug();
          }
        };
      }
    }
  }
  
  /**
   * Updates the position of a player's hit zone debug visualization
   * @param {object} playerObj - The player object
   */
  updateHitZoneDebugPosition(playerObj) {
    if (!playerObj || !playerObj._hitZoneDebug || !playerObj.group) return;
    
    const hitZoneDebug = playerObj._hitZoneDebug;
    const playerPos = playerObj.group.position.clone();
    
    // Adjust height based on whether this is a local (first-person) or remote player
    let baseY = playerPos.y;
    if (playerObj.camera) {
      // Local player's group position is at eye level, so subtract 1.6
      baseY = playerPos.y - 1.6;
    }
    
    // Position the debug group at the player's position
    hitZoneDebug.position.set(playerPos.x, baseY, playerPos.z);
    
    // Apply the player's rotation
    if (playerObj.group.rotation) {
      hitZoneDebug.rotation.y = playerObj.group.rotation.y;
    }
  }
  
  /**
   * Directly handles a server-reported impact for this bullet.
   * @param {string} hitType - Type of impact: 'player', 'npc', 'ground', 'boundary', 'arena'
   * @param {string|number|null} targetId - ID of hit target (for player hits)
   * @param {THREE.Vector3} position - Impact position
   * @param {THREE.Scene} scene - Scene to add effects to
   * @returns {Object} - Result object with active=false
   */
  handleServerImpact(hitType, targetId, position, scene) {
    // Create visual effect based on hit type
    if (position) {
      createImpactEffect(position, this.direction, scene, hitType);
      
      // Play headshot sound if the server reports it was a headshot
      if (hitType === 'player' && window.localPlayer && window.localPlayer.soundManager) {
        // If hitZone data is available and it's a headshot
        if (this.lastHitZone === 'head') {
          window.localPlayer.soundManager.playSound("headshotmarker", 100);
        }
      }
    } else {
      // If no position provided, use current bullet position
      createImpactEffect(this.mesh.position, this.direction, scene, hitType);
    }
    
    // Always deactivate the bullet
    return { active: false, hit: { type: hitType, targetId, position } };
  }
  
  /**
   * Sets the last hit zone information for this bullet (for server validation)
   * @param {string} zone - The hit zone ('head', 'body', 'limbs')
   */
  setLastHitZone(zone) {
    this.lastHitZone = zone;
  }
}

================================================
File: /public/js/effects.js
================================================
// Import the SmokeRingEffect class 
import { SmokeRingEffect } from './smokeRingEffect.js';

/**
 * Recursively disposes geometry and material for the given object.
 * @param {THREE.Object3D} object - The object to dispose.
 */
function disposeHierarchy(object) {
  object.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

/**
 * Helper for spring interpolation used in recoil recovery.
 * @param {number} start - The starting value.
 * @param {number} end - The target value.
 * @param {number} t - Normalized time.
 * @param {number} damping - Damping coefficient.
 * @param {number} frequency - Oscillation frequency.
 * @returns {number} - The interpolated value.
 */
function springInterpolation(start, end, t, damping, frequency) {
  const decay = Math.exp(-damping * t);
  return end + (start - end) * decay * (1 + (damping / frequency) * Math.sin(frequency * t));
}

/**
 * Creates a muzzle flash effect at the given position.
 * @param {THREE.Vector3} position - Effect position.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createMuzzleFlash(position, scene) {
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(position);
  scene.add(flashGroup);

  const coreGeometry = new THREE.SphereGeometry(0.05, 8, 8);
  const coreMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 1
  });
  const core = new THREE.Mesh(coreGeometry, coreMaterial);
  flashGroup.add(core);

  const middleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
  const middleMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFF00,
    transparent: true,
    opacity: 0.8
  });
  const middle = new THREE.Mesh(middleGeometry, middleMaterial);
  middle.scale.x = 1.5;
  flashGroup.add(middle);

  const outerGeometry = new THREE.SphereGeometry(0.12, 8, 8);
  const outerMaterial = new THREE.MeshBasicMaterial({
    color: 0xFF6B00,
    transparent: true,
    opacity: 0.5
  });
  const outer = new THREE.Mesh(outerGeometry, outerMaterial);
  outer.scale.x = 2;
  flashGroup.add(outer);

  const particleCount = 8;
  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFF00,
      transparent: true,
      opacity: 0.7
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    const angle = Math.random() * Math.PI * 2;
    const radius = 0.05 + Math.random() * 0.1;
    particle.position.set(
      Math.cos(angle) * radius,
      Math.sin(angle) * radius,
      (Math.random() - 0.5) * 0.1
    );
    flashGroup.add(particle);
  }

  const flashLight = new THREE.PointLight(0xFF9900, 1, 2);
  flashLight.position.set(0, 0, 0);
  flashGroup.add(flashLight);

  const duration = 100;
  const startTime = performance.now();

  function animateFlash(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      core.scale.multiplyScalar(0.95);
      const fadeOpacity = 1 - progress;
      coreMaterial.opacity = fadeOpacity;
      middleMaterial.opacity = fadeOpacity * 0.8;
      outerMaterial.opacity = fadeOpacity * 0.5;
      flashLight.intensity = 1 - progress;
      requestAnimationFrame(animateFlash);
    } else {
      scene.remove(flashGroup);
      disposeHierarchy(flashGroup);
    }
  }
  requestAnimationFrame(animateFlash);
}

/**
 * Creates a smoke effect emanating from a given position.
 * @param {THREE.Vector3} position - Start position.
 * @param {THREE.Vector3} direction - Direction of smoke.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createSmokeEffect(position, direction, scene) {
  const particleCount = 30;
  const particles = [];
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(position);
  scene.add(smokeGroup);

  const smokeColors = [
    new THREE.Color(0.9, 0.9, 0.9),
    new THREE.Color(0.8, 0.8, 0.8),
    new THREE.Color(0.7, 0.7, 0.7),
    new THREE.Color(0.6, 0.6, 0.6)
  ];

  for (let i = 0; i < particleCount; i++) {
    const size = 0.01 + Math.random() * 0.03;
    const smokeGeometry = new THREE.SphereGeometry(size, 6, 6);
    const colorIndex = Math.floor(Math.random() * smokeColors.length);
    const smokeColor = smokeColors[colorIndex];
    const smokeMaterial = new THREE.MeshBasicMaterial({
      color: smokeColor,
      transparent: true,
      opacity: 0.3 + Math.random() * 0.4
    });
    const smokeParticle = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smokeParticle.position.set(
      (Math.random() - 0.5) * 0.05,
      (Math.random() - 0.5) * 0.05,
      (Math.random() - 0.5) * 0.05
    );
    let particleDir = direction.clone();
    particleDir.x += (Math.random() - 0.5) * 0.6;
    particleDir.y += (Math.random() - 0.5) * 0.2 + 0.2;
    particleDir.z += (Math.random() - 0.5) * 0.6;
    particleDir.normalize();
    const speed = 0.02 + Math.random() * 0.08;
    const velocity = particleDir.multiplyScalar(speed);
    const rotationSpeed = {
      x: (Math.random() - 0.5) * 0.02,
      y: (Math.random() - 0.5) * 0.02,
      z: (Math.random() - 0.5) * 0.02
    };
    smokeGroup.add(smokeParticle);
    particles.push({
      mesh: smokeParticle,
      velocity: velocity,
      rotationSpeed: rotationSpeed,
      life: 40 + Math.floor(Math.random() * 60),
      maxLife: 40 + Math.floor(Math.random() * 60),
      size: size,
      growth: 0.005 + Math.random() * 0.01
    });
  }

  const interval = setInterval(() => {
    let allDead = true;
    particles.forEach(p => {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.velocity.multiplyScalar(0.98);
        p.velocity.x += (Math.random() - 0.5) * 0.001;
        p.velocity.z += (Math.random() - 0.5) * 0.001;
        p.velocity.y += 0.0008;
        p.mesh.rotation.x += p.rotationSpeed.x;
        p.mesh.rotation.y += p.rotationSpeed.y;
        p.mesh.rotation.z += p.rotationSpeed.z;
        const scale = p.size + (p.growth * (p.maxLife - p.life));
        p.mesh.scale.set(scale, scale, scale);
        const lifeRatio = p.life / p.maxLife;
        p.mesh.material.opacity = lifeRatio * 0.5;
        p.life--;
        allDead = false;
      } else {
        smokeGroup.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      }
    });
    if (allDead) {
      clearInterval(interval);
      scene.remove(smokeGroup);
    }
  }, 16);
}

/**
 * Creates a shockwave ring effect in the shooting direction.
 * @param {THREE.Vector3} position - Effect start position.
 * @param {THREE.Vector3} direction - Firing direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createShockwaveRing(position, direction, scene) {
  const shockwaveGroup = new THREE.Group();
  shockwaveGroup.position.copy(position);
  shockwaveGroup.lookAt(position.clone().add(direction));
  scene.add(shockwaveGroup);

  const distortionGeometry = new THREE.CircleGeometry(0.08, 32);
  const distortionMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 0.2,
    blending: THREE.AdditiveBlending
  });
  const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
  shockwaveGroup.add(distortion);

  const lineCount = 18;
  const speedLines = [];
  const speedLineColors = [0xFFFFFF, 0xFFFF00, 0xFF9900, 0xFF6600];

  for (let i = 0; i < lineCount; i++) {
    const lineLength = 0.2 + Math.random() * 0.6;
    const lineWidth = 0.003 + Math.random() * 0.005;
    const lineGeometry = new THREE.BoxGeometry(lineWidth, lineWidth, lineLength);
    lineGeometry.translate(0, 0, lineLength / 2);
    const colorIndex = Math.floor(Math.random() * speedLineColors.length);
    const lineColor = speedLineColors[colorIndex];
    const lineMaterial = new THREE.MeshBasicMaterial({
      color: lineColor,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending
    });
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    const spreadAngle = 15 * (Math.PI / 180);
    line.rotation.x = (Math.random() - 0.5) * spreadAngle;
    line.rotation.y = (Math.random() - 0.5) * spreadAngle;
    line.scale.z = 0.1;
    shockwaveGroup.add(line);
    speedLines.push({
      mesh: line,
      material: lineMaterial,
      maxLength: 1 + Math.random() * 2,
      speed: 0.8 + Math.random() * 0.4,
      delay: Math.random() * 50
    });
  }

  const particleCount = 12;
  const particles = [];

  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFF00,
      transparent: true,
      opacity: 0.6
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    const angle = Math.random() * Math.PI * 0.25;
    const radius = 0.02 + Math.random() * 0.06;
    particle.position.z = Math.cos(angle) * radius;
    const circleAngle = Math.random() * Math.PI * 2;
    particle.position.x = Math.sin(angle) * Math.cos(circleAngle) * radius;
    particle.position.y = Math.sin(angle) * Math.sin(circleAngle) * radius;
    const velocity = new THREE.Vector3(
      particle.position.x * (0.5 + Math.random() * 0.5),
      particle.position.y * (0.5 + Math.random() * 0.5),
      0.05 + Math.random() * 0.1
    );
    shockwaveGroup.add(particle);
    particles.push({
      mesh: particle,
      velocity: velocity,
      life: 10 + Math.floor(Math.random() * 15)
    });
  }

  const flashLight = new THREE.PointLight(0xFF9900, 1, 2);
  flashLight.position.set(0, 0, 0);
  shockwaveGroup.add(flashLight);

  const duration = 350;
  const startTime = performance.now();

  function animateShockwave(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      speedLines.forEach(line => {
        if (elapsed > line.delay) {
          const lineProgress = Math.min((elapsed - line.delay) / (duration - line.delay), 1);
          if (lineProgress < 0.5) {
            const scaleProgress = lineProgress * 2;
            line.mesh.scale.z = line.maxLength * scaleProgress;
          } else {
            line.material.opacity = 0.7 * (1 - ((lineProgress - 0.5) * 2));
          }
        }
      });
      const distortionScale = 1 + progress * 5;
      distortion.scale.set(distortionScale, distortionScale, 1);
      distortionMaterial.opacity = 0.2 * (1 - progress);

      particles.forEach(p => {
        if (p.life > 0) {
          p.mesh.position.add(p.velocity);
          p.mesh.material.opacity = (p.life / 25) * 0.6;
          p.life--;
        } else {
          shockwaveGroup.remove(p.mesh);
        }
      });

      flashLight.intensity = 1 - progress;
      requestAnimationFrame(animateShockwave);
    } else {
      scene.remove(shockwaveGroup);
      disposeHierarchy(shockwaveGroup);
    }
  }
  requestAnimationFrame(animateShockwave);
}

/**
 * Creates an impact effect when a bullet hits a target.
 * Instead of a red disk, this new effect emits particles in the opposite direction
 * of the bullet's travel. When the bullet hits a body (player or NPC), the particles
 * are red (blood). When it hits the ground/solid, the particles are brown (splatter).
 *
 * The particle velocities have been reduced so that they stay near the impact point.
 *
 * Additionally, this function now plays an impact sound:
 * - If hitType is 'ground', "woodimpact.mp3" is played.
 * - If hitType is 'player', "fleshimpact.mp3" is played at the impact position.
 *
 * @param {THREE.Vector3} position - Impact position.
 * @param {THREE.Vector3} direction - Impact (bullet) direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 * @param {string} hitType - Type of impact: 'player', 'npc', or 'ground'.
 */
export function createImpactEffect(position, direction, scene, hitType) {
  const effectGroup = new THREE.Group();
  effectGroup.position.copy(position);
  scene.add(effectGroup);
  
  // Play impact sound based on hit type using positional audio
  if (window.localPlayer && window.localPlayer.soundManager) {
    if (hitType === 'ground') {
      window.localPlayer.soundManager.playSoundAt("woodimpact", position);
    } else if (hitType === 'player') {
      // Calculate distance to local player to avoid playing impact on own body
      const localPlayerPos = window.localPlayer.group.position;
      const distToLocalPlayer = Math.sqrt(
        Math.pow(position.x - localPlayerPos.x, 2) + 
        Math.pow(position.z - localPlayerPos.z, 2)
      );
      
      // Only play flesh impact if not too close to local player (prevents self-impacts)
      if (distToLocalPlayer > 0.5) {
        window.localPlayer.soundManager.playSoundAt("fleshimpact", position);
      }
    }
  }

  // Choose color: red for body impacts, brown for ground.
  const color = (hitType === 'ground') ? 0x8B4513 : 0xFF0000;

  const particleCount = 15;
  const particles = [];
  for (let i = 0; i < particleCount; i++) {
    const size = 0.03 * (0.8 + Math.random() * 0.4);
    const particleGeometry = new THREE.SphereGeometry(size, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 1
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    effectGroup.add(particle);
    // Use a reduced speed so particles stay close to the impact spot.
    const velocity = direction.clone().negate();
    const speed = 0.05 + Math.random() * 0.05;
    velocity.multiplyScalar(speed);
    velocity.x += (Math.random() - 0.5) * 0.05;
    velocity.y += (Math.random() - 0.5) * 0.05;
    velocity.z += (Math.random() - 0.5) * 0.05;
    particles.push({ mesh: particle, velocity: velocity, life: 30 + Math.floor(Math.random() * 20) });
  }

  const duration = 500; // in ms
  const startTime = performance.now();

  function animateEffect() {
    const elapsed = performance.now() - startTime;
    const t = elapsed / duration;
    for (const p of particles) {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.mesh.material.opacity = Math.max(1 - t, 0);
        if (hitType === 'ground') {
          p.velocity.y -= 0.005; // gravity effect on ground splatter
        }
        p.life--;
      }
    }
    if (elapsed < duration) {
      requestAnimationFrame(animateEffect);
    } else {
      scene.remove(effectGroup);
      effectGroup.traverse(child => {
        if (child.isMesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
  }
  requestAnimationFrame(animateEffect);
}

/**
 * Applies a realistic recoil effect.
 * @param {Player} player - The player instance.
 */
export function applyRecoil(player) {
  const originalAimOffset = player.aimOffset.clone();
  const originalFOV = player.camera.fov;
  const originalCameraPos = player.camera.position.clone();
  const originalRotation = player.camera.rotation.clone();

  // Initial recoil changes.
  player.camera.rotation.x -= 0.08;
  player.camera.rotation.z += 0.01;
  player.aimOffset.z += 0.4;
  player.aimOffset.y += 0.15;
  player.aimOffset.x += 0.05;
  player.camera.fov -= 5;
  player.camera.updateProjectionMatrix();

  const recoilSteps = [
    { time: 20, cameraX: -0.04, cameraZ: 0.005, offsetZ: 0.2, offsetY: 0.08, offsetX: 0.03 },
    { time: 40, cameraX: -0.06, cameraZ: 0.008, offsetZ: 0.3, offsetY: 0.12, offsetX: 0.04 },
    { time: 60, cameraX: -0.03, cameraZ: 0.006, offsetZ: 0.25, offsetY: 0.1, offsetX: 0.02 },
    { time: 80, cameraX: -0.02, cameraZ: 0.004, offsetZ: 0.18, offsetY: 0.07, offsetX: 0.01 },
    { time: 100, cameraX: -0.01, cameraZ: 0.002, offsetZ: 0.1, offsetY: 0.05, offsetX: 0.005 }
  ];

  recoilSteps.forEach(step => {
    setTimeout(() => {
      player.camera.rotation.x = originalRotation.x + step.cameraX;
      player.camera.rotation.z = originalRotation.z + step.cameraZ;
      player.aimOffset.z = originalAimOffset.z + step.offsetZ;
      player.aimOffset.y = originalAimOffset.y + step.offsetY;
      player.aimOffset.x = originalAimOffset.x + step.offsetX;
    }, step.time);
  });

  let shakeIntensity = 0.03;
  const shakeDecay = 0.9;
  const shakeInterval = setInterval(() => {
    if (shakeIntensity > 0.002) {
      player.camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
      player.camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity *= shakeDecay;
    } else {
      clearInterval(shakeInterval);
      player.camera.position.copy(originalCameraPos);
    }
  }, 16);

  let progress = 0;
  const duration = 400;
  const startTime = performance.now();

  function recoverFromRecoil(timestamp) {
    progress = (timestamp - startTime) / duration;
    if (progress < 1) {
      const t = progress * 4;
      player.camera.rotation.x = springInterpolation(
        player.camera.rotation.x,
        originalRotation.x,
        t,
        0.4,
        8
      );
      player.camera.rotation.z = springInterpolation(
        player.camera.rotation.z,
        originalRotation.z,
        t,
        0.4,
        8
      );
      player.aimOffset.x = springInterpolation(
        player.aimOffset.x,
        originalAimOffset.x,
        t,
        0.4,
        8
      );
      player.aimOffset.y = springInterpolation(
        player.aimOffset.y,
        originalAimOffset.y,
        t,
        0.4,
        8
      );
      player.aimOffset.z = springInterpolation(
        player.aimOffset.z,
        originalAimOffset.z,
        t,
        0.4,
        8
      );
      player.camera.fov = THREE.MathUtils.lerp(
        player.camera.fov,
        originalFOV,
        progress * 0.3
      );
      player.camera.updateProjectionMatrix();
      requestAnimationFrame(recoverFromRecoil);
    } else {
      player.camera.rotation.copy(originalRotation);
      player.aimOffset.copy(originalAimOffset);
      player.camera.fov = originalFOV;
      player.camera.updateProjectionMatrix();
      player.camera.position.copy(originalCameraPos);
    }
  }
  requestAnimationFrame(recoverFromRecoil);
}

/**
 * Enhanced shell ejection with realistic physics.
 * @param {Player} player - The player instance.
 * @param {THREE.Scene} scene - The scene to add the shell.
 * @param {SoundManager} soundManager - For playing sound effects.
 */
export function ejectShell(player, scene, soundManager) {
  const shellGroup = new THREE.Group();

  const shellGeometry = new THREE.CylinderGeometry(0.01, 0.015, 0.04, 8);
  const shellMaterial = new THREE.MeshStandardMaterial({
    color: 0xD4AF37,
    metalness: 0.8,
    roughness: 0.2
  });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shellGroup.add(shell);

  const primerGeometry = new THREE.CircleGeometry(0.006, 8);
  const primerMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0A0A0,
    metalness: 0.7,
    roughness: 0.3
  });
  const primer = new THREE.Mesh(primerGeometry, primerMaterial);
  primer.position.y = -0.02;
  primer.rotation.x = Math.PI / 2;
  shellGroup.add(primer);

  const shellStart = player.revolver.getBarrelTipWorldPosition();
  shellGroup.position.copy(shellStart);
  shellGroup.position.x += 0.05;
  shellGroup.position.y -= 0.02;
  scene.add(shellGroup);

  const physics = {
    velocity: new THREE.Vector3(
      0.8 + Math.random() * 0.4,
      0.5 + Math.random() * 0.3,
      (Math.random() - 0.5) * 0.2
    ),
    rotationSpeed: new THREE.Vector3(
      Math.random() * 0.2,
      Math.random() * 0.2,
      Math.random() * 0.2
    ),
    gravity: 0.015,
    drag: 0.99
  };

  const duration = 2000;
  const startTime = performance.now();

  function animateShell(timestamp) {
    const elapsed = timestamp - startTime;
    if (elapsed < duration) {
      shellGroup.position.x += physics.velocity.x * 0.016;
      shellGroup.position.y += physics.velocity.y * 0.016;
      shellGroup.position.z += physics.velocity.z * 0.016;
      physics.velocity.y -= physics.gravity;
      physics.velocity.multiplyScalar(physics.drag);
      shellGroup.rotation.x += physics.rotationSpeed.x;
      shellGroup.rotation.y += physics.rotationSpeed.y;
      shellGroup.rotation.z += physics.rotationSpeed.z;

      // Bounce logic on ground impact.
      if (shellGroup.position.y < 0.02 && physics.velocity.y < 0) {
        physics.velocity.y = -physics.velocity.y * 0.6;
        physics.velocity.x *= 0.8;
        physics.velocity.z *= 0.8;
        shellGroup.position.y = 0.02;
        physics.rotationSpeed.x = Math.random() * 0.4;
        physics.rotationSpeed.z = Math.random() * 0.4;
      }
      requestAnimationFrame(animateShell);
    } else {
      scene.remove(shellGroup);
      shellGeometry.dispose();
      shellMaterial.dispose();
      primerGeometry.dispose();
      primerMaterial.dispose();
    }
  }
  requestAnimationFrame(animateShell);
}

// Export the SmokeRingEffect class
export { SmokeRingEffect };

================================================
File: /public/js/input.js
================================================
/**
 * Initializes game input (keyboard + mouse) and pointer lock.
 * @param {THREE.WebGLRenderer} renderer - The renderer instance.
 * @param {Player} player - The local Player instance (first-person).
 * @param {SoundManager} soundManager - The SoundManager for audio feedback.
 */
export function initInput(renderer, player, soundManager) {
  // Request pointer lock on click
  document.body.addEventListener('click', () => {
    if (document.pointerLockElement !== renderer.domElement) {
      renderer.domElement.requestPointerLock();
    }
  });

  // Mouse look
  document.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === renderer.domElement) {
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;

      // Slightly lower sensitivity when aiming
      const sensitivity = player.isAiming ? 0.001 : 0.002;

      // Yaw
      player.group.rotation.y -= movementX * sensitivity;

      // Pitch (limit to avoid flipping)
      player.camera.rotation.x -= movementY * sensitivity;
      player.camera.rotation.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, player.camera.rotation.x)
      );
    }
  });

  // Keyboard down
  document.addEventListener('keydown', (event) => {
    switch (event.code) {
      case 'KeyW':
        player.moveForward = true;
        break;
      case 'KeyS':
        player.moveBackward = true;
        break;
      case 'KeyA':
        player.moveLeft = true;
        break;
      case 'KeyD':
        player.moveRight = true;
        break;
      case 'Space':
        if (player.canJump) {
          // If sprinting, jump higher
          player.velocity.y = player.isSprinting ? 15 : 10;
          player.canJump = false;
        }
        break;
      case 'KeyR':
        // Start reload
        player.startReload();
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Enable sprinting
        player.isSprinting = true;
        break;
      default:
        break;
    }
  });

  // Keyboard up
  document.addEventListener('keyup', (event) => {
    switch (event.code) {
      case 'KeyW':
        player.moveForward = false;
        break;
      case 'KeyS':
        player.moveBackward = false;
        break;
      case 'KeyA':
        player.moveLeft = false;
        break;
      case 'KeyD':
        player.moveRight = false;
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Disable sprinting
        player.isSprinting = false;
        break;
      default:
        break;
    }
  });

  // Mouse down
  document.addEventListener('mousedown', (event) => {
    // Right-click => Aim (only if canAim is true)
    if (event.button === 2 && player.canAim) {
      player.isAiming = true;
      player.revolver.group.visible = true;
      // Optionally show arms in first-person
      if (player.arms) {
        player.arms.setVisible(true);
      }
      // Removed crosshair display - making the game more realistic

      if (soundManager) {
        soundManager.playSound("aimclick");
      }
    }
    // Left-click => Shoot (only if aiming)
    else if (event.button === 0) {
      if (player.revolver.group.visible && !player.isReloading) {
        player.shoot();
      }
    }
  });

  // Mouse up
  document.addEventListener('mouseup', (event) => {
    // Stop aiming on right-click release
    if (event.button === 2) {
      player.isAiming = false;
      player.revolver.group.visible = false;
      if (player.arms) {
        player.arms.setVisible(false);
      }
      // Removed crosshair display code
    }
  });

  // Prevent context menu on right-click
  document.addEventListener('contextmenu', (event) => {
    event.preventDefault();
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    player.camera.aspect = window.innerWidth / window.innerHeight;
    player.camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

================================================
File: /public/js/main.js
================================================
import { initScene, createNPC, updateNPC, updateFPS, scene } from './scene.js';
import { initInput } from './input.js';
import { SoundManager } from './soundManager.js';
import { Player } from './player.js';
import { networkManager } from './network.js';
import { MultiplayerManager } from './multiplayerManager.js';
import { Bullet } from './bullet.js';
import { createMuzzleFlash, createSmokeEffect, createShockwaveRing, createImpactEffect, SmokeRingEffect } from './effects.js';
import { QuickDraw } from './quickDraw.js';
import { ProperShootout } from './properShootout.js'; // Import the new Proper Shootout class
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { PhysicsSystem } from './physics.js';

// Keep track of all bullets in the game, both local and remote
let bullets = [];

// Anti-cheat: Map bullets by ID for server authority
let bulletMap = new Map(); // bulletId -> Bullet object

// We'll keep references to local player, remote players, and a combined map
let localPlayer;
let remotePlayers = new Map();  // (playerId => ThirdPersonModel)
let playersMap = new Map();     // Master map including local + remote

// Scenes, camera, etc.
let renderer, camera, npc;
let multiplayerManager;
let quickDraw;
let properShootout; // Add properShootout reference
let physics;
let lastTime = 0;

// Smoke ring effects
let smokeRings = [];
let maxSmokeRings = 10; // Limit to prevent performance issues

// Add a flag to track debug visualization mode
window.showHitZoneDebug = false;

function init() {
  try {
    const sceneSetup = initScene();
    camera = sceneSetup.camera;
    renderer = sceneSetup.renderer;

    const soundManager = new SoundManager();
    // Load shot sounds
    soundManager.loadSound("shot2", "sounds/shot2.mp3");
    soundManager.loadSound("shot3", "sounds/shot3.mp3");
    soundManager.loadSound("shot5", "sounds/shot5.mp3");
    soundManager.loadSound("aimclick", "sounds/aimclick.mp3");
    soundManager.loadSound("shellejection", "sounds/shellejection.mp3");
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    // Load the bell start sound for Quick Draw start signal
    soundManager.loadSound("bellstart", "sounds/bellstart.mp3");
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    soundManager.loadSound("fleshimpact", "sounds/fleshimpact.mp3");
    
    // Load footstep and jump sounds
    soundManager.loadSound("leftstep", "sounds/leftstep.mp3");
    soundManager.loadSound("rightstep", "sounds/rightstep.mp3");
    soundManager.loadSound("jump", "sounds/jump.mp3");
    
    // Load headshot marker sound
    soundManager.loadSound("headshotmarker", "sounds/headshotmarker.mp3");
    
    // Initialize physics system
    physics = new PhysicsSystem();
    window.physics = physics; // Make physics globally accessible

    // Create town boundary if dimensions are available
    if (window.townDimensions) {
      physics.createTownBoundary(
        window.townDimensions.width,
        window.townDimensions.length,
        5 // Height of the barrier
      );
    }
    
    // Initialize a smoke ring effect pool for reuse
    for (let i = 0; i < 3; i++) {
      const smokeRing = new SmokeRingEffect(scene);
      smokeRing.active = false;
      smokeRings.push(smokeRing);
    }
    
    // Initialize multiplayer manager
    multiplayerManager = new MultiplayerManager(scene, soundManager, remotePlayers);

    // Initialize the local player
    localPlayer = new Player({
      scene,
      camera,
      soundManager,
      onShoot: handleLocalPlayerShoot  // callback for local shooting
    });
    // Make localPlayer globally accessible for hit updates.
    window.localPlayer = localPlayer;

    // Create an NPC target
    npc = createNPC(scene);

    // Initialize input
    initInput(renderer, localPlayer, soundManager);
    
    // Make scene globally accessible for physics visualization
    window.scene = scene;

    // Initialize Quick Draw game mode after the local player is created
    quickDraw = new QuickDraw(scene, localPlayer, networkManager, soundManager);
    
    // Initialize Proper Shootout game mode
    properShootout = new ProperShootout(scene, localPlayer, networkManager, soundManager);
    
    // Share the main physics system with game modes
    quickDraw.physics = physics;
    properShootout.physics = physics;
    
    // Make properShootout globally accessible
    window.properShootout = properShootout;
    
    // Debug toggle for physics visualization (press P)
    window.addEventListener('keydown', (event) => {
      if (event.code === 'KeyP') {
        if (physics) {
          const isDebugMode = !physics.debugMode;
          physics.setDebugMode(isDebugMode);
          console.log(`Physics debug mode: ${isDebugMode ? 'ENABLED' : 'DISABLED'}`);
          
          // Set the global debug flag
          window.showHitZoneDebug = isDebugMode;
          
          // If turning on debug mode, update hit zone debug for all existing players
          if (isDebugMode) {
            // Create debug boxes for remote players and local player with a delay
            // (to allow for physics debug state to be fully set)
            setTimeout(() => {
              // First trigger hit zone debugging on the local player
              if (localPlayer) {
                const dummyBullet = new Bullet(
                  new THREE.Vector3(0, 0, 0),
                  new THREE.Vector3(0, 1, 0)
                );
                dummyBullet.checkPlayerHitZones(localPlayer, new THREE.Vector3(0, 0, 0));
              }
              
              // Then create debug boxes for all remote players
              for (const [playerId, remotePlayer] of remotePlayers.entries()) {
                // Force a collision check to create debug boxes
                const dummyBullet = new Bullet(
                  new THREE.Vector3(0, 0, 0),
                  new THREE.Vector3(0, 1, 0)
                );
                dummyBullet.checkPlayerHitZones(remotePlayer, new THREE.Vector3(0, 0, 0));
              }
              
              console.log("Hit zone debug boxes created for all players");
            }, 50);
          }
        }
      }
    });
    
    // Make updateHealthUI globally accessible for the Quick Draw mode to use
    window.updateHealthUI = updateHealthUI;

    // Show connection status
    const networkStatus = document.createElement('div');
    networkStatus.id = 'network-status';
    networkStatus.textContent = 'Connecting...';
    document.getElementById('game-container').appendChild(networkStatus);

    // Update player count UI when server broadcasts the count.
    networkManager.onPlayerCount = (count) => {
      const playerCountEl = document.getElementById('player-count');
      if (playerCountEl) {
        playerCountEl.textContent = `Players: ${count}`;
      }
    };

    // Listen for network open/close
    networkManager.socket.addEventListener('open', () => {
      networkStatus.textContent = 'Connected';
      networkStatus.style.backgroundColor = 'rgba(0,128,0,0.5)';
      setTimeout(() => { networkStatus.style.opacity = '0'; }, 2000);
    });
    networkManager.socket.addEventListener('close', () => {
      networkStatus.textContent = 'Disconnected';
      networkStatus.style.backgroundColor = 'rgba(255,0,0,0.5)';
      networkStatus.style.opacity = '1';
    });

    // Listen for remote players shooting
    networkManager.onPlayerShoot = (playerId, bulletData, bulletId) => {
      handleRemotePlayerShoot(playerId, bulletData, bulletId);
    };

    // Anti-cheat: Listen for bullet impact notifications from server
    networkManager.onBulletImpact = (bulletId, hitType, targetId, position, hitZone) => {
      handleBulletImpact(bulletId, hitType, targetId, position, hitZone);
    };

    // Anti-cheat: Listen for position corrections from server
    networkManager.onPositionCorrection = (correctedPosition) => {
      if (localPlayer) {
        // Store the server position for reconciliation
        localPlayer.serverPosition = new THREE.Vector3(
          correctedPosition.x,
          correctedPosition.y,
          correctedPosition.z
        );
        localPlayer.isReconciling = true;
      }
    };
    
    // Anti-cheat: Listen for server-initiated respawn
    networkManager.onRespawn = (position, health, bullets) => {
      if (localPlayer) {
        // Set position
        localPlayer.group.position.copy(position);
        localPlayer.previousPosition.copy(position);
        
        // Update health and bullets
        localPlayer.health = health || 100;
        localPlayer.bullets = bullets || localPlayer.maxBullets;
        
        // Reset states
        localPlayer.isReloading = false;
        localPlayer.isAiming = false;
        localPlayer.velocity.y = 0;
        localPlayer.canAim = true;
        
        // Update UI
        updateHealthUI(localPlayer);
        updateAmmoUI(localPlayer);
      }
    };

    // Listen for updates to the remotePlayers map so we can refresh the master map
    multiplayerManager.onRemotePlayersUpdated = () => {
      updatePlayersMap();
      
      // If debug mode is on, make sure new players have hit zone debug boxes
      if (window.showHitZoneDebug && physics && physics.debugMode) {
        setTimeout(() => {
          if (physics.refreshHitZoneDebug && typeof physics.refreshHitZoneDebug === 'function') {
            physics.refreshHitZoneDebug();
          }
        }, 100);
      }
    };

    // Start the animation loop
    animate(0);
    showGameInstructions();
    
  } catch (error) {
    console.error('Initialization failed:', error);
  }
}

/**
 * The main animation loop.
 */
function animate(time) {
  requestAnimationFrame(animate);
  const deltaTime = (time - lastTime) / 1000;
  lastTime = time;

  // Update physics system
  if (physics) {
    physics.update(deltaTime);
  }

  // Update local player
  localPlayer.update(deltaTime);

  // Update NPC using the imported updateNPC function
  updateNPC(npc, deltaTime);

  // Update remote players (animations, movement interpolation, etc.)
  multiplayerManager.update(deltaTime);
  
  // Update Quick Draw game mode
  if (quickDraw) {
    quickDraw.update(deltaTime);
  }
  
  // Update Proper Shootout game mode
  if (properShootout) {
    properShootout.update(deltaTime);
  }

  // Update smoke ring effects
  for (let i = smokeRings.length - 1; i >= 0; i--) {
    // If the smoke ring is inactive after update, we can remove it
    // But keep at least 3 in the pool for reuse
    if (!smokeRings[i].update(deltaTime) && smokeRings.length > 3) {
      smokeRings[i].dispose();
      smokeRings.splice(i, 1);
    }
  }

  // Update bullets (both local & remote)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    const result = bullet.update(deltaTime, npc, scene, playersMap);
    if (!result.active) {
      // If bullet hit something or traveled too far
      if (result.hit && result.hit.type === 'player') {
        console.log(`Bullet hit player ${result.hit.playerId} in the ${result.hit.zone || 'body'} for ${result.hit.damage || 'unknown'} damage`);
        
        // Set the last hit zone for server validation
        if (bullet.bulletId !== null && result.hit.zone) {
          bullet.setLastHitZone(result.hit.zone);
        }
      }
      scene.remove(bullet.mesh);
      bullets.splice(i, 1);
      
      // Anti-cheat: Remove from bullet map if it has an ID
      if (bullet.bulletId !== null) {
        bulletMap.delete(bullet.bulletId);
      }
    }
  }

  // Update FPS display
  updateFPS(renderer, camera, deltaTime);

  // Render
  renderer.render(scene, camera);
}

/**
 * Called whenever the local player fires.
 * Spawns a bullet locally and also notifies the server.
 * @param {THREE.Vector3} bulletStart 
 * @param {THREE.Vector3} shootDir 
 */
function handleLocalPlayerShoot(bulletStart, shootDir) {
  // Spawn bullet in our local game (client-side prediction)
  const bullet = spawnBullet(localPlayer.id, bulletStart, shootDir);

  // Send bullet data over network
  networkManager.sendShoot({
    position: {
      x: bulletStart.x,
      y: bulletStart.y,
      z: bulletStart.z
    },
    direction: {
      x: shootDir.x,
      y: shootDir.y,
      z: shootDir.z
    }
  });
  
  // Add this section to check for Quick Draw hit
  if (quickDraw && quickDraw.inDuel && quickDraw.duelState === 'draw' && quickDraw.duelOpponentId) {
    // We'll handle this in the bullet collision code instead
  }
}

/**
 * Called whenever a remote player fires (based on network data).
 * @param {number} playerId 
 * @param {Object} bulletData 
 * @param {string|number} bulletId - Server-assigned bullet ID
 */
function handleRemotePlayerShoot(playerId, bulletData, bulletId) {
  const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
  const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);

  spawnBullet(playerId, startPos, dir, bulletId);
}

/**
 * Handles a bullet impact notification from the server.
 * @param {string|number} bulletId - The bullet ID
 * @param {string} hitType - Type of impact (player, npc, ground, etc.)
 * @param {string|number|null} targetId - Target ID (for player hits)
 * @param {Object} position - Impact position {x, y, z}
 * @param {string} hitZone - Hit zone (head, body, limbs)
 */
function handleBulletImpact(bulletId, hitType, targetId, position, hitZone) {
  // Convert position to THREE.Vector3 if provided
  let impactPosition = null;
  if (position) {
    impactPosition = new THREE.Vector3(position.x, position.y, position.z);
  }
  
  // Find the bullet in our bullet map
  const bullet = bulletMap.get(bulletId);
  
  if (bullet) {
    // Store hit zone information for potential headshot sound
    if (hitZone) {
      bullet.setLastHitZone(hitZone);
    }
    
    // Create appropriate visual effect and deactivate bullet
    const result = bullet.handleServerImpact(hitType, targetId, impactPosition, scene);
    
    // Find and remove bullet from main array
    const bulletIndex = bullets.findIndex(b => b === bullet);
    if (bulletIndex !== -1) {
      scene.remove(bullet.mesh);
      bullets.splice(bulletIndex, 1);
    }
    
    // Remove from bullet map
    bulletMap.delete(bulletId);
  } else {
    console.log(`Bullet ${bulletId} not found for impact event`);
    
    // If we don't have the bullet object, still create visual effect at impact position
    if (impactPosition) {
      // Create a default direction vector (upward)
      const defaultDir = new THREE.Vector3(0, 1, 0);
      createImpactEffect(impactPosition, defaultDir, scene, hitType);
      
      // Play headshot sound if it was a headshot
      if (hitZone === 'head' && localPlayer && localPlayer.soundManager) {
        localPlayer.soundManager.playSound("headshotmarker", 100);
      }
    }
  }
}

/**
 * Actually spawns a bullet in the world, complete with muzzle flash, etc.
 * @param {string|number} sourcePlayerId 
 * @param {THREE.Vector3} position 
 * @param {THREE.Vector3} direction 
 * @param {string|number} bulletId - Optional server-assigned ID (for remote bullets)
 * @returns {Bullet} The created bullet object
 */
function spawnBullet(sourcePlayerId, position, direction, bulletId = null) {
  const bullet = new Bullet(position, direction, bulletId);
  bullet.setSourcePlayer(sourcePlayerId);
  bullets.push(bullet);
  scene.add(bullet.mesh);
  
  // Anti-cheat: Store bullet in map if it has a bulletId
  if (bulletId !== null) {
    bulletMap.set(bulletId, bullet);
  }

  // Visual effects
  createMuzzleFlash(position, scene);
  createSmokeEffect(position, direction, scene);
  createShockwaveRing(position, direction, scene);
  
  // Add smoke ring effect
  let smokeRing = null;
  
  // Try to reuse an inactive smoke ring first
  for (let i = 0; i < smokeRings.length; i++) {
    if (!smokeRings[i].active) {
      smokeRing = smokeRings[i];
      break;
    }
  }
  
  // If no inactive smoke ring found, create a new one if under the limit
  if (!smokeRing && smokeRings.length < maxSmokeRings) {
    smokeRing = new SmokeRingEffect(scene);
    smokeRings.push(smokeRing);
  }
  
  // Activate the smoke ring
  if (smokeRing) {
    smokeRing.create(position, direction);
  }

  // Sound: randomly choose one of the three shot sounds
  if (localPlayer.soundManager) {
    const shotSounds = ["shot2", "shot3", "shot5"];
    const randomIndex = Math.floor(Math.random() * shotSounds.length);
    const shotSound = shotSounds[randomIndex];
    localPlayer.soundManager.playSound(shotSound);
  }

  return bullet;
}

/**
 * Rebuilds a master map of all remote players.
 * This map is passed to bullet collision checks so bullets can hit any remote player.
 */
function updatePlayersMap() {
  playersMap.clear();
  // Only add remote players so that the local (shooter's) model isn't processed in bullet collisions.
  for (const [pid, remoteModel] of remotePlayers.entries()) {
    playersMap.set(pid, remoteModel);
  }
}


function showGameInstructions() {
  const instructions = document.createElement('div');
  instructions.id = 'instructions';
  instructions.style.position = 'absolute';
  instructions.style.top = '50%';
  instructions.style.left = '50%';
  instructions.style.transform = 'translate(-50%, -50%)';
  instructions.style.color = 'white';
  instructions.style.backgroundColor = 'rgba(0,0,0,0.7)';
  instructions.style.padding = '20px';
  instructions.style.borderRadius = '10px';
  instructions.style.maxWidth = '500px';
  instructions.style.textAlign = 'center';
  instructions.style.zIndex = '1000';
  
  instructions.innerHTML = `
    <h2>Wild Western Shooter - Multiplayer</h2>
    <p>WASD: Move</p>
    <p>Shift: Sprint</p>
    <p>Right-click: Aim</p>
    <p>Left-click (while aiming): Shoot</p>
    <p>R: Reload</p>
    <p>Space: Jump</p>
    <p>P: Toggle physics debug visualization</p>
    <p><strong>Click anywhere to start</strong></p>
    <p><strong>New:</strong> Find the Quick Draw portal near spawn to duel other players!</p>
    <p><strong>New:</strong> Find the Shootout portal to join an all-vs-all match!</p>
    <p><strong>Town Boundary:</strong> You must stay within the town limits and can only access the duel arena through the portal.</p>
    <p><strong>Hit Zones:</strong> Headshots deal 100 damage, body shots 40, and limb shots 20.</p>`;
  
  document.getElementById('game-container').appendChild(instructions);
  
  // Remove instructions on click
  document.addEventListener('click', () => {
    if (instructions.parentNode) {
      instructions.parentNode.removeChild(instructions);
    }
  }, { once: true });
}

// Handle window unload to cleanup game mode resources
window.addEventListener('beforeunload', () => {
  if (quickDraw) {
    quickDraw.cleanup();
  }
  
  if (properShootout) {
    properShootout.cleanup();
  }
  
  if (physics) {
    physics.cleanup();
  }
  
  // Clean up smoke rings
  for (let i = 0; i < smokeRings.length; i++) {
    smokeRings[i].dispose();
  }
  smokeRings = [];
});

// Make Bullet constructor globally available for hit zone debug creation
window.Bullet = Bullet;

init();

================================================
File: /public/js/multiplayerManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';
import { networkManager } from './network.js';
import { updateHealthUI, showDamageIndicator } from './ui.js';

/**
 * Manages all remote players (their models, animations, etc.) but NOT bullets.
 * Bullets are now handled in main.js.
 */
export class MultiplayerManager {
  constructor(scene, soundManager, remotePlayersMap) {
    /**
     * @param remotePlayersMap {Map<number,ThirdPersonModel>}
     * A shared map that main.js also references. We'll update it here.
     */
    this.scene = scene;
    this.soundManager = soundManager;
    
    // This map is passed in from main.js; we mutate it
    this.remotePlayers = remotePlayersMap;

    // Callback that main.js uses to know we changed remotePlayers
    this.onRemotePlayersUpdated = null;

    this.localPlayerId = null;

    // Initialize network handlers
    this.initNetwork();
  }
  
  initNetwork() {
    // When we get the "init" message, set local player ID and add any existing players
    networkManager.onInit = (initData) => {
      this.localPlayerId = initData.id;
      console.log(`Local player initialized with ID: ${this.localPlayerId}`);

      // Add all existing players (these are remote from our POV)
      initData.players.forEach(playerData => {
        this.addPlayer(playerData.id, playerData);
      });
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerJoined = (playerData) => {
      if (playerData.id === this.localPlayerId) return; // skip ourself
      this.addPlayer(playerData.id, playerData);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerLeft = (playerId) => {
      this.removePlayer(playerId);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerUpdate = (playerId, updatedData) => {
      if (playerId === this.localPlayerId) return; // skip ourself
      const playerModel = this.remotePlayers.get(playerId);
      if (playerModel) {
        playerModel.update(updatedData);
      } else {
        // If we don't have this model yet, create it
        this.addPlayer(playerId, updatedData);
      }
    };

    // Anti-cheat: Player got hit (local player) - server validated
    networkManager.onPlayerHit = (sourceId, hitData, newHealth, hitZone) => {
      console.log(`I was hit by player ${sourceId} in the ${hitZone || 'body'}!`);
      this.showHitFeedback();
      
      // Play headshot sound if appropriate
      if (hitZone === 'head' && this.soundManager) {
        this.soundManager.playSound("headshotmarker", 100);
      }
      
      // Reduce local player's health (using value from server)
      if (window.localPlayer) {
        // Calculate damage based on the health difference or hit zone
        let damage = 20; // Default damage
        
        if (newHealth !== undefined) {
          // Calculate damage from previous health
          damage = window.localPlayer.health - newHealth;
          window.localPlayer.health = newHealth;
        } else {
          // Calculate damage based on hit zone if provided
          if (hitZone === 'head') {
            damage = 100;
          } else if (hitZone === 'body') {
            damage = 40;
          } else if (hitZone === 'limbs') {
            damage = 20;
          }
          
          // Apply damage
          window.localPlayer.takeDamage(damage, hitZone);
        }
        
        // Show damage indicator with proper hit zone
        if (typeof window.showDamageIndicator === 'function') {
          window.showDamageIndicator(damage, hitZone);
        }
        
        // Ensure health UI is updated
        if (typeof window.updateHealthUI === 'function') {
          window.updateHealthUI(window.localPlayer);
        }
      }
    };

    // Anti-cheat: Broadcast that some player was hit (server validated)
    networkManager.onPlayerHitBroadcast = (targetId, sourceId, hitPos, newHealth, hitZone) => {
      console.log(`Player ${targetId} was hit by ${sourceId} in the ${hitZone || 'body'}`);
      const tPlayer = this.remotePlayers.get(parseInt(targetId));
      if (tPlayer) {
        tPlayer.showHitFeedback();
        
        // Play headshot sound if appropriate
        if (hitZone === 'head' && this.soundManager) {
          this.soundManager.playSound("headshotmarker", 100);
        }
        
        // Calculate damage based on hit zone
        let damage = 20; // Default damage
        if (hitZone === 'head') {
          damage = 100;
        } else if (hitZone === 'body') {
          damage = 40;
        } else if (hitZone === 'limbs') {
          damage = 20;
        }
        
        // Update health directly from server value if provided
        if (newHealth !== undefined) {
          tPlayer.health = newHealth;
        } else {
          // Apply damage
          if (typeof tPlayer.takeDamage === 'function') {
            tPlayer.takeDamage(damage, hitZone);
          } else {
            // If takeDamage is not defined, manually update health
            tPlayer.health = Math.max((tPlayer.health || 100) - damage, 0);
          }
        }
        
        // Create a hit marker or effect at the hit position if available
        if (hitPos && window.scene) {
          this.createHitMarker(hitPos, hitZone);
        }
      }
    };
  }

  showHitFeedback() {
    // Flash the screen red briefly
    const hitOverlay = document.createElement('div');
    hitOverlay.style.position = 'absolute';
    hitOverlay.style.top = '0';
    hitOverlay.style.left = '0';
    hitOverlay.style.width = '100%';
    hitOverlay.style.height = '100%';
    hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    hitOverlay.style.pointerEvents = 'none';
    hitOverlay.style.transition = 'opacity 0.5s ease-out';
    hitOverlay.style.zIndex = '1000';
    document.body.appendChild(hitOverlay);
    
    setTimeout(() => {
      hitOverlay.style.opacity = '0';
      setTimeout(() => {
        if (hitOverlay.parentNode) {
          hitOverlay.parentNode.removeChild(hitOverlay);
        }
      }, 500);
    }, 100);

    // Optional hit sound
    if (this.soundManager) {
      this.soundManager.playSound("aimclick");
    }
  }

  /**
   * Creates a visual hit marker at the hit position
   * @param {Object} position - The hit position
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   */
  createHitMarker(position, hitZone) {
    // Only create if we have THREE.js and a scene
    if (!window.THREE || !window.scene) return;
    
    // Choose color based on hit zone
    let color = 0xFFFFFF; // Default white
    if (hitZone === 'head') {
      color = 0xFF0000; // Red for headshots
    } else if (hitZone === 'body') {
      color = 0xFF6600; // Orange for body shots
    } else if (hitZone === 'limbs') {
      color = 0xFFFF00; // Yellow for limb shots
    }
    
    // Create a particle system for the hit marker
    const geometry = new THREE.BufferGeometry();
    const vertices = [];
    
    // Create particles in a small sphere
    const particleCount = 10;
    const radius = 0.1;
    
    for (let i = 0; i < particleCount; i++) {
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI;
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      
      vertices.push(x, y, z);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
    
    const material = new THREE.PointsMaterial({
      color: color,
      size: 0.05,
      transparent: true,
      opacity: 1
    });
    
    const particles = new THREE.Points(geometry, material);
    particles.position.copy(position);
    window.scene.add(particles);
    
    // Animate the particles
    const startTime = performance.now();
    const duration = 500; // ms
    
    function animateParticles() {
      const elapsed = performance.now() - startTime;
      const progress = elapsed / duration;
      
      if (progress < 1) {
        // Expand particles
        particles.scale.set(1 + progress * 2, 1 + progress * 2, 1 + progress * 2);
        // Fade out
        material.opacity = 1 - progress;
        
        requestAnimationFrame(animateParticles);
      } else {
        // Clean up
        window.scene.remove(particles);
        geometry.dispose();
        material.dispose();
      }
    }
    
    requestAnimationFrame(animateParticles);
  }

  addPlayer(playerId, data) {
    console.log(`Adding remote player ${playerId}`);
    const model = new ThirdPersonModel(this.scene, playerId);
    model.update(data);
    this.remotePlayers.set(playerId, model);
  }

  removePlayer(playerId) {
    console.log(`Removing remote player ${playerId}`);
    const model = this.remotePlayers.get(playerId);
    if (model) {
      model.remove();
      this.remotePlayers.delete(playerId);
    }
  }

  update(deltaTime) {
    // Animate each remote player's walk cycle and smoothly update movement
    for (const [playerId, remoteModel] of this.remotePlayers.entries()) {
      if (remoteModel.isWalking) {
        remoteModel.animateWalk(deltaTime);
      } else {
        remoteModel.resetWalkAnimation();
      }
      remoteModel.animateMovement(deltaTime);
    }
  }

  notifyPlayersUpdated() {
    if (typeof this.onRemotePlayersUpdated === 'function') {
      this.onRemotePlayersUpdated();
    }
  }
}

================================================
File: /public/js/network.js
================================================
/**
 * NetworkManager class for WebSocket communication.
 * It provides event callbacks for multiplayer events and methods to send data.
 */
export class NetworkManager {
  constructor() {
    this.socket = null;
    this.playerId = null;
    this.otherPlayers = new Map(); // Maps playerId -> playerData from the server

    // Callbacks
    this.onInit = null;              // Called when we first receive 'init' from server
    this.onPlayerJoined = null;
    this.onPlayerLeft = null;
    this.onPlayerUpdate = null;
    this.onPlayerShoot = null;
    this.onPlayerCount = null;
    this.onPlayerHit = null;         // When this player is hit by someone
    this.onPlayerHitBroadcast = null;// When any player is hit
    this.onOpen = null;
    this.onClose = null;
    this.onError = null;

    // Anti-cheat callbacks
    this.onPositionCorrection = null;// When server corrects client position
    this.onBulletImpact = null;      // When a bullet hits something
    this.onRespawn = null;           // When player respawns

    // Automatic reconnect attempts
    this.connectionAttempts = 0;
    this.maxConnectionAttempts = 5;
    this.reconnectTimer = null;

    // Unique sessionId to prevent multiple tabs from colliding
    this.sessionId = this._generateSessionId();
    
    // Anti-cheat: Sequence number for message ordering
    this.sequenceNumber = 0;
    
    // Anti-cheat: Map to track outgoing messages that need nonces
    this.pendingMessages = new Map();
  }

  /**
   * Generates a unique-ish session ID to detect duplicate connections from the same tab.
   */
  _generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }
  
  /**
   * Generates a unique nonce for secure actions.
   * @returns {string} A unique nonce
   */
  _generateNonce() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2) + 
           Math.random().toString(36).substring(2);
  }

  /**
   * Initiates a connection to the WebSocket server.
   */
  connect() {
    this._cleanupSocket();

    // Determine correct ws:// or wss:// based on current protocol
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = `${protocol}${window.location.host}?sessionId=${this.sessionId}`;

    console.log('Attempting to connect to:', wsUrl);
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = (event) => {
      console.log('WebSocket connected');
      this.connectionAttempts = 0;
      if (typeof this.onOpen === 'function') {
        this.onOpen(event);
      }
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleMessage(message);
      } catch (err) {
        console.error('Error parsing server message:', err);
      }
    };

    this.socket.onclose = (event) => {
      console.log(`WebSocket closed: ${event.code} ${event.reason}`);
      if (typeof this.onClose === 'function') {
        this.onClose(event);
      }
      this._scheduleReconnect();
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      if (typeof this.onError === 'function') {
        this.onError(error);
      }
    };
  }

  /**
   * Clean up any existing WebSocket connection.
   */
  _cleanupSocket() {
    if (this.socket) {
      this.socket.onopen = null;
      this.socket.onmessage = null;
      this.socket.onclose = null;
      this.socket.onerror = null;
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close();
      }
      this.socket = null;
    }

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * Schedules a reconnect attempt if under max attempts.
   */
  _scheduleReconnect() {
    if (this.connectionAttempts < this.maxConnectionAttempts) {
      this.connectionAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
      console.log(`Reconnecting in ${(delay / 1000).toFixed(1)}s... (Attempt ${this.connectionAttempts}/${this.maxConnectionAttempts})`);
      
      this.reconnectTimer = setTimeout(() => {
        console.log(`Reconnecting now (Attempt ${this.connectionAttempts})...`);
        this.connect();
      }, delay);
    } else {
      console.error('Max reconnect attempts reached. Please refresh the page.');
    }
  }

  /**
   * Handles all messages from the server.
   * @param {Object} message The parsed JSON message object.
   */
  handleMessage(message) {
    switch (message.type) {
      // New connection initialization
      case 'init':
        this.playerId = message.id;
        console.log(`Assigned player ID: ${this.playerId}`);

        // If there's a callback
        if (typeof this.onInit === 'function') {
          this.onInit(message);
        }

        // Add known players
        message.players.forEach(player => {
          if (this.onPlayerJoined) {
            this.onPlayerJoined(player);
          }
          this.otherPlayers.set(player.id, player);
        });
        break;

      // Another player joined
      case 'playerJoined':
        console.log(`Player ${message.id} joined`);
        if (this.onPlayerJoined) {
          this.onPlayerJoined(message);
        }
        this.otherPlayers.set(message.id, {
          id: message.id,
          position: message.position,
          rotation: message.rotation,
          isAiming: false,
          isShooting: false,
          isReloading: false,
          quickDrawLobbyIndex: message.quickDrawLobbyIndex || -1
        });
        break;

      // Player left
      case 'playerLeft':
        console.log(`Player ${message.id} left`);
        if (this.onPlayerLeft) {
          this.onPlayerLeft(message.id);
        }
        this.otherPlayers.delete(message.id);
        break;

      // General player update (pos/rot/aiming/etc.)
      case 'playerUpdate':
        {
          const existing = this.otherPlayers.get(message.id);
          if (existing) {
            existing.position = message.position || existing.position;
            existing.rotation = message.rotation || existing.rotation;
            existing.isAiming =
              message.isAiming !== undefined ? message.isAiming : existing.isAiming;
            existing.isShooting =
              message.isShooting !== undefined ? message.isShooting : existing.isShooting;
            existing.isReloading =
              message.isReloading !== undefined ? message.isReloading : existing.isReloading;
            existing.quickDrawLobbyIndex =
              message.quickDrawLobbyIndex !== undefined ? message.quickDrawLobbyIndex : existing.quickDrawLobbyIndex;
            existing.health =
              message.health !== undefined ? message.health : existing.health;
          }
          if (this.onPlayerUpdate) {
            this.onPlayerUpdate(message.id, existing);
          }
        }
        break;

      // Remote player fired
      case 'playerShoot':
        if (this.onPlayerShoot) {
          this.onPlayerShoot(message.id, message.bulletData, message.bulletId);
        }
        break;

      // Current total player count
      case 'playerCount':
        if (this.onPlayerCount) {
          this.onPlayerCount(message.count);
        }
        break;

      // This client was hit by another player
      case 'hit':
        console.log(`I was hit by player ${message.sourceId} in the ${message.hitZone || 'body'} for ${message.hitData?.damage || 20} damage`);
        if (this.onPlayerHit) {
          this.onPlayerHit(message.sourceId, message.hitData, message.health, message.hitZone);
        }
        break;

      // A broadcast that someone was hit
      case 'playerHit':
        console.log(`Player ${message.targetId} was hit by player ${message.sourceId} in the ${message.hitZone || 'body'}`);
        if (this.onPlayerHitBroadcast) {
          this.onPlayerHitBroadcast(
            message.targetId,
            message.sourceId,
            message.hitPosition,
            message.health,
            message.hitZone,
            message.damage
          );
        }
        break;

      // Anti-cheat: Server correction of client position
      case 'positionCorrection':
        console.log(`Received position correction:`, message.position);
        if (this.onPositionCorrection) {
          this.onPositionCorrection(message.position);
        }
        break;
        
      // Anti-cheat: Bullet impact notification
      case 'bulletImpact':
        if (this.onBulletImpact) {
          this.onBulletImpact(
            message.bulletId, 
            message.hitType, 
            message.targetId, 
            message.position,
            message.hitZone
          );
        }
        break;
        
      // Anti-cheat: Player respawn notification
      case 'respawn':
        console.log(`Respawning at:`, message.position);
        if (this.onRespawn) {
          this.onRespawn(message.position, message.health, message.bullets);
        }
        break;

      // Generic error from server
      case 'error':
        console.error('Server error:', message.message);
        if (message.fatal) {
          this.connectionAttempts = this.maxConnectionAttempts; // block further reconnect
          alert(`Fatal error: ${message.message}`);
        }
        break;

      default:
        console.warn('Unhandled message:', message);
        break;
    }
  }

  /**
   * Sends local player position/rotation etc. to the server.
   * @param {Object} playerData - { position, rotation, isAiming, isReloading, isSprinting, quickDrawLobbyIndex }
   */
  sendUpdate(playerData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'update',
          sequenceNumber: this.sequenceNumber,
          ...playerData
        })
      );
    }
  }

  /**
   * Notifies server that we fired a bullet.
   * @param {Object} bulletData - { position: {x,y,z}, direction: {x,y,z} }
   */
  sendShoot(bulletData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'shoot',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          bulletData
        })
      );
    }
  }

  /**
   * Notifies server that we hit another player.
   * @param {number|string} hitPlayerId
   * @param {Object} hitData - { position: {x,y,z}, sourcePlayerId: ..., hitZone: 'head'|'body'|'limbs', damage: number }
   * @param {number|string} bulletId - Optional bulletId if known
   */
  sendPlayerHit(hitPlayerId, hitData, bulletId = null) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'playerHit',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          targetId: hitPlayerId,
          bulletId: bulletId,
          hitData
        })
      );
    }
  }
  
  /**
   * Notifies server that player is starting to reload.
   */
  sendReload() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'reload',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }
  
  /**
   * Sends a request to join a specific Quick Draw arena queue.
   * @param {number} arenaIndex - The arena index (0-4)
   */
  sendQuickDrawJoin(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawJoin',
          sequenceNumber: this.sequenceNumber,
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Sends a request to leave the Quick Draw queue.
   */
  sendQuickDrawLeave() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawLeave',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player is ready for a Quick Draw duel.
   * @param {number} arenaIndex - The arena index for the duel
   */
  sendQuickDrawReady(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawReady',
          sequenceNumber: this.sequenceNumber,
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player has shot their opponent in a Quick Draw duel.
   * @param {number|string} opponentId - The opponent's player ID
   * @param {number} arenaIndex - The arena index for the duel
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   * @param {number} damage - The damage amount
   */
  sendQuickDrawShoot(opponentId, arenaIndex, hitZone = 'body', damage = 40) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      console.log(`Sending Quick Draw hit notification to server: player ${this.playerId} hit player ${opponentId} in the ${hitZone} for ${damage} damage`);
      this.socket.send(JSON.stringify({
        type: 'quickDrawShoot',
        sequenceNumber: this.sequenceNumber,
        nonce: nonce,
        opponentId: opponentId,
        arenaIndex: arenaIndex,
        hitZone: hitZone,
        damage: damage
      }));
    }
  }

  /**
   * Sends a request to join a Proper Shootout match.
   */
  sendProperShootoutJoin() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(JSON.stringify({
        type: 'properShootoutJoin',
        sequenceNumber: this.sequenceNumber
      }));
    }
  }

  /**
   * Sends a request to leave the current Proper Shootout match.
   */
  sendProperShootoutLeave() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(JSON.stringify({
        type: 'properShootoutLeave',
        sequenceNumber: this.sequenceNumber
      }));
    }
  }

  /**
   * Closes the connection manually.
   */
  disconnect() {
    this._cleanupSocket();
    console.log('WebSocket connection manually closed');
  }
}

// Export a singleton instance
export const networkManager = new NetworkManager();
// Make it globally accessible
window.networkManager = networkManager;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  networkManager.disconnect();
});

================================================
File: /public/js/physics.js
================================================
/**
 * Physics system using cannon.js for collision detection and physics simulation.
 * Focused on creating invisible boundaries for the QuickDraw arenas and town.
 */
export class PhysicsSystem {
  constructor() {
    // Create a physics world with gravity
    this.world = new CANNON.World();
    this.world.gravity.set(0, -9.8, 0);
    
    // Set default contact material properties
    this.defaultMaterial = new CANNON.Material('default');
    const defaultContactMaterial = new CANNON.ContactMaterial(
      this.defaultMaterial,
      this.defaultMaterial,
      {
        friction: 0.3,
        restitution: 0.3 // Slightly bouncy
      }
    );
    this.world.addContactMaterial(defaultContactMaterial);
    this.world.defaultContactMaterial = defaultContactMaterial;
    
    // Collection of bodies
    this.bodies = [];
    
    // Debug helper for visualizing physics bodies
    this.debugMeshes = [];
    this.debugMode = false;
    
    // Track arena boundaries separately
    this.arenaBoundaryBodies = [];
    
    // Initialize ground
    this.initGround();
  }
  
  /**
   * Initialize the ground plane
   */
  initGround() {
    const groundBody = new CANNON.Body({
      mass: 0, // Static body
      shape: new CANNON.Plane(),
      material: this.defaultMaterial
    });
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be flat
    this.world.addBody(groundBody);
    this.bodies.push(groundBody);
  }
  
  /**
   * Creates an invisible boundary for the town to prevent players from leaving
   * @param {number} width - Width of the town
   * @param {number} length - Length of the town
   * @param {number} height - Height of the barrier
   * @returns {CANNON.Body} - The created physics body
   */
  createTownBoundary(width, length, height) {
    // First remove any existing town boundaries
    this.removeTownBoundary();
    
    // Create a physics body for the town boundary
    const boundaryBody = new CANNON.Body({
      mass: 0, // Static body
      material: this.defaultMaterial
    });
    
    // Add a box shape for each border
    const halfWidth = width / 2;
    const halfLength = length / 2;
    const borderThickness = 0.5;
    
    // Left border (negative X)
    const leftBorderShape = new CANNON.Box(new CANNON.Vec3(
      borderThickness / 2, 
      height / 2, 
      length / 2
    ));
    boundaryBody.addShape(
      leftBorderShape, 
      new CANNON.Vec3(-halfWidth, height / 2, 0)
    );
    
    // Right border (positive X)
    const rightBorderShape = new CANNON.Box(new CANNON.Vec3(
      borderThickness / 2, 
      height / 2, 
      length / 2
    ));
    boundaryBody.addShape(
      rightBorderShape, 
      new CANNON.Vec3(halfWidth, height / 2, 0)
    );
    
    // Front border (negative Z)
    const frontBorderShape = new CANNON.Box(new CANNON.Vec3(
      width / 2, 
      height / 2, 
      borderThickness / 2
    ));
    boundaryBody.addShape(
      frontBorderShape, 
      new CANNON.Vec3(0, height / 2, -halfLength)
    );
    
    // Back border (positive Z)
    const backBorderShape = new CANNON.Box(new CANNON.Vec3(
      width / 2, 
      height / 2, 
      borderThickness / 2
    ));
    boundaryBody.addShape(
      backBorderShape, 
      new CANNON.Vec3(0, height / 2, halfLength)
    );
    
    boundaryBody.townBoundary = true; // Tag this body as a town boundary
    boundaryBody.collisionFilterGroup = 2; // Group 2 for boundaries
    
    // Add the boundary body to the world
    this.world.addBody(boundaryBody);
    this.bodies.push(boundaryBody);
    
    // Create a reference to easily find this body later
    this.townBoundaryBody = boundaryBody;
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(boundaryBody);
    }
    
    console.log("Created town boundary with width", width, "and length", length);
    
    return boundaryBody;
  }
  
  /**
   * Removes the town boundary if it exists
   */
  removeTownBoundary() {
    if (this.townBoundaryBody) {
      this.world.removeBody(this.townBoundaryBody);
      
      // Remove from our bodies array
      const index = this.bodies.indexOf(this.townBoundaryBody);
      if (index !== -1) {
        this.bodies.splice(index, 1);
      }
      
      // Clear the reference
      this.townBoundaryBody = null;
      console.log("Removed town boundary");
    }
  }
  
  /**
   * Creates an invisible cylindrical boundary for a QuickDraw arena
   * @param {THREE.Vector3} center - Center position of the arena
   * @param {number} radius - Radius of the cylindrical arena
   * @param {number} height - Height of the cylindrical arena
   * @param {number} arenaIndex - Index of the arena (0-4)
   * @returns {CANNON.Body} - The created physics body
   */
  createQuickDrawArenaBoundary(center, radius, height, arenaIndex = 0) {
    // First remove any existing arena boundary for this index
    this.removeQuickDrawArenaBoundaryByIndex(arenaIndex);
    
    // Create a physics body for the arena boundary
    const arenaBody = new CANNON.Body({
      mass: 0, // Static body
      material: this.defaultMaterial
    });
    
    // Position at the center
    arenaBody.position.set(center.x, center.y + height/2, center.z);
    
    // Use a hollow cylinder (cylinder + inverted cylinder)
    // We make the walls a bit thick (0.5 units) to ensure reliable collision detection
    const wallThickness = 0.5;
    
    // Outer cylinder (pushing inward)
    const outerRadius = radius + wallThickness;
    const segments = 16; // Number of sides for the cylinder approximation
    
    // Create segments around the circle to approximate the cylinder
    for (let i = 0; i < segments; i++) {
      const angle1 = (i / segments) * Math.PI * 2;
      const angle2 = ((i + 1) / segments) * Math.PI * 2;
      
      const x1 = Math.cos(angle1) * radius;
      const z1 = Math.sin(angle1) * radius;
      const x2 = Math.cos(angle2) * radius;
      const z2 = Math.sin(angle2) * radius;
      
      // Calculate the position and orientation of this wall segment
      const segCenter = {
        x: (x1 + x2) / 2,
        z: (z1 + z2) / 2
      };
      
      const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
      
      // Create a box shape for this wall segment
      const halfExtents = new CANNON.Vec3(length/2, height/2, wallThickness/2);
      const wallShape = new CANNON.Box(halfExtents);
      
      // Get the angle to rotate this wall segment
      const rotationY = Math.atan2(z2 - z1, x2 - x1) + Math.PI/2;
      
      // Add the shape to the body with the appropriate offset and rotation
      const offset = new CANNON.Vec3(segCenter.x, 0, segCenter.z);
      const quaternion = new CANNON.Quaternion();
      quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
      
      arenaBody.addShape(wallShape, offset, quaternion);
    }
    
    // Bottom circle to prevent falling through
    const bottomShape = new CANNON.Cylinder(radius, radius, wallThickness, segments);
    const bottomOffset = new CANNON.Vec3(0, -height/2, 0);
    const bottomQuaternion = new CANNON.Quaternion();
    bottomQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    arenaBody.addShape(bottomShape, bottomOffset, bottomQuaternion);
    
    arenaBody.arenaBoundary = true; // Tag this body as an arena boundary
    arenaBody.arenaIndex = arenaIndex; // Store which arena this belongs to
    arenaBody.collisionFilterGroup = 2; // Group 2 for arena boundaries
    
    // Add the arena body to the world
    this.world.addBody(arenaBody);
    this.bodies.push(arenaBody);
    
    // Store in our array of arena boundaries
    this.arenaBoundaryBodies[arenaIndex] = arenaBody;
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(arenaBody);
    }
    
    console.log(`Created QuickDraw arena boundary ${arenaIndex + 1} at`, center, "with radius", radius, "and height", height);
    
    return arenaBody;
  }
  
  /**
   * Removes a QuickDraw arena boundary for a specific arena index
   * @param {number} arenaIndex - The index of the arena (0-4)
   */
  removeQuickDrawArenaBoundaryByIndex(arenaIndex) {
    if (this.arenaBoundaryBodies[arenaIndex]) {
      this.world.removeBody(this.arenaBoundaryBodies[arenaIndex]);
      
      // Remove from our bodies array
      const index = this.bodies.indexOf(this.arenaBoundaryBodies[arenaIndex]);
      if (index !== -1) {
        this.bodies.splice(index, 1);
      }
      
      // Clear the reference in our arena boundaries array
      this.arenaBoundaryBodies[arenaIndex] = null;
      console.log(`Removed QuickDraw arena boundary ${arenaIndex + 1}`);
    }
  }
  
  /**
   * Removes the QuickDraw arena boundary (legacy method for backward compatibility)
   */
  removeQuickDrawArenaBoundary() {
    // Remove all arena boundaries
    for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
      this.removeQuickDrawArenaBoundaryByIndex(i);
    }
  }
  
  /**
   * Create a physics body for a player
   * @param {THREE.Vector3} position - Initial position
   * @param {number} radius - Player collision radius
   * @param {number} height - Player height
   * @returns {CANNON.Body} - The created physics body
   */
  createPlayerBody(position, radius = 0.3, height = 1.8) {
    // Create a capsule shape (cylinder with spheres at ends)
    const playerBody = new CANNON.Body({
      mass: 70, // Player mass in kg
      material: this.defaultMaterial,
      fixedRotation: true, // Don't rotate the player when colliding
      linearDamping: 0.9 // Add some damping to prevent excessive sliding
    });
    
    // Use a cylinder for the body
    playerBody.addShape(new CANNON.Cylinder(radius, radius, height, 8));
    
    // Position the player body
    playerBody.position.set(position.x, position.y, position.z);
    
    // Add to world
    this.world.addBody(playerBody);
    this.bodies.push(playerBody);
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(playerBody);
    }
    
    return playerBody;
  }
  
  /**
   * Checks if a point is inside any active arena boundary
   * @param {THREE.Vector3} point - The point to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInArenaBoundary(point) {
    // Check all arena boundaries
    for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
      if (this.isPointInSpecificArenaBoundary(point, i)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Checks if a point is inside a specific arena boundary
   * @param {THREE.Vector3} point - The point to check
   * @param {number} arenaIndex - The arena index to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInSpecificArenaBoundary(point, arenaIndex) {
    // If no arena boundary exists for this index, return false
    if (!this.arenaBoundaryBodies[arenaIndex]) return false;
    
    // Get arena position
    const arenaPos = this.arenaBoundaryBodies[arenaIndex].position;
    const pointVec = new CANNON.Vec3(point.x, point.y, point.z);
    
    // Calculate horizontal distance (ignoring Y) from arena center
    const dx = pointVec.x - arenaPos.x;
    const dz = pointVec.z - arenaPos.z;
    const horizontalDist = Math.sqrt(dx * dx + dz * dz);
    
    // Get the radius - assuming 15 is the standard radius for all arenas
    const radius = 15;
    
    // Check if point is inside the cylinder horizontally
    return horizontalDist < radius;
  }

  /**
   * Checks if a point is inside the town boundary
   * @param {THREE.Vector3} point - The point to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInTown(point) {
    // If no town boundary exists, return true (no restriction)
    if (!window.townDimensions) return true;
    
    // Get town dimensions
    const width = window.townDimensions.width;
    const length = window.townDimensions.length;
    
    // Check if the point is within the town boundaries
    return (
      point.x > -width / 2 && 
      point.x < width / 2 && 
      point.z > -length / 2 && 
      point.z < length / 2
    );
  }
  
  /**
   * Creates a debug mesh to visualize a physics body
   * @param {CANNON.Body} body - The physics body to visualize
   */
  createDebugMesh(body) {
    // Only used in debug mode
    if (!this.debugMode) return;
    
    // For each shape in the body, create a wireframe mesh
    body.shapes.forEach((shape, i) => {
      let geometry;
      let mesh;
      
      // Get the shape's offset and orientation
      const offset = body.shapeOffsets[i];
      const orientation = body.shapeOrientations[i];
      
      // Create different geometries based on shape type
      if (shape instanceof CANNON.Box) {
        geometry = new THREE.BoxGeometry(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        mesh.quaternion.set(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
      }
      else if (shape instanceof CANNON.Sphere) {
        geometry = new THREE.SphereGeometry(shape.radius, 16, 16);
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset
        mesh.position.set(offset.x, offset.y, offset.z);
      }
      else if (shape instanceof CANNON.Cylinder) {
        geometry = new THREE.CylinderGeometry(
          shape.radiusTop,
          shape.radiusBottom,
          shape.height,
          shape.numSegments
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Rotate to match cannon.js cylinders
        mesh.rotation.x = Math.PI / 2;
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        const quat = new THREE.Quaternion(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
        mesh.quaternion.multiply(quat);
      }
      
      if (mesh) {
        // Add to the body's group
        const group = new THREE.Group();
        group.add(mesh);
        
        // Store reference for updating
        this.debugMeshes.push({
          mesh: group,
          body: body
        });
        
        // Add to scene
        window.scene.add(group);
      }
    });
  }
  
  /**
   * Update the physics world
   * @param {number} deltaTime - Time step in seconds
   */
  update(deltaTime) {
    // Limit delta time to prevent large jumps
    const timeStep = Math.min(deltaTime, 0.1);
    
    // Update physics world
    this.world.step(timeStep);
    
    // Update debug meshes if in debug mode
    if (this.debugMode) {
      this.updateDebugMeshes();
    }
  }
  
  /**
   * Update debug mesh positions to match their physics bodies
   */
  updateDebugMeshes() {
    if (!this.debugMode) return;
    
    this.debugMeshes.forEach(item => {
      // Update position
      item.mesh.position.set(
        item.body.position.x,
        item.body.position.y,
        item.body.position.z
      );
      
      // Update orientation
      item.mesh.quaternion.set(
        item.body.quaternion.x,
        item.body.quaternion.y,
        item.body.quaternion.z,
        item.body.quaternion.w
      );
    });
  }
  
  /**
   * Enables or disables debug visualization
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  setDebugMode(enabled) {
    // Store previous debug mode to detect changes
    const previousDebugMode = this.debugMode;
    this.debugMode = enabled;
    
    // If enabling and we weren't previously in debug mode
    if (enabled && !previousDebugMode) {
      // Create meshes for existing physics bodies
      this.bodies.forEach(body => {
        this.createDebugMesh(body);
      });
      
      // Set a global flag to signal hit zone debug should be created
      // This is important for making bullet.js know it should show hitboxes
      window.showHitZoneDebug = true;
      
      // Special handling for Proper Shootout mode - ensure boundary is visualized
      if (window.properShootout && window.properShootout.inLobby && window.properShootout.mapBoundaryBody) {
        this.createDebugMesh(window.properShootout.mapBoundaryBody);
        console.log("Created debug visualization for Proper Shootout map boundary");
      }
      
      console.log("Physics debug mode enabled - hit zones visible");
    }
    // If disabling and we were previously in debug mode
    else if (!enabled && previousDebugMode) {
      // Remove all physics debug meshes
      this.debugMeshes.forEach(item => {
        if (item.mesh && window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
      this.debugMeshes = [];
      
      // Remove any hit zone debug visualizations
      this.cleanupHitZoneDebug();
      
      // Clear the global flag for hit zone debugging
      window.showHitZoneDebug = false;
      
      console.log("Physics debug mode disabled - hit zones hidden");
    }
  }
  
  /**
   * Clean up hit zone debug visualizations
   */
  cleanupHitZoneDebug() {
    // Find and remove all hit zone debug objects
    if (window.scene) {
      const hitZoneObjects = [];
      window.scene.traverse(obj => {
        if (obj.name && obj.name.startsWith("hitZoneDebug_")) {
          hitZoneObjects.push(obj);
        }
      });
      
      // Remove each hit zone debug object
      hitZoneObjects.forEach(obj => {
        window.scene.remove(obj);
        // Clean up materials and geometries
        obj.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      });
      
      if (hitZoneObjects.length > 0) {
        console.log(`Removed ${hitZoneObjects.length} hit zone debug visualizations`);
      }
    }
    
    // Clear player hit zone debug references
    // Find all player objects
    if (window.localPlayer) {
      window.localPlayer._hitZoneDebug = null;
    }
    // Remote players
    if (window.remotePlayers) {
      window.remotePlayers.forEach(player => {
        if (player) {
          player._hitZoneDebug = null;
        }
      });
    }
  }
  
  /**
   * Force recreation of hit zone debug boxes for all players
   * Called when needed to refresh the visualizations
   */
  refreshHitZoneDebug() {
    if (!this.debugMode || !window.scene) return;
    
    console.log("Refreshing hit zone debug visualizations");
    
    // First clean up existing hit zone debug objects
    this.cleanupHitZoneDebug();
    
    // Then force recreation for local player and all remote players
    // Create a dummy bullet to use for hit zone checks
    const dummyBullet = new window.Bullet(
      new THREE.Vector3(0, 0, 0),
      new THREE.Vector3(0, 1, 0)
    );
    
    // Check local player
    if (window.localPlayer) {
      dummyBullet.checkPlayerHitZones(window.localPlayer, new THREE.Vector3(0, 0, 0));
    }
    
    // Check remote players
    if (window.remotePlayers) {
      window.remotePlayers.forEach(player => {
        if (player) {
          dummyBullet.checkPlayerHitZones(player, new THREE.Vector3(0, 0, 0));
        }
      });
    }
    
    // Also make sure the Proper Shootout map boundary is visualized if in that mode
    if (window.properShootout && window.properShootout.inLobby && window.properShootout.mapBoundaryBody) {
      // Create debug mesh for Proper Shootout map boundary if it doesn't exist yet
      let hasDebugMesh = false;
      for (const debugMesh of this.debugMeshes) {
        if (debugMesh.body === window.properShootout.mapBoundaryBody) {
          hasDebugMesh = true;
          break;
        }
      }
      
      if (!hasDebugMesh) {
        this.createDebugMesh(window.properShootout.mapBoundaryBody);
        console.log("Created missing debug visualization for Proper Shootout map boundary");
      }
    }
  }
  
  /**
   * Cleans up all physics resources
   */
  cleanup() {
    // Remove all bodies
    this.bodies.forEach(body => {
      this.world.removeBody(body);
    });
    
    // Remove all debug meshes
    if (this.debugMode) {
      this.debugMeshes.forEach(item => {
        if (window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
    }
    
    // Clean up hit zone debug visualizations
    this.cleanupHitZoneDebug();
    
    this.bodies = [];
    this.debugMeshes = [];
    this.arenaBoundaryBodies = [];
  }
}

================================================
File: /public/js/player.js
================================================
import { Revolver } from './revolver.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { applyRecoil, ejectShell } from './effects.js';
import { networkManager } from './network.js';

/**
 * The local Player class (first-person).
 */
export class Player {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene
   * @param {THREE.PerspectiveCamera} config.camera
   * @param {SoundManager} config.soundManager
   * @param {Function} config.onShoot - A callback function called when the player fires a bullet.
   */
  constructor({ scene, camera, soundManager, onShoot }) {
    this.scene = scene;
    this.camera = camera;
    this.soundManager = soundManager;
    this.onShootCallback = onShoot;

    this.group = new THREE.Group();
    
    // Start at a random spawn point in the town street
    this.spawnPlayerRandomly();
    
    this.scene.add(this.group);
    this.camera.position.set(0, 0, 0);
    this.group.add(this.camera);

    this.id = null; // will be set by networkManager.onInit
    this.velocity = new THREE.Vector3();
    this.canJump = false;

    // Movement flags
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    
    // Sprinting flag - new addition
    this.isSprinting = false;
    this.normalSpeed = 5; // Default movement speed
    this.sprintSpeed = 12; // Faster sprint speed
    this.sprintJumpBoost = 1.5; // Jump boost factor when sprinting

    // Aiming
    this.isAiming = false;
    this.defaultFOV = 75;
    this.aimFOV = 65;
    
    // Camera effects for sprinting - with smoothing parameters
    this.defaultCameraHeight = 0;
    this.bobPhase = 0; // Phase accumulator for bob effect
    this.bobIntensity = 0; // Current intensity of bobbing (interpolates)
    this.targetBobIntensity = 0; // Target bobbing intensity
    this.bobTransitionSpeed = 3; // Speed of transition to new bob intensity
    
    // Gun
    this.revolver = new Revolver();
    this.holsterOffset = new THREE.Vector3(0.6, -0.5, -0.8);
    this.aimOffset = new THREE.Vector3(0.3, -0.3, -0.5);
    this.currentGunOffset = this.holsterOffset.clone();
    this.camera.add(this.revolver.group);

    // FOV transition smoothing
    this.currentFOV = this.defaultFOV;
    this.targetFOV = this.defaultFOV;
    this.fovTransitionSpeed = 5; // Speed of FOV transitions

    // Reload
    this.isReloading = false;
    this.reloadTime = 4000; // Changed from 2000ms to 4000ms (4 seconds)
    this.reloadProgress = 0;
    this.bullets = 6;
    this.maxBullets = 6;
    this.canShoot = true;

    // Health
    this.health = 100;

    // Networking
    this.lastNetworkUpdate = 0;
    this.networkUpdateInterval = 50; // ms

    // Quick Draw mode
    this.canAim = true; // Whether the player is allowed to aim (used by Quick Draw)
    
    // Store previous position to detect collision with arena boundary
    this.previousPosition = new THREE.Vector3();

    // Quick Draw lobby information
    this.quickDrawLobbyIndex = -1; // -1 means not in a lobby
    
    // Anti-cheat: Server reconciliation
    this.serverPosition = new THREE.Vector3();
    this.isReconciling = false;
    this.reconciliationLerpFactor = 0.3; // How quickly to move to server position

    // Footstep sound system
    this.lastFootstepTime = 0; // Time of last footstep sound
    this.footstepInterval = 0.5; // Base interval in seconds between steps
    this.isLeftFoot = true; // Track which foot is next
    this.isMovingLastFrame = false; // Track if player was moving in the last frame
    this.isJumping = false; // Track jumping state
    
    // Hit zones for damage calculations
    this.hitZones = {
      head: { damage: 100 },
      body: { damage: 40 },
      limbs: { damage: 20 }
    };
    
    // Initialize network & UI
    this.initNetworking();
    updateAmmoUI(this);
    updateHealthUI(this);
  }

  /**
   * Spawn the player at a random position along the main street
   */
  spawnPlayerRandomly() {
    // Default position if town dimensions aren't available
    let spawnX = 0;
    let spawnY = 1.6;
    let spawnZ = 0;

    // If town dimensions are available, use them for spawn positioning
    if (window.townDimensions) {
      const streetWidth = window.townDimensions.streetWidth;
      const townLength = window.townDimensions.length;
      
      // Random position within the street area
      spawnX = (Math.random() - 0.5) * streetWidth * 0.8; // 80% of street width to avoid edges
      spawnZ = (Math.random() - 0.5) * townLength * 0.8; // 80% of town length
    }

    this.group.position.set(spawnX, spawnY, spawnZ);
    
    // Random rotation (facing any direction)
    this.group.rotation.y = Math.random() * Math.PI * 2;
    
    console.log(`Player spawned at: X=${spawnX.toFixed(2)}, Z=${spawnZ.toFixed(2)}`);
  }

  initNetworking() {
    // Start the WebSocket
    networkManager.connect();

    networkManager.onInit = (initData) => {
      this.id = initData.id;
      console.log(`Local player initialized with ID: ${this.id}`);
    };
    
    // Anti-cheat: Handle position corrections from server
    networkManager.onPositionCorrection = (correctedPosition) => {
      console.log("Received position correction from server:", correctedPosition);
      this.serverPosition.set(
        correctedPosition.x,
        correctedPosition.y,
        correctedPosition.z
      );
      this.isReconciling = true;
    };
    
    // Anti-cheat: Handle respawn from server
    networkManager.onRespawn = (position, health, bullets) => {
      console.log("Server-initiated respawn");
      
      // Set position
      this.group.position.copy(position);
      this.previousPosition.copy(position);
      
      // Update health and bullets
      this.health = health || 100;
      this.bullets = bullets || this.maxBullets;
      
      // Reset states
      this.isReloading = false;
      this.isAiming = false;
      this.velocity.y = 0;
      this.canAim = true;
      
      // Update UI
      updateHealthUI(this);
      updateAmmoUI(this);
    };
  }

  update(deltaTime) {
    // Store previous position before movement for collision detection
    this.previousPosition.copy(this.group.position);
    
    // Anti-cheat: Handle server reconciliation
    if (this.isReconciling) {
      // Smoothly move to server-corrected position
      this.group.position.lerp(this.serverPosition, this.reconciliationLerpFactor);
      
      // Stop reconciling when close enough
      if (this.group.position.distanceTo(this.serverPosition) < 0.1) {
        this.isReconciling = false;
      }
    }
    
    // Smoothly interpolate the gun offset & FOV
    const targetOffset = this.isAiming && this.canAim ? this.aimOffset : this.holsterOffset;
    this.currentGunOffset.lerp(targetOffset, 0.1);
    this.revolver.group.position.copy(this.currentGunOffset);

    // Adjust FOV based on sprinting and aiming with smoother transitions
    if (this.isAiming && this.canAim) {
      this.targetFOV = this.aimFOV;
    } else if (this.isSprinting && this.isMoving() && !window.quickDraw?.inDuel) {
      // FOV effect when sprinting, but not in QuickDraw duel
      this.targetFOV = this.defaultFOV + 7; // Less extreme FOV increase (was 10)
    } else {
      this.targetFOV = this.defaultFOV;
    }
    
    // Smooth FOV transition
    this.currentFOV = THREE.MathUtils.lerp(
      this.currentFOV, 
      this.targetFOV, 
      deltaTime * this.fovTransitionSpeed
    );
    
    // Only update camera FOV if it has changed enough to be noticeable
    if (Math.abs(this.camera.fov - this.currentFOV) > 0.01) {
      this.camera.fov = this.currentFOV;
      this.camera.updateProjectionMatrix();
    }

    // Handle head bob effect when moving - with improvements
    this.updateHeadBob(deltaTime);

    // Gravity
    this.velocity.y -= 20 * deltaTime;
    
    // Check if player is jumping
    const wasOnGround = this.canJump;
    const isJumping = this.velocity.y > 0 && !this.canJump;
    
    // Store the previous jumping state to detect when we first start jumping
    const wasJumping = this.isJumping || false;
    this.isJumping = isJumping;
    
    this.group.position.y += this.velocity.y * deltaTime;
    if (this.group.position.y < 1.6) {
      // Player landed
      if (this.velocity.y < -3 && !wasOnGround) {
        // Play landing sound if falling fast enough
        if (this.soundManager) {
          // Use regular footstep sound for landing, but play it directly for reliability
          this.soundManager.playSound("leftstep", 0, 1.2);
        }
      }
      
      this.velocity.y = 0;
      this.group.position.y = 1.6;
      this.canJump = true;
      this.isJumping = false;
    }

    // Movement - now with sprint capability
    const moveSpeed = this.getMoveSpeed();
    const forward = new THREE.Vector3();
    this.camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    // Store position before movement to check if we actually moved
    const positionBeforeMovement = this.group.position.clone();
    
    // Calculate new position based on movement input
    const newPosition = this.group.position.clone();
    
    if (this.moveForward) newPosition.add(forward.clone().multiplyScalar(moveSpeed * deltaTime));
    if (this.moveBackward) newPosition.add(forward.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveLeft) newPosition.add(right.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveRight) newPosition.add(right.clone().multiplyScalar(moveSpeed * deltaTime));

    // Check for boundary collisions before applying the new position
    const canMove = this.checkBoundaryCollision(newPosition);
    
    if (canMove) {
      this.group.position.copy(newPosition);
    } else {
      // If can't move to the new position, try to slide along the boundary
      // This gives a better feeling than just stopping
      if (this.moveForward || this.moveBackward) {
        const slideX = this.group.position.clone();
        slideX.x = newPosition.x;
        if (this.checkBoundaryCollision(slideX)) {
          this.group.position.copy(slideX);
        }
      }
      
      if (this.moveLeft || this.moveRight) {
        const slideZ = this.group.position.clone();
        slideZ.z = newPosition.z;
        if (this.checkBoundaryCollision(slideZ)) {
          this.group.position.copy(slideZ);
        }
      }
    }
    
    // Footstep sounds logic
    this.updateFootstepSounds(deltaTime, positionBeforeMovement);
    
    // Handle jump sound - only play when we first start jumping (not previously jumping)
    if (isJumping && !wasJumping && this.soundManager) {
      this.soundManager.playSound("jump", 300); // Play jump sound with 300ms cooldown
    }

    // Send periodic network updates
    const now = performance.now();
    if (now - this.lastNetworkUpdate > this.networkUpdateInterval) {
      this.lastNetworkUpdate = now;
      this.sendNetworkUpdate();
    }
  }

  /**
   * Update footstep sounds based on movement
   * @param {number} deltaTime - Time elapsed since last frame
   * @param {THREE.Vector3} previousPosition - Position before movement this frame
   */
  updateFootstepSounds(deltaTime, previousPosition) {
    // Only play footstep sounds if we're on the ground and actually moving
    const isMovingNow = this.isMoving() && this.canJump;
    
    // Calculate how far we've moved this frame
    const distanceMoved = this.group.position.distanceTo(previousPosition);
    
    // Skip if not moving or not on ground
    if (!isMovingNow || distanceMoved < 0.001) {
      this.isMovingLastFrame = false;
      return;
    }
    
    // Calculate the appropriate footstep interval based on speed
    let currentInterval = this.footstepInterval;
    if (this.isSprinting) {
      currentInterval = 0.3; // Faster steps when sprinting
    } else {
      currentInterval = 0.5; // Normal walking pace
    }
    
    // Accumulate time since last footstep
    this.lastFootstepTime += deltaTime;
    
    // Check if it's time for a footstep sound
    if (this.lastFootstepTime >= currentInterval) {
      // Reset the timer, with a small random variation for naturalness
      this.lastFootstepTime = -0.05 + Math.random() * 0.1;
      
      // Determine which foot and play the appropriate sound
      if (this.soundManager) {
        // Temporary debug log
        console.log(`Playing ${this.isLeftFoot ? 'left' : 'right'} footstep`);
        
        // Use direct sound play instead of positional audio for now
        this.soundManager.playSound(
          this.isLeftFoot ? 'leftstep' : 'rightstep',
          0, // No cooldown
          this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
        );
        
        // Try positional audio as fallback
        try {
          this.soundManager.playSoundAt(
            this.isLeftFoot ? 'leftstep' : 'rightstep',
            this.group.position,
            0, // No cooldown
            this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
          );
        } catch (err) {
          console.log("Fallback to positional audio failed:", err);
        }
      }
      
      // Switch feet for next step
      this.isLeftFoot = !this.isLeftFoot;
    }
    
    this.isMovingLastFrame = true;
  }

  /**
   * Updates camera head bobbing effect for walking/running with much smoother transitions
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateHeadBob(deltaTime) {
    // Update target bobbing intensity based on movement
    if (this.isMoving() && this.canJump) {
      // Very subtle bobbing values
      this.targetBobIntensity = this.isSprinting ? 0.02 : 0.01;
    } else {
      this.targetBobIntensity = 0;
    }
    
    // Smoothly transition bob intensity
    this.bobIntensity = THREE.MathUtils.lerp(
      this.bobIntensity,
      this.targetBobIntensity,
      Math.min(1, deltaTime * this.bobTransitionSpeed)
    );
    
    // Only calculate bob if intensity is significant
    if (this.bobIntensity > 0.001) {
      // Update phase at a speed proportional to movement
      // Use different frequencies for vertical and horizontal to create more natural movement
      this.bobPhase += deltaTime * (this.isSprinting ? 10 : 6);
      
      // Calculate vertical and horizontal components
      const verticalBob = Math.sin(this.bobPhase * 2) * this.bobIntensity;
      // Much smaller horizontal component
      const horizontalBob = Math.cos(this.bobPhase) * this.bobIntensity * 0.3;
      
      // Apply to camera position smoothly
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight + verticalBob,
        Math.min(1, deltaTime * 8)
      );
      
      // Extremely subtle horizontal movement
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        horizontalBob,
        Math.min(1, deltaTime * 3)
      );
    } else {
      // Smoothly return to default position when not moving
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight,
        Math.min(1, deltaTime * 4)
      );
      
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        0,
        Math.min(1, deltaTime * 3)
      );
    }
  }

  /**
   * Returns the current movement speed based on sprint state and location
   * @returns {number} The current movement speed
   */
  getMoveSpeed() {
    // Disable sprinting in QuickDraw duels
    if (window.quickDraw && window.quickDraw.inDuel) {
      return this.normalSpeed;
    }
    
    // Apply sprint speed if sprint key is pressed
    return this.isSprinting ? this.sprintSpeed : this.normalSpeed;
  }
  
  /**
   * Checks if the player is currently moving
   * @returns {boolean} True if any movement key is pressed
   */
  isMoving() {
    return this.moveForward || this.moveBackward || this.moveLeft || this.moveRight;
  }

  /**
   * Check if a position is valid regarding boundaries
   * @param {THREE.Vector3} position - The position to check
   * @returns {boolean} - True if the position is valid
   */
  checkBoundaryCollision(position) {
    // First check Quick Draw arena boundary
    if (window.quickDraw) {
      const inArena = window.quickDraw.isPointInArena(position);
      const wasInArena = window.quickDraw.isPointInArena(this.previousPosition);
      
      // If player is in a duel, they must stay inside
      if (window.quickDraw.inDuel && !inArena && wasInArena) {
        return false; // Can't leave arena during duel
      }
      
      // If player is not in a duel, they must stay outside
      if (!window.quickDraw.inDuel && inArena && !wasInArena) {
        return false; // Can't enter arena from outside (except via the portal)
      }
    }
    
    // Check Proper Shootout map boundary
    if (window.properShootout && window.properShootout.inLobby) {
      // If in Proper Shootout, only check those boundaries and ignore town boundaries
      return window.properShootout.isPointInMap(position);
    }
    
    // Check town boundary
    if (window.physics && typeof window.physics.isPointInTown === 'function') {
      if (!window.physics.isPointInTown(position)) {
        return false; // Can't leave town
      }
    } else if (window.townDimensions) {
      // Fallback if physics isn't available but town dimensions are
      const width = window.townDimensions.width;
      const length = window.townDimensions.length;
      
      if (
        position.x < -width / 2 || 
        position.x > width / 2 || 
        position.z < -length / 2 || 
        position.z > length / 2
      ) {
        return false; // Can't leave town
      }
    }
    
    return true; // No collision
  }

  /**
   * Send position/rotation updates to the server.
   */
  sendNetworkUpdate() {
    if (this.id == null) return;
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    networkManager.sendUpdate({
      position: {
        x: this.group.position.x,
        y: this.group.position.y,
        z: this.group.position.z
      },
      rotation: {
        y: this.group.rotation.y
      },
      isAiming: this.isAiming,
      isReloading: this.isReloading,
      isSprinting: this.isSprinting,
      health: this.health,
      quickDrawLobbyIndex: this.quickDrawLobbyIndex
    });
  }

  shoot() {
    if (this.bullets <= 0 || !this.canShoot || this.isReloading) {
      // No bullets or can't shoot
      if (this.bullets === 0) {
        const reloadMessage = document.getElementById('reload-message');
        if (reloadMessage) reloadMessage.style.display = 'block';
      }
      return;
    }
    // Actually shoot
    this.bullets--;
    updateAmmoUI(this);

    this.canShoot = false;
    setTimeout(() => { this.canShoot = true; }, 250);

    // Find bullet spawn
    const bulletStart = this.revolver.getBarrelTipWorldPosition();
    const shootDir = new THREE.Vector3();
    this.camera.getWorldDirection(shootDir);

    // Slight random spread
    shootDir.x += (Math.random() - 0.5) * 0.02;
    shootDir.y += (Math.random() - 0.5) * 0.02;
    shootDir.z += (Math.random() - 0.5) * 0.02;
    shootDir.normalize();

    // Recoil effect
    applyRecoil(this);

    // Call the callback to spawn bullet in main.js
    if (typeof this.onShootCallback === 'function') {
      this.onShootCallback(bulletStart, shootDir);
    }

    // If out of bullets, show reload hint
    if (this.bullets === 0) {
      const reloadMessage = document.getElementById('reload-message');
      if (reloadMessage) {
        reloadMessage.style.display = 'block';
      }
    }
  }

  /**
   * Called when the player takes damage.
   * @param {number} amount - Damage amount.
   * @param {string} hitZone - Hit zone ('head', 'body', 'limbs')
   */
  takeDamage(amount, hitZone) {
    const previousHealth = this.health;
    this.health = Math.max(this.health - amount, 0);
    console.log(`Player ${this.id} took ${amount} damage in the ${hitZone || 'body'}. Health is now ${this.health}`);
    
    // Show damage indicator with damage amount and hit zone
    if (typeof window.showDamageIndicator === 'function') {
      window.showDamageIndicator(amount, hitZone);
    }
    
    // Update health UI
    updateHealthUI(this);
    
    // Add screen flash effect based on damage amount
    this.showDamageEffect(amount);
    
    // If health reached zero, handle death
    if (previousHealth > 0 && this.health === 0) {
      console.log('Game Over');
      // Respawn after a delay
      setTimeout(() => {
        this.respawn();
      }, 1500);
    }
  }

  /**
   * Shows a screen flash effect when taking damage
   * @param {number} amount - The damage amount
   */
  showDamageEffect(amount) {
    // Create a full-screen flash effect
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    flash.style.opacity = '0';
    flash.style.transition = 'opacity 0.1s ease-in, opacity 0.4s ease-out';
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '900';
    document.getElementById('game-container').appendChild(flash);
    
    // Adjust intensity based on damage
    const intensity = Math.min(amount / 100, 0.8);
    flash.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;
    
    // Show and fade out
    setTimeout(() => {
      flash.style.opacity = '1';
      setTimeout(() => {
        flash.style.opacity = '0';
        setTimeout(() => {
          if (flash.parentNode) {
            flash.parentNode.removeChild(flash);
          }
        }, 400);
      }, 100);
    }, 0);
  }

  /**
   * Respawn the player after death
   */
  respawn() {
    // Reset health
    this.health = 100;
    updateHealthUI(this);
    
    // Spawn at a random position
    this.spawnPlayerRandomly();
    
    // Reset weapon state
    this.bullets = this.maxBullets;
    this.isReloading = false;
    this.canAim = true;
    this.isAiming = false;
    updateAmmoUI(this);
    
    // Reset vertical velocity
    this.velocity.y = 0;
    
    // Reset Quick Draw lobby information
    this.quickDrawLobbyIndex = -1;
    
    console.log('Player respawned');
  }

  startReload() {
    if (this.isReloading || this.bullets >= this.maxBullets) return;

    this.isReloading = true;
    this.reloadProgress = 0;
    const reloadMessage = document.getElementById('reload-message');
    const reloadProgressContainer = document.getElementById('reload-progress-container');
    if (reloadMessage) reloadMessage.style.display = 'none';
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'block';

    if (this.soundManager) {
      this.soundManager.playSound("shellejection");
      this.soundManager.playSound("reloading");
    }

    // Eject shells sequentially
    for (let i = 0; i < this.maxBullets - this.bullets; i++) {
      setTimeout(() => {
        ejectShell(this, this.scene, this.soundManager);
      }, i * 200);
    }
    
    // Anti-cheat: Notify server about reload start
    networkManager.sendReload();

    const startTime = performance.now();
    const updateReload = (currentTime) => {
      const elapsed = currentTime - startTime;
      this.reloadProgress = Math.min((elapsed / this.reloadTime) * 100, 100);
      const reloadProgressBar = document.getElementById('reload-progress-bar');
      if (reloadProgressBar) {
        reloadProgressBar.style.width = this.reloadProgress + '%';
      }
      if (elapsed < this.reloadTime) {
        requestAnimationFrame(updateReload);
      } else {
        this.completeReload();
      }
    };
    requestAnimationFrame(updateReload);
  }

  completeReload() {
    this.bullets = this.maxBullets;
    updateAmmoUI(this);

    const reloadProgressContainer = document.getElementById('reload-progress-container');
    const reloadProgressBar = document.getElementById('reload-progress-bar');
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
    if (reloadProgressBar) reloadProgressBar.style.width = '0%';
    
    this.isReloading = false;
    this.sendNetworkUpdate(); // let others know
  }
  
  /**
   * Set the Quick Draw lobby index for this player
   * @param {number} index - The lobby index (0-4) or -1 for none
   */
  setQuickDrawLobby(index) {
    this.quickDrawLobbyIndex = index;
    
    // Update UI indicator
    const lobbyIndicator = document.getElementById('lobby-indicator');
    if (lobbyIndicator) {
      if (index >= 0) {
        lobbyIndicator.textContent = `Arena ${index + 1}`;
        lobbyIndicator.style.display = 'block';
      } else {
        lobbyIndicator.style.display = 'none';
      }
    }
    
    // Send update to server
    this.sendNetworkUpdate();
  }
}

================================================
File: /public/js/playerModel.js
================================================
// /public/js/playerModel.js
import { Revolver } from './revolver.js';

/**
 * A simple blocky first-person arms model.
 */
export class PlayerArms {
  constructor(scene) {
    this.scene = scene;
    this.group = new THREE.Group();

    // Right arm
    this.rightArm = this.createBlockyArm(0xC68642);
    this.rightArm.position.set(0.3, -0.4, -0.3);
    this.rightArm.rotation.set(0.3, 0, 0);
    this.group.add(this.rightArm);

    // Left arm
    this.leftArm = this.createBlockyArm(0xC68642);
    this.leftArm.position.set(-0.3, -0.4, -0.3);
    this.leftArm.rotation.set(0.3, 0, 0);
    this.group.add(this.leftArm);

    // Store initial positions/rotations for animations
    this.rightArmOriginalPos = this.rightArm.position.clone();
    this.rightArmOriginalRot = this.rightArm.rotation.clone();
    this.leftArmOriginalPos = this.leftArm.position.clone();
    this.leftArmOriginalRot = this.leftArm.rotation.clone();

    // Initially not visible
    this.setVisible(false);
  }

  /**
   * Creates a blocky "arm" geometry (only a small cube).
   * @param {number} color - Hex color (e.g. 0xC68642)
   * @returns {THREE.Group}
   */
  createBlockyArm(color) {
    const armGroup = new THREE.Group();

    // A small "hand" cube
    const handGeo = new THREE.BoxGeometry(0.08, 0.08, 0.08);
    const handMat = new THREE.MeshStandardMaterial({ color });
    const handMesh = new THREE.Mesh(handGeo, handMat);
    armGroup.add(handMesh);

    return armGroup;
  }

  /**
   * Sets the arms' visibility.
   * @param {boolean} visible
   */
  setVisible(visible) {
    this.group.visible = visible;
  }

  /**
   * Updates arms for aiming. (Example usage in first-person code.)
   * @param {THREE.Camera} camera
   * @param {boolean} isAiming
   * @param {THREE.Vector3} gunBarrelTip
   */
  updatePosition(camera, isAiming, gunBarrelTip = null) {
    if (isAiming) {
      // Hide left arm by default (single-handed revolver stance)
      this.leftArm.visible = false;
      // Show right arm for aiming
      this.rightArm.visible = true;

      if (gunBarrelTip) {
        // Rough alignment based on gun barrel tip if desired
        this.rightArm.position.set(0.32, -0.35, -0.5);
        this.rightArm.rotation.set(Math.PI / 2, 0, 0);
      }
    } else {
      // Hide arms when not aiming
      this.rightArm.visible = false;
      this.leftArm.visible = false;
    }
  }

  /**
   * Plays a smooth reload animation using the left arm.
   * (This method is for the first-person arms model and remains unchanged.)
   */
  playReloadAnimation() {
    const originalPos = this.leftArm.position.clone();
    const originalRot = this.leftArm.rotation.clone();

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    const frames = [
      { t: 0,   pos: { x: -0.3, y: -0.4, z: -0.3 },      rot: { x: 0, y: 0, z: 0 } },
      { t: 300, pos: { x: -0.1, y: -0.2, z: -0.3 },      rot: { x: -0.2, y: 0.1, z: 0.1 } },
      { t: 600, pos: { x: -0.1, y: -0.2, z: -0.3 },      rot: { x: -0.3, y: 0.1, z: 0.1 } },
      { t: 900, pos: { x: -0.3, y: -0.4, z: -0.3 },      rot: { x: 0, y: 0, z: 0 } }
    ];

    const startTime = performance.now();

    const animate = (time) => {
      const elapsed = time - startTime;
      let currentFrame = frames[0];
      let nextFrame = frames[frames.length - 1];
      for (let i = 0; i < frames.length - 1; i++) {
        if (elapsed >= frames[i].t && elapsed < frames[i + 1].t) {
          currentFrame = frames[i];
          nextFrame = frames[i + 1];
          break;
        }
      }
      const segmentDuration = nextFrame.t - currentFrame.t;
      let segmentTime = elapsed - currentFrame.t;
      let alpha = Math.min(segmentTime / segmentDuration, 1);
      alpha = easeInOutCubic(alpha);

      const lerp = (a, b, t) => a + (b - a) * t;
      const newPos = {
        x: lerp(currentFrame.pos.x, nextFrame.pos.x, alpha),
        y: lerp(currentFrame.pos.y, nextFrame.pos.y, alpha),
        z: lerp(currentFrame.pos.z, nextFrame.pos.z, alpha)
      };
      const newRot = {
        x: lerp(currentFrame.rot.x, nextFrame.rot.x, alpha),
        y: lerp(currentFrame.rot.y, nextFrame.rot.y, alpha),
        z: lerp(currentFrame.rot.z, nextFrame.rot.z, alpha)
      };

      this.leftArm.position.set(newPos.x, newPos.y, newPos.z);
      this.leftArm.rotation.set(newRot.x, newRot.y, newRot.z);

      if (elapsed < frames[frames.length - 1].t) {
        requestAnimationFrame(animate);
      } else {
        this.leftArm.position.copy(originalPos);
        this.leftArm.rotation.copy(originalRot);
      }
    };
    requestAnimationFrame(animate);
  }
}

/**
 * The third-person model used to represent remote players
 * (and possibly the local player in others' view).
 */
export class ThirdPersonModel {
  constructor(scene, playerId) {
    this.scene = scene;
    this.playerId = playerId;
    this.group = new THREE.Group();

    this.collisionBox = new THREE.Box3();
    this.hitboxSize = { width: 0.6, height: 1.8, depth: 0.6 };

    // Health
    this.health = 100;

    // Target position/rotation for smooth interpolation.
    this.targetPosition = this.group.position.clone();
    this.targetRotation = this.group.rotation.y;

    // Build a basic "Minecraft-like" character.
    this.createBlockyCharacter();
    scene.add(this.group);

    this.walkCycle = 0;
    this.isWalking = false;
    this.lastPosition = new THREE.Vector3();

    // To track active hit feedback timeout.
    this.hitFeedbackTimeout = null;
  }

  createBlockyCharacter() {
    // Head
    const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xC68642 });
    this.head = new THREE.Mesh(headGeo, headMat);
    this.head.position.y = 1.6;
    this.group.add(this.head);

    // Body
    const bodyGeo = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3F51B5 });
    this.body = new THREE.Mesh(bodyGeo, bodyMat);
    this.body.position.y = 1.1;
    this.group.add(this.body);

    // Arms
    this.createBlockyArms();
    // Legs
    this.createBlockyLegs();
    // Hat
    this.createCowboyHat();

    // Use the normal revolver model on the left arm.
    this.addRevolver();
  }

  createBlockyArms() {
    // Right arm
    const armGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
    const skinMat = new THREE.MeshStandardMaterial({ color: 0xC68642 });
    this.rightArm = new THREE.Group();
    const rightArmMesh = new THREE.Mesh(armGeo, skinMat);
    rightArmMesh.position.y = -0.3;
    this.rightArm.add(rightArmMesh);
    this.rightArm.position.set(0.3, 1.4, 0);
    this.group.add(this.rightArm);

    // Left arm (holding the revolver)
    this.leftArm = new THREE.Group();
    const leftArmMesh = new THREE.Mesh(armGeo, skinMat);
    leftArmMesh.position.y = -0.3;
    this.leftArm.add(leftArmMesh);
    this.leftArm.position.set(-0.3, 1.4, 0);
    this.group.add(this.leftArm);
  }

  createBlockyLegs() {
    const legGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
    const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1A237E });
    // Right leg
    this.rightLeg = new THREE.Group();
    const rightLegMesh = new THREE.Mesh(legGeo, pantsMat);
    rightLegMesh.position.y = -0.3;
    this.rightLeg.add(rightLegMesh);
    this.rightLeg.position.set(0.1, 0.8, 0);
    this.group.add(this.rightLeg);

    // Left leg
    this.leftLeg = new THREE.Group();
    const leftLegMesh = new THREE.Mesh(legGeo, pantsMat);
    leftLegMesh.position.y = -0.3;
    this.leftLeg.add(leftLegMesh);
    this.leftLeg.position.set(-0.1, 0.8, 0);
    this.group.add(this.leftLeg);
  }

  createCowboyHat() {
    const hatMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

    // Hat brim
    const brimGeo = new THREE.BoxGeometry(0.5, 0.05, 0.5);
    this.hatBrim = new THREE.Mesh(brimGeo, hatMat);
    this.hatBrim.position.y = 0.225;
    this.head.add(this.hatBrim);

    // Hat top
    const topGeo = new THREE.BoxGeometry(0.3, 0.15, 0.3);
    this.hatTop = new THREE.Mesh(topGeo, hatMat);
    this.hatTop.position.y = 0.325;
    this.head.add(this.hatTop);
  }

  /**
   * Adds the normal revolver model to the third-person model's left arm.
   * The left arm holds the revolver.
   */
  addRevolver() {
    this.revolver = new Revolver();
    // Attach the revolver to the left arm.
    this.leftArm.add(this.revolver.group);
    // Set default positions and rotations for non-aiming state.
    this.revolverDefaultRotation = new THREE.Euler(-Math.PI / -1.5, Math.PI, 0);
    this.revolverAimingRotation = new THREE.Euler(-Math.PI / 0.7, Math.PI, 0);
    this.revolver.group.position.set(0.05, -0.8, -0.1);
    this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    this.revolver.group.visible = true;
  }

  updateCollisionBox() {
    const halfWidth = this.hitboxSize.width / 2;
    const halfDepth = this.hitboxSize.depth / 2;

    this.collisionBox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - halfWidth,
        this.group.position.y,
        this.group.position.z - halfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + halfWidth,
        this.group.position.y + this.hitboxSize.height,
        this.group.position.z + halfDepth
      )
    ]);
  }

  /**
   * Smoothly updates the model's position and rotation toward target values.
   * @param {number} deltaTime - Time elapsed since last frame.
   */
  animateMovement(deltaTime) {
    // Interpolate position and rotation for smooth remote movement
    this.group.position.lerp(this.targetPosition, 0.1);
    this.group.rotation.y = THREE.MathUtils.lerp(this.group.rotation.y, this.targetRotation, 0.1);
    this.updateCollisionBox();
  }

  /**
   * Updates the third-person model using data received from the server.
   * @param {Object} playerData
   */
  update(playerData) {
    if (!playerData) return;
    
    // Update target position from network data (shifting from eye-level to model base)
    if (playerData.position) {
      const newPos = new THREE.Vector3(
        playerData.position.x,
        playerData.position.y - 1.6,
        playerData.position.z
      );
      this.targetPosition.copy(newPos);

      // Check if walking based on movement
      this.isWalking = newPos.distanceTo(this.lastPosition) > 0.01;
      this.lastPosition.copy(newPos);
    }

    // Update target rotation with a 180° offset for proper facing
    if (playerData.rotation && playerData.rotation.y !== undefined) {
      this.targetRotation = playerData.rotation.y + Math.PI;
    }

    // Set pose based on whether the player is aiming
    if (playerData.isAiming) {
      this.setAimingPose();
    } else {
      this.setNormalPose();
    }

    // If reloading, play the reload animation
    if (playerData.isReloading) {
      this.playReloadAnimation();
    }

    // Update health if provided
    if (playerData.health !== undefined) {
      this.health = playerData.health;
    }
  }

  /**
   * Sets the model's pose for aiming.
   * The revolver (left arm) is rotated up by 90°.
   */
  setAimingPose() {
    // Right arm remains at default.
    this.rightArm.rotation.set(0, 0, 0);
    this.rightArm.position.set(0.3, 1.4, 0);

    // Left arm (holding revolver) rotates upward.
    this.leftArm.rotation.set(-Math.PI / 2, 0, 0);
    this.leftArm.position.set(-0.3, 1.4, 0);

    if (this.revolver) {
      this.revolver.group.rotation.copy(this.revolverAimingRotation);
    }

    this.head.rotation.x = 0.1;
  }

  /**
   * Sets the model's pose for normal (non-aiming) state.
   * The revolver (left arm) is rotated down a bit.
   */
  setNormalPose() {
    // Right arm stays default.
    this.rightArm.rotation.set(0, 0, 0);
    this.rightArm.position.set(0.3, 1.4, 0);

    // Left arm (holding revolver) is held lower.
    this.leftArm.rotation.set(-Math.PI / 15, 0, 0);
    this.leftArm.position.set(-0.3, 1.4, 0);

    if (this.revolver) {
      this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    }

    this.head.rotation.x = 0;
  }

  /**
   * Plays a smooth reload animation for the model.
   * The reload animation is performed by the right arm.
   */
  playReloadAnimation() {
    const originalPos = this.rightArm.position.clone();
    const originalRot = this.rightArm.rotation.clone();

    // Define keyframes (in ms) for the right arm reload motion.
    const frames = [
      { t: 0,    pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } },
      { t: 250,  pos: { x: 0.2,  y: 1.5, z: 0 },        rot: { x: -Math.PI / 4, y: 0, z: -Math.PI / 4 } },
      { t: 500,  pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } },
      { t: 750,  pos: { x: 0.2,  y: 1.5, z: 0 },        rot: { x: -Math.PI / 4, y: 0, z: -Math.PI / 4 } },
      { t: 1000, pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } }
    ];

    const startTime = performance.now();

    const animate = (time) => {
      const elapsed = time - startTime;
      let currentFrame = frames[0];
      let nextFrame = frames[frames.length - 1];
      for (let i = 0; i < frames.length - 1; i++) {
        if (elapsed >= frames[i].t && elapsed < frames[i + 1].t) {
          currentFrame = frames[i];
          nextFrame = frames[i + 1];
          break;
        }
      }
      const segmentDuration = nextFrame.t - currentFrame.t;
      let segmentTime = elapsed - currentFrame.t;
      let alpha = Math.min(segmentTime / segmentDuration, 1);

      // Cubic easing for smooth interpolation.
      const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      alpha = easeInOutCubic(alpha);

      const lerp = (a, b, t) => a + (b - a) * t;
      const newPos = {
        x: lerp(currentFrame.pos.x, nextFrame.pos.x, alpha),
        y: lerp(currentFrame.pos.y, nextFrame.pos.y, alpha),
        z: lerp(currentFrame.pos.z, nextFrame.pos.z, alpha)
      };
      const newRot = {
        x: lerp(currentFrame.rot.x, nextFrame.rot.x, alpha),
        y: lerp(currentFrame.rot.y, nextFrame.rot.y, alpha),
        z: lerp(currentFrame.rot.z, nextFrame.rot.z, alpha)
      };

      this.rightArm.position.set(newPos.x, newPos.y, newPos.z);
      this.rightArm.rotation.set(newRot.x, newRot.y, newRot.z);

      if (elapsed < frames[frames.length - 1].t) {
        requestAnimationFrame(animate);
      } else {
        this.rightArm.position.copy(originalPos);
        this.rightArm.rotation.copy(originalRot);
      }
    };

    requestAnimationFrame(animate);
  }

  /**
   * Animates the walk cycle.
   * @param {number} deltaTime
   */
  animateWalk(deltaTime) {
    this.walkCycle += deltaTime * 5;
    // Leg swing
    this.rightLeg.rotation.x = Math.sin(this.walkCycle) * 0.7;
    this.leftLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.7;

    // Arm swing (if not in an aiming pose)
    if (this.rightArm.rotation.x === 0 && this.leftArm.rotation.x === 0) {
      this.rightArm.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.5;
      this.leftArm.rotation.x = Math.sin(this.walkCycle) * 0.5;
    }

    // Subtle body bob
    this.body.position.y = 1.1 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.05;
  }

  /**
   * Resets the walk animation.
   */
  resetWalkAnimation() {
    this.rightLeg.rotation.x = 0;
    this.leftLeg.rotation.x = 0;

    if (Math.abs(this.rightArm.rotation.x) < 0.1 &&
        Math.abs(this.leftArm.rotation.x) < 0.1) {
      this.rightArm.rotation.x = 0;
      this.leftArm.rotation.x = 0;
    }
    this.body.position.y = 1.1;
  }

  /**
   * Removes the model from the scene (e.g. on player disconnect).
   * Fully disposes geometry and material.
   */
  remove() {
    this.scene.remove(this.group);
    this.group.traverse(child => {
      if (child.isMesh) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  }

  /**
   * Provides visual feedback (temporary red flash) when the model is hit.
   * The original materials are stored on each mesh (if not already stored)
   * and restored after 200ms.
   */
  showHitFeedback() {
    // Clear any existing hit feedback timeout.
    if (this.hitFeedbackTimeout) {
      clearTimeout(this.hitFeedbackTimeout);
    }
    // Traverse the model and replace each mesh's material with a red flash.
    this.group.traverse(child => {
      if (child.isMesh && child.material) {
        // Store the original material in userData if not already stored.
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        child.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        child.material.needsUpdate = true;
      }
    });
    // After 200ms, restore the original materials.
    this.hitFeedbackTimeout = setTimeout(() => {
      this.group.traverse(child => {
        if (child.isMesh && child.userData.originalMaterial) {
          child.material.dispose();
          child.material = child.userData.originalMaterial;
          child.material.needsUpdate = true;
          delete child.userData.originalMaterial;
        }
      });
      this.hitFeedbackTimeout = null;
    }, 200);
  }

  /**
   * Reduces health when hit.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Remote player ${this.playerId} took ${amount} damage. Health: ${this.health}`);
    // Optionally, you could change the model's appearance or remove it on death.
  }
}

================================================
File: /public/js/properShootout.js
================================================
/**
 * Proper Shootout game mode implementation
 * All-vs-all shootout where the first player to get 10 kills wins.
 * Up to 10 players can join a lobby.
 */

import { PhysicsSystem } from './physics.js';

export class ProperShootout {
    constructor(scene, localPlayer, networkManager, soundManager) {
        this.scene = scene;
        this.localPlayer = localPlayer;
        this.networkManager = networkManager;
        this.soundManager = soundManager;
        
        // Game state
        this.inLobby = false;
        this.lobbyId = null;
        this.kills = 0;
        this.playerScores = new Map(); // Map of playerId -> kills
        
        // Initialize physics system for collision detection
        this.physics = new PhysicsSystem();
        
        // Map dimensions
        this.mapWidth = 50;
        this.mapLength = 50;
        
        // Initialize the portal, game area, and network handlers
        this.initPortal();
        this.createGameArea();
        this.initNetworkHandlers();
        this.createUI();

        // Make this instance globally accessible for network handlers
        window.properShootout = this;
    }
    
    /**
     * Initialize the portal for Proper Shootout
     */
    initPortal() {
        this.portalGroup = new THREE.Group();
        
        // Calculate portal position - next to the Quick Draw portal
        let portalX = 0;
        let portalY = 2.5;
        let portalZ = 0;
        
        // If town dimensions are available, use them for positioning
        if (window.townDimensions) {
            const streetWidth = window.townDimensions.streetWidth;
            const townLength = window.townDimensions.length;
            
            // Position portal on the side of the street in the center of town
            // Offset slightly from the Quick Draw portal (which is at streetWidth * 0.4)
            portalX = streetWidth * 0.4 - 6; // 6 units to the left of Quick Draw portal
            portalZ = 0; // Center of town (Z axis)
        }
        
        // Create a wooden frame portal with different color
        this.createWoodenFramePortal(portalX, portalY, portalZ);
        
        // Create collision detector for the portal
        this.portalCollider = new THREE.Box3(
            new THREE.Vector3(portalX - 2.5, 0, portalZ - 1),
            new THREE.Vector3(portalX + 2.5, portalY * 2, portalZ + 1)
        );
        
        this.scene.add(this.portalGroup);
        
        // Create portal instructions
        this.createPortalInstructions(new THREE.Vector3(portalX, portalY, portalZ));
    }
    
    /**
     * Creates a wooden frame portal with a different color from Quick Draw
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} z - Z position
     */
    createWoodenFramePortal(x, y, z) {
        const frameWidth = 5;
        const frameHeight = 7;
        const beamThickness = 0.25;
        
        // Create wooden beam material with texture
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,  // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        // Create the wooden frame beams
        // Top beam
        const topBeam = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, beamThickness, beamThickness),
            woodMaterial
        );
        topBeam.position.set(0, frameHeight/2, 0);
        this.portalGroup.add(topBeam);
        
        // Bottom beam
        const bottomBeam = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, beamThickness, beamThickness),
            woodMaterial
        );
        bottomBeam.position.set(0, -frameHeight/2, 0);
        this.portalGroup.add(bottomBeam);
        
        // Left beam
        const leftBeam = new THREE.Mesh(
            new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness),
            woodMaterial
        );
        leftBeam.position.set(-frameWidth/2, 0, 0);
        this.portalGroup.add(leftBeam);
        
        // Right beam
        const rightBeam = new THREE.Mesh(
            new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness),
            woodMaterial
        );
        rightBeam.position.set(frameWidth/2, 0, 0);
        this.portalGroup.add(rightBeam);
        
        // Use a custom shader for a green portal filling (different from Quick Draw's blue)
        const fillingGeometry = new THREE.PlaneGeometry(frameWidth - beamThickness, frameHeight - beamThickness, 32, 32);
        const fillingMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                uniform float time;
                
                void main() {
                    vUv = uv;
                    // Add subtle displacement to vertices
                    vec3 pos = position;
                    pos.x += sin(position.y * 2.0 + time * 0.5) * 0.01;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                
                // Simple noise function
                float noise(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                void main() {
                    // Green base color for Proper Shootout (vs blue for Quick Draw)
                    vec3 baseColor = vec3(0.0, 0.8, 0.3);
                    
                    // Add subtle swirl pattern
                    float swirl = sin(vUv.x * vUv.y * 10.0 + time * 0.2) * 0.1;
                    
                    // Add a bit of noise pattern
                    float noiseVal = noise(vUv * 5.0 + vec2(time * 0.05, time * 0.03));
                    
                    // Mix colors for subtle effect
                    vec3 color = mix(baseColor, vec3(0.2, 1.0, 0.4), swirl + noiseVal * 0.1);
                    
                    // Add edge glow
                    float edgeX = smoothstep(0.0, 0.07, vUv.x) * smoothstep(1.0, 0.93, vUv.x);
                    float edgeY = smoothstep(0.0, 0.07, vUv.y) * smoothstep(1.0, 0.93, vUv.y);
                    float edge = edgeX * edgeY;
                    
                    // Subtle pulsing
                    float pulse = 0.9 + sin(time * 0.5) * 0.1;
                    color = mix(color, vec3(0.4, 1.0, 0.7), (1.0 - edge) * pulse * 0.2);
                    
                    gl_FragColor = vec4(color, 0.9); // Slightly transparent
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        const filling = new THREE.Mesh(fillingGeometry, fillingMaterial);
        filling.position.set(0, 0, -0.05);
        this.portalGroup.add(filling);
        
        // Update the time uniform in the shader
        this.animatePortalFilling(fillingMaterial);
        
        // Create a wooden sign on top of the portal
        this.createWoodenSign(frameWidth, frameHeight);
        
        // Add particle effect around the portal
        this.addPortalParticles(frameWidth, frameHeight);
        
        // Position the portal
        this.portalGroup.position.set(x, y, z);
        this.portalGroup.rotation.y = Math.PI / 2; // Make it vertical and facing the street
    }
    
    /**
     * Updates the time uniform in the portal shader
     * @param {THREE.ShaderMaterial} material - The shader material
     */
    animatePortalFilling(material) {
        const animate = () => {
            material.uniforms.time.value += 0.01;
            requestAnimationFrame(animate);
        };
        
        requestAnimationFrame(animate);
    }
    
    /**
     * Creates a wooden sign on top of the portal with text visible from both sides
     * @param {number} frameWidth - Width of the portal frame
     * @param {number} frameHeight - Height of the portal frame
     */
    createWoodenSign(frameWidth, frameHeight) {
        // Create wooden sign material
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,  // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        // Create sign post
        const signWidth = frameWidth * 0.8;
        const signHeight = 0.8;
        const signDepth = 0.1;
        
        // Create the wooden sign board
        const signGeometry = new THREE.BoxGeometry(signWidth, signHeight, signDepth);
        const sign = new THREE.Mesh(signGeometry, woodMaterial);
        
        // Position the sign above the portal
        sign.position.set(0, frameHeight/2 + signHeight/2 + 0.1, 0);
        
        // Create two small posts to connect the sign to the portal frame
        const postGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
        
        // Left post
        const leftPost = new THREE.Mesh(postGeometry, woodMaterial);
        leftPost.position.set(-signWidth/3, frameHeight/2 + 0.2, 0);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeometry, woodMaterial);
        rightPost.position.set(signWidth/3, frameHeight/2 + 0.2, 0);
        
        // Create text for both sides of the sign
        const createSignText = (isBack) => {
            const textCanvas = document.createElement('canvas');
            const context = textCanvas.getContext('2d');
            textCanvas.width = 512;
            textCanvas.height = 128;
            
            // Clear background
            context.fillStyle = '#8B4513'; // Match the wood color
            context.fillRect(0, 0, textCanvas.width, textCanvas.height);
            
            // Add wood grain texture
            context.strokeStyle = '#6B3F13'; // Darker wood color for grain
            context.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                const y = i * 7;
                context.beginPath();
                context.moveTo(0, y);
                // Wavy line for wood grain
                for (let x = 0; x < textCanvas.width; x += 20) {
                    context.lineTo(x + 10, y + (Math.random() * 4 - 2));
                }
                context.stroke();
            }
            
            // Add text
            context.fillStyle = 'white';
            context.font = 'bold 70px Western, Arial, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('Shootout', 256, 64);
            
            // Add a slightly darker stroke to make text more readable
            context.strokeStyle = 'rgba(0,0,0,0.5)';
            context.lineWidth = 2;
            context.strokeText('Shootout', 256, 64);
            
            const texture = new THREE.CanvasTexture(textCanvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });
            
            // Create text plane slightly larger than the sign to avoid z-fighting
            const textGeometry = new THREE.PlaneGeometry(signWidth - 0.05, signHeight - 0.05);
            const textMesh = new THREE.Mesh(textGeometry, material);
            
            // Position text just in front of the sign
            const zOffset = isBack ? -signDepth/2 - 0.01 : signDepth/2 + 0.01;
            textMesh.position.set(0, 0, zOffset);
            
            // If this is the back face, rotate it 180 degrees
            if (isBack) {
                textMesh.rotation.y = Math.PI;
            }
            
            return textMesh;
        };
        
        // Create front and back text
        const frontText = createSignText(false);
        const backText = createSignText(true);
        
        // Add text to sign
        sign.add(frontText);
        sign.add(backText);
        
        // Add everything to the portal group
        this.portalGroup.add(sign);
        this.portalGroup.add(leftPost);
        this.portalGroup.add(rightPost);
    }
    
    /**
     * Adds particle effects around the portal
     * @param {number} width - Width of the portal
     * @param {number} height - Height of the portal
     */
    addPortalParticles(width, height) {
        const particleCount = 50;
        const particleGroup = new THREE.Group();
        
        // Create particle material (green to match portal)
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x00FF00,
            size: 0.15,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        
        // Create particle geometry
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = []; // Store velocities for animation
        
        // Create particles around the frame
        for (let i = 0; i < particleCount; i++) {
            // Position particles around the portal frame
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = (Math.random() - 0.5) * width;
                    y = height/2 + Math.random() * 0.5;
                    break;
                case 1: // right
                    x = width/2 + Math.random() * 0.5;
                    y = (Math.random() - 0.5) * height;
                    break;
                case 2: // bottom
                    x = (Math.random() - 0.5) * width;
                    y = -height/2 - Math.random() * 0.5;
                    break;
                case 3: // left
                    x = -width/2 - Math.random() * 0.5;
                    y = (Math.random() - 0.5) * height;
                    break;
            }
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2; // Small Z variation
            
            // Random velocities moving toward the portal
            velocities.push({
                x: -x * 0.01 * (0.5 + Math.random() * 0.5),
                y: -y * 0.01 * (0.5 + Math.random() * 0.5),
                z: (Math.random() - 0.5) * 0.01,
                life: 0,
                maxLife: 60 + Math.floor(Math.random() * 60) // Random lifetime
            });
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particleGroup.add(particles);
        this.portalGroup.add(particleGroup);
        
        // Animate particles
        const animateParticles = () => {
            const positions = particles.geometry.attributes.position.array;
            
            // Update each particle
            for (let i = 0; i < particleCount; i++) {
                // Update position based on velocity
                positions[i * 3] += velocities[i].x;
                positions[i * 3 + 1] += velocities[i].y;
                positions[i * 3 + 2] += velocities[i].z;
                
                // Update life
                velocities[i].life++;
                
                // If particle has reached end of life or center of portal, reset it
                if (velocities[i].life >= velocities[i].maxLife || 
                    (Math.abs(positions[i * 3]) < 0.3 && Math.abs(positions[i * 3 + 1]) < 0.3)) {
                    
                    // Reset to edge of portal
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    
                    switch(side) {
                        case 0: // top
                            x = (Math.random() - 0.5) * width;
                            y = height/2 + Math.random() * 0.5;
                            break;
                        case 1: // right
                            x = width/2 + Math.random() * 0.5;
                            y = (Math.random() - 0.5) * height;
                            break;
                        case 2: // bottom
                            x = (Math.random() - 0.5) * width;
                            y = -height/2 - Math.random() * 0.5;
                            break;
                        case 3: // left
                            x = -width/2 - Math.random() * 0.5;
                            y = (Math.random() - 0.5) * height;
                            break;
                    }
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // New velocity
                    velocities[i] = {
                        x: -x * 0.01 * (0.5 + Math.random() * 0.5),
                        y: -y * 0.01 * (0.5 + Math.random() * 0.5),
                        z: (Math.random() - 0.5) * 0.01,
                        life: 0,
                        maxLife: 60 + Math.floor(Math.random() * 60)
                    };
                }
            }
            
            // Update geometry
            particles.geometry.attributes.position.needsUpdate = true;
            
            requestAnimationFrame(animateParticles);
        };
        
        requestAnimationFrame(animateParticles);
    }
    
    /**
     * Creates a floating instruction panel for the portal
     * @param {THREE.Vector3} portalPosition - The position of the portal
     */
    createPortalInstructions(portalPosition) {
        // Create a container for the instructions
        const instructionsId = 'proper-shootout-instructions';
        
        // Check if it already exists
        let instructionsElement = document.getElementById(instructionsId);
        if (!instructionsElement) {
            instructionsElement = document.createElement('div');
            instructionsElement.id = instructionsId;
            instructionsElement.className = 'portal-instructions';
            instructionsElement.style.position = 'absolute';
            instructionsElement.style.top = '35%';
            instructionsElement.style.left = '50%';
            instructionsElement.style.transform = 'translate(-50%, -50%)';
            instructionsElement.style.color = 'white';
            instructionsElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
            instructionsElement.style.padding = '20px';
            instructionsElement.style.borderRadius = '10px';
            instructionsElement.style.textAlign = 'center';
            instructionsElement.style.width = '400px';
            instructionsElement.style.display = 'none';
            instructionsElement.style.zIndex = '500';
            instructionsElement.style.fontFamily = 'Arial, sans-serif';
            
            instructionsElement.innerHTML = `
                <h2 style="color:#4CAF50; margin-bottom:10px;">Proper Shootout</h2>
                <p>Enter the portal to join a Shootout match!</p>
                <ul style="text-align:left; margin-top:10px; padding-left:20px;">
                    <li>First player to 10 kills wins the match</li>
                    <li>You'll respawn at a random location when killed</li>
                    <li>Press the Exit button to leave the match</li>
                    <li>Up to 10 players can join a single match</li>
                </ul>
            `;
            
            document.getElementById('game-container').appendChild(instructionsElement);
        }
        
        // Show instructions when player gets close to portal
        // Adjust the proximity box based on portal position
        const proximityBox = new THREE.Box3(
            new THREE.Vector3(portalPosition.x - 4, portalPosition.y - 4, portalPosition.z - 4),
            new THREE.Vector3(portalPosition.x + 4, portalPosition.y + 4, portalPosition.z + 4)
        );
        
        // Store the box reference and element for the portal
        this.portalProximityBox = proximityBox;
        this.instructionsElement = instructionsElement;
    }
    
    /**
     * Create UI elements for Proper Shootout game mode.
     */
    createUI() {
        // Text overlay for messages
        this.messageOverlay = document.createElement('div');
        this.messageOverlay.id = 'proper-shootout-message';
        this.messageOverlay.style.position = 'absolute';
        this.messageOverlay.style.top = '30%';
        this.messageOverlay.style.left = '50%';
        this.messageOverlay.style.transform = 'translate(-50%, -50%)';
        this.messageOverlay.style.color = 'white';
        this.messageOverlay.style.fontSize = '36px';
        this.messageOverlay.style.fontWeight = 'bold';
        this.messageOverlay.style.textAlign = 'center';
        this.messageOverlay.style.display = 'none';
        this.messageOverlay.style.fontFamily = 'Western, Arial, sans-serif';
        this.messageOverlay.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
        this.messageOverlay.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(this.messageOverlay);
        
        // Status indicator
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.id = 'proper-shootout-status';
        this.statusIndicator.style.position = 'absolute';
        this.statusIndicator.style.top = '120px';
        this.statusIndicator.style.left = '20px';
        this.statusIndicator.style.color = 'white';
        this.statusIndicator.style.fontSize = '16px';
        this.statusIndicator.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.statusIndicator.style.padding = '5px';
        this.statusIndicator.style.borderRadius = '5px';
        this.statusIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.statusIndicator);
        
        // Scoreboard
        this.scoreboard = document.createElement('div');
        this.scoreboard.id = 'proper-shootout-scoreboard';
        this.scoreboard.style.position = 'absolute';
        this.scoreboard.style.top = '10px';
        this.scoreboard.style.right = '10px';
        this.scoreboard.style.width = '200px';
        this.scoreboard.style.color = 'white';
        this.scoreboard.style.fontSize = '14px';
        this.scoreboard.style.backgroundColor = 'rgba(0,0,0,0.7)';
        this.scoreboard.style.padding = '10px';
        this.scoreboard.style.borderRadius = '5px';
        this.scoreboard.style.display = 'none';
        this.scoreboard.style.zIndex = '900';
        document.getElementById('game-container').appendChild(this.scoreboard);
        
        // Exit button
        this.exitButton = document.createElement('button');
        this.exitButton.id = 'proper-shootout-exit';
        this.exitButton.textContent = 'Exit Match';
        this.exitButton.style.position = 'absolute';
        this.exitButton.style.top = '10px';
        this.exitButton.style.left = '10px';
        this.exitButton.style.padding = '5px 10px';
        this.exitButton.style.backgroundColor = '#F44336';
        this.exitButton.style.color = 'white';
        this.exitButton.style.border = 'none';
        this.exitButton.style.borderRadius = '5px';
        this.exitButton.style.cursor = 'pointer';
        this.exitButton.style.display = 'none';
        this.exitButton.style.zIndex = '1000';
        this.exitButton.addEventListener('click', () => {
            this.leaveMatch();
        });
        document.getElementById('game-container').appendChild(this.exitButton);
    }
    
    /**
     * Create the game area for the Proper Shootout mode
     */
    createGameArea() {
        this.gameAreaGroup = new THREE.Group();
        
        // Determine map position - somewhere outside the town boundary
        let mapCenterX = 0;
        let mapCenterZ = 0;
        
        // If town dimensions are available, position map outside town
        if (window.townDimensions) {
            const townLength = window.townDimensions.length;
            
            // Position shootout map opposite to Quick Draw arenas
            mapCenterZ = -townLength - 50; // 50 units past the south boundary
        } else {
            mapCenterZ = -100; // Default position if town dimensions aren't available
        }
        
        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(this.mapWidth, this.mapLength);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown dirt color
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(mapCenterX, 0.01, mapCenterZ); // Slightly above zero to prevent z-fighting
        ground.receiveShadow = true;
        this.gameAreaGroup.add(ground);
        
        // Create a border around the map
        this.createMapBorder(mapCenterX, mapCenterZ);
        
        // Add some simple buildings
        this.addSimpleBuildings(mapCenterX, mapCenterZ);
        
        // Store map center position
        this.mapCenter = new THREE.Vector3(mapCenterX, 0, mapCenterZ);
        
        // Initially hide the game area
        this.gameAreaGroup.visible = false;
        this.scene.add(this.gameAreaGroup);
        
        // Create boundary physics
        this.createMapBoundary();
    }
    
    /**
     * Create a visible border around the shootout map
     * @param {number} centerX - X center of the map
     * @param {number} centerZ - Z center of the map
     */
    createMapBorder(centerX, centerZ) {
        const borderHeight = 1;
        const borderWidth = 1;
        
        // Border material
        const borderMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513, // Brown
            roughness: 0.8,
            metalness: 0.2
        });
        
        // Create four border segments
        const createBorderSegment = (x, z, sizeX, sizeZ) => {
            const geometry = new THREE.BoxGeometry(sizeX, borderHeight, sizeZ);
            const border = new THREE.Mesh(geometry, borderMaterial);
            border.position.set(x, borderHeight / 2, z);
            border.castShadow = true;
            border.receiveShadow = true;
            this.gameAreaGroup.add(border);
            return border;
        };
        
        // Left border (negative X)
        const leftBorder = createBorderSegment(
            centerX - this.mapWidth / 2, 
            centerZ, 
            borderWidth, 
            this.mapLength
        );
        
        // Right border (positive X)
        const rightBorder = createBorderSegment(
            centerX + this.mapWidth / 2, 
            centerZ, 
            borderWidth, 
            this.mapLength
        );
        
        // Front border (negative Z)
        const frontBorder = createBorderSegment(
            centerX, 
            centerZ - this.mapLength / 2, 
            this.mapWidth, 
            borderWidth
        );
        
        // Back border (positive Z)
        const backBorder = createBorderSegment(
            centerX, 
            centerZ + this.mapLength / 2, 
            this.mapWidth, 
            borderWidth
        );
    }
    
    /**
     * Add simple buildings to the map for cover
     * @param {number} centerX - X center of the map
     * @param {number} centerZ - Z center of the map
     */
    addSimpleBuildings(centerX, centerZ) {
        // Add a few primitive buildings scattered around
        const buildingCount = 8;
        const buildingPositions = [];
        
        // Ensure buildings don't overlap by keeping track of positions
        for (let i = 0; i < buildingCount; i++) {
            let validPosition = false;
            let x, z;
            
            // Try to find a non-overlapping position
            for (let attempts = 0; attempts < 10 && !validPosition; attempts++) {
                // Random position within the map
                x = centerX + (Math.random() - 0.5) * (this.mapWidth - 6);
                z = centerZ + (Math.random() - 0.5) * (this.mapLength - 6);
                
                validPosition = true;
                
                // Check against existing buildings
                for (const pos of buildingPositions) {
                    const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(z - pos.z, 2));
                    if (distance < 8) { // Minimum distance between buildings
                        validPosition = false;
                        break;
                    }
                }
            }
            
            if (validPosition) {
                buildingPositions.push({ x, z });
                this.createSimpleBuilding(x, z);
            }
        }
    }
    
    /**
     * Create a simple building at the specified position
     * @param {number} x - X position
     * @param {number} z - Z position
     */
    createSimpleBuilding(x, z) {
        // Randomize building dimensions
        const width = 3 + Math.random() * 3;
        const height = 3 + Math.random() * 2;
        const depth = 3 + Math.random() * 3;
        
        const buildingGroup = new THREE.Group();
        
        // Building body
        const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
        const buildingMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, // Brown variations
            roughness: 0.8,
            metalness: 0.2
        });
        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
        building.position.set(0, height / 2, 0);
        building.castShadow = true;
        building.receiveShadow = true;
        buildingGroup.add(building);
        
        // Simple flat roof
        const roofGeometry = new THREE.BoxGeometry(width + 0.5, 0.2, depth + 0.5);
        const roofMaterial = new THREE.MeshStandardMaterial({
            color: 0x4D3300, // Darker brown
            roughness: 0.9,
            metalness: 0.1
        });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.set(0, height + 0.1, 0);
        roof.castShadow = true;
        buildingGroup.add(roof);
        
        // Add some simple windows and a door
        // Door
        if (Math.random() > 0.5) {
            const doorGeometry = new THREE.PlaneGeometry(1, 2);
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x4D2600, // Dark brown
                roughness: 0.8,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1, depth / 2 + 0.01);
            buildingGroup.add(door);
        }
        
        // Add 1-3 windows
        const windowCount = 1 + Math.floor(Math.random() * 3);
        for (let i = 0; i < windowCount; i++) {
            const windowGeometry = new THREE.PlaneGeometry(0.8, 0.8);
            const windowMaterial = new THREE.MeshStandardMaterial({
                color: 0xECF0F1, // White-ish
                roughness: 0.4,
                metalness: 0.6,
                side: THREE.DoubleSide
            });
            
            // Create window
            const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
            
            // Decide which wall to place the window on
            const wallIndex = Math.floor(Math.random() * 4);
            switch (wallIndex) {
                case 0: // Front wall
                    windowMesh.position.set(-width / 4 + i * width / 2, height / 2, depth / 2 + 0.01);
                    break;
                case 1: // Back wall
                    windowMesh.position.set(-width / 4 + i * width / 2, height / 2, -depth / 2 - 0.01);
                    windowMesh.rotation.y = Math.PI;
                    break;
                case 2: // Left wall
                    windowMesh.position.set(-width / 2 - 0.01, height / 2, -depth / 4 + i * depth / 2);
                    windowMesh.rotation.y = -Math.PI / 2;
                    break;
                case 3: // Right wall
                    windowMesh.position.set(width / 2 + 0.01, height / 2, -depth / 4 + i * depth / 2);
                    windowMesh.rotation.y = Math.PI / 2;
                    break;
            }
            
            buildingGroup.add(windowMesh);
        }
        
        // Position the building
        buildingGroup.position.set(x, 0, z);
        
        // Random rotation for variety
        buildingGroup.rotation.y = Math.random() * Math.PI * 2;
        
        this.gameAreaGroup.add(buildingGroup);
    }
    
    /**
   * Create a physics boundary for the shootout map
   */
  createMapBoundary() {
    if (!this.physics) return;
    
    // Remove any existing boundary first
    this.removeMapBoundary();
    
    // Create a box boundary around the map
    const boundaryBody = new CANNON.Body({
      mass: 0, // Static body
      material: this.physics.defaultMaterial
    });
    
    // Add a box shape for each border
    const halfWidth = this.mapWidth / 2;
    const halfLength = this.mapLength / 2;
    const borderThickness = 1;
    const wallHeight = 5;
    
    // Left border (negative X)
    const leftBorderShape = new CANNON.Box(new CANNON.Vec3(
      borderThickness / 2, 
      wallHeight / 2, 
      halfLength
    ));
    boundaryBody.addShape(
      leftBorderShape, 
      new CANNON.Vec3(this.mapCenter.x - halfWidth, wallHeight / 2, this.mapCenter.z)
    );
    
    // Right border (positive X)
    const rightBorderShape = new CANNON.Box(new CANNON.Vec3(
      borderThickness / 2, 
      wallHeight / 2, 
      halfLength
    ));
    boundaryBody.addShape(
      rightBorderShape, 
      new CANNON.Vec3(this.mapCenter.x + halfWidth, wallHeight / 2, this.mapCenter.z)
    );
    
    // Front border (negative Z)
    const frontBorderShape = new CANNON.Box(new CANNON.Vec3(
      halfWidth, 
      wallHeight / 2, 
      borderThickness / 2
    ));
    boundaryBody.addShape(
      frontBorderShape, 
      new CANNON.Vec3(this.mapCenter.x, wallHeight / 2, this.mapCenter.z - halfLength)
    );
    
    // Back border (positive Z)
    const backBorderShape = new CANNON.Box(new CANNON.Vec3(
      halfWidth, 
      wallHeight / 2, 
      borderThickness / 2
    ));
    boundaryBody.addShape(
      backBorderShape, 
      new CANNON.Vec3(this.mapCenter.x, wallHeight / 2, this.mapCenter.z + halfLength)
    );
    
    boundaryBody.mapBoundary = true; // Tag this body as a map boundary
    boundaryBody.collisionFilterGroup = 2; // Group 2 for boundaries
    
    // Add the boundary body to the world
    this.physics.world.addBody(boundaryBody);
    this.physics.bodies.push(boundaryBody);
    
    // Store a reference to easily find this body later
    this.mapBoundaryBody = boundaryBody;
    
    // If debug mode is enabled, create a visual representation
    if (this.physics.debugMode) {
      this.physics.createDebugMesh(boundaryBody);
      console.log("Creating debug visualization for shootout map boundary");
    }
    
    console.log("Created shootout map boundary");
  }
    
    /**
     * Remove the map boundary
     */
    removeMapBoundary() {
        if (this.mapBoundaryBody && this.physics) {
            this.physics.world.removeBody(this.mapBoundaryBody);
            
            // Remove from physics bodies array
            const index = this.physics.bodies.indexOf(this.mapBoundaryBody);
            if (index !== -1) {
                this.physics.bodies.splice(index, 1);
            }
            
            // Clear the reference
            this.mapBoundaryBody = null;
            console.log("Removed shootout map boundary");
        }
    }
    
    /**
     * Initialize network handlers for Proper Shootout game mode.
     */
    initNetworkHandlers() {
        // Extend existing network manager with Proper Shootout methods
        this.networkManager.sendProperShootoutJoin = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'properShootoutJoin'
                }));
            }
        };
        
        this.networkManager.sendProperShootoutLeave = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'properShootoutLeave'
                }));
            }
        };
        
        // Hook into the existing socket onmessage handler
        const originalOnMessage = this.networkManager.socket.onmessage;
        this.networkManager.socket.onmessage = (event) => {
            // Call original handler
            if (originalOnMessage) {
                originalOnMessage(event);
            }
            
            try {
                const message = JSON.parse(event.data);
                
                // Handle Proper Shootout specific messages
                switch (message.type) {
                    case 'properShootoutJoin':
                        this.handleJoinConfirmation(message);
                        break;
                    case 'properShootoutLeave':
                        this.handleLeaveConfirmation(message);
                        break;
                    case 'properShootoutKill':
                        this.handleKillNotification(message);
                        break;
                    case 'properShootoutScores':
                        this.updateScores(message.scores);
                        break;
                    case 'properShootoutPlayerJoin':
                        this.handlePlayerJoin(message);
                        break;
                    case 'properShootoutPlayerLeave':
                        this.handlePlayerLeave(message);
                        break;
                    case 'properShootoutEnd':
                        this.handleMatchEnd(message);
                        break;
                }
            } catch (err) {
                console.error('Error parsing Proper Shootout message:', err);
            }
        };
    }
    
    /**
   * Update method called from main animation loop.
   */
  update(deltaTime) {
    // Skip if player not loaded
    if (!this.localPlayer || !this.localPlayer.group) {
      return;
    }
    
    // Update physics system
    if (this.physics) {
      this.physics.update(deltaTime);
      
      // If the player is in the shootout map, enforce map boundary collision
      if (this.inLobby && this.mapBoundaryBody) {
        const playerPos = this.localPlayer.group.position.clone();
        const isInMap = this.isPointInMap(playerPos);
        
        if (!isInMap) {
          // If player is outside the map, push them back in
          const dirToCenter = new THREE.Vector3(
            this.mapCenter.x - playerPos.x,
            0,
            this.mapCenter.z - playerPos.z
          ).normalize();
          
          // Move player back inside
          this.localPlayer.group.position.x += dirToCenter.x * 0.1;
          this.localPlayer.group.position.z += dirToCenter.z * 0.1;
        }
        
        // Make sure map boundary is visualized in debug mode - with proper null checking
        if (this.physics.debugMode && this.mapBoundaryBody) {
          // Check if debugMeshes array exists and has items
          let hasDebugMesh = false;
          if (this.physics.debugMeshes && Array.isArray(this.physics.debugMeshes)) {
            hasDebugMesh = this.physics.debugMeshes.some(item => item && item.body === this.mapBoundaryBody);
          }
          
          if (!hasDebugMesh) {
            this.physics.createDebugMesh(this.mapBoundaryBody);
            console.log("Recreating debug visualization for shootout map boundary");
          }
        }
      }
    }
    
    // Update portal instruction visibility
    this.updatePortalInstructions();

    // Check for portal collision when not in lobby
    if (!this.inLobby) {
        const playerPos = this.localPlayer.group.position.clone();
        
        // Check if player is colliding with the portal
        if (this.portalCollider && this.portalCollider.containsPoint(playerPos)) {
            this.joinMatch();
        }
    }
  }
    
    /**
     * Check if a point is inside the map
     * @param {THREE.Vector3} point - The point to check
     * @returns {boolean} - True if inside the map
     */
    isPointInMap(point) {
        // Simple rectangular check
        return (
            point.x >= this.mapCenter.x - this.mapWidth / 2 &&
            point.x <= this.mapCenter.x + this.mapWidth / 2 &&
            point.z >= this.mapCenter.z - this.mapLength / 2 &&
            point.z <= this.mapCenter.z + this.mapLength / 2
        );
    }
    
    /**
     * Check if player is near the portal and show appropriate instructions
     */
    updatePortalInstructions() {
        if (!this.localPlayer || !this.localPlayer.group) {
            return;
        }
        
        const playerPos = this.localPlayer.group.position.clone();
        
        // Check if near portal
        if (this.portalProximityBox && this.portalProximityBox.containsPoint(playerPos) && 
            !this.inLobby) {
            // Show portal instructions
            if (this.instructionsElement) {
                this.instructionsElement.style.display = 'block';
            }
        } else {
            // Hide instructions
            if (this.instructionsElement) {
                this.instructionsElement.style.display = 'none';
            }
        }
    }
    
    /**
     * Updates the status indicator.
     */
    updateStatusIndicator() {
        if (!this.statusIndicator) return;
        
        if (this.inLobby) {
            this.statusIndicator.textContent = `Proper Shootout: ${this.kills} / 10 kills`;
            this.statusIndicator.style.display = 'block';
            this.statusIndicator.style.backgroundColor = 'rgba(76, 175, 80, 0.7)'; // Green
        } else {
            this.statusIndicator.style.display = 'none';
        }
    }
    
    /**
     * Updates the scoreboard with player scores
     * @param {Array} scores - Array of {playerId, playerName, kills}
     */
    updateScoreboard(scores) {
        if (!this.scoreboard) return;
        
        if (!this.inLobby) {
            this.scoreboard.style.display = 'none';
            return;
        }
        
        this.scoreboard.style.display = 'block';
        
        // Sort scores by kills in descending order
        scores.sort((a, b) => b.kills - a.kills);
        
        // Create HTML content
        let html = '<h3>Scoreboard</h3><table style="width:100%">';
        html += '<tr><th style="text-align:left">Player</th><th style="text-align:right">Kills</th></tr>';
        
        scores.forEach(score => {
            // Highlight local player
            const isLocalPlayer = score.playerId === this.localPlayer.id;
            const style = isLocalPlayer ? 'color:#4CAF50;font-weight:bold;' : '';
            
            html += `<tr style="${style}">
                <td>${isLocalPlayer ? 'You' : 'Player ' + score.playerId}</td>
                <td style="text-align:right">${score.kills}</td>
            </tr>`;
        });
        
        html += '</table>';
        this.scoreboard.innerHTML = html;
    }
    
    /**
     * Join the Proper Shootout match
     */
    joinMatch() {
        if (this.inLobby) {
            return; // Already in a match
        }
        
        this.showMessage('Joining Shootout match...');
        
        // Send join request to server
        this.networkManager.sendProperShootoutJoin();
        
        console.log("Sent request to join Proper Shootout match");
    }
    
    /**
     * Handle join confirmation from server
     * @param {Object} message - Server message
     */
    handleJoinConfirmation(message) {
        this.inLobby = true;
        this.lobbyId = message.lobbyId;
        this.kills = 0;
        
        // Make the game area visible
        this.gameAreaGroup.visible = true;
        
        // Teleport player to a random position in the map
        this.respawnAtRandomPosition();
        
        // Show UI elements
        this.exitButton.style.display = 'block';
        this.updateStatusIndicator();
        this.updateScores(message.scores || []);
        
        // Show welcome message
        this.showMessage('Joined Shootout match!', 2000);
        
        console.log(`Joined Proper Shootout match with lobby ID: ${this.lobbyId}`);
    }
    
    /**
     * Leave the current match
     */
    leaveMatch() {
        if (!this.inLobby) {
            return; // Not in a match
        }
        
        // Send leave request to server
        this.networkManager.sendProperShootoutLeave();
        
        // Handle cleanup locally in case server message is delayed
        this.handleLeaveConfirmation();
    }
    
    /**
     * Handle leave confirmation
     */
    handleLeaveConfirmation() {
        this.inLobby = false;
        this.lobbyId = null;
        this.kills = 0;
        
        // Hide game area
        this.gameAreaGroup.visible = false;
        
        // Hide UI elements
        this.exitButton.style.display = 'none';
        this.statusIndicator.style.display = 'none';
        this.scoreboard.style.display = 'none';
        
        // Return player to town
        this.localPlayer.spawnPlayerRandomly();
        
        console.log("Left Proper Shootout match");
    }
    
    /**
     * Handle notification that another player joined the match
     * @param {Object} message - Server message with player info
     */
    handlePlayerJoin(message) {
        if (!this.inLobby) return;
        
        this.showMessage(`Player ${message.playerId} joined the match!`, 2000);
        
        // Update scoreboard if scores are provided
        if (message.scores) {
            this.updateScores(message.scores);
        }
    }
    
    /**
     * Handle notification that another player left the match
     * @param {Object} message - Server message with player info
     */
    handlePlayerLeave(message) {
        if (!this.inLobby) return;
        
        this.showMessage(`Player ${message.playerId} left the match!`, 2000);
        
        // Update scoreboard if scores are provided
        if (message.scores) {
            this.updateScores(message.scores);
        }
    }
    
    /**
     * Handle kill notification
     * @param {Object} message - Kill notification with killer and victim info
     */
    handleKillNotification(message) {
        if (!this.inLobby) return;
        
        const killerId = message.killerId;
        const victimId = message.victimId;
        
        // Check if local player got a kill
        if (killerId === this.localPlayer.id) {
            this.kills++;
            this.updateStatusIndicator();
            
            // Show kill message
            this.showMessage(`You killed Player ${victimId}!`, 2000);
        }
        // Check if local player was killed
        else if (victimId === this.localPlayer.id) {
            // Show death message
            this.showMessage(`Killed by Player ${killerId}!`, 2000);
            
            // Respawn after a short delay
            setTimeout(() => {
                this.respawnAtRandomPosition();
            }, 2000);
        }
        // Another player killed another player
        else {
            this.showMessage(`Player ${killerId} killed Player ${victimId}!`, 2000);
        }
        
        // Update scoreboard if scores are provided
        if (message.scores) {
            this.updateScores(message.scores);
        }
    }
    
    /**
     * Update scores from server
     * @param {Array} scores - Array of {playerId, kills}
     */
    updateScores(scores) {
        if (!this.inLobby) return;
        
        // Store scores locally
        this.playerScores.clear();
        scores.forEach(score => {
            this.playerScores.set(score.playerId, score.kills);
            
            // Update local kills if it's the local player
            if (score.playerId === this.localPlayer.id) {
                this.kills = score.kills;
                this.updateStatusIndicator();
            }
        });
        
        // Update scoreboard UI
        this.updateScoreboard(scores);
    }
    
    /**
     * Handle match end notification
     * @param {Object} message - Match end info with winner
     */
    handleMatchEnd(message) {
        if (!this.inLobby) return;
        
        const winnerId = message.winnerId;
        const isLocalPlayerWinner = winnerId === this.localPlayer.id;
        
        // Show end message
        if (isLocalPlayerWinner) {
            this.showMessage('You won the match!', 3000);
        } else {
            this.showMessage(`Player ${winnerId} won the match!`, 3000);
        }
        
        // Return to town after a delay
        setTimeout(() => {
            this.handleLeaveConfirmation();
        }, 3000);
    }
    
    /**
     * Respawn player at a random position within the map
     */
    respawnAtRandomPosition() {
        if (!this.localPlayer) return;
        
        // Generate random position within the map
        const x = this.mapCenter.x + (Math.random() - 0.5) * (this.mapWidth - 5);
        const y = 1.6;
        const z = this.mapCenter.z + (Math.random() - 0.5) * (this.mapLength - 5);
        
        // Teleport player
        this.localPlayer.group.position.set(x, y, z);
        
        // Random rotation
        this.localPlayer.group.rotation.y = Math.random() * Math.PI * 2;
        
        // Reset health
        this.localPlayer.health = 100;
        if (typeof window.updateHealthUI === 'function') {
            window.updateHealthUI(this.localPlayer);
        }
    }
    
    /**
     * Helper to show a message in the center of the screen.
     * @param {string} message - The message to display
     * @param {number} duration - How long to show the message (0 = indefinite)
     */
    showMessage(message, duration = 0) {
        if (!this.messageOverlay) return;
        
        this.messageOverlay.textContent = message;
        this.messageOverlay.style.display = 'block';
        
        if (duration > 0) {
            setTimeout(() => {
                this.messageOverlay.style.display = 'none';
            }, duration);
        }
    }
    
    /**
     * Cleanup resources.
     */
    cleanup() {
        // Leave any active match
        if (this.inLobby) {
            this.leaveMatch();
        }
        
        // Remove the portal group
        if (this.portalGroup) {
            this.scene.remove(this.portalGroup);
            this.portalGroup.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        // Remove game area
        if (this.gameAreaGroup) {
            this.scene.remove(this.gameAreaGroup);
            this.gameAreaGroup.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        // Remove instruction elements
        if (this.instructionsElement && this.instructionsElement.parentNode) {
            this.instructionsElement.parentNode.removeChild(this.instructionsElement);
        }
        
        // Clean up physics
        this.removeMapBoundary();
        if (this.physics) {
            this.physics.cleanup();
        }
        
        // Remove UI elements
        if (this.messageOverlay && this.messageOverlay.parentNode) {
            this.messageOverlay.parentNode.removeChild(this.messageOverlay);
        }
        
        if (this.statusIndicator && this.statusIndicator.parentNode) {
            this.statusIndicator.parentNode.removeChild(this.statusIndicator);
        }
        
        if (this.scoreboard && this.scoreboard.parentNode) {
            this.scoreboard.parentNode.removeChild(this.scoreboard);
        }
        
        if (this.exitButton && this.exitButton.parentNode) {
            this.exitButton.parentNode.removeChild(this.exitButton);
        }
    }
}

================================================
File: /public/js/quickDraw.js
================================================
/**
 * Quick Draw game mode implementation
 * Players face off in a wild west duel where they must wait for the "draw" signal
 * before pulling their revolvers and shooting at each other.
 * Now with a single portal that automatically assigns players to available arenas.
 */

import { PhysicsSystem } from './physics.js';

export class QuickDraw {
    constructor(scene, localPlayer, networkManager, soundManager) {
        this.scene = scene;
        this.localPlayer = localPlayer;
        this.networkManager = networkManager;
        this.soundManager = soundManager;
        
        // Game state
        this.inLobby = false;
        this.inDuel = false;
        this.duelOpponentId = null;
        this.duelState = 'none'; // 'none', 'ready', 'countdown', 'draw'
        this.gunLocked = false;
        this.originalCanAim = true;
        // Record the time (in ms) until which the gun remains locked
        this.penaltyEndTime = 0;
        
        // Current active arena index (0-4, -1 means none)
        this.activeArenaIndex = -1;
        
        // Arena configurations
        this.maxArenas = 5; // Support for 5 concurrent lobbies as requested
        this.arenaConfigs = this.createArenaConfigs();
        
        // Initialize physics system for collision detection
        this.physics = new PhysicsSystem();
        
        // Track arena physics bodies
        this.arenaBoundaries = new Array(this.maxArenas).fill(null);
        
        // Initialize the single portal, duel areas, and network handlers
        this.initPortal();
        this.createDuelAreas();
        this.initNetworkHandlers();
        this.createUI();

        // Make this instance globally accessible for network handlers
        window.quickDraw = this;
    }
    
    /**
     * Create arena configurations with different positions
     */
    createArenaConfigs() {
        const configs = [];
        // Positioning logic - arenas are placed in a row with proper spacing
        
        // Calculate base position - if town dimensions are available, place them outside town
        let baseZ = 0;
        if (window.townDimensions) {
            baseZ = window.townDimensions.length + 50; // Position outside town boundary
        } else {
            baseZ = 100; // Default position if town dimensions aren't available
        }
        
        // Arena spacing - make sure they don't overlap
        const spacingX = 50; // Allow enough space between arenas
        
        // Create 5 arena configs
        for (let i = 0; i < this.maxArenas; i++) {
            // Calculate position - arrange in a row along X axis
            let offsetX = (i - 2) * spacingX; // Center on zero, spread outward
            
            configs.push({
                index: i,
                center: new THREE.Vector3(offsetX, 0, baseZ),
                radius: 15,  // Arena radius
                height: 5,   // Arena height
                portalColor: this.getPortalColor(i),
                active: false, // Whether this arena is currently in use
                portalCollider: null, // Will store collision box for the portal
                duelArea: null, // Will store the THREE.Group for the arena
                duelAreaActive: false // Track if this duel area is currently visible
            });
        }
        
        return configs;
    }
    
    /**
     * Get a unique color for each portal
     */
    getPortalColor(index) {
        const colors = [
            0xFF6B00, // Orange (original)
            0x4CAF50, // Green
            0x2196F3, // Blue
            0x9C27B0, // Purple
            0xFFEB3B  // Yellow
        ];
        
        return colors[index % colors.length];
    }
    
    /**
     * Create UI elements for Quick Draw game mode.
     */
    createUI() {
        // Text overlay for messages
        this.messageOverlay = document.createElement('div');
        this.messageOverlay.id = 'quick-draw-message';
        this.messageOverlay.style.position = 'absolute';
        this.messageOverlay.style.top = '50%';
        this.messageOverlay.style.left = '50%';
        this.messageOverlay.style.transform = 'translate(-50%, -50%)';
        this.messageOverlay.style.color = 'white';
        this.messageOverlay.style.fontSize = '48px';
        this.messageOverlay.style.fontWeight = 'bold';
        this.messageOverlay.style.textAlign = 'center';
        this.messageOverlay.style.display = 'none';
        this.messageOverlay.style.fontFamily = 'Western, Arial, sans-serif';
        this.messageOverlay.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
        this.messageOverlay.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(this.messageOverlay);
        
        // Draw circle animation
        this.drawCircle = document.createElement('div');
        this.drawCircle.id = 'draw-circle';
        this.drawCircle.style.position = 'absolute';
        this.drawCircle.style.top = '50%';
        this.drawCircle.style.left = '50%';
        this.drawCircle.style.transform = 'translate(-50%, -50%) scale(0)';
        this.drawCircle.style.width = '600px';
        this.drawCircle.style.height = '600px';
        this.drawCircle.style.borderRadius = '50%';
        this.drawCircle.style.border = '8px solid #FF0000';
        this.drawCircle.style.boxShadow = '0 0 20px #FF0000';
        this.drawCircle.style.opacity = '0';
        this.drawCircle.style.transition = 'transform 0.3s, opacity 0.3s';
        this.drawCircle.style.pointerEvents = 'none';
        this.drawCircle.style.zIndex = '999';
        this.drawCircle.style.display = 'none';
        document.getElementById('game-container').appendChild(this.drawCircle);
        
        // Add status indicator
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.id = 'quick-draw-status';
        this.statusIndicator.style.position = 'absolute';
        this.statusIndicator.style.top = '120px';
        this.statusIndicator.style.left = '20px';
        this.statusIndicator.style.color = 'white';
        this.statusIndicator.style.fontSize = '16px';
        this.statusIndicator.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.statusIndicator.style.padding = '5px';
        this.statusIndicator.style.borderRadius = '5px';
        this.statusIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.statusIndicator);
        
        // Add lobby indicator
        this.lobbyIndicator = document.createElement('div');
        this.lobbyIndicator.id = 'lobby-indicator';
        this.lobbyIndicator.style.position = 'absolute';
        this.lobbyIndicator.style.top = '150px';
        this.lobbyIndicator.style.left = '20px';
        this.lobbyIndicator.style.color = 'white';
        this.lobbyIndicator.style.fontSize = '16px';
        this.lobbyIndicator.style.backgroundColor = 'rgba(255, 107, 0, 0.7)';
        this.lobbyIndicator.style.padding = '8px 12px';
        this.lobbyIndicator.style.borderRadius = '5px';
        this.lobbyIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.lobbyIndicator);
    }
    
    /**
     * Initialize the single portal for all Quick Draw arenas
     */
    initPortal() {
        this.portalGroup = new THREE.Group();
        
        // Calculate portal position
        let portalX = 0;
        let portalY = 2.5; // Increased Y position for a taller portal
        let portalZ = 0;
        
        // If town dimensions are available, use them for positioning
        if (window.townDimensions) {
            const streetWidth = window.townDimensions.streetWidth;
            const townLength = window.townDimensions.length;
            
            // Position portal on the side of the street in the center of town
            portalX = streetWidth * 0.4; // Move to the right side of the street
            portalZ = 0; // Center of town (Z axis)
        }
        
        // Create a wooden frame portal
        this.createWoodenFramePortal(portalX, portalY, portalZ);
        
        // Create collision detector for the portal - make it larger to match the bigger portal
        const portalCollider = new THREE.Box3(
            new THREE.Vector3(portalX - 2.5, 0, portalZ - 1),
            new THREE.Vector3(portalX + 2.5, portalY * 2, portalZ + 1)
        );
        
        // Store the collider for all arena configs to reference the same portal
        for (let i = 0; i < this.maxArenas; i++) {
            this.arenaConfigs[i].portalCollider = portalCollider;
        }
        
        this.scene.add(this.portalGroup);
        
        // Create portal instructions
        this.createPortalInstructions(new THREE.Vector3(portalX, portalY, portalZ));
    }
    
    /**
     * Creates a wooden frame portal with Minecraft-like portal filling and a wooden sign on top
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} z - Z position
     */
    createWoodenFramePortal(x, y, z) {
        const frameWidth = 5; // Wider frame
        const frameHeight = 7; // Taller frame
        const beamThickness = 0.25; // Thicker beams
        
        // Create wooden beam material with more texture
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,  // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        // Create the wooden frame beams
        // Top beam
        const topBeam = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, beamThickness, beamThickness),
            woodMaterial
        );
        topBeam.position.set(0, frameHeight/2, 0);
        this.portalGroup.add(topBeam);
        
        // Bottom beam
        const bottomBeam = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, beamThickness, beamThickness),
            woodMaterial
        );
        bottomBeam.position.set(0, -frameHeight/2, 0);
        this.portalGroup.add(bottomBeam);
        
        // Left beam
        const leftBeam = new THREE.Mesh(
            new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness),
            woodMaterial
        );
        leftBeam.position.set(-frameWidth/2, 0, 0);
        this.portalGroup.add(leftBeam);
        
        // Right beam
        const rightBeam = new THREE.Mesh(
            new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness),
            woodMaterial
        );
        rightBeam.position.set(frameWidth/2, 0, 0);
        this.portalGroup.add(rightBeam);
        
        // Create the Minecraft-like portal filling with a more static appearance
        const fillingGeometry = new THREE.PlaneGeometry(frameWidth - beamThickness, frameHeight - beamThickness, 32, 32); // More segments for wave effect
        
        // Create a custom shader material for Minecraft nether portal effect - more static version
        const fillingMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                uniform float time;
                
                void main() {
                    vUv = uv;
                    // Add very subtle displacement to vertices
                    vec3 pos = position;
                    pos.x += sin(position.y * 2.0 + time * 0.5) * 0.01;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                
                // Simple noise function
                float noise(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                void main() {
                    // Static blue base with subtle animated swirls
                    vec3 baseColor = vec3(0.0, 0.3, 0.8); // Blue base
                    
                    // Add subtle swirl pattern
                    float swirl = sin(vUv.x * vUv.y * 10.0 + time * 0.2) * 0.1;
                    
                    // Add a bit of noise pattern
                    float noiseVal = noise(vUv * 5.0 + vec2(time * 0.05, time * 0.03));
                    
                    // Mix colors for subtle effect
                    vec3 color = mix(baseColor, vec3(0.2, 0.6, 1.0), swirl + noiseVal * 0.1);
                    
                    // Add edge glow
                    float edgeX = smoothstep(0.0, 0.07, vUv.x) * smoothstep(1.0, 0.93, vUv.x);
                    float edgeY = smoothstep(0.0, 0.07, vUv.y) * smoothstep(1.0, 0.93, vUv.y);
                    float edge = edgeX * edgeY;
                    
                    // Subtle pulsing
                    float pulse = 0.9 + sin(time * 0.5) * 0.1;
                    color = mix(color, vec3(0.4, 0.7, 1.0), (1.0 - edge) * pulse * 0.2);
                    
                    gl_FragColor = vec4(color, 0.9); // Slightly transparent
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        const filling = new THREE.Mesh(fillingGeometry, fillingMaterial);
        filling.position.set(0, 0, -0.05);
        this.portalGroup.add(filling);
        
        // Update the time uniform in the shader
        this.animatePortalFilling(fillingMaterial);
        
        // Create a wooden sign on top of the portal
        this.createWoodenSign(frameWidth, frameHeight);
        
        // Add particle effect around the portal
        this.addPortalParticles(frameWidth, frameHeight);
        
        // Position the portal
        this.portalGroup.position.set(x, y, z);
        this.portalGroup.rotation.y = Math.PI / 2; // Make it vertical and facing the street
    }
    
    /**
     * Creates a wooden sign on top of the portal with text visible from both sides
     * @param {number} frameWidth - Width of the portal frame
     * @param {number} frameHeight - Height of the portal frame
     */
    createWoodenSign(frameWidth, frameHeight) {
        // Create wooden sign material
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,  // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        // Create sign post
        const signWidth = frameWidth * 0.8;
        const signHeight = 0.8;
        const signDepth = 0.1;
        
        // Create the wooden sign board
        const signGeometry = new THREE.BoxGeometry(signWidth, signHeight, signDepth);
        const sign = new THREE.Mesh(signGeometry, woodMaterial);
        
        // Position the sign above the portal
        sign.position.set(0, frameHeight/2 + signHeight/2 + 0.1, 0);
        
        // Create two small posts to connect the sign to the portal frame
        const postGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
        
        // Left post
        const leftPost = new THREE.Mesh(postGeometry, woodMaterial);
        leftPost.position.set(-signWidth/3, frameHeight/2 + 0.2, 0);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeometry, woodMaterial);
        rightPost.position.set(signWidth/3, frameHeight/2 + 0.2, 0);
        
        // Create text for both sides of the sign
        const createSignText = (isBack) => {
            const textCanvas = document.createElement('canvas');
            const context = textCanvas.getContext('2d');
            textCanvas.width = 512;
            textCanvas.height = 128;
            
            // Clear background
            context.fillStyle = '#8B4513'; // Match the wood color
            context.fillRect(0, 0, textCanvas.width, textCanvas.height);
            
            // Add wood grain texture
            context.strokeStyle = '#6B3F13'; // Darker wood color for grain
            context.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                const y = i * 7;
                context.beginPath();
                context.moveTo(0, y);
                // Wavy line for wood grain
                for (let x = 0; x < textCanvas.width; x += 20) {
                    context.lineTo(x + 10, y + (Math.random() * 4 - 2));
                }
                context.stroke();
            }
            
            // Add text
            context.fillStyle = 'white';
            context.font = 'bold 70px Western, Arial, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('Join 1v1', 256, 64);
            
            // Add a slightly darker stroke to make text more readable
            context.strokeStyle = 'rgba(0,0,0,0.5)';
            context.lineWidth = 2;
            context.strokeText('Join 1v1', 256, 64);
            
            const texture = new THREE.CanvasTexture(textCanvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });
            
            // Create text plane slightly larger than the sign to avoid z-fighting
            const textGeometry = new THREE.PlaneGeometry(signWidth - 0.05, signHeight - 0.05);
            const textMesh = new THREE.Mesh(textGeometry, material);
            
            // Position text just in front of the sign
            const zOffset = isBack ? -signDepth/2 - 0.01 : signDepth/2 + 0.01;
            textMesh.position.set(0, 0, zOffset);
            
            // If this is the back face, rotate it 180 degrees
            if (isBack) {
                textMesh.rotation.y = Math.PI;
            }
            
            return textMesh;
        };
        
        // Create front and back text
        const frontText = createSignText(false);
        const backText = createSignText(true);
        
        // Add text to sign
        sign.add(frontText);
        sign.add(backText);
        
        // Add everything to the portal group
        this.portalGroup.add(sign);
        this.portalGroup.add(leftPost);
        this.portalGroup.add(rightPost);
    }
    
    /**
     * Adds particle effects around the portal to enhance the Minecraft feel
     * @param {number} width - Width of the portal
     * @param {number} height - Height of the portal
     */
    addPortalParticles(width, height) {
        const particleCount = 50;
        const particleGroup = new THREE.Group();
        
        // Create particle material (white to contrast with blue portal)
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.15,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        
        // Create particle geometry
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = []; // Store velocities for animation
        
        // Create particles around the frame
        for (let i = 0; i < particleCount; i++) {
            // Position particles around the portal frame
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = (Math.random() - 0.5) * width;
                    y = height/2 + Math.random() * 0.5;
                    break;
                case 1: // right
                    x = width/2 + Math.random() * 0.5;
                    y = (Math.random() - 0.5) * height;
                    break;
                case 2: // bottom
                    x = (Math.random() - 0.5) * width;
                    y = -height/2 - Math.random() * 0.5;
                    break;
                case 3: // left
                    x = -width/2 - Math.random() * 0.5;
                    y = (Math.random() - 0.5) * height;
                    break;
            }
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2; // Small Z variation
            
            // Random velocities moving toward the portal
            velocities.push({
                x: -x * 0.01 * (0.5 + Math.random() * 0.5),
                y: -y * 0.01 * (0.5 + Math.random() * 0.5),
                z: (Math.random() - 0.5) * 0.01,
                life: 0,
                maxLife: 60 + Math.floor(Math.random() * 60) // Random lifetime
            });
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particleGroup.add(particles);
        this.portalGroup.add(particleGroup);
        
        // Animate particles
        const animateParticles = () => {
            const positions = particles.geometry.attributes.position.array;
            
            // Update each particle
            for (let i = 0; i < particleCount; i++) {
                // Update position based on velocity
                positions[i * 3] += velocities[i].x;
                positions[i * 3 + 1] += velocities[i].y;
                positions[i * 3 + 2] += velocities[i].z;
                
                // Update life
                velocities[i].life++;
                
                // If particle has reached end of life or center of portal, reset it
                if (velocities[i].life >= velocities[i].maxLife || 
                    (Math.abs(positions[i * 3]) < 0.3 && Math.abs(positions[i * 3 + 1]) < 0.3)) {
                    
                    // Reset to edge of portal
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    
                    switch(side) {
                        case 0: // top
                            x = (Math.random() - 0.5) * width;
                            y = height/2 + Math.random() * 0.5;
                            break;
                        case 1: // right
                            x = width/2 + Math.random() * 0.5;
                            y = (Math.random() - 0.5) * height;
                            break;
                        case 2: // bottom
                            x = (Math.random() - 0.5) * width;
                            y = -height/2 - Math.random() * 0.5;
                            break;
                        case 3: // left
                            x = -width/2 - Math.random() * 0.5;
                            y = (Math.random() - 0.5) * height;
                            break;
                    }
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // New velocity
                    velocities[i] = {
                        x: -x * 0.01 * (0.5 + Math.random() * 0.5),
                        y: -y * 0.01 * (0.5 + Math.random() * 0.5),
                        z: (Math.random() - 0.5) * 0.01,
                        life: 0,
                        maxLife: 60 + Math.floor(Math.random() * 60)
                    };
                }
            }
            
            // Update geometry
            particles.geometry.attributes.position.needsUpdate = true;
            
            requestAnimationFrame(animateParticles);
        };
        
        requestAnimationFrame(animateParticles);
    }
    
    /**
     * Animate the portal filling shader
     * @param {THREE.ShaderMaterial} material - The shader material to animate
     */
    animatePortalFilling(material) {
        const animate = () => {
            material.uniforms.time.value += 0.01;
            requestAnimationFrame(animate);
        };
        
        requestAnimationFrame(animate);
    }
    
    /**
     * Creates a floating instruction panel for the portal
     * @param {THREE.Vector3} portalPosition - The position of the portal
     */
    createPortalInstructions(portalPosition) {
        // Create a container for the instructions
        const instructionsId = 'portal-instructions';
        
        // Check if it already exists
        let instructionsElement = document.getElementById(instructionsId);
        if (!instructionsElement) {
            instructionsElement = document.createElement('div');
            instructionsElement.id = instructionsId;
            instructionsElement.className = 'portal-instructions';
            instructionsElement.style.position = 'absolute';
            instructionsElement.style.top = '35%';
            instructionsElement.style.left = '50%';
            instructionsElement.style.transform = 'translate(-50%, -50%)';
            instructionsElement.style.color = 'white';
            instructionsElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
            instructionsElement.style.padding = '20px';
            instructionsElement.style.borderRadius = '10px';
            instructionsElement.style.textAlign = 'center';
            instructionsElement.style.width = '400px';
            instructionsElement.style.display = 'none';
            instructionsElement.style.zIndex = '500';
            instructionsElement.style.fontFamily = 'Arial, sans-serif';
            
            instructionsElement.innerHTML = `
                <h2 style="color:#FF6B00; margin-bottom:10px;">Quick Draw Duel</h2>
                <p>Step into the portal to challenge another player to a classic western showdown!</p>
                <ul style="text-align:left; margin-top:10px; padding-left:20px;">
                    <li>Wait for opponent and follow the "READY?" signal</li>
                    <li>Keep your gun holstered until you see "DRAW!"</li>
                    <li>Drawing too early will lock your gun for 3 seconds</li>
                    <li>First player to hit their opponent wins!</li>
                </ul>
            `;
            
            document.getElementById('game-container').appendChild(instructionsElement);
        }
        
        // Show instructions when player gets close to portal
        // Adjust the proximity box based on portal position
        const proximityBox = new THREE.Box3(
            new THREE.Vector3(portalPosition.x - 4, portalPosition.y - 4, portalPosition.z - 4),
            new THREE.Vector3(portalPosition.x + 4, portalPosition.y + 4, portalPosition.z + 4)
        );
        
        // Store the box reference and element for the portal
        this.portalProximityBox = proximityBox;
        this.instructionsElement = instructionsElement;
    }
    
    /**
     * Check if player is near the portal and show appropriate instructions
     */
    updatePortalInstructions() {
        if (!this.localPlayer || !this.localPlayer.group) {
            return;
        }
        
        const playerPos = this.localPlayer.group.position.clone();
        
        // Check if near portal
        if (this.portalProximityBox && this.portalProximityBox.containsPoint(playerPos) && 
            !this.inLobby && !this.inDuel) {
            // Show portal instructions
            if (this.instructionsElement) {
                this.instructionsElement.style.display = 'block';
            }
        } else {
            // Hide instructions
            if (this.instructionsElement) {
                this.instructionsElement.style.display = 'none';
            }
        }
    }
    
    /**
     * Create all duel areas
     */
    createDuelAreas() {
        for (let i = 0; i < this.maxArenas; i++) {
            this.createDuelArea(i);
        }
    }
    
    /**
     * Create a duel area for a specific arena index
     * @param {number} arenaIndex - The arena index (0-4)
     */
    createDuelArea(arenaIndex) {
        const config = this.arenaConfigs[arenaIndex];
        const duelArea = new THREE.Group();
        
        // Ground platform
        const groundGeometry = new THREE.CircleGeometry(config.radius, 32);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xCD853F, // Sandy color
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.copy(config.center);
        ground.position.y = 0.01; // Slightly above main ground
        ground.receiveShadow = true;
        duelArea.add(ground);
        
        // Add western-themed props
        this.addDuelProps(duelArea, arenaIndex);
        
        // Initially hide the duel area
        duelArea.visible = false;
        this.scene.add(duelArea);
        
        // Store in arena config
        config.duelArea = duelArea;
    }
    
    /**
     * Add western-themed props to a specific duel area
     * @param {THREE.Group} duelArea - The duel area group to add props to
     * @param {number} arenaIndex - The arena index for variations
     */
    addDuelProps(duelArea, arenaIndex) {
        const config = this.arenaConfigs[arenaIndex];
        
        // Add cacti around the edge with variations based on arenaIndex
        const cactusCount = 6 + arenaIndex % 3; // Vary cactus count by arena
        
        for (let i = 0; i < cactusCount; i++) {
            const angle = (i / cactusCount) * Math.PI * 2;
            const distance = 12 + Math.random() * 2;
            
            const x = config.center.x + Math.cos(angle) * distance;
            const z = config.center.z + Math.sin(angle) * distance;
            
            this.createCactus(x, z, duelArea, arenaIndex);
        }
        
        // Add arena number marker in the center
        this.createArenaMarker(config.center, arenaIndex, duelArea);
    }
    
    /**
     * Create a central marker showing the arena number
     * @param {THREE.Vector3} center - The center position of the arena
     * @param {number} arenaIndex - The arena index (0-4)
     * @param {THREE.Group} duelArea - The duel area group to add the marker to
     */
    createArenaMarker(center, arenaIndex, duelArea) {
        // Create a standalone sign post
        const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
        const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const post = new THREE.Mesh(postGeometry, woodMaterial);
        post.position.set(center.x, 1, center.z);
        duelArea.add(post);
        
        // Create a sign with the arena number
        const signGeometry = new THREE.BoxGeometry(1, 0.7, 0.1);
        const signMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
        const sign = new THREE.Mesh(signGeometry, signMaterial);
        sign.position.set(center.x, 1.8, center.z);
        duelArea.add(sign);
        
        // Create a texture for the text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        context.fillStyle = 'white';
        context.font = 'bold 40px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(`#${arenaIndex + 1}`, 64, 32);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        // Apply texture to a plane in front of the sign
        const textGeometry = new THREE.PlaneGeometry(0.8, 0.5);
        const textMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
        });
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(center.x, 1.8, center.z + 0.06);
        duelArea.add(textMesh);
    }
    
    /**
     * Create a simple cactus model at the given position with variations based on arena index
     * @param {number} x - X position
     * @param {number} z - Z position
     * @param {THREE.Group} duelArea - The duel area group to add the cactus to
     * @param {number} arenaIndex - Arena index for variations
     */
    createCactus(x, z, duelArea, arenaIndex) {
        const cactusGroup = new THREE.Group();
        
        // Different cactus colors based on arena index
        const cactusColors = [
            0x2E8B57, // Sea green (default)
            0x006400, // Dark green
            0x228B22, // Forest green
            0x3CB371, // Medium sea green
            0x32CD32  // Lime green
        ];
        
        const cactusColor = cactusColors[arenaIndex % cactusColors.length];
        
        // Main body
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
        const cactusMaterial = new THREE.MeshStandardMaterial({ color: cactusColor });
        const body = new THREE.Mesh(bodyGeometry, cactusMaterial);
        body.position.y = 1;
        cactusGroup.add(body);
        
        // Add arms
        const armCount = (arenaIndex % 3) + 1; // 1, 2, or 3 arms based on arena index
        
        for (let i = 0; i < armCount; i++) {
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const arm = new THREE.Mesh(armGeometry, cactusMaterial);
            
            const angle = Math.random() * Math.PI * 2;
            const height = 0.5 + Math.random() * 1;
            
            arm.position.set(
                Math.cos(angle) * 0.3,
                height,
                Math.sin(angle) * 0.3
            );
            
            arm.rotation.z = Math.PI / 4 * (Math.random() > 0.5 ? 1 : -1);
            arm.rotation.y = angle;
            
            cactusGroup.add(arm);
        }
        
        cactusGroup.position.set(x, 0, z);
        cactusGroup.castShadow = true;
        duelArea.add(cactusGroup);
    }
    
    /**
     * Initialize network handlers for Quick Draw game mode.
     */
    initNetworkHandlers() {
        // Extend existing network manager with Quick Draw methods
        this.networkManager.sendQuickDrawJoin = (arenaIndex) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawJoin',
                    arenaIndex: arenaIndex
                }));
            }
        };
        
        this.networkManager.sendQuickDrawLeave = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawLeave'
                }));
            }
        };
        
        this.networkManager.sendQuickDrawShoot = (opponentId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                console.log(`Sending Quick Draw hit notification to server: player ${this.localPlayer.id} hit player ${opponentId}`);
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawShoot',
                    opponentId: opponentId,
                    arenaIndex: this.activeArenaIndex
                }));
            }
        };
        
        this.networkManager.sendQuickDrawReady = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawReady',
                    arenaIndex: this.activeArenaIndex
                }));
            }
        };
        
        // Hook into the existing socket onmessage handler
        const originalOnMessage = this.networkManager.socket.onmessage;
        this.networkManager.socket.onmessage = (event) => {
            // Call original handler
            if (originalOnMessage) {
                originalOnMessage(event);
            }
            
            try {
                const message = JSON.parse(event.data);
                
                // Handle Quick Draw specific messages
                switch (message.type) {
                    case 'quickDrawJoin':
                        this.handleQueueJoin(message);
                        break;
                    case 'quickDrawMatch':
                        this.handleMatchFound(message);
                        break;
                    case 'quickDrawReady':
                        this.showReadyMessage();
                        break;
                    case 'quickDrawCountdown':
                        this.startDuelCountdown();
                        break;
                    case 'quickDrawDraw':
                        this.triggerDraw();
                        break;
                    case 'quickDrawEnd':
                        this.endDuel(message.winnerId);
                        break;
                }
            } catch (err) {
                console.error('Error parsing Quick Draw message:', err);
            }
        };
    }
    
    /**
     * Creates an invisible cylindrical boundary for a specific QuickDraw arena
     * @param {number} arenaIndex - The arena index (0-4)
     */
    createQuickDrawArenaBoundary(arenaIndex) {
        if (!this.physics) return null;
        
        const config = this.arenaConfigs[arenaIndex];
        
        // Create the physics boundary for this arena
        const arenaBody = this.physics.createQuickDrawArenaBoundary(
            config.center,
            config.radius,
            config.height
        );
        
        // Store the arena body for this arena
        this.arenaBoundaries[arenaIndex] = arenaBody;
        
        return arenaBody;
    }
    
    /**
     * Removes a specific QuickDraw arena boundary
     * @param {number} arenaIndex - The arena index (0-4)
     */
    removeQuickDrawArenaBoundary(arenaIndex) {
        if (!this.physics) return;
        
        // If there's a boundary for this arena, remove it
        if (this.arenaBoundaries[arenaIndex]) {
            this.physics.removeQuickDrawArenaBoundaryByIndex(arenaIndex);
            this.arenaBoundaries[arenaIndex] = null;
        }
    }
    
    /**
     * Check if a point is inside any active arena
     * @param {THREE.Vector3} point - The point to check
     * @returns {boolean} - True if inside an active arena
     */
    isPointInArena(point) {
        // First check if any arena is active
        if (this.activeArenaIndex < 0 || !this.arenaConfigs[this.activeArenaIndex].duelAreaActive) {
            return false;
        }
        
        const config = this.arenaConfigs[this.activeArenaIndex];
        
        // Use the physics system to check if the point is inside the active arena boundary
        if (this.physics && this.physics.isPointInArenaBoundary) {
            return this.physics.isPointInArenaBoundary(point);
        }
        
        // Fallback to simple cylindrical check if physics is not available
        const dx = point.x - config.center.x;
        const dz = point.z - config.center.z;
        const distanceFromCenter = Math.sqrt(dx * dx + dz * dz);
        
        // Check if within radius and height
        return distanceFromCenter <= config.radius && point.y >= 0 && point.y <= config.height;
    }
    
    /**
     * Check if a point is inside a specific arena
     * @param {THREE.Vector3} point - The point to check
     * @param {number} arenaIndex - The arena index to check
     * @returns {boolean} - True if inside the specified arena
     */
    isPointInSpecificArena(point, arenaIndex) {
        if (arenaIndex < 0 || arenaIndex >= this.maxArenas) {
            return false;
        }
        
        const config = this.arenaConfigs[arenaIndex];
        
        // Simple cylindrical check
        const dx = point.x - config.center.x;
        const dz = point.z - config.center.z;
        const distanceFromCenter = Math.sqrt(dx * dx + dz * dz);
        
        // Check if within radius and height
        return distanceFromCenter <= config.radius && point.y >= 0 && point.y <= config.height;
    }
    
    /**
     * Find the optimal arena index to join by checking where other players are waiting
     * @returns {number} - The arena index to join
     */
    getOptimalArenaIndex() {
        // Get information about other players from the network manager
        const arenaPlayerCounts = Array(this.maxArenas).fill(0);
        let foundWaitingPlayer = false;
        
        // If we can access the other players through networkManager
        if (this.networkManager && this.networkManager.otherPlayers) {
            // Count players in each lobby/queue
            for (const [_, playerData] of this.networkManager.otherPlayers) {
                // Check if player is in a Quick Draw lobby but not in a duel
                if (playerData.quickDrawLobbyIndex >= 0 && 
                    playerData.quickDrawLobbyIndex < this.maxArenas) {
                    arenaPlayerCounts[playerData.quickDrawLobbyIndex]++;
                    
                    // If this player appears to be waiting alone in a queue
                    if (arenaPlayerCounts[playerData.quickDrawLobbyIndex] === 1) {
                        foundWaitingPlayer = true;
                    }
                }
            }
            
            // If we found at least one player waiting in a queue
            if (foundWaitingPlayer) {
                // Find all arenas with exactly one player waiting
                const queuesWithOnePlayer = [];
                for (let i = 0; i < this.maxArenas; i++) {
                    if (arenaPlayerCounts[i] === 1) {
                        queuesWithOnePlayer.push(i);
                    }
                }
                
                // If we found arenas with one player waiting, join one of them
                if (queuesWithOnePlayer.length > 0) {
                    // If multiple arenas have one player, pick one randomly
                    const randomIndex = Math.floor(Math.random() * queuesWithOnePlayer.length);
                    return queuesWithOnePlayer[randomIndex];
                }
            }
        }
        
        // If we couldn't find a player waiting or couldn't access player data,
        // look for completely empty arenas
        const emptyArenas = [];
        for (let i = 0; i < this.maxArenas; i++) {
            if (arenaPlayerCounts[i] === 0) {
                emptyArenas.push(i);
            }
        }
        
        // If we found empty arenas, pick one randomly
        if (emptyArenas.length > 0) {
            const randomIndex = Math.floor(Math.random() * emptyArenas.length);
            return emptyArenas[randomIndex];
        }
        
        // If all arenas have players, pick the one with the fewest players
        let minPlayers = Infinity;
        let minArenas = [];
        
        for (let i = 0; i < this.maxArenas; i++) {
            if (arenaPlayerCounts[i] < minPlayers) {
                minPlayers = arenaPlayerCounts[i];
                minArenas = [i];
            } else if (arenaPlayerCounts[i] === minPlayers) {
                minArenas.push(i);
            }
        }
        
        // If we found arenas with the minimum number of players, pick one randomly
        if (minArenas.length > 0) {
            const randomIndex = Math.floor(Math.random() * minArenas.length);
            return minArenas[randomIndex];
        }
        
        // Fallback to a random arena if something went wrong
        return Math.floor(Math.random() * this.maxArenas);
    }
    
    /**
     * Update method called from main animation loop.
     */
    update(deltaTime) {
        // Skip if player not loaded
        if (!this.localPlayer || !this.localPlayer.group) {
            return;
        }
        
        // Update physics system
        if (this.physics) {
            this.physics.update(deltaTime);
            
            // If the player is in the arena, enforce arena boundary collision
            if (this.inDuel && this.activeArenaIndex >= 0 && this.arenaBoundaries[this.activeArenaIndex]) {
                const playerPos = this.localPlayer.group.position.clone();
                const config = this.arenaConfigs[this.activeArenaIndex];
                const isInArena = this.isPointInSpecificArena(playerPos, this.activeArenaIndex);
                
                if (!isInArena) {
                    // If player is outside the arena but should be inside, push them back in
                    const dirToCenter = new THREE.Vector3(
                        config.center.x - playerPos.x,
                        0,
                        config.center.z - playerPos.z
                    ).normalize();
                    
                    // Move player back inside
                    this.localPlayer.group.position.x += dirToCenter.x * 0.1;
                    this.localPlayer.group.position.z += dirToCenter.z * 0.1;
                }
            }
        }
        
        // Check for portal collision when not in lobby or duel
        if (!this.inLobby && !this.inDuel) {
            const playerPos = this.localPlayer.group.position.clone();
            
            // Check if player is colliding with the single portal
            if (this.arenaConfigs[0].portalCollider && this.arenaConfigs[0].portalCollider.containsPoint(playerPos)) {
                this.joinQueue(this.getOptimalArenaIndex());
            }
        }
        
        // If in countdown phase, check for early aiming
        if (this.inDuel && this.duelState === 'countdown') {
            if (this.localPlayer.isAiming && !this.gunLocked) {
                this.penalizeEarlyDraw();
            }
        }
        
        // Enforce penalty lock regardless of duel state if penalty is active
        if (performance.now() < this.penaltyEndTime) {
            this.localPlayer.canAim = false;
            this.localPlayer.isAiming = false;
            this.localPlayer.revolver.group.visible = false;
        }
        
        // Update portal instruction visibility
        this.updatePortalInstructions();
    }
    
    /**
     * Updates the Quick Draw status indicator.
     */
    updateStatusIndicator() {
        if (!this.statusIndicator) return;
        
        if (this.inLobby) {
            const arenaNum = this.activeArenaIndex + 1;
            this.statusIndicator.textContent = `Quick Draw Arena ${arenaNum}: Waiting for opponent...`;
            this.statusIndicator.style.display = 'block';
            this.statusIndicator.style.backgroundColor = 'rgba(33, 150, 243, 0.7)';
        } else if (this.inDuel) {
            const arenaNum = this.activeArenaIndex + 1;
            let statusText = `Quick Draw Arena ${arenaNum}: Duel in progress`;
            let bgColor = 'rgba(255, 87, 34, 0.7)';
            
            if (this.duelState === 'ready') {
                statusText = `Quick Draw Arena ${arenaNum}: Get ready!`;
            } else if (this.duelState === 'countdown') {
                statusText = `Quick Draw Arena ${arenaNum}: Wait for the signal...`;
            } else if (this.duelState === 'draw') {
                statusText = `Quick Draw Arena ${arenaNum}: DRAW!`;
                bgColor = 'rgba(244, 67, 54, 0.7)';
            }
            
            this.statusIndicator.textContent = statusText;
            this.statusIndicator.style.display = 'block';
            this.statusIndicator.style.backgroundColor = bgColor;
        } else {
            this.statusIndicator.style.display = 'none';
        }
    }
    
    /**
     * Join the Quick Draw queue for a specific arena.
     * @param {number} arenaIndex - The arena index to join (0-4)
     */
    joinQueue(arenaIndex) {
        if (this.inLobby || this.inDuel) {
            return; // Already in queue or duel
        }
        
        if (arenaIndex < 0 || arenaIndex >= this.maxArenas) {
            console.error(`Invalid arena index: ${arenaIndex}`);
            return;
        }
        
        this.inLobby = true;
        this.activeArenaIndex = arenaIndex;
        
        // Update the player's lobby index
        this.localPlayer.setQuickDrawLobby(arenaIndex);
        
        this.showMessage(`Joining Quick Draw Arena ${arenaIndex + 1} queue...`);
        this.updateStatusIndicator();
        
        // Send join request to server with arena index
        this.networkManager.sendQuickDrawJoin(arenaIndex);
        
        console.log(`Joined Quick Draw queue for arena ${arenaIndex + 1}`);
    }
    
    /**
     * Handle queue join confirmation from server.
     */
    handleQueueJoin(message) {
        // Make sure the arena index matches what we expect
        if (message.arenaIndex !== undefined && message.arenaIndex !== this.activeArenaIndex) {
            this.activeArenaIndex = message.arenaIndex;
            this.localPlayer.setQuickDrawLobby(message.arenaIndex);
        }
        
        this.showMessage(`Waiting for opponent in Arena ${this.activeArenaIndex + 1}...`);
        this.updateStatusIndicator();
        console.log(`Quick Draw queue joined for arena ${this.activeArenaIndex + 1}, waiting for opponent`);
    }
    
    /**
     * Handle match found notification from server.
     */
    handleMatchFound(message) {
        this.inLobby = false;
        this.inDuel = true;
        this.duelOpponentId = message.opponentId;
        
        // Make sure we're using the correct arena
        if (message.arenaIndex !== undefined) {
            this.activeArenaIndex = message.arenaIndex;
            this.localPlayer.setQuickDrawLobby(message.arenaIndex);
        }
        
        this.updateStatusIndicator();
        
        this.showMessage(`Opponent found! Preparing duel in Arena ${this.activeArenaIndex + 1}...`);
        
        const config = this.arenaConfigs[this.activeArenaIndex];
        
        // Teleport to the correct duel area
        // For "left" side, spawn on the left; for "right", spawn on the right
        const playerPosition = message.position === 'left' ?
            new THREE.Vector3(config.center.x - 5, 1.6, config.center.z) : 
            new THREE.Vector3(config.center.x + 5, 1.6, config.center.z);
        
        this.localPlayer.group.position.copy(playerPosition);
        
        // Invert player orientation by 180°:
        // For left side, set rotation.y to (Math.PI/2 + Math.PI) = 3π/2; for right, (-Math.PI/2 + Math.PI) = π/2
        if (message.position === 'left') {
            this.localPlayer.group.rotation.y = 3 * Math.PI / 2;
        } else {
            this.localPlayer.group.rotation.y = Math.PI / 2;
        }
        
        // Make the correct duel area visible
        if (config.duelArea) {
            config.duelArea.visible = true;
            config.duelAreaActive = true;
        }
        
        // Create the arena physics boundary
        this.createQuickDrawArenaBoundary(this.activeArenaIndex);
        
        // Disable weapon drawing immediately and forcefully
        this.originalCanAim = this.localPlayer.canAim !== false;
        this.localPlayer.canAim = false;
        this.localPlayer.isAiming = false;
        this.localPlayer.revolver.group.visible = false;
        
        // Tell server we're ready after a moment
        setTimeout(() => {
            this.networkManager.sendQuickDrawReady();
        }, 1000);
    }
    
    /**
     * Show the "READY?" message with enhanced typography.
     */
    showReadyMessage() {
        this.duelState = 'ready';
        this.updateStatusIndicator();
        this.messageOverlay.textContent = 'READY?';
        this.messageOverlay.style.display = 'block';
        this.messageOverlay.style.fontSize = '64px';
        this.messageOverlay.style.color = '#FFFFFF';
        
        // Use a slight scale animation
        this.messageOverlay.style.transition = 'transform 0.2s ease-in-out';
        this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // Trigger animation
        setTimeout(() => {
            this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1.1)';
            setTimeout(() => {
                this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 200);
        }, 10);
        
        // Hide after 1 second
        setTimeout(() => {
            this.hideMessage();
        }, 1000);
    }
    
    /**
     * Start the countdown phase of the duel.
     */
    startDuelCountdown() {
        this.duelState = 'countdown';
        this.updateStatusIndicator();
        this.hideMessage();
        
        // Explicitly disable aiming during countdown
        this.localPlayer.canAim = false;
        
        console.log('Duel countdown started - waiting for draw signal');
    }
    
    /**
     * Trigger the "DRAW!" signal with just the expanding circle.
     */
    triggerDraw() {
        this.duelState = 'draw';
        this.updateStatusIndicator();
        
        // Show animated circle with CSS animation
        this.drawCircle.style.display = 'block';
        this.drawCircle.classList.add('draw-circle-animation');
        
        // Only enable aiming if the penalty period has expired.
        if (performance.now() >= this.penaltyEndTime) {
            this.localPlayer.canAim = this.originalCanAim;
        } else {
            console.log("Penalty still active; gun remains locked.");
        }
        
        console.log('DRAW signal triggered - players can now shoot (if not penalized)');
        
        // Play bell start sound instead of a gunshot
        if (this.soundManager) {
            this.soundManager.playSound("bellstart");
        }
        
        // Remove animation class after it completes
        setTimeout(() => {
            this.drawCircle.classList.remove('draw-circle-animation');
            this.drawCircle.style.display = 'none';
        }, 400);
    }
    
    /**
     * Apply a penalty with dramatic red flashing warning.
     * Once triggered, records a penalty end time so that gun drawing remains locked
     * for a full 3 seconds even if the "DRAW!" signal comes.
     */
    penalizeEarlyDraw() {
        if (this.gunLocked) return;
        
        this.gunLocked = true;
        this.penaltyEndTime = performance.now() + 3000;
        
        // Show the message with a warning style
        this.showMessage('TOO EARLY!', 3000);
        this.messageOverlay.classList.add('gun-locked-warning');
        
        // Disable aiming for penalty duration
        this.localPlayer.canAim = false;
        this.localPlayer.isAiming = false;
        this.localPlayer.revolver.group.visible = false;
        
        // Add a subtle screen flash
        const penaltyFlash = document.createElement('div');
        penaltyFlash.style.position = 'absolute';
        penaltyFlash.style.top = '0';
        penaltyFlash.style.left = '0';
        penaltyFlash.style.width = '100%';
        penaltyFlash.style.height = '100%';
        penaltyFlash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        penaltyFlash.style.opacity = '0';
        penaltyFlash.style.transition = 'opacity 0.3s ease-in-out';
        penaltyFlash.style.pointerEvents = 'none';
        penaltyFlash.style.zIndex = '990';
        document.getElementById('game-container').appendChild(penaltyFlash);
        
        // Flash the screen
        setTimeout(() => {
            penaltyFlash.style.opacity = '1';
            setTimeout(() => {
                penaltyFlash.style.opacity = '0';
                setTimeout(() => {
                    if (penaltyFlash.parentNode) {
                        penaltyFlash.parentNode.removeChild(penaltyFlash);
                    }
                }, 300);
            }, 200);
        }, 10);
        
        // Play error sound
        if (this.soundManager) {
            this.soundManager.playSound("aimclick");
        }
        
        // Countdown timer text update
        let secondsLeft = 3;
        const updateCountdown = () => {
            this.messageOverlay.textContent = `TOO EARLY! Gun locked (${secondsLeft}s)`;
            secondsLeft--;
            
            if (secondsLeft >= 0) {
                this.penaltyTimer = setTimeout(updateCountdown, 1000);
            }
        };
        updateCountdown();
        
        // After 3 seconds, clear the penalty
        setTimeout(() => {
            this.gunLocked = false;
            this.penaltyEndTime = 0;
            this.hideMessage();
            this.messageOverlay.classList.remove('gun-locked-warning');
        }, 3000);
    }
    
    /**
     * End the duel with enhanced win/lose UI effects.
     */
    endDuel(winnerId) {
        const isWinner = winnerId === this.localPlayer.id;
        
        // Show winner/loser message with dramatic styling
        if (isWinner) {
            this.showMessage('YOU WIN!', 2000);
            this.messageOverlay.classList.add('quick-draw-winner');
            
            // Add a subtle victory flash
            const victoryFlash = document.createElement('div');
            victoryFlash.style.position = 'absolute';
            victoryFlash.style.top = '0';
            victoryFlash.style.left = '0';
            victoryFlash.style.width = '100%';
            victoryFlash.style.height = '100%';
            victoryFlash.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
            victoryFlash.style.opacity = '0';
            victoryFlash.style.transition = 'opacity 0.5s ease-in-out';
            victoryFlash.style.pointerEvents = 'none';
            victoryFlash.style.zIndex = '990';
            document.getElementById('game-container').appendChild(victoryFlash);
            
            setTimeout(() => {
                victoryFlash.style.opacity = '1';
                setTimeout(() => {
                    victoryFlash.style.opacity = '0';
                    setTimeout(() => {
                        if (victoryFlash.parentNode) {
                            victoryFlash.parentNode.removeChild(victoryFlash);
                        }
                    }, 500);
                }, 1000);
            }, 10);
        } else {
            this.showMessage('YOU LOSE!', 2000);
            this.messageOverlay.classList.add('quick-draw-loser');
            
            // Add a defeat flash for the loser
            const defeatFlash = document.createElement('div');
            defeatFlash.style.position = 'absolute';
            defeatFlash.style.top = '0';
            defeatFlash.style.left = '0';
            defeatFlash.style.width = '100%';
            defeatFlash.style.height = '100%';
            defeatFlash.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
            defeatFlash.style.opacity = '0';
            defeatFlash.style.transition = 'opacity 0.5s ease-in-out';
            defeatFlash.style.pointerEvents = 'none';
            defeatFlash.style.zIndex = '990';
            document.getElementById('game-container').appendChild(defeatFlash);
            
            setTimeout(() => {
                defeatFlash.style.opacity = '1';
                setTimeout(() => {
                    defeatFlash.style.opacity = '0';
                    setTimeout(() => {
                        if (defeatFlash.parentNode) {
                            defeatFlash.parentNode.removeChild(defeatFlash);
                        }
                    }, 500);
                }, 1000);
            }, 10);
        }
        
        // Store the current arena index before resetting
        const endedArenaIndex = this.activeArenaIndex;
        
        // Reset duel state
        this.duelState = 'none';
        this.inDuel = false;
        this.duelOpponentId = null;
        this.updateStatusIndicator();
        
        // Clean up the physics boundary
        this.removeQuickDrawArenaBoundary(endedArenaIndex);
        
        // Clear any timers
        if (this.countdownTimer) clearTimeout(this.countdownTimer);
        if (this.drawTimer) clearTimeout(this.drawTimer);
        if (this.penaltyTimer) clearTimeout(this.penaltyTimer);
        
        // Hide the active duel area and teleport back to spawn after delay
        setTimeout(() => {
            // Make sure we're hiding the correct duel area
            if (endedArenaIndex >= 0 && endedArenaIndex < this.maxArenas) {
                const config = this.arenaConfigs[endedArenaIndex];
                if (config.duelArea) {
                    config.duelArea.visible = false;
                    config.duelAreaActive = false;
                }
            }
            
            // Teleport back to normal spawn
            this.localPlayer.spawnPlayerRandomly();
            
            // Re-enable normal controls
            this.localPlayer.canAim = this.originalCanAim;
            this.gunLocked = false;
            
            // Reset health
            this.localPlayer.health = 100;
            if (typeof window.updateHealthUI === 'function') {
                window.updateHealthUI(this.localPlayer);
            }
            
            // Reset message styling
            this.messageOverlay.classList.remove('quick-draw-winner', 'quick-draw-loser');
            
            // Reset active arena and Quick Draw lobby
            this.activeArenaIndex = -1;
            this.localPlayer.setQuickDrawLobby(-1);
        }, 2000);
    }
    
    /**
     * Helper to show a message in the center of the screen.
     */
    showMessage(message, duration = 0) {
        this.messageOverlay.textContent = message;
        this.messageOverlay.style.display = 'block';
        
        if (duration > 0) {
            setTimeout(() => {
                this.hideMessage();
            }, duration);
        }
    }
    
    /**
     * Hide the message overlay.
     */
    hideMessage() {
        this.messageOverlay.style.display = 'none';
    }
    
    /**
     * Cleanup resources.
     */
    cleanup() {
        // Remove the portal group
        if (this.portalGroup) {
            this.scene.remove(this.portalGroup);
            this.portalGroup.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        // Remove duel areas
        for (let i = 0; i < this.maxArenas; i++) {
            const config = this.arenaConfigs[i];
            
            // Remove duel area
            if (config.duelArea) {
                this.scene.remove(config.duelArea);
                config.duelArea.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            
            // Remove physics boundary
            this.removeQuickDrawArenaBoundary(i);
        }
        
        // Remove instruction elements
        if (this.instructionsElement && this.instructionsElement.parentNode) {
            this.instructionsElement.parentNode.removeChild(this.instructionsElement);
        }
        
        // Clean up physics
        if (this.physics) {
            this.physics.cleanup();
        }
        
        // Remove UI elements
        if (this.messageOverlay && this.messageOverlay.parentNode) {
            this.messageOverlay.parentNode.removeChild(this.messageOverlay);
        }
        
        if (this.drawCircle && this.drawCircle.parentNode) {
            this.drawCircle.parentNode.removeChild(this.drawCircle);
        }
        
        if (this.statusIndicator && this.statusIndicator.parentNode) {
            this.statusIndicator.parentNode.removeChild(this.statusIndicator);
        }
        
        if (this.lobbyIndicator && this.lobbyIndicator.parentNode) {
            this.lobbyIndicator.parentNode.removeChild(this.lobbyIndicator);
        }
        
        // Clear timers
        if (this.countdownTimer) clearTimeout(this.countdownTimer);
        if (this.drawTimer) clearTimeout(this.drawTimer);
        if (this.penaltyTimer) clearTimeout(this.penaltyTimer);
    }
}

================================================
File: /public/js/revolver.js
================================================
/**
 * A simple Revolver class that loads a low-poly gun model (GLB) for first-person view.
 */
export class Revolver {
  constructor() {
    this.group = new THREE.Group();

    // Internal flag to log the barrel lookup only once.
    this._barrelLogged = false;
    // This will be our anchor attached to the barrel, used for muzzle flash and bullet spawn.
    this.muzzleFlashAnchor = null;

    // Use GLTFLoader to load the .glb gun model
    const loader = new THREE.GLTFLoader();
    loader.load(
      'models/lowpolygun.glb',
      (gltf) => {
        const gunModel = gltf.scene;
        gunModel.scale.set(0.5, 0.5, 0.5);
        gunModel.position.set(0, 0, 0);
        // Flip the model 180° so it points forward
        gunModel.rotation.set(0, Math.PI, 0);

        // Optional: log all child names for debugging purposes
        // gunModel.traverse(child => console.log(child.name));

        this.group.add(gunModel);
        this.gunModel = gunModel;

        // Attempt to find the barrel by its name in the imported model
        const barrel = gunModel.getObjectByName("Magnum_Barrel_Magnum_mat_0");
        if (!this._barrelLogged) {
          if (barrel) {
            console.log('Revolver barrel found: "Magnum_Barrel_Magnum_mat_0".');
          } else {
            console.warn('Revolver barrel "Magnum_Barrel_Magnum_mat_0" not found. Muzzle flash anchor will not be attached.');
          }
          this._barrelLogged = true;
        }
        if (barrel) {
          // Create a muzzle flash anchor and attach it to the barrel.
          this.muzzleFlashAnchor = new THREE.Object3D();
          // Set an upward offset on the anchor (adjust as necessary)
          this.muzzleFlashAnchor.position.set(-2, 8, -10);
          barrel.add(this.muzzleFlashAnchor);
          console.log('Muzzle flash anchor attached to barrel.');
        }
      },
      undefined,
      (error) => {
        console.error('Error loading revolver model:', error);
      }
    );

    // Initially hidden until the player aims
    this.group.visible = false;
  }

  /**
   * Returns the world position of the gun barrel tip.
   * If a muzzle flash anchor was attached to the barrel, its world position is returned,
   * ensuring that the emission point remains fixed relative to the barrel.
   * Otherwise, it falls back to a default local offset relative to the revolver group.
   *
   * @returns {THREE.Vector3} The world position for spawning bullets and muzzle flash effects.
   */
  getBarrelTipWorldPosition() {
    if (this.muzzleFlashAnchor) {
      const worldPos = new THREE.Vector3();
      this.muzzleFlashAnchor.getWorldPosition(worldPos);
      return worldPos;
    }
    // Fallback: use a default local offset relative to the revolver group
    return this.group.localToWorld(new THREE.Vector3(0, 0, -0.7));
  }
}


================================================
File: /public/js/scene.js
================================================
// /public/js/scene.js
export let scene;

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {Object} - Contains the camera and renderer.
 */
export function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 10, 100); // Reduced fog distance for smaller world

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // Set output encoding for consistent lighting and color reproduction.
  renderer.outputEncoding = THREE.sRGBEncoding;

  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) {
    throw new Error("Game container not found in HTML.");
  }
  gameContainer.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(1, 1, 0.5).normalize();
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);

  // Create the western town instead of just a ground plane
  createWesternTown();

  return { camera, renderer };
}

/**
 * Creates a western town with a main street and buildings
 */
function createWesternTown() {
  // Town dimensions
  const TOWN_WIDTH = 60;  // Width of the town (X-axis)
  const TOWN_LENGTH = 100; // Length of the town (Z-axis)
  const STREET_WIDTH = 15; // Width of the main street

  // Create the ground (smaller than the original 1000x1000)
  const groundGeometry = new THREE.PlaneGeometry(TOWN_WIDTH, TOWN_LENGTH);
  const groundMaterial = new THREE.MeshStandardMaterial({
    color: 0xCD853F, // Sandy color
    roughness: 0.8,
    metalness: 0.2
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Create the main street
  const streetGeometry = new THREE.PlaneGeometry(STREET_WIDTH, TOWN_LENGTH);
  const streetMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0522D, // Brown street
    roughness: 0.9,
    metalness: 0.1
  });
  const street = new THREE.Mesh(streetGeometry, streetMaterial);
  street.rotation.x = -Math.PI / 2;
  street.position.y = 0.01; // Slightly above ground to prevent z-fighting
  street.receiveShadow = true;
  scene.add(street);

  // Add buildings on both sides of the street
  const buildingCount = 5; // Number of buildings on each side
  const buildingSpacing = TOWN_LENGTH / (buildingCount + 1);
  
  // Left side buildings (negative X)
  for (let i = 1; i <= buildingCount; i++) {
    const offset = i * buildingSpacing - TOWN_LENGTH / 2 + buildingSpacing / 2;
    createWesternBuilding(-STREET_WIDTH / 2 - 5, 0, offset);
  }
  
  // Right side buildings (positive X)
  for (let i = 1; i <= buildingCount; i++) {
    const offset = i * buildingSpacing - TOWN_LENGTH / 2 + buildingSpacing / 2;
    createWesternBuilding(STREET_WIDTH / 2 + 5, 0, offset);
  }

  // Create a visible border around the town
  createTownBorder(TOWN_WIDTH, TOWN_LENGTH);
  
  // Store these values in a global variable for access in other files
  window.townDimensions = {
    width: TOWN_WIDTH,
    length: TOWN_LENGTH,
    streetWidth: STREET_WIDTH
  };
}

/**
 * Creates a simple western-style building
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} z - Z position
 */
function createWesternBuilding(x, y, z) {
  // Randomize building dimensions
  const width = 8 + Math.random() * 4;
  const height = 5 + Math.random() * 3;
  const depth = 6 + Math.random() * 4;
  
  const buildingGroup = new THREE.Group();
  
  // Building body
  const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
  const buildingMaterial = new THREE.MeshStandardMaterial({
    color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, // Brown variations
    roughness: 0.8,
    metalness: 0.2
  });
  const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
  building.position.set(0, height / 2, 0);
  building.castShadow = true;
  building.receiveShadow = true;
  buildingGroup.add(building);
  
  // Roof (simple triangular prism)
  const roofHeight = 2;
  const roofGeometry = new THREE.BufferGeometry();
  
  const vertices = new Float32Array([
    // Front triangle
    -width/2, height, -depth/2,
    width/2, height, -depth/2,
    0, height + roofHeight, -depth/2,
    
    // Back triangle
    -width/2, height, depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, depth/2,
    
    // Left side
    -width/2, height, -depth/2,
    -width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2,
    
    // Right side
    width/2, height, -depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2
  ]);
  
  const indices = [
    // Front triangle
    0, 1, 2,
    
    // Back triangle
    3, 5, 4,
    
    // Left side
    6, 8, 7,
    7, 8, 9,
    
    // Right side
    10, 11, 12,
    11, 13, 12
  ];
  
  roofGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  roofGeometry.setIndex(indices);
  roofGeometry.computeVertexNormals();
  
  const roofMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Dark brown
    roughness: 0.9,
    metalness: 0.1
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.castShadow = true;
  buildingGroup.add(roof);
  
  // Door
  const doorWidth = 1.5;
  const doorHeight = 3;
  const doorGeometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
  const doorMaterial = new THREE.MeshStandardMaterial({
    color: 0x4d2600, // Dark brown
    roughness: 0.8,
    metalness: 0.2
  });
  const door = new THREE.Mesh(doorGeometry, doorMaterial);
  door.position.set(0, doorHeight / 2, depth / 2 + 0.01);
  buildingGroup.add(door);
  
  // Windows (1-3 random windows)
  const windowCount = 1 + Math.floor(Math.random() * 3);
  for (let i = 0; i < windowCount; i++) {
    const windowWidth = 1;
    const windowHeight = 1;
    const windowGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
    const windowMaterial = new THREE.MeshStandardMaterial({
      color: 0xECF0F1, // White-ish
      roughness: 0.4,
      metalness: 0.6
    });
    const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
    
    // Position windows randomly on the front face
    let wxPos = -width / 3 + i * width / 3;
    if (windowCount === 1) wxPos = 0;
    
    windowMesh.position.set(
      wxPos,
      height / 2 + 0.5,
      depth / 2 + 0.01
    );
    buildingGroup.add(windowMesh);
  }
  
  // Position the whole building
  buildingGroup.position.set(x, y, z);
  
  // Rotate the building to face the street
  if (x < 0) {
    buildingGroup.rotation.y = Math.PI / 2;
  } else {
    buildingGroup.rotation.y = -Math.PI / 2;
  }
  
  scene.add(buildingGroup);
}

/**
 * Creates a visible border around the town
 * @param {number} width - Width of the town
 * @param {number} length - Length of the town
 */
function createTownBorder(width, length) {
  const borderHeight = 0.5;
  const borderWidth = 0.5;
  
  // Border material
  const borderMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Brown
    roughness: 0.8,
    metalness: 0.2
  });
  
  // Create four border segments
  const createBorderSegment = (x, z, sizeX, sizeZ) => {
    const geometry = new THREE.BoxGeometry(sizeX, borderHeight, sizeZ);
    const border = new THREE.Mesh(geometry, borderMaterial);
    border.position.set(x, borderHeight / 2, z);
    border.castShadow = true;
    border.receiveShadow = true;
    scene.add(border);
    return border;
  };
  
  // Left border (negative X)
  const leftBorder = createBorderSegment(-width / 2, 0, borderWidth, length);
  
  // Right border (positive X)
  const rightBorder = createBorderSegment(width / 2, 0, borderWidth, length);
  
  // Front border (negative Z)
  const frontBorder = createBorderSegment(0, -length / 2, width, borderWidth);
  
  // Back border (positive Z)
  const backBorder = createBorderSegment(0, length / 2, width, borderWidth);
  
  // Store border references in a global variable
  window.townBorders = {
    left: leftBorder,
    right: rightBorder,
    front: frontBorder,
    back: backBorder,
    width: width,
    length: length,
    height: borderHeight
  };
}

/**
 * Creates a simple NPC target.
 * @param {THREE.Scene} scene - The scene to add the NPC.
 * @returns {THREE.Group} - The NPC group.
 */
export function createNPC(scene) {
  const npcGroup = new THREE.Group();
  const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.9;
  npcGroup.add(body);
  const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
  const headMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 1.8;
  npcGroup.add(head);
  const hatGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8);
  const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const hat = new THREE.Mesh(hatGeometry, hatMaterial);
  hat.position.y = 2.0;
  npcGroup.add(hat);

  // Position the NPC within the town instead of at (0, 0, -10)
  if (window.townDimensions) {
    // Place NPC at a random position in the town
    const x = (Math.random() - 0.5) * window.townDimensions.streetWidth * 0.8;
    const z = -window.townDimensions.length * 0.3; // Towards the front of the town
    npcGroup.position.set(x, 0, z);
  } else {
    // Default position as fallback
    npcGroup.position.set(0, 0, -10);
  }
  
  scene.add(npcGroup);
  return npcGroup;
}

/**
 * Updates the NPC's position.
 * @param {THREE.Group} npc - The NPC group.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateNPC(npc, deltaTime) {
  if (npc) {
    npc.userData.direction = npc.userData.direction || 1;
    
    // Adjust the movement range to be appropriate for the town size
    const movementRange = window.townDimensions ? 
      window.townDimensions.streetWidth * 0.4 : // 40% of street width if town exists
      15; // Original value as fallback
    
    npc.position.x += npc.userData.direction * 2 * deltaTime;
    
    if (npc.position.x > movementRange) {
      npc.userData.direction = -1;
      npc.rotation.y = Math.PI / 2;
    } else if (npc.position.x < -movementRange) {
      npc.userData.direction = 1;
      npc.rotation.y = -Math.PI / 2;
    }
  }
}

/**
 * Updates the FPS counter.
 * @param {THREE.WebGLRenderer} renderer - The renderer.
 * @param {THREE.Camera} camera - The camera.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateFPS(renderer, camera, deltaTime) {
  const fpsCounter = document.getElementById('fps-counter');
  if (fpsCounter) {
    const currentFPS = deltaTime > 0 ? Math.round(1 / deltaTime) : 0;
    fpsCounter.textContent = `FPS: ${currentFPS}`;
  }
}

================================================
File: /public/js/smokeRingEffect.js
================================================
/**
 * Smoke Ring Effect implementation for the Western Shooter game
 * Creates a stylized low-poly smoke ring when firing
 */
export class SmokeRingEffect {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.scene.add(this.group);
        
        this.puffs = [];
        this.active = false;
        
        // Create smoke material - using PhongMaterial with flatShading
        this.smokeMaterial = new THREE.MeshPhongMaterial({
            color: 0xCCCCCC, // Light gray
            flatShading: true,
            shininess: 0,
            transparent: true
        });
    }
    
    /**
     * Create a smoke ring effect at the specified position and direction
     * @param {THREE.Vector3} position - The position to create the smoke ring
     * @param {THREE.Vector3} direction - The direction the weapon is firing
     */
    create(position, direction) {
        // Clear any existing puffs
        while(this.group.children.length > 0) {
            let mesh = this.group.children[0];
            this.group.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        }
        this.puffs = [];
        
        // Position the smoke ring at the muzzle
        this.group.position.copy(position);
        this.group.lookAt(position.clone().add(direction));
        
        // Create the smoke ring effect
        this._createSmokeRing();
        
        this.active = true;
    }
    
    /**
     * Create a smoke ring with proper radial particles
     * @private
     */
    _createSmokeRing() {
        // Main ring particles
        const numRingParticles = 20; // Adjusted for revolver (smaller than blunderbuss)
        const initialRingRadius = 0.15; // Smaller initial radius for revolver
        
        for (let i = 0; i < numRingParticles; i++) {
            const angle = (i / numRingParticles) * Math.PI * 2;
            
            // Slightly randomize the ring radius for a less perfect circle
            const radiusVariation = initialRingRadius * (0.9 + Math.random() * 0.2);
            
            // Create puff with low-poly icosahedron
            const geometry = new THREE.IcosahedronGeometry(0.05 + Math.random() * 0.03, 0);
            const material = this.smokeMaterial.clone();
            
            // Compute normals for flat shading
            geometry.computeVertexNormals();
            
            const puffMesh = new THREE.Mesh(geometry, material);
            
            // Position in ring formation
            puffMesh.position.x = Math.cos(angle) * radiusVariation;
            puffMesh.position.y = Math.sin(angle) * radiusVariation;
            puffMesh.position.z = 0.05 + Math.random() * 0.1; // Slight forward offset
            
            // Random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Start with small scale
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            this.group.add(puffMesh);
            
            // Outward velocity along the ring angle
            const outwardSpeed = 1.8 + Math.random() * 0.7; // Slightly slower for revolver
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.6 + Math.random() * 0.3, // Shorter lifespan for revolver
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    0.2 + Math.random() * 0.4 // Slight forward movement
                ),
                rotationSpeed: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                ),
                initialSize: 0.05 + Math.random() * 0.03
            });
        }
        
        // Add just a few particles near origin for muzzle blast effect
        for (let i = 0; i < 3; i++) {
            const geometry = new THREE.IcosahedronGeometry(0.06 + Math.random() * 0.04, 0);
            const material = this.smokeMaterial.clone();
            geometry.computeVertexNormals();
            
            const puffMesh = new THREE.Mesh(geometry, material);
            
            // Position very close to origin with minimal spread
            const smallOffset = 0.08;
            puffMesh.position.set(
                (Math.random() - 0.5) * smallOffset,
                (Math.random() - 0.5) * smallOffset,
                0
            );
            
            // Random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            this.group.add(puffMesh);
            
            // Random outward direction
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 0.6;
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.4 + Math.random() * 0.2, // Shorter lifespan
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    0.3 + Math.random() * 0.3
                ),
                rotationSpeed: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                ),
                initialSize: 0.06 + Math.random() * 0.04
            });
        }
    }
    
    /**
     * Update the smoke ring effect
     * @param {number} deltaTime - Time elapsed since last frame
     * @returns {boolean} - Whether the effect is still active
     */
    update(deltaTime) {
        if (!this.active) return false;
        
        let allExpired = true;
        
        for (let i = 0; i < this.puffs.length; i++) {
            const puff = this.puffs[i];
            puff.age += deltaTime;
            
            if (puff.age < puff.lifespan) {
                allExpired = false;
                
                // Calculate life ratio
                const lifeRatio = puff.age / puff.lifespan;
                
                // Update position based on velocity
                puff.mesh.position.x += puff.velocity.x * deltaTime;
                puff.mesh.position.y += puff.velocity.y * deltaTime;
                puff.mesh.position.z += puff.velocity.z * deltaTime;
                
                // Update rotation
                puff.mesh.rotation.x += puff.rotationSpeed.x;
                puff.mesh.rotation.y += puff.rotationSpeed.y;
                puff.mesh.rotation.z += puff.rotationSpeed.z;
                
                // Modified scale curve - quick growth, plateau, then fade
                let scaleFactor;
                
                if (lifeRatio < 0.2) {
                    // Quick growth phase - 0 to 0.2
                    scaleFactor = lifeRatio / 0.2;
                } else if (lifeRatio < 0.7) {
                    // Maintain size with slight growth - 0.2 to 0.7
                    scaleFactor = 1.0 + (lifeRatio - 0.2) * 0.3;
                } else {
                    // Shrink phase - 0.7 to 1.0
                    scaleFactor = 1.3 - (lifeRatio - 0.7) * (1.3 / 0.3);
                }
                
                puff.mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                // Handle transparency in final phase
                if (lifeRatio > 0.7) {
                    const opacity = 1 - ((lifeRatio - 0.7) / 0.3);
                    puff.mesh.material.opacity = opacity;
                }
                
                // Adjust drag based on life stage
                const dragFactor = lifeRatio < 0.5 ? 0.98 : 0.96;
                puff.velocity.multiplyScalar(dragFactor);
            } else {
                // Make expired puffs invisible
                puff.mesh.visible = false;
            }
        }
        
        // If all puffs have expired, clean up and set active to false
        if (allExpired) {
            // Clean up
            while(this.group.children.length > 0) {
                let mesh = this.group.children[0];
                this.group.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            }
            this.puffs = [];
            this.active = false;
            return false;
        }
        
        return true;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        // Clean up all meshes and materials
        while(this.group.children.length > 0) {
            let mesh = this.group.children[0];
            this.group.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        }
        this.puffs = [];
        
        // Remove group from scene
        if (this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
}

================================================
File: /public/js/soundManager.js
================================================
export class SoundManager {
  constructor() {
    // For non-positional playback
    this.sounds = {};
    // For positional playback using Web Audio API
    this.buffers = {};
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // For footstep optimization - preload audio nodes for footsteps
    this.footstepSources = {
      left: [],
      right: []
    };
    this.footstepPoolSize = 3; // Number of audio nodes to cycle through
    this.currentFootstepIndex = 0;
    
    // For sound cooldowns (prevent sound spam)
    this.soundCooldowns = {};
  }
  
  /**
   * Loads an audio file and caches it.
   * Loads both as an HTMLAudioElement (for simple playback)
   * and as an AudioBuffer (for positional audio).
   * @param {string} name - Sound key.
   * @param {string} url - Audio file URL.
   */
  loadSound(name, url) {
    try {
      // Load using HTMLAudioElement for non-positional playback
      const audio = new Audio();
      audio.src = url;
      audio.load();
      this.sounds[name] = audio;
      
      console.log(`Loaded sound "${name}" as HTMLAudioElement from ${url}`);
    } catch (error) {
      console.error(`Error loading sound "${name}" from ${url}:`, error);
    }
    
    // Also load using fetch for positional audio
    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network response failed for sound ${name}: ${response.status} ${response.statusText}`);
        }
        return response.arrayBuffer();
      })
      .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        this.buffers[name] = audioBuffer;
        console.log(`Loaded sound "${name}" as AudioBuffer from ${url}`);
        
        // Preload footstep sources if this is a footstep sound
        if (name === 'leftstep' || name === 'rightstep') {
          const footType = name === 'leftstep' ? 'left' : 'right';
          console.log(`Preloading ${footType} footstep sources`);
          // Create a pool of audio sources for footsteps
          for (let i = 0; i < this.footstepPoolSize; i++) {
            this.footstepSources[footType][i] = {
              source: null,
              gainNode: this.audioContext.createGain(),
              panner: this.audioContext.createPanner()
            };
            
            // Set up the audio chain
            this.footstepSources[footType][i].gainNode.connect(this.audioContext.destination);
            this.footstepSources[footType][i].panner.connect(this.footstepSources[footType][i].gainNode);
            
            // Configure panner for 3D audio
            this.footstepSources[footType][i].panner.panningModel = 'HRTF';
            this.footstepSources[footType][i].panner.distanceModel = 'inverse';
            this.footstepSources[footType][i].panner.refDistance = 1;
            this.footstepSources[footType][i].panner.maxDistance = 10000;
            this.footstepSources[footType][i].panner.rolloffFactor = 1;
          }
        }
      })
      .catch(error => {
        console.error(`Error loading sound buffer "${name}" from ${url}:`, error);
      });
  }
  
  /**
   * Plays a cached sound by cloning the HTMLAudioElement.
   * @param {string} name - Sound key.
   * @param {number} cooldown - Optional cooldown in milliseconds to prevent rapid repetition.
   * @param {number} volume - Optional volume multiplier (0-1)
   */
  playSound(name, cooldown = 0, volume = 1.0) {
    if (this.sounds[name]) {
      // Check cooldown if specified
      if (cooldown > 0) {
        const now = Date.now();
        if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
          // Still in cooldown period
          return;
        }
        this.soundCooldowns[name] = now;
      }
      
      const audioClone = this.sounds[name].cloneNode();
      // Apply volume adjustment
      audioClone.volume = Math.max(0, Math.min(1, volume));
      
      audioClone.play().catch(error => {
        console.error(`Error playing sound "${name}":`, error);
      });
    } else {
      console.error(`Sound "${name}" not found in cache.`);
    }
  }
  
  /**
   * Plays a sound at a given 3D position using the Web Audio API.
   * @param {string} name - Sound key.
   * @param {THREE.Vector3} position - 3D position for the sound.
   * @param {number} cooldown - Optional cooldown in milliseconds.
   * @param {number} volume - Optional volume multiplier.
   */
  playSoundAt(name, position, cooldown = 0, volume = 1.0) {
    if (!this.buffers[name]) {
      console.error(`Positional sound "${name}" not found in buffers.`);
      return;
    }
    
    // Check cooldown if specified
    if (cooldown > 0) {
      const now = Date.now();
      if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
        // Still in cooldown period
        return;
      }
      this.soundCooldowns[name] = now;
    }
    
    try {
      const source = this.audioContext.createBufferSource();
      source.buffer = this.buffers[name];
      
      const panner = this.audioContext.createPanner();
      panner.panningModel = 'HRTF';
      panner.distanceModel = 'inverse';
      panner.refDistance = 1;
      panner.maxDistance = 10000;
      panner.rolloffFactor = 1;
      panner.coneInnerAngle = 360;
      panner.coneOuterAngle = 0;
      panner.coneOuterGain = 0;
      panner.setPosition(position.x, position.y, position.z);
      
      // Add volume control gain node
      const gainNode = this.audioContext.createGain();
      gainNode.gain.value = volume;
      
      source.connect(panner);
      panner.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      source.start(0);
    } catch (error) {
      console.error(`Error playing positional sound "${name}":`, error);
    }
  }
  
  /**
   * Efficiently plays footstep sounds by reusing audio nodes.
   * Optimized for frequent calls during walking.
   * @param {string} foot - 'left' or 'right' to determine which sound to play.
   * @param {THREE.Vector3} position - 3D position for the sound.
   * @param {number} volume - Volume multiplier based on movement speed.
   */
  playFootstep(foot, position, volume = 1.0) {
    const footType = foot === 'left' ? 'left' : 'right';
    const soundName = foot === 'left' ? 'leftstep' : 'rightstep';
    
    if (!this.buffers[soundName]) {
      console.error(`Footstep sound "${soundName}" not found in buffers.`);
      return;
    }
    
    try {
      // Get the next footstep source from the pool
      const sourceObj = this.footstepSources[footType][this.currentFootstepIndex];
      this.currentFootstepIndex = (this.currentFootstepIndex + 1) % this.footstepPoolSize;
      
      // If there's an existing source playing, stop it
      if (sourceObj.source !== null) {
        try {
          sourceObj.source.stop();
        } catch (e) {
          // Ignore errors if the source was already stopped
        }
      }
      
      // Create a new source
      sourceObj.source = this.audioContext.createBufferSource();
      sourceObj.source.buffer = this.buffers[soundName];
      
      // Update position and volume
      sourceObj.panner.setPosition(position.x, position.y, position.z);
      sourceObj.gainNode.gain.value = volume;
      
      // Connect and play
      sourceObj.source.connect(sourceObj.panner);
      sourceObj.source.start(0);
    } catch (error) {
      console.error(`Error playing footstep sound "${soundName}":`, error);
    }
  }
  
  /**
   * Plays a sequence: after sound1 ends, sound2 plays.
   * @param {string} sound1 - First sound key.
   * @param {string} sound2 - Second sound key.
   */
  playSoundSequence(sound1, sound2) {
    if (this.sounds[sound1]) {
      const audioClone = this.sounds[sound1].cloneNode();
      audioClone.play().then(() => {
        audioClone.addEventListener('ended', () => {
          this.playSound(sound2);
        });
      }).catch(error => {
        console.error(`Error playing sound "${sound1}":`, error);
      });
    } else {
      console.error(`Sound "${sound1}" not found in cache.`);
    }
  }
}

================================================
File: /public/js/ui.js
================================================
/**
 * Updates the ammo counter in the UI.
 * @param {Player} player - The player instance.
 */
export function updateAmmoUI(player) {
  const ammoCounter = document.getElementById('ammo-counter');
  if (ammoCounter && player) {
    ammoCounter.textContent = `Bullets: ${player.bullets}/${player.maxBullets}`;
  }
}

/**
* Updates the health counter in the UI.
* @param {Player|ThirdPersonModel} player - The player instance.
*/
export function updateHealthUI(player) {
  const healthCounter = document.getElementById('health-counter');
  if (healthCounter && player) {
    const healthText = `Health: ${player.health}`;
    healthCounter.textContent = healthText;
    
    // Add visual indication of health level
    if (player.health > 75) {
      healthCounter.style.color = '#4CAF50'; // Green for good health
    } else if (player.health > 30) {
      healthCounter.style.color = '#FFC107'; // Yellow/amber for medium health
    } else {
      healthCounter.style.color = '#F44336'; // Red for low health
    }
  }
}

/**
* Creates a temporary damage indicator overlay when player takes damage.
* @param {number} damage - The amount of damage taken.
* @param {string} hitZone - The hit zone ('head', 'body', 'limbs').
*/
export function showDamageIndicator(damage, hitZone) {
  // Create damage indicator element if it doesn't exist
  let damageIndicator = document.getElementById('damage-indicator');
  if (!damageIndicator) {
      damageIndicator = document.createElement('div');
      damageIndicator.id = 'damage-indicator';
      damageIndicator.style.position = 'absolute';
      damageIndicator.style.top = '40%';
      damageIndicator.style.left = '50%';
      damageIndicator.style.transform = 'translate(-50%, -50%)';
      damageIndicator.style.color = 'red';
      damageIndicator.style.fontSize = '48px';
      damageIndicator.style.fontWeight = 'bold';
      damageIndicator.style.opacity = '0';
      damageIndicator.style.textShadow = '2px 2px 4px #000000';
      damageIndicator.style.transition = 'opacity 0.3s ease-in, opacity 0.5s ease-out';
      damageIndicator.style.zIndex = '1000';
      damageIndicator.style.pointerEvents = 'none';
      document.getElementById('game-container').appendChild(damageIndicator);
  }
  
  // Set text based on hit zone
  let hitText = `-${damage}`;
  if (hitZone) {
      switch (hitZone) {
          case 'head':
              hitText += ' HEADSHOT!';
              break;
          case 'body':
              hitText += ' (Body Shot)';
              break;
          case 'limbs':
              hitText += ' (Limb Shot)';
              break;
      }
  }
  
  // Display damage indicator
  damageIndicator.textContent = hitText;
  damageIndicator.style.opacity = '1';
  
  // Set color based on damage
  if (damage >= 100) {
      damageIndicator.style.color = '#FF0000'; // Bright red for headshots
      damageIndicator.style.fontSize = '64px';
  } else if (damage >= 40) {
      damageIndicator.style.color = '#FF4500'; // Orange-red for body shots
  } else {
      damageIndicator.style.color = '#FFA500'; // Orange for limb shots
  }
  
  // Fade out after a delay
  setTimeout(() => {
      damageIndicator.style.opacity = '0';
  }, 800);
}

/**
* Updates all UI elements related to player status.
* @param {Player} player - The player instance.
*/
export function updatePlayerUI(player) {
  updateAmmoUI(player);
  updateHealthUI(player);
}

================================================
File: /server.js
================================================
// server.js
const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const url = require('url');
const app = express();

// Port default 8080 to match your previous Cloudflare Tunnel config
const PORT = process.env.PORT || 8080;

// Serve static files from "public"
app.use(express.static('public'));

const server = http.createServer(app);
const wss = new WebSocket.Server({ server, clientTracking: true });

// Track connected players
const players = new Map();    // playerId -> { ws, sessionId, position, rotation, health, ... }
const sessions = new Set();   // tracks sessionIds to prevent duplicate connections
let nextPlayerId = 1;

// Track Quick Draw game mode queues and active duels
// Support for 5 concurrent lobbies
const MAX_ARENAS = 5;
const quickDrawQueues = Array(MAX_ARENAS).fill(null).map(() => []);  // Array of queues for each arena
const quickDrawDuels = new Map(); // Map of duelId -> { player1Id, player2Id, state, arenaIndex, ... }

// Track Proper Shootout game mode
const properShootoutLobbies = new Map(); // lobbyId -> { players: Set(), scores: Map() }
let nextLobbyId = 1;
const MAX_SHOOTOUT_PLAYERS = 10;
const SHOOTOUT_WIN_SCORE = 10;
const SHOOTOUT_MAP_CENTER = { x: 0, z: -100 }; // Coordinates matching the client map center
const SHOOTOUT_MAP_DIMENSIONS = { width: 50, length: 50 };

// Anti-cheat: Game physics constants
const GAME_CONSTANTS = {
  // Weapon constraints
  BULLET_SPEED: 80,           // Bullet speed units/second
  MAX_BULLET_DISTANCE: 100,   // Maximum distance a bullet can travel
  WEAPON_COOLDOWN: 250,       // Minimum time between shots in ms
  RELOAD_TIME: 4000,          // Time required to reload in ms
  DAMAGE_PER_HIT: 20,         // Health points reduced per hit
  // Town boundaries
  TOWN_WIDTH: 60,             // Width of the town
  TOWN_LENGTH: 100,           // Length of the town
  // Physics update rate
  PHYSICS_UPDATE_INTERVAL: 16 // ms (approx 60fps)
};

// Anti-cheat: Active bullets map
const activeBullets = new Map(); // bulletId -> {sourcePlayerId, position, direction, timeCreated, etc}
let nextBulletId = 1;

// Anti-cheat: Timeout tracking (for rate limiting and cooldowns)
const playerTimeouts = new Map(); // playerId -> { lastShot, lastReload, lastTeleport, etc }

// Anti-cheat: Nonce tracking (for anti-replay protection)
const playerNonces = new Map(); // playerId -> Set of used nonces
const playerSequences = new Map(); // playerId -> last sequence number

// On new connection
wss.on('connection', (ws, req) => {
  // Parse sessionId from query string
  const parameters = url.parse(req.url, true).query;
  const sessionId = parameters.sessionId;

  // If we already have this sessionId, reject as duplicate
  if (sessionId && sessions.has(sessionId)) {
    console.log(`Rejecting duplicate connection with sessionId: ${sessionId}`);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Duplicate connection detected',
      fatal: true
    }));
    return ws.close(1008, 'Duplicate connection');
  }

  if (sessionId) {
    sessions.add(sessionId);
  }

  const playerId = nextPlayerId++;
  console.log(`Player ${playerId} connected (sessionId: ${sessionId || 'none'})`);

  // Create initial player data with health and QuickDraw info
  players.set(playerId, {
    ws,
    sessionId,
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { y: 0 },
    isAiming: false,
    isShooting: false,
    isReloading: false,
    health: 100,
    lastActivity: Date.now(),
    quickDrawLobbyIndex: -1, // -1 means not in any lobby
    inQuickDrawQueue: false,
    inQuickDrawDuel: false,
    quickDrawDuelId: null,
    // Proper Shootout info
    inProperShootout: false,
    properShootoutLobbyId: null,
    // Additional player state
    bullets: 6,
    maxBullets: 6,
    lastUpdateTime: Date.now()
  });

  // Anti-cheat: Initialize timeout tracking
  playerTimeouts.set(playerId, {
    lastShot: 0,
    lastMovement: 0,
    lastReload: 0,
    lastPositionUpdate: 0,
    reloadStartTime: 0,
    isReloading: false
  });

  // Anti-cheat: Initialize nonce/sequence tracking
  playerNonces.set(playerId, new Set());
  playerSequences.set(playerId, 0);

  // Send init data to this client (their ID + existing players)
  ws.send(JSON.stringify({
    type: 'init',
    id: playerId,
    players: Array.from(players.entries())
      .filter(([pid]) => pid !== playerId)
      .map(([pid, p]) => ({
        id: pid,
        position: p.position,
        rotation: p.rotation,
        isAiming: p.isAiming,
        isShooting: p.isShooting,
        isReloading: p.isReloading,
        health: p.health,
        quickDrawLobbyIndex: p.quickDrawLobbyIndex
      }))
  }));

  // Notify others that a new player joined
  broadcastToOthers(playerId, {
    type: 'playerJoined',
    id: playerId,
    position: players.get(playerId).position,
    rotation: players.get(playerId).rotation,
    health: players.get(playerId).health,
    quickDrawLobbyIndex: players.get(playerId).quickDrawLobbyIndex
  });

  // Handle incoming messages
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);

      // Update lastActivity
      const player = players.get(playerId);
      if (!player) return;
      
      player.lastActivity = Date.now();

      // Anti-cheat: Sequence number validation
      if (data.sequenceNumber !== undefined) {
        const lastSequence = playerSequences.get(playerId) || 0;
        
        // Reject if sequence number is not greater than the last one
        if (data.sequenceNumber <= lastSequence) {
          console.log(`Rejecting message with old sequence number: ${data.sequenceNumber} (last: ${lastSequence})`);
          return sendErrorToPlayer(playerId, "Invalid sequence number", false);
        }
        
        // Update the last sequence number
        playerSequences.set(playerId, data.sequenceNumber);
      }

      // Anti-cheat: Nonce validation for critical actions
      if ((data.type === 'shoot' || data.type === 'playerHit') && data.nonce) {
        const playerNonceSet = playerNonces.get(playerId);
        
        // Check if nonce has been used before
        if (playerNonceSet && playerNonceSet.has(data.nonce)) {
          console.log(`Rejecting repeated nonce: ${data.nonce} from player ${playerId}`);
          return sendErrorToPlayer(playerId, "Duplicate nonce detected", false);
        }
        
        // Store the nonce
        if (playerNonceSet) {
          playerNonceSet.add(data.nonce);
          
          // Limit nonce set size to prevent memory issues
          if (playerNonceSet.size > 1000) {
            // Keep only the most recent 500 nonces
            const nonceArray = Array.from(playerNonceSet);
            const newNonceSet = new Set(nonceArray.slice(nonceArray.length - 500));
            playerNonces.set(playerId, newNonceSet);
          }
        }
      }

      switch (data.type) {
        case 'update':
          handlePlayerUpdate(playerId, data);
          break;

        case 'shoot':
          handlePlayerShoot(playerId, data);
          break;

        case 'playerHit':
          handlePlayerHit(playerId, data);
          break;

        case 'reload':
          handlePlayerReload(playerId, data);
          break;

        case 'ping':
          // respond
          ws.send(JSON.stringify({ type: 'pong' }));
          break;
          
        case 'quickDrawJoin':
          handleQuickDrawJoin(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawLeave':
          handleQuickDrawLeave(playerId);
          break;
          
        case 'quickDrawReady':
          handleQuickDrawReady(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawShoot':
          // Pass the hit zone and damage if provided
          handleQuickDrawShoot(
            playerId, 
            data.opponentId, 
            data.arenaIndex, 
            data.hitZone || 'body', 
            data.damage || 40
          );
          break;
          
        case 'properShootoutJoin':
          handleProperShootoutJoin(playerId);
          break;
          
        case 'properShootoutLeave':
          handleProperShootoutLeave(playerId);
          break;

        default:
          break;
      }
    } catch (err) {
      console.error('Error processing message:', err);
    }
  });

  // On close
  ws.on('close', () => {
    cleanupPlayer(playerId);
  });

  // On error
  ws.on('error', (err) => {
    console.error(`WebSocket error for player ${playerId}:`, err);
    cleanupPlayer(playerId);
  });

  // Update the global player count UI
  updatePlayerCount();
});

// Handle player updates - removed speed/position validation
function handlePlayerUpdate(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Basic rate limit for position updates only
  if (now - timeouts.lastPositionUpdate < 16) { // Max 60 updates per second
    return; // Silently ignore too frequent updates
  }
  timeouts.lastPositionUpdate = now;
  
  // Update player data
  if (data.position) {
    player.position = data.position;
  }
  
  // Update other player properties
  player.rotation = data.rotation || player.rotation;
  player.isAiming = data.isAiming !== undefined ? data.isAiming : player.isAiming;
  player.isReloading = data.isReloading !== undefined ? data.isReloading : player.isReloading;
  
  // Update QuickDraw lobby index if provided
  if (data.quickDrawLobbyIndex !== undefined) {
    player.quickDrawLobbyIndex = data.quickDrawLobbyIndex;
  }
  
  if (data.isSprinting !== undefined) {
    player.isSprinting = data.isSprinting;
  }
  
  // Broadcast valid update to others
  broadcastToOthers(playerId, {
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    rotation: player.rotation,
    isAiming: player.isAiming,
    isShooting: player.isShooting,
    isReloading: player.isReloading,
    health: player.health,
    quickDrawLobbyIndex: player.quickDrawLobbyIndex
  });
}

// Anti-cheat: Handle player shooting with validation and server-side trajectory
function handlePlayerShoot(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Check if player has bullets
  if (player.bullets <= 0) {
    return sendErrorToPlayer(playerId, "Cannot shoot: out of ammo", false);
  }
  
  // Anti-cheat: Check if player is reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Cannot shoot while reloading", false);
  }
  
  // Anti-cheat: Enforce weapon cooldown
  if (now - timeouts.lastShot < GAME_CONSTANTS.WEAPON_COOLDOWN) {
    console.log(`Rate limit exceeded: Player ${playerId} attempted to shoot too quickly`);
    return sendErrorToPlayer(playerId, "Shooting too fast", false);
  }
  
  // Quick Draw gun lock validation
  if (player.inQuickDrawDuel && player.quickDrawDuelId) {
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel && duel.state !== 'draw') {
      return sendErrorToPlayer(playerId, "Cannot shoot before draw signal", false);
    }
  }
  
  // Validate bullet data
  if (!data.bulletData || !data.bulletData.position || !data.bulletData.direction) {
    return sendErrorToPlayer(playerId, "Invalid bullet data", false);
  }
  
  // Validate bullet direction (must be normalized)
  const direction = data.bulletData.direction;
  const dirMagnitude = Math.sqrt(direction.x*direction.x + direction.y*direction.y + direction.z*direction.z);
  
  if (Math.abs(dirMagnitude - 1) > 0.01) {
    console.log(`Invalid bullet direction: not normalized for player ${playerId} (magnitude: ${dirMagnitude.toFixed(2)})`);
    
    // Normalize the direction
    direction.x /= dirMagnitude;
    direction.y /= dirMagnitude;
    direction.z /= dirMagnitude;
  }
  
  // All validations passed, decrement bullet count
  player.bullets--;
  
  // Update lastShot timestamp
  timeouts.lastShot = now;
  
  // Create a server-side bullet
  const bulletId = nextBulletId++;
  
  const bullet = {
    id: bulletId,
    sourcePlayerId: playerId,
    position: data.bulletData.position,
    direction: direction,
    distanceTraveled: 0,
    maxDistance: GAME_CONSTANTS.MAX_BULLET_DISTANCE,
    speed: GAME_CONSTANTS.BULLET_SPEED,
    timeCreated: now,
    active: true
  };
  
  // Add to active bullets
  activeBullets.set(bulletId, bullet);
  
  // Notify clients of the shot
  broadcastToAll({
    type: 'playerShoot',
    id: playerId,
    bulletId: bulletId,
    bulletData: {
      position: data.bulletData.position,
      direction: direction
    }
  });
  
  // Update the player's shooting state
  player.isShooting = true;
  
  // Reset shooting state after a short delay
  setTimeout(() => {
    if (players.has(playerId)) {
      players.get(playerId).isShooting = false;
    }
  }, 100);
}

// Anti-cheat: Handle player reload with validation
function handlePlayerReload(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Check if player is already reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Already reloading", false);
  }
  
  // Check if player has full ammo
  if (player.bullets >= player.maxBullets) {
    return sendErrorToPlayer(playerId, "Ammo already full", false);
  }
  
  // Start reload process
  player.isReloading = true;
  timeouts.isReloading = true;
  timeouts.reloadStartTime = now;
  
  // Notify all players about reload start
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    isReloading: true
  });
  
  // Schedule reload completion
  setTimeout(() => {
    if (!players.has(playerId)) return;
    
    const timeouts = playerTimeouts.get(playerId);
    if (!timeouts) return;
    
    // Check if player is still reloading (could have been cancelled)
    if (timeouts.isReloading) {
      const player = players.get(playerId);
      
      // Complete reload
      player.bullets = player.maxBullets;
      player.isReloading = false;
      timeouts.isReloading = false;
      
      // Notify all players about reload completion
      broadcastToAll({
        type: 'playerUpdate',
        id: playerId,
        isReloading: false,
        bullets: player.maxBullets
      });
    }
  }, GAME_CONSTANTS.RELOAD_TIME);
}

// Anti-cheat: Handle player hit validation
function handlePlayerHit(playerId, data) {
  if (!data.targetId) return;
  
  const targetId = parseInt(data.targetId);
  const sourcePlayer = players.get(playerId);
  const targetPlayer = players.get(targetId);
  
  if (!sourcePlayer || !targetPlayer) return;
  
  // Validate that players are in compatible game modes
  const sourceInQuickDraw = sourcePlayer.inQuickDrawDuel;
  const targetInQuickDraw = targetPlayer.inQuickDrawDuel;
  const sourceInShootout = sourcePlayer.inProperShootout;
  const targetInShootout = targetPlayer.inProperShootout;
  
  // Verify that players are either both in QuickDraw, both in Shootout, or both in regular mode
  const bothInQuickDraw = sourceInQuickDraw && targetInQuickDraw && 
                         sourcePlayer.quickDrawDuelId === targetPlayer.quickDrawDuelId;
  const bothInShootout = sourceInShootout && targetInShootout &&
                         sourcePlayer.properShootoutLobbyId === targetPlayer.properShootoutLobbyId;
  const bothInRegularMode = !sourceInQuickDraw && !targetInQuickDraw && 
                           !sourceInShootout && !targetInShootout;
  
  if (!(bothInQuickDraw || bothInShootout || bothInRegularMode)) {
    console.log(`Rejecting hit claim from player ${playerId} on ${targetId}: incompatible game modes`);
    console.log(`Source: QuickDraw=${sourceInQuickDraw}, Shootout=${sourceInShootout}`);
    console.log(`Target: QuickDraw=${targetInQuickDraw}, Shootout=${targetInShootout}`);
    return sendErrorToPlayer(playerId, "Invalid hit: players in different game modes", false);
  }
  
  // Get hit data
  const hitZone = data.hitData && data.hitData.hitZone ? data.hitData.hitZone : 'body';
  const damage = data.hitData && data.hitData.damage ? data.hitData.damage : 40;
  
  // Validate hit zone and damage
  let finalDamage = damage;
  if (hitZone === 'head') {
    finalDamage = 100; // Headshot is always lethal
  } else if (hitZone === 'body') {
    finalDamage = 40; // Body shot deals 40 damage
  } else if (hitZone === 'limbs') {
    finalDamage = 20; // Limb shot deals 20 damage
  }
  
  // Apply hit effects: reduce health
  targetPlayer.health = Math.max(targetPlayer.health - finalDamage, 0);
  
  // Inform the target
  if (targetPlayer.ws.readyState === WebSocket.OPEN) {
    targetPlayer.ws.send(JSON.stringify({
      type: 'hit',
      sourceId: playerId,
      hitData: data.hitData,
      health: targetPlayer.health,
      hitZone: hitZone
    }));
  }
  
  // Broadcast the hit to everyone
  broadcastToAll({
    type: 'playerHit',
    targetId: targetId,
    sourceId: playerId,
    hitPosition: data.hitData ? data.hitData.position : null,
    health: targetPlayer.health,
    bulletId: data.bulletId,
    hitZone: hitZone,
    damage: finalDamage
  });
  
  // Check for player death
  if (targetPlayer.health <= 0) {
    handlePlayerDeath(targetId, playerId);
  }
}

// Anti-cheat: Bullet-player collision detection
function isPlayerHitByBullet(player, bullet) {
  // Calculate player hitbox (simple cylinder)
  const playerRadius = 0.6;  // Increased horizontal radius to match client's bodyWidth
  const playerHeight = 2.0;  // vertical height
  
  // Calculate distance from bullet to player (horizontal only)
  const dx = bullet.position.x - player.position.x;
  const dz = bullet.position.z - player.position.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  // Check if bullet is within player's horizontal radius
  if (horizontalDist > playerRadius) {
    return false;
  }
  
  // Check if bullet is within player's vertical bounds
  const bulletY = bullet.position.y;
  const playerBottom = player.position.y - 1.6; // Adjust based on your coordinate system
  const playerTop = playerBottom + playerHeight;
  
  // Add some tolerance to vertical bounds
  const tolerance = 0.2;
  if (bulletY < playerBottom - tolerance || bulletY > playerTop + tolerance) {
    return false;
  }
  
  // Bullet is inside player's hitbox
  return true;
}

// Anti-cheat: Handle player death
function handlePlayerDeath(playerId, killedById) {
  const player = players.get(playerId);
  if (!player) return;
  
  console.log(`Player ${playerId} was killed by player ${killedById}`);
  
  // If player is in Quick Draw duel, end the duel
  if (player.inQuickDrawDuel && player.quickDrawDuelId) {
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel) {
      endQuickDrawDuel(player.quickDrawDuelId, killedById);
    }
  }
  
  // If player was in Proper Shootout, handle kill scoring
  if (player.inProperShootout && player.properShootoutLobbyId) {
    const lobbyId = player.properShootoutLobbyId;
    const lobby = properShootoutLobbies.get(lobbyId);
    const killer = players.get(killedById);
    
    if (lobby && killer && killer.inProperShootout && killer.properShootoutLobbyId === lobbyId) {
      // Increment killer's score
      const currentKills = lobby.scores.get(killedById) || 0;
      const newKills = currentKills + 1;
      lobby.scores.set(killedById, newKills);
      
      // Notify lobby about the kill
      notifyLobbyPlayers(lobbyId, {
        type: 'properShootoutKill',
        killerId: killedById,
        victimId: playerId,
        scores: getScoresArray(lobby)
      });
      
      // Check if killer reached win condition
      if (newKills >= SHOOTOUT_WIN_SCORE) {
        // End the match
        notifyLobbyPlayers(lobbyId, {
          type: 'properShootoutEnd',
          winnerId: killedById,
          scores: getScoresArray(lobby)
        });
        
        // Reset the lobby
        resetProperShootoutLobby(lobbyId);
      }
    }
  }
  
  // Respawn the player
  respawnPlayer(playerId);
}

// Anti-cheat: Respawn a player
function respawnPlayer(playerId) {
  const player = players.get(playerId);
  if (!player) return;
  
  // Reset player state
  player.health = 100;
  player.bullets = player.maxBullets;
  player.isReloading = false;
  player.isAiming = false;
  player.isShooting = false;
  
  // If in Proper Shootout, use map-specific spawn
  if (player.inProperShootout) {
    const spawnPos = generateRandomShootoutPosition();
    player.position = spawnPos;
  } else {
    // Generate random spawn position within town
    const spawnX = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_WIDTH * 0.8;
    const spawnY = 1.6;
    const spawnZ = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_LENGTH * 0.8;
    
    // Set spawn position
    player.position = { x: spawnX, y: spawnY, z: spawnZ };
  }
  
  // Reset QuickDraw-related state if not in a duel
  if (!player.inQuickDrawDuel) {
    player.quickDrawLobbyIndex = -1;
  }
  
  // Notify the player they're respawning
  if (player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'respawn',
      position: player.position,
      health: player.health,
      bullets: player.bullets
    }));
  }
  
  // Broadcast the respawn to all players
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    health: player.health,
    isReloading: false,
    isAiming: false
  });
}

// Anti-cheat: Check if position is within town boundaries
function isPositionInTown(position) {
  return (
    position.x >= -GAME_CONSTANTS.TOWN_WIDTH / 2 &&
    position.x <= GAME_CONSTANTS.TOWN_WIDTH / 2 &&
    position.z >= -GAME_CONSTANTS.TOWN_LENGTH / 2 &&
    position.z <= GAME_CONSTANTS.TOWN_LENGTH / 2
  );
}

// Anti-cheat: Check if position is in arena
function isPositionInArena(position, arenaIndex) {
  // Define arena positions and radius
  const arenaRadius = 15;
  
  // Calculate arena center position based on index
  const spacingX = 50;
  const baseZ = GAME_CONSTANTS.TOWN_LENGTH + 50;
  
  const offsetX = (arenaIndex - 2) * spacingX; // Center on zero, spread outward
  const arenaCenter = { x: offsetX, y: 0, z: baseZ };
  
  // Check if point is inside arena (horizontally)
  const dx = position.x - arenaCenter.x;
  const dz = position.z - arenaCenter.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  return horizontalDist < arenaRadius;
}

// Anti-cheat: Send position correction to player
function sendPositionCorrection(playerId, correctPosition) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  player.ws.send(JSON.stringify({
    type: 'positionCorrection',
    position: correctPosition
  }));
}

// Anti-cheat: Send error message to player
function sendErrorToPlayer(playerId, message, fatal = false) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  player.ws.send(JSON.stringify({
    type: 'error',
    message: message,
    fatal: fatal
  }));
}

// Cleanup a disconnected or stale player
function cleanupPlayer(playerId) {
  const player = players.get(playerId);
  if (player) {
    console.log(`Player ${playerId} disconnected`);
    if (player.sessionId) {
      sessions.delete(player.sessionId);
    }
    
    // Quick Draw cleanup
    if (player.inQuickDrawQueue && player.quickDrawLobbyIndex >= 0) {
      // Remove from the appropriate queue
      const queueIndex = player.quickDrawLobbyIndex;
      if (queueIndex >= 0 && queueIndex < MAX_ARENAS) {
        const queue = quickDrawQueues[queueIndex];
        const index = queue.indexOf(playerId);
        if (index !== -1) {
          queue.splice(index, 1);
        }
      }
    }
    
    if (player.inQuickDrawDuel && player.quickDrawDuelId) {
      // End any active duel
      const duel = quickDrawDuels.get(player.quickDrawDuelId);
      if (duel) {
        // The other player wins by default
        const winnerId = duel.player1Id === playerId ? duel.player2Id : duel.player1Id;
        endQuickDrawDuel(player.quickDrawDuelId, winnerId);
      }
    }
    
    // Proper Shootout cleanup
    if (player.inProperShootout && player.properShootoutLobbyId) {
      removePlayerFromShootoutLobby(playerId, player.properShootoutLobbyId);
    }
    
    players.delete(playerId);
    
    // Anti-cheat: Clean up associated data
    playerTimeouts.delete(playerId);
    playerNonces.delete(playerId);
    playerSequences.delete(playerId);

    // Notify all that the player left
    broadcastToAll({
      type: 'playerLeft',
      id: playerId
    });

    updatePlayerCount();
  }
}

// Broadcast a "playerCount" update to all
function updatePlayerCount() {
  broadcastToAll({
    type: 'playerCount',
    count: players.size
  });
}

// Broadcast to all except a given playerId
function broadcastToOthers(excludeId, data) {
  for (const [pid, pl] of players.entries()) {
    if (pid === excludeId) continue;
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Broadcast to all players
function broadcastToAll(data) {
  for (const [pid, pl] of players.entries()) {
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

/**
 * Handle a player joining a specific Quick Draw queue.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index to join (0-4)
 */
function handleQuickDrawJoin(playerId, arenaIndex) {
  // Validate arena index
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    console.error(`Invalid arena index: ${arenaIndex}`);
    return;
  }
  
  console.log(`Player ${playerId} joined Quick Draw queue for arena ${arenaIndex + 1}`);
  const playerData = players.get(playerId);
  
  if (!playerData || playerData.inQuickDrawQueue || playerData.inQuickDrawDuel || playerData.inProperShootout) {
    return; // Invalid state
  }
  
  // Add to the specific queue
  playerData.inQuickDrawQueue = true;
  playerData.quickDrawLobbyIndex = arenaIndex;
  quickDrawQueues[arenaIndex].push(playerId);
  
  // Notify the player they joined the queue
  playerData.ws.send(JSON.stringify({
    type: 'quickDrawJoin',
    arenaIndex: arenaIndex
  }));
  
  // Check if we have enough players in this queue to start a match
  checkQuickDrawQueue(arenaIndex);
}

/**
 * Handle a player leaving the Quick Draw queue.
 * @param {number} playerId - The player's ID
 */
function handleQuickDrawLeave(playerId) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawQueue) {
    return; // Invalid state
  }
  
  // Get the arena index
  const arenaIndex = playerData.quickDrawLobbyIndex;
  if (arenaIndex >= 0 && arenaIndex < MAX_ARENAS) {
    console.log(`Player ${playerId} left Quick Draw queue for arena ${arenaIndex + 1}`);
    
    // Remove from appropriate queue
    const index = quickDrawQueues[arenaIndex].indexOf(playerId);
    if (index !== -1) {
      quickDrawQueues[arenaIndex].splice(index, 1);
    }
  }
  
  // Reset player state
  playerData.inQuickDrawQueue = false;
  playerData.quickDrawLobbyIndex = -1;
}

/**
 * Check if we have enough players in a specific Quick Draw queue to start a match.
 * @param {number} arenaIndex - The arena index to check
 */
function checkQuickDrawQueue(arenaIndex) {
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    return; // Invalid arena index
  }
  
  const queue = quickDrawQueues[arenaIndex];
  
  if (queue.length < 2) {
    return; // Not enough players in this queue
  }
  
  // Get the two players who have been waiting the longest
  const player1Id = queue.shift();
  const player2Id = queue.shift();
  
  // Make sure both players are still connected
  const player1 = players.get(player1Id);
  const player2 = players.get(player2Id);
  
  if (!player1 || !player2) {
    // Put the valid player back in the queue
    if (player1) queue.push(player1Id);
    if (player2) queue.push(player2Id);
    return;
  }
  
  // Create a new duel
  const duelId = `duel_${arenaIndex}_${player1Id}_${player2Id}`;
  quickDrawDuels.set(duelId, {
    id: duelId,
    arenaIndex: arenaIndex,
    player1Id,
    player2Id,
    state: 'starting',
    startTime: Date.now()
  });
  
  // Mark players as in a duel
  player1.inQuickDrawQueue = false;
  player1.inQuickDrawDuel = true;
  player1.quickDrawDuelId = duelId;
  
  player2.inQuickDrawQueue = false;
  player2.inQuickDrawDuel = true;
  player2.quickDrawDuelId = duelId;
  
  // Reset player health to full at the start of the duel
  player1.health = 100;
  player2.health = 100;
  
  // Notify players of the match
  player1.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player2Id,
    position: 'left', // Player 1 spawns on the left
    arenaIndex: arenaIndex
  }));
  
  player2.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player1Id,
    position: 'right', // Player 2 spawns on the right
    arenaIndex: arenaIndex
  }));
  
  console.log(`Started Quick Draw duel ${duelId} between players ${player1Id} and ${player2Id} in arena ${arenaIndex + 1}`);
}

/**
 * Handle a player being ready in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index for the duel
 */
function handleQuickDrawReady(playerId, arenaIndex) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  const duelId = playerData.quickDrawDuelId;
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  // Verify arena index matches
  if (arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
    console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
    return;
  }
  
  // Mark this player as ready
  if (duel.player1Id === playerId) {
    duel.player1Ready = true;
  } else if (duel.player2Id === playerId) {
    duel.player2Ready = true;
  }
  
  // If both players are ready, start the duel sequence
  if (duel.player1Ready && duel.player2Ready) {
    startQuickDrawDuel(duelId);
  }
}

/**
 * Start the Quick Draw duel sequence.
 * @param {string} duelId - The duel ID
 */
function startQuickDrawDuel(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'ready';
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Show "READY?" message to both players
  player1.ws.send(JSON.stringify({ type: 'quickDrawReady' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawReady' }));
  
  // After 1 second, start the countdown
  setTimeout(() => {
    if (quickDrawDuels.has(duelId)) {
      duel.state = 'countdown';
      player1.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
      player2.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
      
      // Set a random time for the draw signal (1-8 seconds)
      const drawTime = 1000 + Math.floor(Math.random() * 7000);
      duel.drawTimeout = setTimeout(() => {
        if (quickDrawDuels.has(duelId)) {
          sendDrawSignal(duelId);
        }
      }, drawTime);
    }
  }, 1000);
}

/**
 * Send the "DRAW!" signal to both players.
 * @param {string} duelId - The duel ID
 */
function sendDrawSignal(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'draw';
  duel.drawTime = Date.now();
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Send draw signal to both players
  player1.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  
  console.log(`Draw signal sent for duel ${duelId} in arena ${duel.arenaIndex + 1}`);
}

/**
 * Handle a player shooting in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} targetId - The target player's ID
 * @param {number} arenaIndex - The arena index for the duel
 * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
 * @param {number} damage - The damage amount
 */
function handleQuickDrawShoot(playerId, targetId, arenaIndex, hitZone = 'body', damage = 40) {
    playerId = Number(playerId);
    targetId = Number(targetId);
    
    console.log(`Quick Draw shoot: Player ${playerId} shot player ${targetId} in arena ${arenaIndex + 1} (${hitZone}, ${damage} damage)`);
    
    const playerData = players.get(playerId);
    
    if (!playerData || !playerData.inQuickDrawDuel) {
        console.log(`Quick Draw shoot rejected: Player ${playerId} not in a duel`);
        return; // Invalid state
    }
    
    const duelId = playerData.quickDrawDuelId;
    const duel = quickDrawDuels.get(duelId);
    
    if (!duel) {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not found`);
        return; // Invalid duel
    }
    
    // Verify arena index matches
    if (arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
        console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
        return;
    }
    
    if (duel.state !== 'draw') {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not in 'draw' state, current state: ${duel.state}`);
        return; // Can only shoot in 'draw' state
    }
    
    // Make sure the target is the opponent in this duel
    const isValidTarget = (duel.player1Id === playerId && duel.player2Id === targetId) ||
                          (duel.player2Id === playerId && duel.player1Id === targetId);
    
    if (!isValidTarget) {
        console.log(`Quick Draw shoot rejected: Invalid target ${targetId} for player ${playerId} in duel ${duelId}`);
        return; // Not shooting at the opponent
    }
    
    // Get the target player to check their health
    const targetPlayer = players.get(targetId);
    if (!targetPlayer) {
        console.log(`Quick Draw shoot rejected: Target player ${targetId} not found`);
        return;
    }
    
    console.log(`Quick Draw shoot ACCEPTED: Player ${playerId} hit player ${targetId} in duel ${duelId}`);
    
    // Calculate damage based on hit zone if not explicitly provided
    let finalDamage = damage;
    if (!finalDamage) {
        if (hitZone === 'head') {
            finalDamage = 100; // Headshot is fatal
        } else if (hitZone === 'body') {
            finalDamage = 40;  // Body shot
        } else if (hitZone === 'limbs') {
            finalDamage = 20;  // Limb shot
        } else {
            finalDamage = 40;  // Default to body shot damage
        }
    }
    
    // Apply the damage to the target player
    const previousHealth = targetPlayer.health;
    targetPlayer.health = Math.max(targetPlayer.health - finalDamage, 0);
    console.log(`Applied ${finalDamage} damage to player ${targetId}. Health reduced from ${previousHealth} to ${targetPlayer.health}`);
    
    // Notify the hit player
    if (targetPlayer.ws.readyState === WebSocket.OPEN) {
        targetPlayer.ws.send(JSON.stringify({
            type: 'hit',
            sourceId: playerId,
            hitData: { 
                position: targetPlayer.position, 
                hitZone: hitZone,
                damage: finalDamage
            },
            health: targetPlayer.health,
            hitZone: hitZone
        }));
    }
    
    // Broadcast hit to all players
    broadcastToAll({
        type: 'playerHit',
        targetId: targetId,
        sourceId: playerId,
        hitPosition: targetPlayer.position,
        health: targetPlayer.health,
        hitZone: hitZone,
        damage: finalDamage
    });
    
    // Only end the duel if the target's health is 0
    if (targetPlayer.health <= 0) {
        console.log(`Player ${targetId} was killed. Ending duel ${duelId} with ${playerId} as winner`);
        endQuickDrawDuel(duelId, playerId);
    } else {
        console.log(`Player ${targetId} was hit but survived with ${targetPlayer.health} health. Duel continues.`);
        // Don't end the duel, just let the game continue
    }
}

/**
 * End a Quick Draw duel.
 * @param {string} duelId - The ID of the duel to end
 * @param {number|null} winnerId - The ID of the winning player or null if draw/aborted
 */
function endQuickDrawDuel(duelId, winnerId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  const arenaIndex = duel.arenaIndex;
  console.log(`Ending duel ${duelId} in arena ${arenaIndex + 1} with winner ${winnerId || 'none'}`);
  
  // Clear any pending timeouts
  if (duel.drawTimeout) {
    clearTimeout(duel.drawTimeout);
  }
  
  // Get the players
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  // Update player states
  if (player1) {
    player1.inQuickDrawDuel = false;
    player1.quickDrawDuelId = null;
    
    // Notify player 1 of the result
    player1.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId
    }));
    
    // If player 1 lost, set their health to 0
    if (winnerId && winnerId !== duel.player1Id) {
      player1.health = 0;
    }
  }
  
  if (player2) {
    player2.inQuickDrawDuel = false;
    player2.quickDrawDuelId = null;
    
    // Notify player 2 of the result
    player2.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId
    }));
    
    // If player 2 lost, set their health to 0
    if (winnerId && winnerId !== duel.player2Id) {
      player2.health = 0;
    }
  }
  
  // Remove the duel
  quickDrawDuels.delete(duelId);
}

/**
 * Handle a player joining a Proper Shootout match
 * @param {number} playerId - The player's ID
 */
function handleProperShootoutJoin(playerId) {
  const player = players.get(playerId);
  
  if (!player) {
    return; // Invalid player
  }
  
  console.log(`Player ${playerId} requested to join Proper Shootout match`);
  
  // Check if player is already in a game mode
  if (player.inQuickDrawQueue || player.inQuickDrawDuel || player.inProperShootout) {
    return sendErrorToPlayer(playerId, "Already in a game mode", false);
  }
  
  // Find a lobby with space or create a new one
  let lobbyId = null;
  let lobby = null;
  
  // Look for existing lobbies with space
  for (const [id, existingLobby] of properShootoutLobbies.entries()) {
    if (existingLobby.players.size < MAX_SHOOTOUT_PLAYERS) {
      lobbyId = id;
      lobby = existingLobby;
      break;
    }
  }
  
  // Create a new lobby if none found
  if (!lobbyId) {
    lobbyId = `lobby_${nextLobbyId++}`;
    lobby = {
      id: lobbyId,
      players: new Set(),
      scores: new Map(), // playerId -> kills
      startTime: Date.now()
    };
    properShootoutLobbies.set(lobbyId, lobby);
    console.log(`Created new Proper Shootout lobby: ${lobbyId}`);
  }
  
  // Add player to lobby
  lobby.players.add(playerId);
  lobby.scores.set(playerId, 0);
  
  // Update player state
  player.inProperShootout = true;
  player.properShootoutLobbyId = lobbyId;
  
  // Reset player health
  player.health = 100;
  
  // Generate random spawn position
  const spawnPos = generateRandomShootoutPosition();
  
  // Send join confirmation to player with spawn position
  player.ws.send(JSON.stringify({
    type: 'properShootoutJoin',
    lobbyId: lobbyId,
    position: spawnPos,
    scores: getScoresArray(lobby)
  }));
  
  // Notify other players in the lobby
  notifyLobbyPlayers(lobbyId, {
    type: 'properShootoutPlayerJoin',
    playerId: playerId,
    scores: getScoresArray(lobby)
  }, playerId);
  
  console.log(`Player ${playerId} joined Proper Shootout lobby ${lobbyId}`);
}

/**
 * Handle a player leaving a Proper Shootout match
 * @param {number} playerId - The player's ID
 */
function handleProperShootoutLeave(playerId) {
  const player = players.get(playerId);
  
  if (!player || !player.inProperShootout) {
    return; // Invalid state
  }
  
  const lobbyId = player.properShootoutLobbyId;
  const lobby = properShootoutLobbies.get(lobbyId);
  
  if (lobby) {
    removePlayerFromShootoutLobby(playerId, lobbyId);
  }
  
  // Update player state
  player.inProperShootout = false;
  player.properShootoutLobbyId = null;
  
  // Send leave confirmation to player
  player.ws.send(JSON.stringify({
    type: 'properShootoutLeave'
  }));
  
  console.log(`Player ${playerId} left Proper Shootout lobby ${lobbyId}`);
}

/**
 * Remove a player from a Proper Shootout lobby and update lobby state
 * @param {number} playerId - The player's ID
 * @param {string} lobbyId - The lobby ID
 */
function removePlayerFromShootoutLobby(playerId, lobbyId) {
  const lobby = properShootoutLobbies.get(lobbyId);
  
  if (!lobby) {
    return;
  }
  
  // Remove player from lobby
  lobby.players.delete(playerId);
  lobby.scores.delete(playerId);
  
  // Notify other players in the lobby
  notifyLobbyPlayers(lobbyId, {
    type: 'properShootoutPlayerLeave',
    playerId: playerId,
    scores: getScoresArray(lobby)
  });
  
  // If lobby is empty, remove it
  if (lobby.players.size === 0) {
    properShootoutLobbies.delete(lobbyId);
    console.log(`Removed empty Proper Shootout lobby: ${lobbyId}`);
  }
}

/**
 * Generate a random position within the Proper Shootout map
 * @returns {Object} - Random position {x, y, z}
 */
function generateRandomShootoutPosition() {
  const x = SHOOTOUT_MAP_CENTER.x + (Math.random() - 0.5) * (SHOOTOUT_MAP_DIMENSIONS.width - 5);
  const y = 1.6; // Player height
  const z = SHOOTOUT_MAP_CENTER.z + (Math.random() - 0.5) * (SHOOTOUT_MAP_DIMENSIONS.length - 5);
  
  return { x, y, z };
}

/**
 * Notify all players in a lobby about an event
 * @param {string} lobbyId - The lobby ID
 * @param {Object} data - The message data to send
 * @param {number} excludeId - Optional player ID to exclude
 */
function notifyLobbyPlayers(lobbyId, data, excludeId = null) {
  const lobby = properShootoutLobbies.get(lobbyId);
  
  if (!lobby) {
    return;
  }
  
  for (const playerId of lobby.players) {
    if (excludeId !== null && playerId === excludeId) {
      continue;
    }
    
    const player = players.get(playerId);
    if (player && player.ws.readyState === WebSocket.OPEN) {
      player.ws.send(JSON.stringify(data));
    }
  }
}

/**
 * Convert lobby scores map to array for sending to clients
 * @param {Object} lobby - The lobby object
 * @returns {Array} - Array of {playerId, kills}
 */
function getScoresArray(lobby) {
  const scores = [];
  
  for (const [playerId, kills] of lobby.scores.entries()) {
    scores.push({
      playerId,
      kills
    });
  }
  
  return scores;
}

/**
 * Reset a Proper Shootout lobby after a match ends
 * @param {string} lobbyId - The lobby ID
 */
function resetProperShootoutLobby(lobbyId) {
  const lobby = properShootoutLobbies.get(lobbyId);
  
  if (!lobby) {
    return;
  }
  
  // Create a new lobby with the same ID
  const newLobby = {
    id: lobbyId,
    players: new Set(), // Start with no players
    scores: new Map(),
    startTime: Date.now()
  };
  
  properShootoutLobbies.set(lobbyId, newLobby);
  
  // Remove players from the old lobby, they'll need to rejoin
  for (const playerId of lobby.players) {
    const player = players.get(playerId);
    if (player) {
      player.inProperShootout = false;
      player.properShootoutLobbyId = null;
    }
  }
  
  console.log(`Reset Proper Shootout lobby: ${lobbyId}`);
}

// Anti-cheat: Server-side bullet physics update
function updateBullets() {
  const now = Date.now();
  
  // Update each active bullet
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) continue;
    
    // Calculate time since last update
    const deltaTime = (now - bullet.timeCreated) / 1000;
    
    // Calculate new position
    const distanceThisFrame = bullet.speed * deltaTime;
    bullet.position.x += bullet.direction.x * distanceThisFrame;
    bullet.position.y += bullet.direction.y * distanceThisFrame;
    bullet.position.z += bullet.direction.z * distanceThisFrame;
    
    // Update total distance traveled
    bullet.distanceTraveled += distanceThisFrame;
    
    // Check if bullet has traveled too far
    if (bullet.distanceTraveled >= bullet.maxDistance) {
      bullet.active = false;
      continue;
    }
    
    // Check for collisions with terrain (ground or town boundary)
    if (bullet.position.y <= 0.1) {
      // Hit ground
      bullet.active = false;
      broadcastBulletImpact(bulletId, 'ground', null, bullet.position);
      continue;
    }
    
    // Check town boundaries (if not in a Quick Draw arena)
    if (!isPositionInTown(bullet.position)) {
      // Only check arena boundaries if source player is in a duel
      const sourcePlayer = players.get(bullet.sourcePlayerId);
      if (!sourcePlayer || !sourcePlayer.inQuickDrawDuel) {
        bullet.active = false;
        broadcastBulletImpact(bulletId, 'boundary', null, bullet.position);
        continue;
      }
    }
    
    // Check for collisions with players
    for (const [playerId, player] of players.entries()) {
      // Skip collision with bullet owner
      if (playerId === bullet.sourcePlayerId) continue;
      
      // Skip collisions across arena boundary
      const bulletSourcePlayer = players.get(bullet.sourcePlayerId);
      const targetInDuel = player.inQuickDrawDuel;
      const sourceInDuel = bulletSourcePlayer ? bulletSourcePlayer.inQuickDrawDuel : false;
      
      // Only allow hits if both in same state (both in arena or both outside)
      if (targetInDuel !== sourceInDuel) {
        continue;
      }
      
      // Check for collision
      if (isPlayerHitByBullet(player, bullet)) {
        bullet.active = false;
        
        // Calculate damage based on hit position (simplified for server-side)
        // This is a simplified version; the client sends more detailed hit zone info
        let damage = GAME_CONSTANTS.DAMAGE_PER_HIT;
        let hitZone = 'body'; // Default to body hit
        
        // Very basic hit zone detection based on bullet height
        const playerBottom = player.position.y - 1.6;
        const playerTop = playerBottom + 2.0;
        const relativeHeight = (bullet.position.y - playerBottom) / (playerTop - playerBottom);
        
        if (relativeHeight > 0.8) {
          hitZone = 'head';
          damage = 100; // Headshot is fatal
        } else if (relativeHeight > 0.4) {
          hitZone = 'body';
          damage = 40; // Body shot
        } else {
          hitZone = 'limbs';
          damage = 20; // Limb shot
        }
        
        // Handle the hit
        player.health = Math.max(player.health - damage, 0);
        
        // Notify the hit player
        if (player.ws.readyState === WebSocket.OPEN) {
          player.ws.send(JSON.stringify({
            type: 'hit',
            sourceId: bullet.sourcePlayerId,
            bulletId: bulletId,
            health: player.health,
            hitZone: hitZone
          }));
        }
        
        // Broadcast hit to all players
        broadcastBulletImpact(bulletId, 'player', playerId, bullet.position, hitZone);
        
        // Check for player death
        if (player.health <= 0) {
          handlePlayerDeath(playerId, bullet.sourcePlayerId);
        }
        
        break;
      }
    }
  }
  
  // Clean up inactive bullets
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) {
      activeBullets.delete(bulletId);
    }
  }
}

// Anti-cheat: Broadcast bullet impact to all players
function broadcastBulletImpact(bulletId, hitType, targetId, position, hitZone) {
  broadcastToAll({
    type: 'bulletImpact',
    bulletId: bulletId,
    hitType: hitType,
    targetId: targetId,
    position: position,
    hitZone: hitZone
  });
}

// Heartbeat to remove stale connections
const HEARTBEAT_INTERVAL = 30000; // 30s
const CONNECTION_TIMEOUT = 60000; // 60s

setInterval(() => {
  const now = Date.now();
  for (const [id, player] of players.entries()) {
    if (now - player.lastActivity > CONNECTION_TIMEOUT) {
      console.log(`Removing stale connection for player ${id}`);
      if (player.ws.readyState === WebSocket.OPEN) {
        player.ws.close(1000, 'Connection timeout');
      }
      cleanupPlayer(id);
    } else if (player.ws.readyState === WebSocket.OPEN) {
      // keep alive
      player.ws.send(JSON.stringify({ type: 'ping' }));
    }
  }
}, HEARTBEAT_INTERVAL);

// Anti-cheat: Run physics update loop
setInterval(updateBullets, GAME_CONSTANTS.PHYSICS_UPDATE_INTERVAL);

// Start server
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  
  // If the environment variable USE_NGROK is set to 'true', start an ngrok tunnel.
  if (process.env.USE_NGROK === 'true') {
    // Dynamically require ngrok so it is only used when needed.
    const ngrok = require('ngrok');
    (async function() {
      try {
        // Connect ngrok to the same port that the server is running on.
        const url = await ngrok.connect({
          addr: PORT,
          // You can add additional ngrok options here (e.g., authtoken, subdomain, region)
        });
        console.log(`ngrok tunnel established at ${url}`);
      } catch (error) {
        console.error('Error starting ngrok tunnel:', error);
      }
    })();
  }
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Server shutting down...');
  
  // End all Quick Draw duels
  for (const duelId of quickDrawDuels.keys()) {
    endQuickDrawDuel(duelId, null);
  }
  
  for (const [id, player] of players.entries()) {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.close(1000, 'Server shutting down');
    }
  }
  server.close(() => {
    console.log('Server shutdown complete.');
    process.exit(0);
  });
});
    </codebase>
</context>

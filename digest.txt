<goal>
I want you to fully explain to me how the basic multiplayer/websocket server and player animation statemachine/syncing between clients work, so that i have a starting point that helps me create another multiplayer server for another game.
</goal>


<context>
    <codebase>
Directory structure:
└── /./
    ├── LICENSE
    ├── package.json
    ├── public/
    │   ├── css/
    │   │   └── style.css
    │   ├── dev.html
    │   ├── index.html
    │   ├── js/
    │   │   ├── bullet.js
    │   │   ├── chat.js
    │   │   ├── desertTerrain.js
    │   │   ├── effects.js
    │   │   ├── flyingEagle.js
    │   │   ├── input.js
    │   │   ├── logger.js
    │   │   ├── main.js
    │   │   ├── multiplayerManager.js
    │   │   ├── network.js
    │   │   ├── networkManager.js
    │   │   ├── npcManager.js
    │   │   ├── phantom-wallet.js
    │   │   ├── physics.js
    │   │   ├── player.js
    │   │   ├── playerIdentity.js
    │   │   ├── playerModel.js
    │   │   ├── quickDraw.js
    │   │   ├── scene.js
    │   │   ├── smokeRingEffect.js
    │   │   ├── soundManager.js
    │   │   ├── train-animation.js
    │   │   ├── tumbleweed.js
    │   │   ├── ui.js
    │   │   ├── viewmodel-config.js
    │   │   └── viewmodel.js
    │   ├── models/
    │   │   ├── bartender.glb
    │   │   ├── eagle.glb
    │   │   ├── playermodel.glb
    │   │   ├── sheriff.glb
    │   │   ├── textures/
    │   │   ├── town.glb
    │   │   ├── townold2.glb
    │   │   ├── train.glb
    │   │   ├── tumbleweed.glb
    │   │   ├── viewmodel.glb
    │   │   └── viewmodelold.glb
    │   ├── sounds/
    │   └── wallet-demo.html
    ├── readme.md
    └── server.js

================================================
File: /LICENSE
================================================
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU Affero General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Remote Network Interaction; Use with the GNU General Public License.

  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<https://www.gnu.org/licenses/>.


================================================
File: /package.json
================================================
{
  "name": "wild-western-shooter",
  "version": "1.0.0",
  "description": "A Three.js Wild Western Shooter game with a Node.js server.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "@solana/wallet-adapter-base": "^0.9.24",
    "@solana/wallet-adapter-phantom": "^0.9.25",
    "@solana/web3.js": "^1.98.0",
    "cannon": "^0.6.2",
    "dotenv": "^16.4.7",
    "express": "^4.18.2",
    "ngrok": "^4.3.3",
    "node-telegram-bot-api": "^0.66.0",
    "ws": "^8.13.0"
  }
}


================================================
File: /public/css/style.css
================================================
/* Add this at the top to ensure proper fullscreen */
*, *::before, *::after {
  box-sizing: border-box;
}

body, html {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background-color: #000;
  font-family: 'Courier New', Courier, monospace;
  /* Ensure the canvas extends to the edge of the screen */
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}

#game-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #000;
}

canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100% !important;
  height: 100% !important;
  margin: 0;
  padding: 0;
  display: block;
  background-color: #000;
}

#ammo-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
}
#reload-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  display: none;
}
#reload-progress-container {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-progress-bar {
  height: 100%;
  width: 0%;
  background-color: #FF6B00;
  border-radius: 10px;
  transition: width 0.05s linear;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  /* transform is now handled by inline style with !important */
  width: 80px;
  height: 80px;
  display: none; /* Will be controlled by JavaScript */
  pointer-events: none;
  z-index: 100;
  will-change: transform, opacity;
}

#crosshair svg {
  width: 100%;
  height: 100%;
}

/* Corner group style and transforms */
.corner-group {
  transform-origin: 50px 50px;
  opacity: 0;
  will-change: transform, opacity;
}

/* Center dot animation */
#crosshair circle {
  opacity: 0;
  will-change: opacity;
  transition: opacity 250ms cubic-bezier(0.2, 0.8, 0.2, 1);
}

#crosshair.expand circle {
  opacity: 1;
  transition-delay: 0ms; /* Fade in first */
}

#crosshair.expanded circle {
  opacity: 1;
}

#crosshair.contract circle {
  opacity: 0;
  transition-delay: 0ms; /* Immediate fade out instead of delayed */
}

/* Top corner animations */
@keyframes expand-top {
  0% {
    transform: translate(0, 35px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-top {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(0, 35px) scale(0);
    opacity: 0;
  }
}

/* Bottom left corner animations */
@keyframes expand-bottom-left {
  0% {
    transform: translate(30px, -25px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-bottom-left {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(30px, -25px) scale(0);
    opacity: 0;
  }
}

/* Bottom right corner animations */
@keyframes expand-bottom-right {
  0% {
    transform: translate(-30px, -25px) scale(0);
    opacity: 0;
  }
  100% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
}

@keyframes contract-bottom-right {
  0% {
    transform: translate(0, 0) scale(1);
    opacity: 1;
  }
  100% {
    transform: translate(-30px, -25px) scale(0);
    opacity: 0;
  }
}

/* Apply specific animations to each corner */
#crosshair.expand #top-corner {
  animation: expand-top 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.expand #bottom-left-corner {
  animation: expand-bottom-left 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.expand #bottom-right-corner {
  animation: expand-bottom-right 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #top-corner {
  animation: contract-top 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #bottom-left-corner {
  animation: contract-bottom-left 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

#crosshair.contract #bottom-right-corner {
  animation: contract-bottom-right 250ms cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
}

/* Set expanded state */
#crosshair.expanded #top-corner,
#crosshair.expanded #bottom-left-corner,
#crosshair.expanded #bottom-right-corner {
  opacity: 1;
  transform: translate(0, 0) scale(1);
}

/* Make all elements animate with the same timing function */
#crosshair path,
#crosshair g,
#crosshair circle {
  transition-property: opacity, transform;
  transition-duration: 250ms;
  transition-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
}

/* Ensure elements fade out when contract class is present */
#crosshair.contract circle {
  opacity: 0;
  transition-delay: 0ms; /* Immediate fade out instead of delayed */
}

/* Make corner groups start contracting before center dot fades */
#crosshair.contract #top-corner {
  animation-delay: 50ms !important; /* Delay to start after dot begins fading */
}

#crosshair.contract #bottom-left-corner {
  animation-delay: 70ms !important; /* Slightly more delay */
}

#crosshair.contract #bottom-right-corner {
  animation-delay: 70ms !important; /* Slightly more delay */
}

/* Individual delays for staggered animation */
#top-corner {
  animation-delay: 50ms !important; /* Delayed after center dot appears */
}

#bottom-left-corner {
  animation-delay: 80ms !important; /* Delayed after center dot appears */
}

#bottom-right-corner {
  animation-delay: 80ms !important; /* Delayed after center dot appears */
}

/* SVG Line styles */
#crosshair line {
  stroke-linecap: round;
  transform-box: fill-box;
  transform-origin: center;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}

/* Remove the above styles and add these instead */
#crosshair path {
  stroke-linecap: round;
  stroke-linejoin: round;
}

/* Force hardware acceleration for smoother animations */
#crosshair, #crosshair svg, #crosshair g, #crosshair path, #crosshair circle {
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  -webkit-perspective: 1000;
  perspective: 1000;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}

#fps-counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#player-count {
  position: absolute;
  top: 50px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#connection-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#network-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
  transition: opacity 1s;
}

/* Quick Draw game mode styles */
#quick-draw-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 48px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  z-index: 1000;
}

#draw-circle {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 300px;
  height: 300px;
  border-radius: 50%;
  border: 8px solid #FF0000;
  box-shadow: 0 0 20px #FF0000;
  opacity: 0;
  transition: transform 0.3s, opacity 0.3s;
  pointer-events: none;
  z-index: 999;
  display: none;
}

@keyframes portalPulse {
  0% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1); opacity: 0.8; }
}

@keyframes drawCircleAnim {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
  80% { transform: translate(-50%, -50%) scale(3); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(4); opacity: 0; }
}

/* Mobile optimized smoke ring effect */
@keyframes drawCircleAnimMobile {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
  80% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.5; }
  100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
}

/* Super lightweight mobile animation - even less GPU intensive */
@keyframes drawCircleAnimMobileLite {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.6; }
  50% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
  100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}

.portal-animation {
  animation: portalPulse 2s infinite ease-in-out;
}

.draw-circle-animation {
  animation: drawCircleAnim 0.3s ease-out forwards;
}

.draw-circle-animation-mobile {
  animation: drawCircleAnimMobileLite 0.2s ease-out forwards;
}

/* Mobile-specific smoke ring */
@media (max-width: 1024px), (pointer: coarse) {
  #draw-circle {
    width: 150px;
    height: 150px;
    border-width: 4px;
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
  }
}

/* Styling for Quick Draw countdown */
#quick-draw-countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 72px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.7);
  z-index: 1001;
}

/* Styling for winner/loser message */
.quick-draw-winner {
  color: #4CAF50 !important;
  text-shadow: 0 0 10px #4CAF50, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

.quick-draw-loser {
  color: #F44336 !important;
  text-shadow: 0 0 10px #F44336, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

/* Styling for gun locked warning */
.gun-locked-warning {
  color: #F44336 !important;
  font-size: 36px !important;
  animation: flashWarning 0.5s infinite alternate;
}

@keyframes flashWarning {
  0% { opacity: 0.7; }
  100% { opacity: 1; }
}

#quick-draw-status {
  position: absolute;
  top: 120px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 8px 12px;
  border-radius: 5px;
  transition: background-color 0.3s ease;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#portal-instructions {
  position: absolute;
  background-color: rgba(0,0,0,0.8);
  border: 2px solid #FF6B00;
  border-radius: 8px;
  padding: 15px;
  width: 400px;
  text-align: center;
  box-shadow: 0 0 15px rgba(255, 107, 0, 0.6);
  color: #EEEEEE;
  font-family: 'Courier New', Courier, monospace;
  z-index: 100;
  transition: opacity 0.3s ease;
}

#portal-instructions h2 {
  color: #FF6B00;
  font-family: 'Western', 'Courier New', Courier, monospace;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
  margin-bottom: 10px;
  font-size: 22px;
}

#portal-instructions p {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.4;
}

#portal-instructions ul {
  text-align: left;
  margin-top: 10px;
  padding-left: 20px;
  font-size: 14px;
  line-height: 1.5;
}

#portal-instructions li {
  margin-bottom: 5px;
  list-style-type: square;
}

/* Lobby display for showing which arena the player is in */
#lobby-indicator {
  position: absolute;
  top: 150px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(255, 107, 0, 0.7);
  padding: 8px 12px;
  border-radius: 5px;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  display: none;
}

/* Fix font loading */
@font-face {
  font-family: 'Western';
  src: local('Georgia'), local('Times New Roman');
  font-weight: bold;
  font-style: normal;
}

/* Health counter styling */
#health-counter {
  display: none; /* Hide the problematic right UI panel */
}

/* Damage indicator (added dynamically) */
#damage-indicator {
  position: absolute;
  top: 40%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: red;
  font-size: 48px;
  font-weight: bold;
  opacity: 0;
  text-shadow: 2px 2px 4px #000000;
  transition: opacity 0.3s ease-in, opacity 0.5s ease-out;
  z-index: 1000;
  pointer-events: none;
}

/* Different damage types */
.damage-headshot {
  color: #FF0000 !important;
  font-size: 64px !important;
}

.damage-body {
  color: #FF4500 !important;
}

.damage-limb {
  color: #FFA500 !important;
}

/* Health bar (alternative to text) */
#health-bar-container {
  display: none; /* Hide the health bar container as well */
}

/* Hit marker */
.hit-marker {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotate(45deg);
  pointer-events: none;
}

.hit-marker::before,
.hit-marker::after {
  content: '';
  position: absolute;
  background-color: white;
}

.hit-marker::before {
  width: 2px;
  height: 16px;
  left: 7px;
  top: 0;
}

.hit-marker::after {
  width: 8px;
  height: 2px;
  top: 7px;
  left: 4px;
}

/* Headshot marker */
.hit-marker-headshot::before,
.hit-marker-headshot::after {
  background-color: red;
}

/* Mobile support styles */
#touch-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 999;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
}

/* Add a CSS comment that shows the configurable constants for reference */
/* 
MOBILE CONTROLS CONFIGURATION CONSTANTS:
-------------------------------------
JUMP_BUTTON = {
  BOTTOM: 120,  // Distance from bottom edge
  RIGHT: 30,   // Distance from right edge
  SIZE: 60     // Button size
}

LEFT_JOYSTICK = {
  BOTTOM: 50,  // Distance from bottom edge
  LEFT: 50,    // Distance from left edge
  SIZE: 120    // Joystick size
}

RIGHT_JOYSTICK = {
  BOTTOM: 70,  // Distance from bottom edge
  RIGHT: 130,   // Distance from right edge
  SIZE: 100    // Joystick size
}

CAMERA_AREA = {
  Y_OFFSET: 130,  // Distance above the aim joystick
  HEIGHT: 150,    // Height of the camera area
  WIDTH: 120      // Width of the camera area
}

MOVE_THRESHOLD: 10
MOVE_SENSITIVITY: 0.15
LOOK_SENSITIVITY: 0.4
CAMERA_ROTATION_SENSITIVITY: 0.5
*/

/* Mobile buttons */
.mobile-button {
  position: fixed;
  width: 80px;  /* Adjustable through JUMP_BUTTON.SIZE */
  height: 80px;  /* Adjustable through JUMP_BUTTON.SIZE */
  background-color: rgba(0, 0, 0, 0.6);
  border: 3px solid rgba(255, 255, 255, 0.7);
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size: 36px;
  z-index: 1000;
  touch-action: none;
  display: none;
  pointer-events: auto !important;
}

#jump-button {
  bottom: 50px;  /* Adjustable through JUMP_BUTTON.BOTTOM */
  right: 50px;   /* Adjustable through JUMP_BUTTON.RIGHT */
}

/* Simulate visible joystick areas */
.control-hint {
  position: fixed;
  width: 150px; /* Adjustable through joystick SIZE */
  height: 150px; /* Adjustable through joystick SIZE */
  border-radius: 50%;
  border: 2px dashed rgba(255, 255, 255, 0.3);
  z-index: 999;
  pointer-events: none;
  display: none;
  background-color: rgba(255, 255, 255, 0.1);
}

#left-control-hint {
  bottom: 50px;  /* Adjustable through LEFT_JOYSTICK.BOTTOM */
  left: 50px;    /* Adjustable through LEFT_JOYSTICK.LEFT */
}

#right-control-hint {
  bottom: 90px; /* Adjustable through RIGHT_JOYSTICK.BOTTOM */
  right: 80px;   /* Adjustable through RIGHT_JOYSTICK.RIGHT */
}

/* Camera control hint - covers the whole screen but invisible */
#camera-control-hint {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: transparent;
  border: none;
  z-index: 900; /* Below other controls but above canvas */
  pointer-events: none;
  display: flex;
}

/* Only show mobile controls on mobile devices */
@media (max-width: 1024px), (pointer: coarse) {
  .mobile-button {
    display: block;
  }
  
  .control-hint {
    display: block;
  }
  
  #ammo-counter, #health-counter {
    font-size: 16px;
    padding: 8px;
    z-index: 1001; /* Ensure they appear above the touch overlay */
    max-width: 80px;
    text-align: center;
  }
  
  #health-counter {
    top: 10px;
    right: 10px;
    width: auto;
    left: auto;
    background-color: rgba(0, 0, 0, 0.7);
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 3px;
  }
  
  /* Hide all info banners and instructions on mobile */
  #fps-counter, #player-count, #connection-status, #network-status, 
  #quick-draw-status, #lobby-indicator, #portal-instructions,
  #reload-message, #quick-draw-message, #quick-draw-countdown,
  #proper-shootout-instructions {
    display: none !important;
  }
  
  /* Make ammo and health more visible but compact */
  #ammo-counter {
    bottom: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    font-weight: bold;
    font-size: 14px;
    padding: 4px 8px;
    border-radius: 3px;
  }
  
  @media (orientation: landscape) {
    .mobile-button {
      height: 70px;  /* Smaller for landscape */
      width: 70px;   /* Smaller for landscape */
      font-size: 28px;
    }
    
    #jump-button {
      bottom: 40px; /* Adjusted for landscape */
      right: 40px;  /* Adjusted for landscape */
    }
    
    /* Control hints (joystick indicators) */
    .control-hint {
      width: 120px;
      height: 120px;
    }
    
    #left-control-hint {
      bottom: 40px;  /* Moved up */
      left: 40px;    /* Moved right */
    }
    
    #right-control-hint {
      bottom: 80px; /* Adjusted for landscape */
      right: 80px;   /* Moved more to the left */
    }
    
    /* Remove camera control hint specific styling for landscape */
    #camera-control-hint {
      /* Keep it simple - just maintain the full-screen invisible area */
      border: none;
      background-color: transparent;
    }
    
    /* Ensure crosshair is visible */
    #crosshair {
      z-index: 1500;
    }
    
    /* Simplify health display to prevent overflow */
    #health-counter {
      padding: 3px 5px;
      font-size: 12px;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 3px;
    }
  }
}

/* Force landscape for mobile - fix vertical bar issue */
@media (max-width: 1024px) and (orientation: portrait) {
  #game-container {
    transform: rotate(90deg);
    transform-origin: left top;
    width: 100vh;
    height: 100vw;
    position: absolute;
    top: 0;
    left: 0;
    overflow: hidden;
  }
  
  /* Fix for systems with notches/home indicators */
  body {
    background-color: #000;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
  }
  
  /* Full screen canvas with proper alignment */
  canvas {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
  }
  
  /* Additional fix for the orientation wrapper */
  #orientation-message {
    transform: rotate(-90deg);
    width: 100vw;
    height: 100vh;
  }
}

/* Meta viewport tag doesn't allow scaling on mobiles, so add touch control */
@media (max-width: 1024px) {
  body {
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
    overflow: hidden;
    background-color: #000;
    /* Ensure no whitespace around edges */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
  }
  
  /* Ensure full screen coverage */
  #game-container {
    width: 100vw;
    height: 100vh;
    overflow: hidden;
    background-color: #000;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
  }
  
  canvas {
    width: 100vw !important;
    height: 100vh !important;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: 0;
    padding: 0;
    object-fit: cover;
  }
  
  /* Make sure controls are responsive to touch */
  .mobile-button {
    touch-action: none;
    -webkit-touch-callout: none;
  }
  
  /* Prevent all portal instructions from showing */
  #portal-instructions,
  #proper-shootout-instructions,
  div[class*="portal-instructions"] {
    display: none !important;
    pointer-events: none !important;
    visibility: hidden !important;
  }
}

/* For landscape orientation */
@media (orientation: landscape) {
  .control-hint {
    width: 120px;
    height: 120px;
  }
}

/* Chat styles */
#chat-container {
  position: absolute;
  bottom: 80px;
  left: 20px;
  max-width: 400px;
  height: auto;
  max-height: 250px;
  overflow-y: auto;
  background-color: transparent;
  border-radius: 5px;
  padding: 10px;
  font-family: Arial, sans-serif;
  color: #fff;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  font-size: 14px;
  scrollbar-width: none; /* Hide scrollbar for Firefox */
  -ms-overflow-style: none; /* Hide scrollbar for IE and Edge */
  transition: background-color 0.2s ease;
}

#chat-container.active {
  background-color: transparent;
  scrollbar-width: thin; /* Show scrollbar for Firefox when active */
  scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.2);
}

#chat-messages {
  margin-bottom: 5px;
  overflow-y: auto;
  max-height: 230px;
  display: flex;
  flex-direction: column;
  scrollbar-width: none; /* Hide scrollbar for Firefox */
  -ms-overflow-style: none; /* Hide scrollbar for IE and Edge */
}

#chat-container.active #chat-messages {
  scrollbar-width: thin; /* Show scrollbar for Firefox when active */
  scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.2);
}

/* Hide scrollbar for Chrome, Safari and Opera */
#chat-container::-webkit-scrollbar,
#chat-messages::-webkit-scrollbar {
  width: 0; 
  display: none;
}

/* Show scrollbar for Chrome, Safari and Opera when active */
#chat-container.active::-webkit-scrollbar,
#chat-container.active #chat-messages::-webkit-scrollbar {
  width: 6px;
  display: block;
  opacity: 1;
}

/* Scrollbar track and thumb styles for active chat */
#chat-container.active::-webkit-scrollbar-track,
#chat-container.active #chat-messages::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.2);
  border-radius: 3px;
}

#chat-container.active::-webkit-scrollbar-thumb,
#chat-container.active #chat-messages::-webkit-scrollbar-thumb {
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 3px;
}

.chat-message {
  margin-bottom: 5px;
  word-wrap: break-word;
  padding: 2px 0;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 1), 0 0 6px rgba(0, 0, 0, 0.9);
  line-height: 1.4;
}

.username {
  font-weight: bold;
  margin-right: 5px;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 1), 0 0 5px rgba(0, 0, 0, 0.9);
}

#chat-input-container {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 400px;
  z-index: 1000;
  display: none;
}

#chat-input {
  width: 100%;
  padding: 8px;
  border-radius: 5px;
  border: none;
  background-color: rgba(0, 0, 0, 0.7);
  color: #fff;
  font-family: Arial, sans-serif;
  outline: none;
}

.system-message {
  color: #ddd;
  text-shadow: 1px 1px 3px rgba(0, 0, 0, 1), 0 0 6px rgba(0, 0, 0, 0.9);
}

.hidden {
  display: none;
}

/* Letterbox effect for cinematic eagle camera view */
.letterbox-top, 
.letterbox-bottom {
  position: fixed;
  left: 0;
  width: 100%;
  height: 0;
  background-color: #000;
  z-index: 1000;
  transition: height 0.7s ease-in-out;
}

.letterbox-top {
  top: 0;
}

.letterbox-bottom {
  bottom: 0;
}

.letterbox-active .letterbox-top,
.letterbox-active .letterbox-bottom {
  height: 15vh;  /* 15% of viewport height for each bar */
}

/* Mobile-specific chat styles */
@media (max-width: 1024px) {
  #chat-container {
    background-color: transparent !important; /* Remove background */
    touch-action: auto !important; /* Override any touch restrictions */
    -webkit-touch-callout: default !important; /* Allow touch interactions */
    -webkit-user-select: text !important; /* Allow text selection in chat */
    user-select: text !important;
    pointer-events: auto !important; /* Ensure pointer events work */
    padding: 10px !important; /* Smaller padding */
    min-height: 30px; /* Ensure there's always something to tap */
    /* Position from the left edge - no more notch adjustment */
    left: 0px !important; 
    top: 10px !important;
    width: 70% !important;
    max-width: 70% !important;
  }
  
  /* For iPhone X and later with notch */
  @supports (padding-top: env(safe-area-inset-top)) {
    #chat-container {
      padding-left: calc(env(safe-area-inset-left) + 5px) !important;
      padding-top: env(safe-area-inset-top) !important;
    }
  }
  
  /* iOS-compatible chat link styles - invisible but clickable */
  #chat-mobile-link {
    /* Reset all visible styles */
    background-color: transparent !important;
    border: none !important;
    color: transparent !important;
    box-shadow: none !important;
    opacity: 0 !important;
    
    /* Keep functional properties */
    -webkit-tap-highlight-color: transparent !important;
    -webkit-touch-callout: none !important;
    -webkit-user-select: none !important;
    user-select: none !important;
    touch-action: manipulation !important;
    display: block !important;
    
    /* Positioning - match chat container exactly */
    position: fixed !important;
    top: 10px !important;
    left: 0px !important;
    width: 70% !important;
    height: 30% !important;
    z-index: 9999 !important;
    
    /* Critical for functionality */
    pointer-events: auto !important;
  }
}

/* Mobile-specific enhancements for chat without background */
@media (max-width: 1024px) {
  .chat-message {
    text-shadow: 2px 2px 3px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1) !important;
    font-weight: bold !important;
    color: rgba(255, 255, 255, 0.95) !important;
  }
  
  .system-message {
    color: rgba(255, 255, 255, 0.9) !important;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1) !important;
  }
  
  .username {
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1) !important;
  }
}

@supports (padding-top: env(safe-area-inset-top)) {
  #chat-container {
    padding-left: calc(env(safe-area-inset-left) + 5px) !important;
    padding-top: env(safe-area-inset-top) !important;
  }
}

/* Chat messages specific styles */
#chat-messages {
  padding-right: 5px !important;
}

#chat-input-container {
  touch-action: auto !important;
  -webkit-touch-callout: default !important;
  -webkit-user-select: text !important;
  user-select: text !important;
  pointer-events: auto !important;
}

#chat-input {
  font-size: 16px; /* iOS Safari requires 16px+ to prevent zoom */
}

#chat-send-button {
  min-height: 44px; /* Apple recommends 44px minimum touch target size */
  min-width: 44px;
  touch-action: manipulation;
  -webkit-appearance: none; /* Prevent iOS default styling */
}

/* iOS-compatible chat link styles - invisible but clickable */
#chat-mobile-link {
  /* Reset all visible styles */
  background-color: transparent !important;
  border: none !important;
  color: transparent !important;
  box-shadow: none !important;
  opacity: 0 !important;
  
  /* Keep functional properties */
  -webkit-tap-highlight-color: transparent !important;
  -webkit-touch-callout: none !important;
  -webkit-user-select: none !important;
  user-select: none !important;
  touch-action: manipulation !important;
  display: block !important;
  
  /* Positioning - match chat container exactly */
  position: fixed !important;
  top: 10px !important;
  left: 0px !important;
  width: 70% !important;
  height: 30% !important;
  z-index: 9999 !important;
  
  /* Critical for functionality */
  pointer-events: auto !important;
}

/* Remove active state visual effects */
#chat-mobile-link:active {
  opacity: 0 !important;
  background-color: transparent !important;
  transform: none !important;
}

/* Remove the fire button CSS */
#fire-button {
  display: none; /* Hide it completely */
}

@media (max-width: 1024px), (pointer: coarse) {
  @media (orientation: landscape) {
    #fire-button {
      display: none; /* Hide in landscape mode as well */
    }
  }
}

/* Joystick knob styles */
.joystick-knob {
  position: absolute;
  border-radius: 50%;
  pointer-events: none;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: transform 0.05s ease-out;
  will-change: transform;
}

#left-joystick-knob {
  width: 40%;
  height: 40%;
  background-color: rgba(255, 255, 255, 0.4);
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

#right-joystick-knob {
  width: 40%;
  height: 40%;
  background-color: rgba(0, 0, 0, 0.3);
  display: flex;
  justify-content: center;
  align-items: center;
}

#right-joystick-knob img {
  width: 70%;
  height: 70%;
  object-fit: contain;
}

/* Updated control hints */
.control-hint {
  position: fixed;
  border-radius: 50%;
  border: 2px dashed rgba(255, 255, 255, 0.3);
  z-index: 997;
  pointer-events: none;
  display: block;
  background-color: rgba(0, 0, 0, 0.3);
}

@media (max-width: 1024px), (pointer: coarse) {
  @media (orientation: landscape) {
    .joystick-knob {
      transition: transform 0.03s ease-out;
    }
    
    #left-joystick-knob, #right-joystick-knob {
      width: 35%;
      height: 35%;
    }
  }
}

================================================
File: /public/dev.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wild West Shooter - Dev Tools</title>
    <style>
        body {
            background-color: #333;
            color: #f8bb00;
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .card {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 20px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        h2 {
            color: #f8bb00;
            margin-top: 0;
        }
        p {
            color: #fff;
        }
        button {
            background-color: #8b0000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #a00000;
        }
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .separator {
            height: 1px;
            background-color: #444;
            width: 100%;
            margin: 20px 0;
        }
        .player-frames {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            width: 100%;
        }
        .player-frame {
            width: 100%;
            height: 400px;
            border: 2px solid #8b0000;
            border-radius: 8px;
            overflow: hidden;
            background-color: #000;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        @media (min-width: 1024px) {
            .player-frame {
                width: calc(50% - 10px);
            }
        }
    </style>
</head>
<body>
    <h1>Wild West Shooter - Development Tools</h1>
    
    <div class="card">
        <h2>Testing Options</h2>
        <p>Use these buttons to launch test instances with unique player identities:</p>
        
        <div class="buttons">
            <button onclick="openGameTab()">Launch Game Tab</button>
            <button onclick="openGameTab(true)">Launch Dev Player</button>
            <button onclick="openSideBySide()">Open Side-by-Side</button>
        </div>
        
        <div class="separator"></div>
        
        <h2>Side-by-Side Testing</h2>
        <p>Test two separate player instances right here:</p>
        
        <div class="player-frames">
            <div class="player-frame">
                <iframe id="player1" src=""></iframe>
            </div>
            <div class="player-frame">
                <iframe id="player2" src=""></iframe>
            </div>
        </div>
    </div>
    
    <script>
        // Base game URL
        const baseUrl = window.location.href.replace('/dev.html', '/');
        
        // Function to open game in new tab
        function openGameTab(isDev = false) {
            const url = isDev ? `${baseUrl}?newplayer=true&t=${Date.now()}` : baseUrl;
            window.open(url, '_blank');
        }
        
        // Function to open side-by-side player frames
        function openSideBySide() {
            const timestamp = Date.now();
            document.getElementById('player1').src = `${baseUrl}?newplayer=true&t=${timestamp}`;
            document.getElementById('player2').src = `${baseUrl}?newplayer=true&t=${timestamp + 1}`;
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Development tools ready');
        });
    </script>
</body>
</html> 

================================================
File: /public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="Wild Western FPS" />
  <meta name="mobile-web-app-capable" content="yes" />
  <!-- Additional iOS specific meta tags for better fullscreen handling -->
  <meta name="format-detection" content="telephone=no" />
  <meta name="HandheldFriendly" content="true" />
  <title>Wild Western FPS – Multiplayer</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    /* Ensure fullscreen with no white bars */
    *, *::before, *::after {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    
    /* Improved iOS safe area handling for status bar and notches */
    #game-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      /* Apply safe area insets for notched devices */
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: #000;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      margin: 0;
      padding: 0;
    }
    
    #admin-controls {
      position: absolute;
      bottom: 200px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 999;
      user-select: none;
    }
    
    .admin-buttons {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .admin-buttons button {
      background-color: #4a2519;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
    
    .admin-buttons button:hover {
      background-color: #6c392b;
    }
    
    .hidden {
      display: none;
    }
    
    .error-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 5px;
      z-index: 9999;
      text-align: center;
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="ammo-counter">Bullets: 6/6</div>
    <div id="health-counter">Health: 100</div>
    <div id="reload-message">Hold R to reload</div>
    <div id="reload-progress-container">
      <div id="reload-progress-bar"></div>
    </div>
    <div id="crosshair" style="transform: translate(calc(-50% + 2px), calc(-50% - 1px)) !important;">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
        <!-- Top corner group -->
        <g id="top-corner" class="corner-group">
          <path d="M45,20 L50,15 L55,20" fill="none" stroke="rgba(0, 0, 0, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Bottom left corner group -->
        <g id="bottom-left-corner" class="corner-group">
          <path d="M20,75 L25,75 M20,75 L20,70" fill="none" stroke="rgba(0, 0, 0, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Bottom right corner group -->
        <g id="bottom-right-corner" class="corner-group">
          <path d="M75,75 L80,75 M80,75 L80,70" fill="none" stroke="rgba(0, 0, 0, 0.8)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
        </g>
        
        <!-- Center dot -->
        <circle cx="50" cy="50" r="3" fill="rgba(255, 255, 255, 0.8)" />
      </svg>
    </div>
    <div id="fps-counter">FPS: 0</div>
    <div id="player-count">Players: 1</div>
    <div id="connection-status"></div>
  </div>

  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader for loading the GLB gun model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Cannon.js for physics (non-ES module version) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <!-- Solana Web3.js -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  
  <!-- Phantom Wallet integration -->
  <script type="module">
    import phantomWalletAdapter from './js/phantom-wallet.js';
    
    // Make the wallet adapter globally available
    window.phantomWalletAdapter = phantomWalletAdapter;
    
    // Initialize the Phantom wallet adapter when the page loads
    // (Network Manager will be connected later in main.js)
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Phantom wallet adapter made globally available');
    });
  </script>
  
  <!-- Main JS as ES6 module -->
  <script type="module" src="js/main.js"></script>
  
  <!-- Letterbox effect for cinematic eagle camera view -->
  <div class="letterbox-top"></div>
  <div class="letterbox-bottom"></div>
  
  <!-- Vibe Jam 2025 entrant badge -->
  <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">🕹️ Vibe Jam 2025</a>

  <!-- Admin controls for developers -->
  <div id="admin-controls" class="hidden">
    <div class="admin-panel">
      <h3>Admin Controls</h3>
      <p>NPCs are now server-controlled. Bot controls have been removed.</p>
    </div>
  </div>

  <!-- Add script for admin controls -->
  <script>
    // Show admin controls with key combo Ctrl+Shift+B
    document.addEventListener('keydown', function(e) {
      if (e.ctrlKey && e.shiftKey && e.key === 'B') {
        const adminControls = document.getElementById('admin-controls');
        adminControls.classList.toggle('hidden');
      }
    });
  </script>
</body>
</html>

================================================
File: /public/js/bullet.js
================================================
import { createImpactEffect } from './effects.js';

// Reusable objects for collision detection to avoid creating new ones every frame
const raycaster = new THREE.Raycaster();
const tmpVec3 = new THREE.Vector3();
const reusableBox = new THREE.Box3();

/**
 * A bullet class with client-side prediction and server validation.
 * It lets the server have final authority on collisions and hits.
 */
export class Bullet {
  /**
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Normalized direction vector
   * @param {string|number} bulletId - Optional server-assigned bullet ID (for remote bullets)
   * @param {boolean} isShotgunPellet - Whether this bullet is a pellet from a shotgun
   */
  constructor(position, direction, bulletId = null, isShotgunPellet = false) {
    // Dynamic bullet trajectory adjustment based on viewport
    this.adjustTrajectoryForViewport(direction);
    
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xB8860B })
    );
    this.mesh.position.copy(position);

    this.direction = direction.clone();
    this.speed = 80; // speed units/second
    this.distanceTraveled = 0;
    this.maxDistance = 100;
    this.timeCreated = performance.now();

    // Remember previous position for continuous detection
    this.lastPosition = position.clone();

    // Track which player fired this bullet
    this.sourcePlayerId = null;
    
    // Anti-cheat: Server-assigned bulletId
    this.bulletId = bulletId;
    
    // Anti-cheat: Track whether this bullet is local (created by local player)
    this.isLocalBullet = true;
    
    // Set up the bullet's ray for continuous collision detection
    this.rayOrigin = position.clone();
    this.rayDirection = direction.clone();
    
    // Flag to identify if this bullet is a shotgun pellet
    this.isShotgunPellet = isShotgunPellet;
    
    // Create a visual path for trajectory debugging
    if (window.debugMode) {
      this.createTrajectoryVisualization(position, direction);
    }
  }

  /**
   * Adjusts bullet trajectory based on actual viewport dimensions.
   * Especially useful for iOS where fullscreen mode isn't available by default.
   * @param {THREE.Vector3} direction - The original direction vector to modify
   */
  adjustTrajectoryForViewport(direction) {
    // Skip if not iOS or not needed
    if (!this.isIOS() || !this.needsAdjustment()) {
      return;
    }

    // Get viewport info
    const viewportInfo = this.getViewportInfo();
    
    // Only adjust if there's unused space
    if (viewportInfo.hasUnusedSpace) {
      // Calculate adjustment based on the ratio of unused space
      // This is the percentage of the screen that's not being used
      const visualToDeviceRatio = viewportInfo.visualHeight / viewportInfo.deviceHeight;
      
      // Apply a much smaller adjustment - just enough to align with crosshair
      // Start with a very subtle adjustment factor
      const offsetY = (1 - visualToDeviceRatio) * 0.2; // Reduced from 0.7 to 0.2
      
      // Apply vertical adjustment to direction
      direction.y += offsetY;
      
      // No horizontal adjustment needed - this was causing misalignment
      
      // Renormalize the direction vector
      direction.normalize();
      
      // Debug logs
      if (window.debugMode) {
        console.log(`Bullet trajectory adjusted: Y+${offsetY.toFixed(4)}, ratio: ${visualToDeviceRatio.toFixed(2)}`);
      }
    }
  }

  /**
   * Detects if the device is running iOS
   * @returns {boolean} True if device is iOS
   */
  isIOS() {
    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  }

  /**
   * Checks if trajectory adjustment is needed
   * @returns {boolean} True if adjustment is needed
   */
  needsAdjustment() {
    // Only adjust for horizontal orientation on iOS
    return this.isIOS() && window.innerWidth > window.innerHeight;
  }

  /**
   * Gets information about the viewport dimensions
   * @returns {Object} Viewport information
   */
  getViewportInfo() {
    // Get the actual visible viewport sizes
    const visualWidth = window.innerWidth;
    const visualHeight = window.innerHeight;
    
    // Get full device screen dimensions
    const deviceWidth = window.screen.width;
    const deviceHeight = window.screen.height;
    
    // Check if we're in landscape mode
    const isLandscape = visualWidth > visualHeight;
    
    // Determine if there's unused space (especially for iOS)
    // In landscape, unused space would be at the top/bottom
    const hasUnusedSpace = isLandscape && (visualHeight < deviceHeight);
    
    return {
      visualWidth,
      visualHeight,
      deviceWidth,
      deviceHeight,
      isLandscape,
      hasUnusedSpace
    };
  }

  /**
   * Sets the player ID that fired this bullet.
   * @param {string|number} playerId - The ID of the player who fired the bullet.
   */
  setSourcePlayer(playerId) {
    this.sourcePlayerId = playerId;
    
    // Anti-cheat: Determine if this is a local bullet
    if (window.localPlayer) {
      this.isLocalBullet = Number(playerId) === Number(window.localPlayer.id);
    }
  }

  /**
   * Updates the bullet's movement & handles collisions with NPC or players.
   * Uses client-side prediction with server authority.
   * @param {number} deltaTime
   * @param {THREE.Group} npc
   * @param {THREE.Scene} scene
   * @param {Map<number, object>} allPlayers - Map of local + remote players.
   * @returns {Object} - Result of the update containing active state and hit info.
   */
  update(deltaTime, npc, scene, allPlayers) {
    // Previous position for boundary crossing detection
    this.lastPosition = this.mesh.position.clone();
    
    // If we're still active, update bullet position and check for player hits
    this.lastPosition.copy(this.mesh.position);
    
    // Move the bullet
    const displacement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
    this.mesh.position.add(displacement);
    this.distanceTraveled += displacement.length();

    // Current bullet position
    const endPos = this.mesh.position.clone();
    
    // Check if crossing Quick Draw arena boundary using the physics system
    if (window.quickDraw && window.quickDraw.physics) {
      const physics = window.quickDraw.physics;
      
      // Check if bullet is crossing the arena boundary
      const bulletInArena = window.quickDraw.isPointInArena(endPos);
      const prevInArena = window.quickDraw.isPointInArena(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInArena !== prevInArena;
      
      // If the bullet is crossing the boundary
      if (bulletCrossingBoundary) {
        // Removed boundary crossing restrictions to allow free shooting across boundaries
        /*
        const playerInDuel = window.quickDraw.inDuel;
        const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
        
        // Case 1: Player in duel and their bullet trying to exit
        if (playerInDuel && isLocalPlayerBullet && !bulletInArena) {
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 2: Player outside trying to shoot in
        if (!playerInDuel && isLocalPlayerBullet && bulletInArena) {
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 3: Bullet from duel player hitting boundary from inside
        if (playerInDuel && !isLocalPlayerBullet && !bulletInArena) {
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 4: Bullet from outside player hitting boundary from outside
        if (!playerInDuel && !isLocalPlayerBullet && bulletInArena) {
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        */
      }
    }

    // Check for tumbleweed hits if tumbleweedManager exists
    if (window.tumbleweedManager) {
      // Update the raycaster with the bullet's movement path
      raycaster.set(this.lastPosition, this.direction);
      
      // Check for intersection with tumbleweeds
      const tumbleweedHit = window.tumbleweedManager.checkRayIntersection(raycaster);
      
      if (tumbleweedHit) {
        // Create a small impact effect
        createImpactEffect(tumbleweedHit.point, this.direction, scene, 'ground');
        
        // Return hit info
        return { 
          active: false, 
          hit: { 
            type: 'tumbleweed', 
            position: tumbleweedHit.point,
            distance: tumbleweedHit.distance
          } 
        };
      }
    }

    // Check for eagle hits if flyingEagle exists
    if (window.flyingEagle) {
      // Update the raycaster with the bullet's movement path
      raycaster.set(this.lastPosition, this.direction);
      
      // Check for intersection with eagle's hitbox
      const eagleIntersection = raycaster.ray.intersectSphere(window.flyingEagle.hitbox, new THREE.Vector3());
      
      if (eagleIntersection) {
        // Create a small impact effect
        createImpactEffect(eagleIntersection, this.direction, scene, 'eagle');
        
        // Hit the eagle
        window.flyingEagle.hit();
        
        // Return hit info
        return { 
          active: false, 
          hit: { 
            type: 'eagle', 
            position: eagleIntersection,
            distance: eagleIntersection.distanceTo(raycaster.ray.origin)
          } 
        };
      }
    }

    // Anti-cheat: For local bullets, collision detection is only client-side prediction
    // For remote bullets, we rely on client-side collision for visual effects
    
    // 1) Check collision with NPC
    if (npc) {
      const npcBox = new THREE.Box3().setFromObject(npc);
      npcBox.expandByScalar(0.2);
      if (npcBox.containsPoint(endPos)) {
        createImpactEffect(endPos, this.direction, scene, 'npc');
        return { active: false, hit: { type: 'npc', target: npc } };
      }
    }

    // 2) Check collision with players
    if (allPlayers) {
      for (const [playerId, playerObj] of allPlayers.entries()) {
        // Skip bullet's owner by converting both IDs to numbers
        if (Number(playerId) === Number(this.sourcePlayerId)) continue;
        if (!playerObj || !playerObj.group) continue;

        // Prevent hits across arena boundary or between different game modes
        // Only allow hits if players are in compatible states:
        // 1. Both in the same QuickDraw duel
        // 2. Both in the regular town area (not in any game mode)
        
        const sourcePlayerId = Number(this.sourcePlayerId);
        const targetPlayerId = Number(playerId);
        
        // Check if source and target are in QuickDraw duel
        const bulletPlayerInDuel = window.quickDraw && window.quickDraw.inDuel;
        const targetPlayerInDuel = window.quickDraw && 
                                   window.quickDraw.duelOpponentId === targetPlayerId;
        
        // Make sure players are in the same game mode to allow hits
        // Remove restriction to allow free shooting
        // const bothInDuel = bulletPlayerInDuel && targetPlayerInDuel;
        // const bothInRegularTown = !bulletPlayerInDuel && !targetPlayerInDuel;
        
        // if (!(bothInDuel || bothInRegularTown)) {
        //   continue; // Skip collision check if players are in different areas/modes
        // }
        
        // Detect which hit zone was hit (head, body, limbs)
        const hitResult = this.checkPlayerHitZones(playerObj, endPos);
        
        if (hitResult.hit) {
          // Check that this isn't a hit on the local player's own model
          const isHitOnLocalPlayer = window.localPlayer && 
                                   Number(window.localPlayer.id) === Number(playerId);
          
          if (!isHitOnLocalPlayer) {
            // Create the impact effect
            createImpactEffect(endPos, this.direction, scene, 'player');
            
            // Only play sounds and show hitmarker if this is the local player's bullet
            if (this.isLocalBullet && window.localPlayer && window.localPlayer.soundManager) {
              // Show hitmarker image for 100ms
              this.showHitMarker(endPos);
              
              // Play sound with 300ms delay
              if (hitResult.zone === 'head') {
                // For headshots, only play headshotmarker (not both sounds)
                setTimeout(() => {
                  window.localPlayer.soundManager.playSound("headshotmarker", 100);
                }, 300);
              } else {
                // For body/limb hits, play regular hitmarker sound
                setTimeout(() => {
                  window.localPlayer.soundManager.playSound("hitmarker", 100);
                }, 300);
              }
            }
          } else {
            console.log("Prevented impact effect on local player's own model");
          }
          
          // Anti-cheat: For local bullets, send hit to server and let server decide
          if (this.isLocalBullet && window.networkManager) {
            // Track recent hits to prevent accidentally sending multiple hit notifications
            if (!window.hitDebounce) {
              window.hitDebounce = new Map();
            }
            
            // Generate a unique key for this hit (player ID + hit zone + approximate position)
            const hitKey = `${playerId}_${hitResult.zone}_${Math.round(endPos.x)}_${Math.round(endPos.y)}_${Math.round(endPos.z)}`;
            const now = performance.now();
            const lastHitTime = window.hitDebounce.get(hitKey) || 0;
            
            // Use a shorter debounce time for shotgun pellets to allow multiple pellets to register hits
            const debounceTime = this.isShotgunPellet ? 50 : 500; // 50ms for shotgun, 500ms for regular bullets
            
            if (now - lastHitTime < debounceTime) {
              // Use logger for debug logs
              if (window.logger) {
                window.logger.debug(`Debouncing duplicate hit detection: ${hitKey}`);
              }
              return { 
                active: false, 
                hit: { 
                  type: 'player', 
                  playerId, 
                  bulletId: this.bulletId,
                  zone: hitResult.zone,
                  damage: hitResult.damage,
                  debounced: true
                } 
              };
            }
            
            // Update the last hit time for this target
            window.hitDebounce.set(hitKey, now);
            
            window.networkManager.sendPlayerHit(playerId, {
              position: { x: endPos.x, y: endPos.y, z: endPos.z },
              sourcePlayerId: this.sourcePlayerId,
              hitZone: hitResult.zone, // Send the hit zone to the server
              damage: hitResult.damage, // Send the damage amount to the server
              isShotgunPellet: this.isShotgunPellet // Send information about shotgun pellets
            }, this.bulletId);
            
            // Quick Draw duels with better logging
            if (window.quickDraw && window.quickDraw.inDuel && 
                window.quickDraw.duelState === 'draw' && 
                Number(playerId) === Number(window.quickDraw.duelOpponentId) && 
                Number(this.sourcePlayerId) === Number(window.localPlayer.id)) {
                
                // Use logger for important hit information
                if (window.logger) {
                  window.logger.info(`Quick Draw hit detected! Player ${this.sourcePlayerId} hit player ${playerId} in the ${hitResult.zone} for ${hitResult.damage} damage`);
                }
                
                // We don't need to send both a playerHit and a quickDrawShoot - just use one
                // The previous playerHit is enough for the server to handle this hit
                // Commenting out the additional QuickDraw notification to prevent double-hits
                /*
                window.networkManager.sendQuickDrawShoot(
                  playerId, 
                  window.quickDraw.activeArenaIndex,
                  hitResult.zone,
                  hitResult.damage
                );
                */
            }
          }
          
          return { 
            active: false, 
            hit: { 
              type: 'player', 
              playerId, 
              bulletId: this.bulletId,
              zone: hitResult.zone,
              damage: hitResult.damage
            } 
          };
        }
      }
    }

    // 3) Check collision with ground
    if (this.mesh.position.y <= 0.1) {
      // Skip creating ground impact effect
      return { active: false, hit: { type: 'ground', position: endPos } };
    }

    // 4) If bullet exceeded max distance, remove it.
    if (this.distanceTraveled >= this.maxDistance) {
      return { active: false, hit: null };
    }

    // Still active
    return { active: true, hit: null };
  }
  
  /**
   * Checks which part of the player model was hit and returns damage amount.
   * Uses ray casting against actual player meshes for more precise hit detection.
   * @param {object} playerObj - The player object to check
   * @param {THREE.Vector3} bulletPos - The bullet position
   * @returns {object} - Contains hit (boolean), zone (string), and damage (number)
   */
  checkPlayerHitZones(playerObj, bulletPos) {
    // If the player has a ThirdPersonModel, use its dedicated mesh-based hit detection
    if (playerObj.playerModel && playerObj.playerModel.checkBulletHit) {
      const hitResult = playerObj.playerModel.checkBulletHit(bulletPos, this.isShotgunPellet);
      
      // If this is a shotgun pellet, adjust the damage (should be handled by the model now)
      return hitResult;
    }
    
    // Fallback to box-based hit detection for local player or models without mesh hit detection
    
    // Get player's base position for collision box
    // For local players (first-person), group.position is at eye-level so subtract 1.6
    // Remote players (third-person) have group.position at the base
    const playerPos = playerObj.group.position.clone();
    let baseY = playerPos.y;
    if (playerObj.camera) { // local player
      baseY = playerPos.y - 1.6;
    }
    
    // Define hit zone dimensions
    const headSize = 0.4; // Head is a smaller target
    const bodyWidth = 0.5;
    const bodyHeight = 0.9;
    const limbWidth = 0.2;
    const limbHeight = 0.6;
    
    // Calculate vertical positions of each zone
    // Using the adjusted values for better alignment
    const headBottom = baseY + 1.8 - headSize;
    const headTop = baseY + 1.8;
    const bodyBottom = baseY + 0.9;
    const bodyTop = baseY + 1.8 - headSize;
    const legBottom = baseY + 0.2;
    const legTop = baseY + 0.8;
    const armBottom = baseY + 0.8;
    const armTop = baseY + 1.4;
    
    // Create debug visualization if physics debug mode is enabled or global debug flag is set
    if ((window.physics && window.physics.debugMode) || window.showHitZoneDebug) {
      if (!playerObj._hitZoneDebug) {
        this.createHitZoneDebugBoxes(playerObj, {
          playerPos, baseY, 
          headSize, bodyWidth, bodyHeight, limbWidth, limbHeight,
          headBottom, headTop, bodyBottom, bodyTop, 
          legBottom, legTop, armBottom, armTop
        });
      }
    }
    
    // Reuse the global THREE.Box3 object for better performance
    
    // First do a quick test with the overall player bounding box
    reusableBox.min.set(
      playerPos.x - bodyWidth,
      baseY + 0.2, // Adjusted to match new bottom height
      playerPos.z - bodyWidth
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth,
      baseY + 1.8, // Adjusted to match new top height
      playerPos.z + bodyWidth
    );
    
    const overallBox = reusableBox;
    
    if (!overallBox.containsPoint(bulletPos)) {
      return { hit: false, zone: null, damage: 0 };
    }
    
    // Setup ray casting from the bullet's previous position to current position
    // This gives us more accurate hit detection along the bullet's path
    raycaster.set(this.lastPosition, this.direction);
    
    // Define ray length (distance the bullet traveled this frame)
    const rayLength = this.lastPosition.distanceTo(bulletPos);
    raycaster.far = rayLength * 1.1; // Add a small margin
    
    // Check head zone (highest damage)
    reusableBox.min.set(
      playerPos.x - headSize/2,
      headBottom,
      playerPos.z - headSize/2
    );
    reusableBox.max.set(
      playerPos.x + headSize/2,
      headTop,
      playerPos.z + headSize/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 10 : 100;
      return { hit: true, zone: 'head', damage: damage };
    }
    
    // Check body zone (medium damage)
    reusableBox.min.set(
      playerPos.x - bodyWidth/2,
      bodyBottom,
      playerPos.z - bodyWidth/2
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth/2,
      bodyTop,
      playerPos.z + bodyWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 40;
      return { hit: true, zone: 'body', damage: damage };
    }
    
    // Check arms (low damage, simplified to two boxes on sides)
    // Left arm
    reusableBox.min.set(
      playerPos.x - bodyWidth/2 - limbWidth,
      armBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x - bodyWidth/2,
      armTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // Right arm
    reusableBox.min.set(
      playerPos.x + bodyWidth/2,
      armBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth/2 + limbWidth,
      armTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // Check legs (low damage)
    // Left leg
    reusableBox.min.set(
      playerPos.x - bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x - bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // Right leg
    reusableBox.min.set(
      playerPos.x + bodyWidth/4 - limbWidth/2,
      legBottom,
      playerPos.z - limbWidth/2
    );
    reusableBox.max.set(
      playerPos.x + bodyWidth/4 + limbWidth/2,
      legTop,
      playerPos.z + limbWidth/2
    );
    
    if (reusableBox.containsPoint(bulletPos)) {
      // Apply different damage based on whether this is a shotgun pellet
      const damage = this.isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // If we reach here but hit the overall box, it's a grazing hit to the body
    // Instead of no damage, register it as a body hit with reduced damage
    const damage = this.isShotgunPellet ? 5 : 30;
    return { hit: true, zone: 'body', damage: damage };
  }
  
  /**
   * Creates visible debug boxes for hit zones when physics debug mode is enabled
   * @param {object} playerObj - The player object
   * @param {object} dims - Dimensions and positions for the hit zones
   */
  createHitZoneDebugBoxes(playerObj, dims) {
    // Only used in debug mode
    if (!window.scene) return;
    
    // Remove any existing debug boxes for this player
    if (playerObj._hitZoneDebug) {
      window.scene.remove(playerObj._hitZoneDebug);
      playerObj._hitZoneDebug.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
    }
    
    // Create a new group for hitbox visualization
    const hitZoneGroup = new THREE.Group();
    hitZoneGroup.name = "hitZoneDebug_" + playerObj.id;
    
    // Create helper function to make box helpers
    const createBoxHelper = (min, max, color) => {
      // Use BoxGeometry instead of Box3Helper for more reliable visual feedback
      const sizeX = max.x - min.x;
      const sizeY = max.y - min.y;
      const sizeZ = max.z - min.z;
      
      const geometry = new THREE.BoxGeometry(sizeX, sizeY, sizeZ);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });
      
      const mesh = new THREE.Mesh(geometry, material);
      // Position at the center of the box
      mesh.position.set(
        min.x + sizeX/2,
        min.y + sizeY/2,
        min.z + sizeZ/2
      );
      
      hitZoneGroup.add(mesh);
      return mesh;
    };
    
    // Calculate all zones relative to player position
    // Note: these are local to the player, not world positions
    
    // Head zone - red
    const headMin = new THREE.Vector3(
      -dims.headSize/2,
      dims.headBottom - dims.baseY,
      -dims.headSize/2
    );
    const headMax = new THREE.Vector3(
      dims.headSize/2,
      dims.headTop - dims.baseY,
      dims.headSize/2
    );
    const headHelper = createBoxHelper(headMin, headMax, 0xff0000);
    
    // Body zone - orange
    const bodyMin = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.bodyBottom - dims.baseY,
      -dims.bodyWidth/2
    );
    const bodyMax = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.bodyTop - dims.baseY,
      dims.bodyWidth/2
    );
    const bodyHelper = createBoxHelper(bodyMin, bodyMax, 0xff7700);
    
    // Left arm - yellow
    const leftArmMin = new THREE.Vector3(
      -dims.bodyWidth/2 - dims.limbWidth,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftArmMax = new THREE.Vector3(
      -dims.bodyWidth/2,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftArmHelper = createBoxHelper(leftArmMin, leftArmMax, 0xffff00);
    
    // Right arm - green
    const rightArmMin = new THREE.Vector3(
      dims.bodyWidth/2,
      dims.armBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightArmMax = new THREE.Vector3(
      dims.bodyWidth/2 + dims.limbWidth,
      dims.armTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightArmHelper = createBoxHelper(rightArmMin, rightArmMax, 0x00ff00);
    
    // Left leg - blue
    const leftLegMin = new THREE.Vector3(
      -dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const leftLegMax = new THREE.Vector3(
      -dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const leftLegHelper = createBoxHelper(leftLegMin, leftLegMax, 0x0000ff);
    
    // Right leg - purple
    const rightLegMin = new THREE.Vector3(
      dims.bodyWidth/4 - dims.limbWidth/2,
      dims.legBottom - dims.baseY,
      -dims.limbWidth/2
    );
    const rightLegMax = new THREE.Vector3(
      dims.bodyWidth/4 + dims.limbWidth/2,
      dims.legTop - dims.baseY,
      dims.limbWidth/2
    );
    const rightLegHelper = createBoxHelper(rightLegMin, rightLegMax, 0x800080);
    
    // Add the hitzone group to the scene
    window.scene.add(hitZoneGroup);
    
    // Store reference to debug visualization group
    playerObj._hitZoneDebug = hitZoneGroup;
    
    // Update hitbox position immediately
    this.updateHitZoneDebugPosition(playerObj);

    // Add an update function to the player object
    if (!playerObj._updateHitZoneDebug) {
      const self = this;
      playerObj._updateHitZoneDebug = function() {
        if (this._hitZoneDebug) {
          self.updateHitZoneDebugPosition(this);
        }
      };
      
      // Modify the player's update function to include hitbox updates
      if (playerObj.update && typeof playerObj.update === 'function') {
        const originalUpdate = playerObj.update;
        playerObj.update = function(deltaTime) {
          // Call original update
          originalUpdate.call(this, deltaTime);
          // Update hit zone debug
          if (this._updateHitZoneDebug) {
            this._updateHitZoneDebug();
          }
        };
      }
    }
  }
  
  /**
   * Updates the position of a player's hit zone debug visualization
   * @param {object} playerObj - The player object
   */
  updateHitZoneDebugPosition(playerObj) {
    if (!playerObj || !playerObj._hitZoneDebug || !playerObj.group) return;
    
    const hitZoneDebug = playerObj._hitZoneDebug;
    const playerPos = playerObj.group.position.clone();
    
    // Adjust height based on whether this is a local (first-person) or remote player
    let baseY = playerPos.y;
    if (playerObj.camera) {
      // Local player's group position is at eye level, so subtract 1.6
      baseY = playerPos.y - 1.6;
    }
    
    // Position the debug group at the player's position
    hitZoneDebug.position.set(playerPos.x, baseY, playerPos.z);
    
    // Apply the player's rotation
    if (playerObj.group.rotation) {
      hitZoneDebug.rotation.y = playerObj.group.rotation.y;
    }
  }
  
  /**
   * Directly handles a server-reported impact for this bullet.
   * @param {string} hitType - Type of impact: 'player', 'npc', 'ground', 'boundary', 'arena'
   * @param {string|number|null} targetId - ID of hit target (for player hits)
   * @param {THREE.Vector3} position - Impact position
   * @param {THREE.Scene} scene - Scene to add effects to
   * @returns {Object} - Result object with active=false
   */
  handleServerImpact(hitType, targetId, position, scene) {
    // Skip creating ground impact effect
    if (hitType === 'ground' || hitType === 'arena' || hitType === 'boundary') {
      return { active: false, hit: { type: hitType, targetId, position } };
    }
    
    // Create visual effect based on hit type
    if (position) {
      createImpactEffect(position, this.direction, scene, hitType);
      
      // Play impact sound based on hit type at the impact position
      if (window.localPlayer && window.localPlayer.soundManager) {
        // Select appropriate impact sound based on hit type
        let impactSound = null; // No default sound for ground/other impacts
        
        if (hitType === 'player') {
          impactSound = "fleshimpact";
          
          // If this is a local player's bullet, we don't need to show hitmarker again
          // because we already showed it in the update method when client detected the hit
          if (this.isLocalBullet) {
            // Don't show hitmarker or play hitmarker sound again (already done client-side)
            // This prevents double hit markers on production servers
          }
          
          // Play headshot sound if the server reports it was a headshot
          else if (this.lastHitZone === 'head') {
            // For mobile devices, simplify audio to prevent layering
            if (window.isMobile) {
              // Just play one non-spatialized sound to avoid sync/double sound issues on mobile
              window.localPlayer.soundManager.playSound("headshotmarker", 0, 0.9);
            } else {
              // Headshots should be clearly audible regardless of distance
              if (this.isLocalBullet) {
                // For local player's headshots, play non-spatialized sound for feedback
                window.localPlayer.soundManager.playSound("headshotmarker", 100, 1.0);
                // And a quieter spatial sound for everyone else
                window.localPlayer.soundManager.playSoundAt("headshotmarker", position, 100, 0.5);
              } else {
                // For other players' headshots, use spatial audio
                window.localPlayer.soundManager.playSoundAt("headshotmarker", position, 100, 0.8);
              }
            }
          }
        }
        
        // Determine if this is a local player's bullet impact
        const isLocalPlayerBullet = this.isLocalBullet;
        
        // On mobile, simplify impact sounds to reduce audio overlapping
        if (window.isMobile && impactSound) {
          // Simpler sound approach for mobile to avoid sync issues
          window.localPlayer.soundManager.playSound(impactSound, 0, 0.6);
        } else if (impactSound && isLocalPlayerBullet) {
          // Desktop: Local player impacts should have more immediate feedback
          window.localPlayer.soundManager.playSound(impactSound, 50, 0.5);
          // With a spatial component as well
          window.localPlayer.soundManager.playSoundAt(impactSound, position, 50, 0.3);
        } else if (impactSound) {
          // Remote player impacts use spatial audio only
          window.localPlayer.soundManager.playSoundAt(impactSound, position, 50, 0.7);
        }
      }
    } else {
      // If no position provided, use current bullet position
      createImpactEffect(this.mesh.position, this.direction, scene, hitType);
    }
    
    // Always deactivate the bullet
    return { active: false, hit: { type: hitType, targetId, position } };
  }
  
  /**
   * Sets the last hit zone information for this bullet (for server validation)
   * @param {string} zone - The hit zone ('head', 'body', 'limbs')
   */
  setLastHitZone(zone) {
    this.lastHitZone = zone;
  }
  
  /**
   * Shows a hitmarker on the screen when a bullet hits a target
   * @param {THREE.Vector3} position - The 3D world position of the hit
   */
  showHitMarker(position) {
    // Create a new hit marker element for each hit rather than reusing one
    const hitMarker = document.createElement('div');
    hitMarker.style.position = 'absolute';
    hitMarker.style.transform = 'translate(-50%, -50%)';
    hitMarker.style.width = '40px';
    hitMarker.style.height = '40px';
    hitMarker.style.backgroundImage = 'url("models/hitmarker.png")';
    hitMarker.style.backgroundSize = 'contain';
    hitMarker.style.backgroundRepeat = 'no-repeat';
    hitMarker.style.pointerEvents = 'none';
    hitMarker.style.zIndex = '1000';
    hitMarker.style.opacity = '1';
    hitMarker.style.transition = 'opacity 0.1s ease-in-out';
    
    document.body.appendChild(hitMarker);
    
    // Convert 3D world position to 2D screen position
    if (position && window.localPlayer && window.localPlayer.camera) {
      // Clone the position to avoid modifying the original
      const screenPos = this.worldToScreen(position);
      
      // Only show if the hit is in front of the camera
      if (screenPos) {
        // Position the hit marker at the calculated screen position
        hitMarker.style.left = screenPos.x + 'px';
        hitMarker.style.top = screenPos.y + 'px';
      } else {
        // Fallback to center of screen if behind camera
        hitMarker.style.left = '50%';
        hitMarker.style.top = '50%';
      }
    } else {
      // Fallback to center of screen if no position provided or cannot convert
      hitMarker.style.left = '50%';
      hitMarker.style.top = '50%';
    }
    
    // Hide and remove after 100ms
    setTimeout(() => {
      hitMarker.style.opacity = '0';
      // Remove from DOM after fade out completes
      setTimeout(() => {
        if (hitMarker.parentNode) {
          hitMarker.parentNode.removeChild(hitMarker);
        }
      }, 100);
    }, 100);
  }
  
  /**
   * Converts a 3D world position to 2D screen coordinates
   * @param {THREE.Vector3} worldPos - The 3D world position to convert
   * @returns {Object|null} - The 2D screen position {x, y} or null if behind camera
   */
  worldToScreen(worldPos) {
    if (!window.localPlayer || !window.localPlayer.camera) return null;
    
    // Get the camera
    const camera = window.localPlayer.camera;
    
    // Clone position to avoid modifying the original
    const pos = worldPos.clone();
    
    // Project the 3D position to 2D clip space
    pos.project(camera);
    
    // If the point is behind the camera, don't show the hitmarker
    if (pos.z > 1) return null;
    
    // Convert from normalized device coordinates (-1 to +1) to window coordinates
    const widthHalf = window.innerWidth / 2;
    const heightHalf = window.innerHeight / 2;
    
    const x = (pos.x * widthHalf) + widthHalf;
    const y = -(pos.y * heightHalf) + heightHalf;
    
    return { x, y };
  }

  /**
   * Creates a visual path showing the bullet's trajectory for debugging
   * @param {THREE.Vector3} startPos - Start position
   * @param {THREE.Vector3} direction - Direction vector 
   */
  createTrajectoryVisualization(startPos, direction) {
    // Only create visualization if we're in debug mode and in the scene
    if (!window.debugMode || !window.scene) return;
    
    // Create line showing the projected path
    const lineMaterial = new THREE.LineBasicMaterial({ 
      color: 0xff0000,
      transparent: true,
      opacity: 0.7
    });
    
    // Create points along trajectory
    const points = [];
    points.push(startPos.clone());
    
    // Add a point 10 units away to show direction
    const endPoint = startPos.clone().add(direction.clone().multiplyScalar(10));
    points.push(endPoint);
    
    // Create the line geometry
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    
    // Add to scene
    window.scene.add(line);
    
    // Store reference to remove later
    this.trajectoryLine = line;
    
    // Remove line after 2 seconds
    setTimeout(() => {
      if (this.trajectoryLine && window.scene) {
        window.scene.remove(this.trajectoryLine);
        this.trajectoryLine = null;
      }
    }, 2000);
  }
}

================================================
File: /public/js/chat.js
================================================
/**
 * Chat system for player communication
 */

// Store original key handlers
let originalKeydownHandler;
let originalKeyupHandler;

// Chat state
let isChatActive = false;
let chatInputContainer;
let chatInput;
let chatMessages;
let chatContainer;
let messageCount = 0;
let lastSentMessage = null;
let lastMessageTime = 0; // Track when the last message was sent

/**
 * Initialize the chat system
 * @param {NetworkManager} networkManager - The network manager for sending messages
 */
export function initChat(networkManager) {
  createChatUI();
  setupChatEventListeners(networkManager);
}

/**
 * Create the chat UI elements
 */
function createChatUI() {
  const gameContainer = document.getElementById('game-container') || document.body;
  
  // Create chat container
  chatContainer = document.createElement('div');
  chatContainer.id = 'chat-container';
  
  // Initially size to content until we have multiple messages
  chatContainer.style.height = 'auto';
  gameContainer.appendChild(chatContainer);
  
  // Create messages container
  chatMessages = document.createElement('div');
  chatMessages.id = 'chat-messages';
  chatContainer.appendChild(chatMessages);
  
  // Create input container
  chatInputContainer = document.createElement('div');
  chatInputContainer.id = 'chat-input-container';
  gameContainer.appendChild(chatInputContainer);
  
  // Create input field
  chatInput = document.createElement('input');
  chatInput.id = 'chat-input';
  chatInput.type = 'text';
  chatInput.maxLength = 60; // Limit message length
  chatInput.placeholder = 'Type your message...';
  chatInputContainer.appendChild(chatInput);
  
  // Create send button for mobile
  const sendButton = document.createElement('button');
  sendButton.id = 'chat-send-button';
  sendButton.textContent = 'Send';
  sendButton.style.display = 'none'; // Initially hidden, shown only on mobile
  chatInputContainer.appendChild(sendButton);
  
  // Check if mobile and apply special styling
  if (isMobileDevice()) {
    // Position chat in top left for mobile - without dark background
    chatContainer.style.position = 'fixed';
    chatContainer.style.top = '10px';
    chatContainer.style.left = '0px'; // Changed from 10px to 0px - more to the left
    chatContainer.style.width = '70%';
    chatContainer.style.maxHeight = '30%';
    chatContainer.style.backgroundColor = 'transparent'; // Remove background
    chatContainer.style.zIndex = '1000';
    
    // COMPLETELY NEW APPROACH: Create a simple HTML link that opens a prompt
    // This is the most compatible approach for iOS Safari
    const chatButtonLink = document.createElement('a');
    chatButtonLink.id = 'chat-mobile-link';
    chatButtonLink.href = '#chat';  // Non-empty href required for iOS
    chatButtonLink.textContent = ''; // No text
    chatButtonLink.style.position = 'fixed';
    chatButtonLink.style.top = '10px';
    chatButtonLink.style.left = '0px'; // Also changed to 0px to match chat container
    chatButtonLink.style.width = '70%'; // Match chat container width
    chatButtonLink.style.height = '30%'; // Match chat container height
    chatButtonLink.style.padding = '0';
    chatButtonLink.style.zIndex = '2000';
    chatButtonLink.style.backgroundColor = 'transparent'; // Invisible
    chatButtonLink.style.border = 'none'; // No border
    chatButtonLink.style.color = 'transparent'; // Invisible text
    chatButtonLink.style.textDecoration = 'none';
    chatButtonLink.style.textAlign = 'left';
    chatButtonLink.style.opacity = '0'; // Make completely invisible
    // Still need pointer events to work
    chatButtonLink.style.pointerEvents = 'auto';
    
    // Add link to DOM
    document.body.appendChild(chatButtonLink);
    
    // Use simple prompt-based chat for maximum iOS compatibility
    chatButtonLink.addEventListener('click', function(e) {
      e.preventDefault();
      
      // Use native prompt() dialog which works reliably on all browsers
      const message = prompt('Enter your message:');
      
      if (message && message.trim()) {
        // Get network manager from global scope
        const networkManager = window.networkManager;
        
        if (networkManager) {
          // Process the chat message
          lastSentMessage = message.trim();
          sendChatMessage(message.trim(), networkManager);
        }
      }
    });
    
    // Hide the standard chat input on mobile since we're using prompt
    chatInputContainer.style.display = 'none';
    
    // Add system message about chat being available - shorter version
    addSystemMessage("Tap here to chat");
  } else {
    // Add desktop-specific message
    addSystemMessage("Press \"Enter\" to chat with other players!");
  }
  
  // Adjust chat container size on window resize
  window.addEventListener('resize', updateChatPosition);
}

/**
 * Set up event listeners for the chat
 * @param {NetworkManager} networkManager - The network manager for sending messages
 */
function setupChatEventListeners(networkManager) {
  // Store original document key handlers
  originalKeydownHandler = document.onkeydown;
  originalKeyupHandler = document.onkeyup;
  
  // Add keydown event listener for chat activation
  document.addEventListener('keydown', (event) => {
    // Press Enter to toggle chat input
    if (event.code === 'Enter') {
      event.preventDefault();
      
      if (isChatActive) {
        const message = chatInput.value.trim();
        if (message) {
          lastSentMessage = message; // Store last sent message to prevent duplication
          sendChatMessage(message, networkManager);
        }
        closeChat();
      } else {
        openChat();
      }
      return;
    }
    
    // If chat is active, handle chat-specific keys
    if (isChatActive) {
      // Close chat on Escape
      if (event.code === 'Escape') {
        closeChat();
        event.preventDefault();
      }
      
      // Prevent game actions while typing
      event.stopPropagation();
    }
  }, true);
  
  // Handle clicks to close chat when clicking outside chat elements
  document.addEventListener('click', (event) => {
    if (isChatActive) {
      // Check if click is outside chat elements
      if (!chatContainer.contains(event.target) && !chatInputContainer.contains(event.target)) {
        closeChat();
      }
    }
  });
  
  // Add event listener for send button
  const sendButton = document.getElementById('chat-send-button');
  if (sendButton) {
    // Use both click and touchend for better mobile experience
    ['click', 'touchend'].forEach(eventType => {
      sendButton.addEventListener(eventType, function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const message = chatInput.value.trim();
        if (message) {
          lastSentMessage = message;
          sendChatMessage(message, networkManager);
        }
        closeChat();
      });
    });
  }
}

/**
 * Open the chat input
 */
function openChat() {
  isChatActive = true;
  chatInputContainer.style.display = 'block';
  chatInput.value = '';
  
  // Add active class to chat container for styling
  chatContainer.classList.add('active');
  
  // Unlock pointer for chat interaction
  if (document.pointerLockElement) {
    document.exitPointerLock();
  }
  
  // Disable game controls while chat is active
  disableGameControls();
  
  // Special handling for mobile keyboards
  if (isMobileDevice()) {
    // Create and append a temporary button that we'll click/focus to help trigger the keyboard
    const tempButton = document.createElement('button');
    tempButton.style.position = 'fixed';
    tempButton.style.bottom = '0';
    tempButton.style.right = '0';
    tempButton.style.width = '1px';
    tempButton.style.height = '1px';
    tempButton.style.opacity = '0.01';
    tempButton.style.pointerEvents = 'none';
    document.body.appendChild(tempButton);
    
    // Force iOS Safari to show keyboard
    setTimeout(() => {
      // Remove readonly attribute completely
      chatInput.removeAttribute('readonly');
      
      // Use these attributes to help iOS Safari
      chatInput.setAttribute('autocomplete', 'off');
      chatInput.setAttribute('autocorrect', 'off');
      chatInput.setAttribute('autocapitalize', 'none');
      chatInput.style.fontSize = '16px'; // iOS Safari requires at least 16px
      
      // Click the temporary button to ensure iOS transitions focus properly
      tempButton.focus();
      tempButton.click();
      
      // Now focus and click the actual input
      chatInput.focus();
      chatInput.click();
      
      // Some iOS versions need a double focus attempt with delay
      setTimeout(() => {
        chatInput.focus();
        chatInput.click();
        
        // Remove the temporary button
        document.body.removeChild(tempButton);
      }, 50);
    }, 300);
  } else {
    chatInput.focus();
  }
}

/**
 * Close the chat input
 */
function closeChat() {
  isChatActive = false;
  chatInputContainer.style.display = 'none';
  chatInput.blur();
  
  // Remove active class from chat container
  chatContainer.classList.remove('active');
  
  // Re-lock pointer if game-container exists
  const gameContainer = document.getElementById('game-container');
  if (gameContainer) {
    const canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.requestPointerLock();
    }
  }
  
  // Re-enable game controls
  enableGameControls();
}

/**
 * Disable game controls while chatting
 */
function disableGameControls() {
  // If there's a local player, disable its movement
  if (window.localPlayer) {
    window.localPlayer.chatActive = true;
  }
}

/**
 * Re-enable game controls after chat is closed
 */
function enableGameControls() {
  // Re-enable local player movement
  if (window.localPlayer) {
    window.localPlayer.chatActive = false;
  }
}

/**
 * Send a chat message to the server
 * @param {string} message - The message to send
 * @param {NetworkManager} networkManager - The network manager for sending messages
 */
function sendChatMessage(message, networkManager) {
  // Client-side rate limiting to give immediate feedback
  const now = Date.now();
  if (now - lastMessageTime < 2000) {
    addSystemMessage("Please wait 2 seconds between messages");
    return;
  }
  
  // Update last message timestamp
  lastMessageTime = now;
  
  // Get username from player identity or use default
  const username = window.playerIdentity?.username || 'Player';
  
  // Add message to local chat first (local player message)
  addChatMessage(username, message, true);
  
  // Send message to server if network is available
  if (networkManager && networkManager.socket && 
      networkManager.socket.readyState === WebSocket.OPEN) {
    networkManager.socket.send(JSON.stringify({
      type: 'chat',
      message: message
    }));
  }
}

/**
 * Add a chat message to the UI
 * @param {string} username - The username of the sender
 * @param {string} message - The message content
 * @param {boolean} isLocal - Whether this is the local player's message
 */
export function addChatMessage(username, message, isLocal = false) {
  // Avoid duplicate messages when receiving back your own message from server
  const localUsername = window.playerIdentity?.username || 'Player';
  if (!isLocal && username === localUsername && message === lastSentMessage) {
    lastSentMessage = null; // Reset after checking
    return;
  }
  
  const messageElement = document.createElement('div');
  messageElement.className = 'chat-message';
  
  const usernameSpan = document.createElement('span');
  usernameSpan.className = 'username';
  
  // Generate a color for the username based on the username string
  const color = getUsernameColor(username);
  
  usernameSpan.style.color = color;
  usernameSpan.textContent = username + ':';
  
  messageElement.appendChild(usernameSpan);
  messageElement.appendChild(document.createTextNode(' ' + message));
  
  chatMessages.appendChild(messageElement);
  messageCount++;
  
  // Update chat container size if needed
  updateChatPosition();
  
  // Auto scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // No fadeout or removal - messages persist indefinitely
}

/**
 * Add a system message to the chat
 * @param {string} message - The system message
 */
export function addSystemMessage(message) {
  const messageElement = document.createElement('div');
  messageElement.className = 'chat-message system-message';
  messageElement.textContent = 'SYSTEM: ' + message;
  
  chatMessages.appendChild(messageElement);
  messageCount++;
  
  // Update chat container size if needed
  updateChatPosition();
  
  // Auto scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
  
  // System messages persist indefinitely like regular messages
}

/**
 * Generate a consistent color for a username
 * @param {string} username - The username
 * @returns {string} - CSS color string
 */
function getUsernameColor(username) {
  // Generate a hash from username string
  let hash = 0;
  for (let i = 0; i < username.length; i++) {
    hash = username.charCodeAt(i) + ((hash << 5) - hash);
  }
  
  // Generate bright colors by using high saturation and lightness
  const h = Math.abs(hash) % 360;  // Hue (0-360)
  const s = 70 + (Math.abs(hash) % 30);  // Saturation (70-100%)
  const l = 60 + (Math.abs(hash) % 15);  // Lightness (60-75%)
  
  return `hsl(${h}, ${s}%, ${l}%)`;
}

/**
 * Handle incoming chat messages from other players
 * @param {Object} data - The chat message data from the server
 */
export function handleChatMessage(data) {
  addChatMessage(data.username, data.message);
}

/**
 * Check if chat is currently active
 * @returns {boolean} - True if chat input is active
 */
export function isChatInputActive() {
  return isChatActive;
}

/**
 * Update chat container position based on screen size
 */
export function updateChatPosition() {
  if (!chatContainer) return;
  
  const isMobile = isMobileDevice();
  
  if (isMobile) {
    // Mobile positioning - top left corner, transparent background
    chatContainer.style.position = 'fixed';
    chatContainer.style.top = '10px';
    chatContainer.style.left = '0px'; // Changed from 10px to 0px - more to the left
    chatContainer.style.width = '70%';
    chatContainer.style.maxHeight = '30%';
    chatContainer.style.backgroundColor = 'transparent';
    chatContainer.style.overflow = 'auto';
    
    // Update chat button link position if it exists
    const chatButton = document.getElementById('chat-mobile-link');
    if (chatButton) {
      chatButton.style.top = '10px';
      chatButton.style.left = '0px';
      chatButton.style.width = '70%';
      chatButton.style.height = '30%';
    }
    
    // Style input for mobile (hidden but keeping styles in case we need them)
    if (chatInputContainer) {
      chatInputContainer.style.position = 'fixed';
      chatInputContainer.style.top = '50%';
      chatInputContainer.style.left = '50%';
      chatInputContainer.style.transform = 'translate(-50%, -50%)';
      chatInputContainer.style.width = '80%';
      chatInputContainer.style.maxWidth = '400px';
      chatInputContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      chatInputContainer.style.padding = '10px';
      chatInputContainer.style.borderRadius = '5px';
    }
  } else {
    // Desktop positioning - bottom left corner
    const gameHeight = window.innerHeight;
    const chatHeight = Math.min(gameHeight * 0.25, 200); // Max 25% of game height or 200px
    
    chatContainer.style.position = 'absolute';
    chatContainer.style.bottom = '80px';
    chatContainer.style.left = '20px';
    chatContainer.style.width = '400px';
    chatContainer.style.maxHeight = `${chatHeight}px`;
    
    // Style input for desktop
    if (chatInputContainer) {
      chatInputContainer.style.position = 'absolute';
      chatInputContainer.style.bottom = '20px';
      chatInputContainer.style.left = '20px';
      chatInputContainer.style.width = '400px';
      chatInputContainer.style.backgroundColor = 'transparent';
      chatInputContainer.style.transform = 'none';
    }
    
    // Hide send button on desktop
    const sendButton = document.getElementById('chat-send-button');
    if (sendButton) {
      sendButton.style.display = 'none';
    }
    
    // Style chat input for desktop
    if (chatInput) {
      chatInput.style.width = '100%';
      chatInput.style.padding = '5px';
      chatInput.style.fontSize = '14px';
    }
  }
}

/**
 * Check if the user is on a mobile device
 * @returns {boolean} True if on mobile device
 */
function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || 
          navigator.maxTouchPoints > 0 || 
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
} 

================================================
File: /public/js/desertTerrain.js
================================================
/**
 * Creates an endless procedural desert terrain around the town.
 * Based on Perlin noise for natural-looking dunes and terrain features.
 */

// A simple Perlin noise implementation for terrain generation
class PerlinNoise {
    constructor(seed = Math.random()) {
        this.seed = seed;
        this.perm = new Array(512);
        this.gradP = new Array(512);
        
        // Initialize permutation table
        const p = new Array(256);
        for (let i = 0; i < 256; i++) {
            p[i] = Math.floor(seed * 10000 + i) % 256;
        }
        
        // Populate permutation tables
        for (let i = 0; i < 512; i++) {
            this.perm[i] = p[i & 255];
            this.gradP[i] = this.gradients[this.perm[i] % 12];
        }
    }
    
    gradients = [
        [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
        [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
        [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
    ];
    
    fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
    }
    
    lerp(a, b, t) {
        return (1 - t) * a + t * b;
    }
    
    grad(hash, x, y, z) {
        const g = this.gradP[hash];
        return g[0] * x + g[1] * y + g[2] * z;
    }
    
    noise(x, y, z = 0) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        const Z = Math.floor(z) & 255;
        
        x -= Math.floor(x);
        y -= Math.floor(y);
        z -= Math.floor(z);
        
        const u = this.fade(x);
        const v = this.fade(y);
        const w = this.fade(z);
        
        const A = this.perm[X] + Y;
        const AA = this.perm[A] + Z;
        const AB = this.perm[A + 1] + Z;
        const B = this.perm[X + 1] + Y;
        const BA = this.perm[B] + Z;
        const BB = this.perm[B + 1] + Z;
        
        return this.lerp(
            this.lerp(
                this.lerp(this.grad(this.perm[AA], x, y, z), this.grad(this.perm[BA], x - 1, y, z), u),
                this.lerp(this.grad(this.perm[AB], x, y - 1, z), this.grad(this.perm[BB], x - 1, y - 1, z), u),
                v
            ),
            this.lerp(
                this.lerp(this.grad(this.perm[AA + 1], x, y, z - 1), this.grad(this.perm[BA + 1], x - 1, y, z - 1), u),
                this.lerp(this.grad(this.perm[AB + 1], x, y - 1, z - 1), this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1), u),
                v
            ),
            w
        );
    }
}

export class DesertTerrain {
    constructor(scene, townDimensions) {
        this.scene = scene;
        this.townDimensions = townDimensions;
        
        // Calculate optimal terrain size based on town dimensions
        const townSize = Math.max(townDimensions.width, townDimensions.length);
        const desertSize = Math.max(5000, townSize * 25); // At least 25x larger than town
        
        // Setup with appropriate settings
        this.config = {
            size: desertSize, // Size based on town dimensions
            resolution: 196, // Resolution of the terrain (vertices per side)
            cactiCount: 120, // Number of cacti to place (increased from 60)
            noiseScale: {
                base: 0.0003,
                dunes: 0.0008,
                secondaryDunes: 0.0015,
                ridges: 0.003,
                detail: 0.01,
                flat: 0.0003,
                // Enhanced micro-detail scales for more prominent sand ripples
                microRipples: 0.04, // Adjusted for better groove definition
                sandGrains: 0.3
            },
            heightScale: {
                base: 15,
                dunes: 40, // Reduced from 70 for lower dune heights
                secondaryDunes: 20, // Reduced from 30
                ridges: 10, // Reduced from 15
                detail: 8,
                // Increased height adjustments for more pronounced micro-detail
                microRipples: 2.0, // Increased for more visible grooves
                sandGrains: 0.3  // Slightly increased from 0.2
            },
            duneDirection: Math.PI * 0.25, // Wind direction
            sandColors: [
                new THREE.Color(0xec9e5c), // Base sand color
                new THREE.Color(0xd4884a), // Slightly darker
                new THREE.Color(0xf7b777), // Slightly lighter
                new THREE.Color(0xb7703e), // Darker/shadow areas
                new THREE.Color(0xffc890)  // Highlight areas
            ],
            distanceBlur: {
                enabled: true,
                startDistance: desertSize * 0.35, // Start blurring at 35% distance from center
                endDistance: desertSize * 0.5,    // Maximum blur at edge
                skyboxColor: new THREE.Color(0xaad6f5), // Light blue to match skybox horizon
                atmosphericHaze: true,            // Enable atmospheric haze on dunes
                hazeStartDistance: desertSize * 0.15, // Start atmospheric effect closer
                hazeFactor: 0.6                  // Strength of the atmospheric effect
            },
            dunes: {
                smoothing: true,          // Enable dune edge smoothing
                smoothingFactor: 0.7,     // How much to smooth dune edges (0-1)
                ridgeSharpness: 0.4       // Reduced ridge sharpness (0-1)
            },
            townBuffer: townSize * 1.2 // Buffer distance around town where terrain is flat
        };
        
        console.log(`Creating desert terrain with size ${desertSize} around town of size ${townSize}`);
        
        // Create noise generators
        this.baseNoise = new PerlinNoise(Math.random());
        this.duneNoise = new PerlinNoise(Math.random() + 100);
        this.secondaryDuneNoise = new PerlinNoise(Math.random() + 150);
        this.ridgeNoise = new PerlinNoise(Math.random() + 175);
        this.detailNoise = new PerlinNoise(Math.random() + 200);
        this.colorNoise = new PerlinNoise(Math.random() + 300);
        // Add micro-detail noise generators
        this.microRipplesNoise = new PerlinNoise(Math.random() + 400);
        this.sandGrainsNoise = new PerlinNoise(Math.random() + 500);
    }
    
    // Create directional dunes effect
    getDirectionalDuneHeight(x, z) {
        // Extract directional component based on wind angle
        const direction = this.config.duneDirection;
        
        // Rotate coordinates based on wind direction
        const rotX = x * Math.cos(direction) + z * Math.sin(direction);
        const rotZ = -x * Math.sin(direction) + z * Math.cos(direction);
        
        // Sample noise for directional dune patterns
        const duneHeight = this.duneNoise.noise(
            rotX * this.config.noiseScale.dunes,
            rotZ * this.config.noiseScale.dunes * 0.5
        ) * this.config.heightScale.dunes;
        
        // Add secondary dune system
        const secondaryHeight = this.secondaryDuneNoise.noise(
            rotX * this.config.noiseScale.secondaryDunes,
            rotZ * this.config.noiseScale.secondaryDunes
        ) * this.config.heightScale.secondaryDunes;
        
        // Add ridge details with reduced sharpness
        const ridges = this.ridgeNoise.noise(
            rotX * this.config.noiseScale.ridges,
            rotZ * this.config.noiseScale.ridges
        );
        
        // Create smoother ridges if smoothing is enabled
        let ridgeHeight;
        if (this.config.dunes.smoothing) {
            // Use a smoother curve for ridge calculation
            const smoothedRidge = (Math.abs(ridges * 2 - 1));
            // Apply smoothing factor
            const smoothingPower = 1.0 + this.config.dunes.smoothingFactor * 2.0;
            ridgeHeight = Math.pow(smoothedRidge, smoothingPower) * this.config.heightScale.ridges;
            
            // Further reduce sharp edges by applying a gentler curve
            ridgeHeight *= this.config.dunes.ridgeSharpness;
        } else {
            // Original ridge calculation
            ridgeHeight = (Math.abs(ridges * 2 - 1)) * this.config.heightScale.ridges;
        }
        
        return duneHeight + secondaryHeight + ridgeHeight;
    }
    
    // Check if a point is near the train track
    isNearTrainTrack(x, z) {
        // Access global train track constants
        const trackStart = window.TRAIN_TRACK_START || new THREE.Vector3(0, 0, -1000);
        const trackEnd = window.TRAIN_TRACK_END || new THREE.Vector3(0, 0, 1000);
        
        // Width of the flattened area on each side of the track (1m as requested)
        const trackWidth = 1.0;
        
        // Create a line segment representing the track
        const trackVector = new THREE.Vector3().subVectors(trackEnd, trackStart).normalize();
        const pointVector = new THREE.Vector3(x, 0, z);
        
        // Calculate the projection of the point onto the track line
        const trackStartToPoint = new THREE.Vector3().subVectors(pointVector, trackStart);
        const dotProduct = trackStartToPoint.dot(trackVector);
        
        // Clamp the projection to the track segment
        const projectionScalar = Math.max(0, Math.min(dotProduct, trackEnd.distanceTo(trackStart)));
        
        // Calculate the closest point on the track
        const closestPoint = new THREE.Vector3().copy(trackStart).addScaledVector(trackVector, projectionScalar);
        
        // Calculate the distance from the point to the closest point on the track
        const distance = pointVector.distanceTo(closestPoint);
        
        // Check if the point is within the track width and within the track segment
        return distance <= trackWidth && projectionScalar >= 0 && projectionScalar <= trackEnd.distanceTo(trackStart);
    }
    
    // Get blend factor for town area (0 = in town, 1 = full desert)
    getTownBlendFactor(x, z) {
        // Calculate distance from town center
        const distFromTown = Math.sqrt(x * x + z * z);
        
        // Check if point is near train track
        const isOnTrack = this.isNearTrainTrack(x, z);
        
        // If near train track, return 0 to make it flat
        if (isOnTrack) {
            return 0;
        }
        
        // Normal town blending
        if (distFromTown < this.config.townBuffer) {
            // Completely flat within town
            return 0;
        } else if (distFromTown < this.config.townBuffer * 1.5) {
            // Gradual transition at edge of town
            const transitionFactor = (distFromTown - this.config.townBuffer) / (this.config.townBuffer * 0.5);
            return Math.pow(transitionFactor, 2.0); // Squared for smoother transition
        } else {
            // Full desert terrain
            return 1.0;
        }
    }
    
    // Generate terrain mesh
    generateTerrain() {
        // Create textures for sand
        const normalMapTexture = this.createSandNormalMap();
        const roughnessTexture = this.createSandRoughnessMap();
        
        // Create geometry
        const geometry = new THREE.PlaneGeometry(
            this.config.size, 
            this.config.size, 
            this.config.resolution, 
            this.config.resolution
        );
        
        geometry.rotateX(-Math.PI / 2);
        
        const vertices = geometry.attributes.position.array;
        
        // Create vertex colors array
        const colors = new Float32Array(vertices.length);
        
        // Edge fade values
        const edgeFadeStart = this.config.size * 0.4; // Start fading at 40% from center
        const edgeFadeEnd = this.config.size * 0.5;   // Complete fade at edge
        
        // Create buffer for vertex height adjustments (for sand waves)
        const heightAtEdge = this.config.size * 0.03;  // Raise edges slightly to blend with sky better
        
        // Apply noise to create terrain
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            
            // Calculate distance from center for edge blending
            const distFromCenter = Math.sqrt(x * x + z * z);
            
            // Calculate town blend factor (0 = flat town area, 1 = full desert)
            const townBlend = this.getTownBlendFactor(x, z);
            
            // Base terrain
            let height = this.baseNoise.noise(x * this.config.noiseScale.base, z * this.config.noiseScale.base) * this.config.heightScale.base;
            
            // Add directional dunes with smoothing
            let duneHeight = this.getDirectionalDuneHeight(x, z);
            
            // Smooth transitions between dunes for more natural silhouettes
            if (this.config.dunes.smoothing) {
                // Apply additional smoothing to dune transitions
                const smoothingNoise = this.baseNoise.noise(
                    x * this.config.noiseScale.dunes * 2,
                    z * this.config.noiseScale.dunes * 2
                );
                
                // Use noise to slightly adjust dune height in a natural way
                duneHeight *= (0.85 + smoothingNoise * 0.3);
            }
            
            // Apply town blend factor to terrain height
            height += duneHeight * townBlend;
            
            // Add small ripples to dunes (more pronounced farther from town)
            const detailHeight = this.detailNoise.noise(x * this.config.noiseScale.detail, z * this.config.noiseScale.detail) 
                * this.config.heightScale.detail;
            height += detailHeight * Math.min(1, duneHeight / 20) * townBlend;
            
            // Add micro-ripples from wind patterns - aligned with wind direction
            const windDirection = this.config.duneDirection;
            const alignedX = x * Math.cos(windDirection) + z * Math.sin(windDirection);
            const alignedZ = -x * Math.sin(windDirection) + z * Math.cos(windDirection);
            
            // More pronounced micro-ripples
            const microRipples = this.microRipplesNoise.noise(
                alignedX * this.config.noiseScale.microRipples,
                alignedZ * this.config.noiseScale.microRipples * 5 // More stretching for pronounced directional ripples
            ) * this.config.heightScale.microRipples;
            
            // Create additional small ripple detail for more complex patterns
            const secondaryRipples = this.microRipplesNoise.noise(
                alignedX * this.config.noiseScale.microRipples * 2,
                alignedZ * this.config.noiseScale.microRipples * 7
            ) * this.config.heightScale.microRipples * 0.4;
            
            // Add sand grain detail for very close-up detail
            const sandGrains = this.sandGrainsNoise.noise(
                x * this.config.noiseScale.sandGrains,
                z * this.config.noiseScale.sandGrains
            ) * this.config.heightScale.sandGrains;
            
            // Apply micro-detail based on distance from town (more detail in desert areas)
            height += (microRipples + secondaryRipples + sandGrains) * townBlend;
            
            // Add occasional flat areas (dried lake beds)
            const flatArea = this.baseNoise.noise(x * this.config.noiseScale.flat + 500, z * this.config.noiseScale.flat + 500);
            if (flatArea > 0.6 && townBlend > 0.8) {
                height *= 0.2;
            }
            
            // Apply edge blending - gradually reduce height near edges
            if (distFromCenter > edgeFadeStart) {
                const edgeFactor = 1.0 - Math.min(1, (distFromCenter - edgeFadeStart) / (edgeFadeEnd - edgeFadeStart));
                height *= edgeFactor;
            }
            
            // Apply height to vertex
            vertices[i + 1] = height;
            
            // Calculate color index
            const colorNoise = this.colorNoise.noise(
                x * this.config.noiseScale.base * 2, 
                z * this.config.noiseScale.base * 2
            );
            
            // Calculate slope for color variation (approximation)
            let slope = 0;
            if (i > 3 && i < vertices.length - 3) {
                const prevHeight = vertices[i - 2];
                const nextHeight = vertices[i + 4];
                slope = Math.abs(nextHeight - prevHeight) / 2;
            }
            
            // Blend different sand colors
            const heightFactor = Math.max(0, Math.min(1, (height + 10) / 80));
            
            // Start with base color
            let finalColor = this.config.sandColors[0].clone();
            
            // Add darker sand in valleys
            if (heightFactor < 0.5) {
                finalColor.lerp(this.config.sandColors[1], 0.5 - heightFactor);
            }
            
            // Add lighter sand on peaks
            if (heightFactor > 0.5) {
                finalColor.lerp(this.config.sandColors[2], (heightFactor - 0.5) * 2);
            }
            
            // Add random variation
            if (colorNoise > 0) {
                finalColor.lerp(this.config.sandColors[4], colorNoise * 0.3);
            } else {
                finalColor.lerp(this.config.sandColors[3], -colorNoise * 0.3);
            }
            
            // Add slope-based coloring
            if (slope > 0.2) {
                const slopeFactor = Math.min(1, (slope - 0.2) * 5);
                finalColor.lerp(this.config.sandColors[3], slopeFactor * 0.5);
            }
            
            // Add micro-ripple highlights and shadows
            const microDetail = microRipples / this.config.heightScale.microRipples;
            if (microDetail > 0.3) {
                // Add highlights to ripple peaks
                finalColor.lerp(this.config.sandColors[4], (microDetail - 0.3) * 0.2);
            } else if (microDetail < -0.3) {
                // Add shadows to ripple valleys
                finalColor.lerp(this.config.sandColors[3], Math.abs(microDetail + 0.3) * 0.2);
            }
            
            // Store color
            const colorIdx = i;
            colors[colorIdx] = finalColor.r;
            colors[colorIdx + 1] = finalColor.g;
            colors[colorIdx + 2] = finalColor.b;
            
            // Apply atmospheric haze effect to dune edges and higher areas
            if (this.config.distanceBlur.atmosphericHaze && distFromCenter > this.config.distanceBlur.hazeStartDistance) {
                // Calculate haze factor based on distance and height
                const distanceFactor = Math.min(1.0, (distFromCenter - this.config.distanceBlur.hazeStartDistance) / 
                                   (this.config.distanceBlur.endDistance - this.config.distanceBlur.hazeStartDistance));
                
                // More haze on higher terrain (silhouettes against sky)
                const heightFactor = Math.min(1.0, height / (this.config.heightScale.dunes * 0.5));
                
                // Combine factors with configurable intensity
                const hazeFactor = distanceFactor * heightFactor * this.config.distanceBlur.hazeFactor;
                
                // Apply more intense sky color blending to higher dunes
                const skyColorBlend = this.config.distanceBlur.skyboxColor.clone();
                
                // Apply haze color blend
                colors[colorIdx] = finalColor.r * (1 - hazeFactor) + skyColorBlend.r * hazeFactor;
                colors[colorIdx + 1] = finalColor.g * (1 - hazeFactor) + skyColorBlend.g * hazeFactor;
                colors[colorIdx + 2] = finalColor.b * (1 - hazeFactor) + skyColorBlend.b * hazeFactor;
            }
            
            // Apply distance blur/fog effect by blending with skybox color at edges
            if (this.config.distanceBlur.enabled && distFromCenter > this.config.distanceBlur.startDistance) {
                const blurFactor = Math.min(1.0, (distFromCenter - this.config.distanceBlur.startDistance) / 
                                       (this.config.distanceBlur.endDistance - this.config.distanceBlur.startDistance));
                
                // Apply stronger color blend for more dramatic effect
                colors[colorIdx] = colors[colorIdx] * (1 - blurFactor) + this.config.distanceBlur.skyboxColor.r * blurFactor;
                colors[colorIdx + 1] = colors[colorIdx + 1] * (1 - blurFactor) + this.config.distanceBlur.skyboxColor.g * blurFactor;
                colors[colorIdx + 2] = colors[colorIdx + 2] * (1 - blurFactor) + this.config.distanceBlur.skyboxColor.b * blurFactor;
                
                // Gradually raise the terrain at edges to create a smooth blend with sky
                if (distFromCenter > this.config.distanceBlur.startDistance) {
                    const heightBlendFactor = Math.pow(blurFactor, 2.0); // Stronger curve for height adjustment
                    vertices[i + 1] += heightAtEdge * heightBlendFactor;
                }
            }
        }
        
        // Add colors to geometry
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.computeVertexNormals();
        
        // Create sand material with textures
        const sandMaterial = new THREE.MeshPhongMaterial({
            vertexColors: true,
            shininess: 0,
            specular: new THREE.Color(0x000000),
            normalMap: normalMapTexture,
            normalScale: new THREE.Vector2(1.2, 1.2),
            fog: true
        });
        
        // Ensure no environment reflections
        sandMaterial.envMap = null;
        
        // No custom shader modifications - rely on the built-in fog system and vertex colors
        
        // Create terrain mesh
        this.terrainMesh = new THREE.Mesh(geometry, sandMaterial);
        this.terrainMesh.receiveShadow = true;
        this.terrainMesh.castShadow = true;
        
        // Position the terrain mesh a tiny bit below the current ground plane
        // to avoid z-fighting and ensure seamless transition
        this.terrainMesh.position.y = -0.05;
        
        // Center the terrain on the town's center (0,0,0)
        // This ensures the town is in the center of our desert terrain
        this.terrainMesh.position.set(0, -0.05, 0);
        
        this.scene.add(this.terrainMesh);
        
        return this.terrainMesh;
    }
    
    // Create a procedural normal map for sand texture
    createSandNormalMap() {
        const size = 1024;
        const data = new Uint8Array(size * size * 4);
        const normalStrength = 40; // Increased from 30 to restore groove visibility
        
        // Generate sand ripple and grain patterns using noise
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Calculate normalized coordinates
                const nx = x / size;
                const ny = y / size;
                
                // Multiple layers of noise for different scales of detail
                // Wind ripples - elongated with directional flow
                const windDirection = this.config.duneDirection;
                const windAlignedX = nx * Math.cos(windDirection) + ny * Math.sin(windDirection);
                const windAlignedY = -nx * Math.sin(windDirection) + ny * Math.cos(windDirection);
                
                // Enhanced ripple pattern - more pronounced
                const ripples = this.microRipplesNoise.noise(
                    windAlignedX * 35,
                    windAlignedY * 12
                ) * 1.8;
                
                // Fine sand grain texture
                const grains = this.sandGrainsNoise.noise(nx * 200, ny * 200) * 0.2;
                
                // Medium-scale variations
                const mediumVar = this.detailNoise.noise(nx * 40, ny * 40) * 0.5;
                
                // Combine layers - emphasize ripples more but with balanced intensity
                const combined = ripples * 0.8 + grains * 0.3 + mediumVar * 0.2; // Adjusted weights to better show grooves
                
                // Convert to normal map values
                // Calculate local derivatives for normal
                const idx = (y * size + x) * 4;
                
                // Calculate height differences for normal approximation
                const left = x > 0 ? ripples * 0.8 + this.sandGrainsNoise.noise((nx - 1/size) * 200, ny * 200) * 0.2 + 
                    this.detailNoise.noise((nx - 1/size) * 40, ny * 40) * 0.3 : combined;
                const right = x < size-1 ? ripples * 0.8 + this.sandGrainsNoise.noise((nx + 1/size) * 200, ny * 200) * 0.2 +
                    this.detailNoise.noise((nx + 1/size) * 40, ny * 40) * 0.3 : combined;
                const up = y > 0 ? ripples * 0.8 + this.sandGrainsNoise.noise(nx * 200, (ny - 1/size) * 200) * 0.2 +
                    this.detailNoise.noise(nx * 40, (ny - 1/size) * 40) * 0.3 : combined;
                const down = y < size-1 ? ripples * 0.8 + this.sandGrainsNoise.noise(nx * 200, (ny + 1/size) * 200) * 0.2 +
                    this.detailNoise.noise(nx * 40, (ny + 1/size) * 40) * 0.3 : combined;
                
                // X normal component (R)
                data[idx] = Math.min(255, Math.max(0, 128 + normalStrength * (right - left)));
                // Y normal component (G)
                data[idx + 1] = Math.min(255, Math.max(0, 128 + normalStrength * (down - up)));
                // Z normal component (B) - always positive since we're looking at the top
                data[idx + 2] = 255;
                // Alpha
                data[idx + 3] = 255;
            }
        }
        
        // Create texture from data
        const texture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(15, 15); // Reduced from 20 to make patterns larger
        texture.needsUpdate = true;
        
        return texture;
    }
    
    // Create a procedural roughness map for sand texture
    createSandRoughnessMap() {
        const size = 512;
        const data = new Uint8Array(size * size);
        
        // Generate sand grain patterns
        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                // Calculate normalized coordinates
                const nx = x / size;
                const ny = y / size;
                
                // Multi-layer noise for varying roughness
                const baseRoughness = 245; // High base roughness
                
                // Wind direction-aligned roughness variation (simulates sand accumulation)
                const windDirection = this.config.duneDirection;
                const alignedX = nx * Math.cos(windDirection) + ny * Math.sin(windDirection);
                const alignedY = -nx * Math.sin(windDirection) + ny * Math.cos(windDirection);
                
                // More pronounced wind ripples with stronger contrast for roughness variation
                const windPattern = this.microRipplesNoise.noise(alignedX * 30, alignedY * 8);
                
                // Fine grain roughness detail
                const fineGrains = this.sandGrainsNoise.noise(nx * 300, ny * 300) * 5;
                
                // Calculate final roughness value - higher in troughs, slightly lower on crests
                // This variation helps with visual appearance while keeping overall roughness high
                const roughness = Math.min(255, Math.max(230, 
                    baseRoughness + (windPattern < 0 ? 10 : -5) + fineGrains
                ));
                
                // Store the value
                data[y * size + x] = roughness;
            }
        }
        
        // Create texture from data
        const texture = new THREE.DataTexture(data, size, size, THREE.RedFormat);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(20, 20);
        texture.needsUpdate = true;
        
        return texture;
    }
    
    // Add cacti to the scene
    addCacti() {
        // Create cactus materials
        const cactusMaterial = new THREE.MeshStandardMaterial({
            color: 0x2d5c2d,
            roughness: 0.8,
            metalness: 0.2,
        });
        
        // Cactus segments to be instanced
        const segmentGeometries = [
            // Main trunk (shorter now)
            this.createCactusTrunk(2.5, 4, 20, 8),
            // Arm segment (horizontal part)
            this.createCactusArm(1.8, 2.2, 8, 8),
            // Arm tip (vertical part) 
            this.createCactusTrunk(1.5, 1.8, 12, 8),
        ];
        
        // Create instanced mesh for each geometry type
        const cactusCount = this.config.cactiCount;
        const instancedSegments = [];
        
        // Create instanced mesh for each segment type
        for (let i = 0; i < segmentGeometries.length; i++) {
            const instancedMesh = new THREE.InstancedMesh(
                segmentGeometries[i],
                cactusMaterial,
                cactusCount * (i === 0 ? 1 : 2) // One trunk per cactus, two arms per cactus
            );
            instancedMesh.castShadow = true;
            instancedMesh.receiveShadow = true;
            instancedSegments.push(instancedMesh);
        }
        
        // Helper matrices and vectors
        const matrix = new THREE.Matrix4();
        const position = new THREE.Vector3();
        const rotation = new THREE.Euler();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        
        // Create cacti in a ring pattern around the town
        for (let i = 0; i < cactusCount; i++) {
            // Random position avoiding town center area using a ring distribution
            let x, z, townBlend;
            const angle = Math.random() * Math.PI * 2; // Random angle around circle
            const minRadius = Math.max(this.townDimensions.width, this.townDimensions.length) + 150; // Min distance from town center
            const maxRadius = this.config.size * 0.3; // Max distance from town center
            
            // Calculate position in a ring around the town
            const radius = minRadius + Math.random() * (maxRadius - minRadius);
            x = Math.cos(angle) * radius;
            z = Math.sin(angle) * radius;
            
            // Verify this position is in the desert part of the terrain
            townBlend = this.getTownBlendFactor(x, z);
            
            // If not in desert, try again with a larger radius
            if (townBlend < 0.9) {
                const adjustedRadius = minRadius * 1.2;
                x = Math.cos(angle) * adjustedRadius;
                z = Math.sin(angle) * adjustedRadius;
                townBlend = this.getTownBlendFactor(x, z);
            }
            
            // Calculate height based on terrain
            const baseHeight = this.baseNoise.noise(x * this.config.noiseScale.base, z * this.config.noiseScale.base) 
                * this.config.heightScale.base;
            const duneHeight = this.getDirectionalDuneHeight(x, z);
            const y = baseHeight + duneHeight;
            
            // Random scale and rotation
            const cactusScale = 0.3 + Math.random() * 0.5; // Slightly smaller scale range
            const trunkRotation = Math.random() * Math.PI * 2;
            
            // Position and orient the trunk
            position.set(x, y, z);
            rotation.set(0, trunkRotation, 0);
            quaternion.setFromEuler(rotation);
            scale.set(cactusScale, cactusScale, cactusScale);
            
            matrix.compose(position, quaternion, scale);
            instancedSegments[0].setMatrixAt(i, matrix);
            
            // Add arms to the cactus with varying heights and angles
            for (let arm = 0; arm < 2; arm++) {
                // Calculate arm position on the trunk
                const armHeight = 5 + Math.random() * 8; // Lower arm position
                const armAngle = arm * Math.PI + (Math.random() * 0.5 - 0.25);
                const armLength = 4 + Math.random() * 3;
                
                // Horizontal arm segment
                const armX = x + Math.cos(trunkRotation + armAngle) * 2 * cactusScale;
                const armZ = z + Math.sin(trunkRotation + armAngle) * 2 * cactusScale;
                const armY = y + armHeight * cactusScale;
                
                position.set(armX, armY, armZ);
                rotation.set(Math.PI/2, trunkRotation + armAngle + Math.PI/2, 0);
                quaternion.setFromEuler(rotation);
                
                matrix.compose(position, quaternion, scale);
                instancedSegments[1].setMatrixAt(i * 2 + arm, matrix);
                
                // Vertical arm tip
                const tipX = armX + Math.cos(trunkRotation + armAngle) * armLength * cactusScale;
                const tipZ = armZ + Math.sin(trunkRotation + armAngle) * armLength * cactusScale;
                const tipY = armY;
                
                position.set(tipX, tipY, tipZ);
                rotation.set(0, trunkRotation, 0);
                quaternion.setFromEuler(rotation);
                
                matrix.compose(position, quaternion, scale);
                instancedSegments[2].setMatrixAt(i * 2 + arm, matrix);
            }
        }
        
        // Update matrices and add to scene
        for (const instancedMesh of instancedSegments) {
            instancedMesh.instanceMatrix.needsUpdate = true;
            this.scene.add(instancedMesh);
        }
        
        return instancedSegments;
    }
    
    // Create a cactus trunk segment
    createCactusTrunk(topRadius, bottomRadius, height, segments) {
        const geometry = new THREE.CylinderGeometry(topRadius, bottomRadius, height, segments);
        geometry.translate(0, height/2, 0);
        return geometry;
    }
    
    // Create a cactus arm segment (horizontal part)
    createCactusArm(topRadius, bottomRadius, length, segments) {
        const geometry = new THREE.CylinderGeometry(topRadius, bottomRadius, length, segments);
        geometry.rotateZ(Math.PI/2);
        geometry.translate(length/2, 0, 0);
        return geometry;
    }
    
    // Generate the entire desert environment
    generate() {
        console.log("Generating procedural desert terrain...");
        
        // Generate terrain mesh
        this.generateTerrain();
        
        // Add cacti
        this.addCacti();
        
        console.log("Desert terrain generation complete");
    }
} 

================================================
File: /public/js/effects.js
================================================
// Import the SmokeRingEffect class 
import { SmokeRingEffect } from './smokeRingEffect.js';

/**
 * Recursively disposes geometry and material for the given object.
 * @param {THREE.Object3D} object - The object to dispose.
 */
function disposeHierarchy(object) {
  object.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

/**
 * Helper for spring interpolation used in recoil recovery.
 * @param {number} start - The starting value.
 * @param {number} end - The target value.
 * @param {number} t - Normalized time.
 * @param {number} damping - Damping coefficient.
 * @param {number} frequency - Oscillation frequency.
 * @returns {number} - The interpolated value.
 */
function springInterpolation(start, end, t, damping, frequency) {
  const decay = Math.exp(-damping * t);
  return end + (start - end) * decay * (1 + (damping / frequency) * Math.sin(frequency * t));
}

/**
 * Creates a muzzle flash effect at the given position with the specified direction
 * @param {THREE.Vector3} position - Starting position of the muzzle flash
 * @param {THREE.Vector3} direction - Direction the flash should face
 * @param {THREE.Scene} scene - The scene to add the effect to
 * @param {Object} options - Optional configuration for the effect
 * @param {boolean} isPreloading - Whether this is being created for preloading
 * @returns {Object} The created flash group and meshes for preloading
 */
export function createMuzzleFlash(position, direction, scene, options = null, isPreloading = false) {
  // Skip on mobile devices
  if (window.isMobile && !isPreloading) {
    return;
  }
  
  // Create flash group
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(position);
  
  // Make the flash face the direction of fire
  flashGroup.lookAt(position.clone().add(direction));
  
  // Add to scene
  scene.add(flashGroup);
  
  // Configure flash based on options
  const flashSize = (options && options.size) || 0.2;
  const flashColor = (options && options.color) || 0xFFF7D6;
  const flashDuration = (options && options.duration) || 0.05;
  
  // Create core flash - using MeshBasicMaterial without emissive properties
  const flashGeometry = new THREE.IcosahedronGeometry(flashSize, 1);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: flashColor,
    transparent: true,
    opacity: 0.9
  });
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position the flash slightly in front
  flash.position.z = 0.1;
  
  // Add some random rotation
  flash.rotation.x = Math.random() * Math.PI;
  flash.rotation.y = Math.random() * Math.PI;
  flash.rotation.z = Math.random() * Math.PI;
  
  // Add flash to group
  flashGroup.add(flash);
  
  // Add a glow for better visibility - using MeshBasicMaterial without emissive properties
  const glowGeometry = new THREE.IcosahedronGeometry(flashSize * 1.5, 0);
  const glowMaterial = new THREE.MeshBasicMaterial({
    color: flashColor,
    transparent: true,
    opacity: 0.5
  });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  
  // Position the glow slightly in front and larger
  glow.position.z = 0.05;
  glow.scale.set(1.5, 1.5, 0.5);
  
  // Add glow to group
  flashGroup.add(glow);
  
  // Create animation tracking variables
  const startTime = performance.now();
  const endTime = startTime + flashDuration * 1000;
  
  // Store references needed for the animation
  // This closure makes everything accessible to the animateFlash function
  const animation = { startTime, endTime, flash, glow, flashGroup };
  
  // Function to animate the flash
  function animateFlash(timestamp) {
    // Calculate how far through the animation we are (0 to 1)
    const elapsed = timestamp - animation.startTime;
    const duration = animation.endTime - animation.startTime;
    const progress = Math.min(elapsed / duration, 1);
    
    // If animation complete, remove from scene
    if (progress >= 1) {
      if (!isPreloading) {
        scene.remove(animation.flashGroup);
        animation.flash.geometry.dispose();
        animation.flash.material.dispose();
        animation.glow.geometry.dispose();
        animation.glow.material.dispose();
      }
      return false;
    }
    
    // Create a decay curve - quick fade out
    // Use quadratic easing for more visual pop at the start
    const opacityFactor = 1 - (progress * progress);
    
    // Update materials
    animation.flash.material.opacity = 0.9 * opacityFactor;
    animation.glow.material.opacity = 0.5 * opacityFactor;
    
    // Scale down as it fades
    const scaleFactor = 1 - progress * 0.3;
    animation.flashGroup.scale.set(scaleFactor, scaleFactor, 1);
    
    // Continue animation
    if (!isPreloading) {
      requestAnimationFrame(animateFlash);
    }
    return true;
  }
  
  // Start animation loop if not preloading (preloading will call this manually)
  if (!isPreloading) {
    requestAnimationFrame(animateFlash);
  }
  
  // Return objects needed for preloading
  return { flashGroup, flash, glow, animateFlash };
}

/**
 * Creates a smoke effect at the given position with the specified direction
 * @param {THREE.Vector3} position - Starting position of the smoke
 * @param {THREE.Vector3} direction - Direction the smoke should face
 * @param {THREE.Scene} scene - The scene to add the effect to
 * @param {boolean} isPreloading - Whether this is being created for preloading
 * @returns {Object} The created smoke group and particles for preloading
 */
export function createSmokeEffect(position, direction, scene, isPreloading = false) {
  // Create a group for the smoke particles
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(position);
  
  // Orient the smoke in the direction of fire
  smokeGroup.lookAt(position.clone().add(direction));
  
  // Add to scene
  scene.add(smokeGroup);
  
  // Generate a random number of particles
  const numParticles = Math.floor(5 + Math.random() * 3);
  const particles = [];
  
  // Create individual smoke particles
  for (let i = 0; i < numParticles; i++) {
    // Random size for each particle
    const size = 0.01 + Math.random() * 0.02;
    
    // Create geometry
    const particleGeometry = new THREE.IcosahedronGeometry(size, 0);
    
    // Smoke material - semi-transparent gray
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xCCCCCC,
      transparent: true,
      opacity: 0.3 + Math.random() * 0.4
    });
    
    // Create mesh
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    
    // Random initial position with slight offset from center
    const offset = 0.03;
    particle.position.set(
      (Math.random() - 0.5) * offset,
      (Math.random() - 0.5) * offset,
      (Math.random() - 0.5) * offset
    );
    
    // Random rotation
    particle.rotation.set(
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2
    );
    
    // Add to group
    smokeGroup.add(particle);
    
    // Generate velocity for this particle
    // Base direction is the fire direction but with added spread
    const spread = 0.3;
    const vel = direction.clone().normalize();
    
    // Add some randomization to velocity
    vel.x += (Math.random() - 0.5) * spread;
    vel.y += (Math.random() - 0.5) * spread;
    vel.z += (Math.random() - 0.5) * spread;
    
    // Scale velocity by a random factor
    vel.multiplyScalar(0.3 + Math.random() * 0.5);
    
    // Store particle properties
    particles.push({
      mesh: particle,
      velocity: vel,
      life: 0,
      maxLife: 0.5 + Math.random() * 0.5
    });
  }
  
  // Animation variables
  const startTime = performance.now();
  const state = { particles, startTime, lastTime: startTime };
  
  // Function to animate the smoke particles
  function animateSmoke(timestamp) {
    // Calculate time delta
    const dt = (timestamp - state.lastTime) / 1000; // in seconds
    state.lastTime = timestamp;
    
    // Track if any particles are still alive
    let anyAlive = false;
    
    // Update each particle
    for (const particle of state.particles) {
      // Increase particle life
      particle.life += dt;
      
      // Check if particle is still alive
      if (particle.life < particle.maxLife) {
        anyAlive = true;
        
        // Calculate remaining life as a percentage
        const lifePercent = particle.life / particle.maxLife;
        
        // Move particle based on its velocity
        particle.mesh.position.x += particle.velocity.x * dt;
        particle.mesh.position.y += particle.velocity.y * dt;
        particle.mesh.position.z += particle.velocity.z * dt;
        
        // Slow down over time - apply drag
        particle.velocity.multiplyScalar(0.98);
        
        // Fade out as it ages
        particle.mesh.material.opacity = 0.5 * (1 - lifePercent);
        
        // Grow slightly larger
        const scale = 1 + lifePercent * 2;
        particle.mesh.scale.set(scale, scale, scale);
        
        // Rotate slowly for some movement
        particle.mesh.rotation.x += dt * 0.2;
        particle.mesh.rotation.y += dt * 0.1;
      } else {
        // Particle has expired, make it invisible
        particle.mesh.visible = false;
      }
    }
    
    // If all particles are dead and not preloading, remove the effect
    if (!anyAlive && !isPreloading) {
      // Clean up
      particles.forEach(p => {
        smokeGroup.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      });
      scene.remove(smokeGroup);
      return false;
    }
    
    // Continue animation if needed
    if (!isPreloading) {
      requestAnimationFrame(animateSmoke);
    }
    return true;
  }
  
  // Start animation loop if not preloading (preloading will call this manually)
  if (!isPreloading) {
    requestAnimationFrame(animateSmoke);
  }
  
  // Return objects needed for preloading
  return { smokeGroup, particles, animateSmoke };
}

// Create global blood effect resources for reuse across all impacts
const BLOOD_POOL = {
  geometries: [],
  materials: [],
  particles: []
};

/**
 * Creates an impact effect when a bullet hits a target.
 * Generates realistic blood particles with varied splatter patterns and curved trajectories.
 * Optimized with object pooling and selective calculations.
 *
 * @param {THREE.Vector3} position - Impact position.
 * @param {THREE.Vector3} direction - Impact (bullet) direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 * @param {string} hitType - Type of impact: 'player', 'npc', or 'ground'.
 */
export function createImpactEffect(position, direction, scene, hitType) {
  // Skip ground impact effects completely
  if (hitType === 'ground') {
    return;
  }

  const effectGroup = new THREE.Group();
  effectGroup.position.copy(position);
  scene.add(effectGroup);
  
  // Play impact sound based on hit type using positional audio
  if (window.localPlayer && window.localPlayer.soundManager) {
    if (hitType === 'player' || hitType === 'npc') {
      // Calculate distance to local player to avoid playing impact on own body
      const localPlayerPos = window.localPlayer.group.position;
      const distToLocalPlayer = Math.sqrt(
        Math.pow(position.x - localPlayerPos.x, 2) + 
        Math.pow(position.z - localPlayerPos.z, 2)
      );
      
      // Only play flesh impact if not too close to local player
      if (distToLocalPlayer > 0.5) {
        window.localPlayer.soundManager.playSoundAt("fleshimpact", position);
      }
    }
  }

  // Blood effect settings
  const particleCount = 22; // Balance between visual quality and performance
  const particles = [];
  
  // More varied blood colors for visual interest
  const bloodColors = [
    0xCC0000, // Standard red
    0xAA0000, // Darker red
    0x880000, // Very dark red
    0xFF0000, // Bright red
    0xDD0000  // Medium red
  ];
  
  // Precomputed direction vector 
  const negatedDir = direction.clone().negate();
  
  // Create initial blood burst (center of impact)
  const burstSize = 0.04;
  const burstMaterial = new THREE.MeshBasicMaterial({
    color: 0xAA0000,
    transparent: true,
    opacity: 0.9,
    depthWrite: false
  });
  
  let burstGeom;
  if (BLOOD_POOL.geometries.length > 0) {
    burstGeom = BLOOD_POOL.geometries.pop();
  } else {
    burstGeom = new THREE.SphereGeometry(burstSize, 4, 3);
  }
  
  const burst = new THREE.Mesh(burstGeom, burstMaterial);
  effectGroup.add(burst);
  
  // Create impact direction-aligned disc for initial spray pattern
  const spraySize = 0.06;
  const sprayMaterial = new THREE.MeshBasicMaterial({
    color: 0x990000,
    transparent: true,
    opacity: 0.8,
    depthWrite: false
  });
  
  const sprayGeom = new THREE.CircleGeometry(spraySize, 8);
  const spray = new THREE.Mesh(sprayGeom, sprayMaterial);
  
  // Position spray slightly in front of impact point
  spray.position.copy(negatedDir.clone().multiplyScalar(0.01));
  
  // Orient spray to face away from impact direction
  spray.lookAt(spray.position.clone().add(negatedDir));
  
  effectGroup.add(spray);
  
  // Add burst and spray to particles for animation
  particles.push({
    mesh: burst,
    type: 'burst',
    velocity: new THREE.Vector3(0, 0, 0),
    life: 8,
    gravity: new THREE.Vector3(0, 0, 0)
  });
  
  particles.push({
    mesh: spray,
    type: 'spray',
    velocity: new THREE.Vector3(0, 0, 0),
    life: 12,
    gravity: new THREE.Vector3(0, 0, 0)
  });
  
  // Create blood droplets with varied patterns
  for (let i = 0; i < particleCount; i++) {
    // Get or create particle
    let particle, isNewParticle = false;
    let particleType = '';
    
    // Determine particle type (affects behavior)
    const randValue = Math.random();
    if (randValue < 0.6) {
      particleType = 'droplet'; // Small fast droplets
    } else if (randValue < 0.9) {
      particleType = 'medium'; // Medium sized drops
    } else {
      particleType = 'chunk'; // Large slow chunks
    }
    
    // Try to get a particle from the pool
    if (BLOOD_POOL.particles.length > 0) {
      particle = BLOOD_POOL.particles.pop();
      // Reset particle properties
      particle.visible = true;
      particle.scale.set(1, 1, 1);
      
      // Update material color
      const colorIndex = Math.floor(Math.random() * bloodColors.length);
      particle.material.color.setHex(bloodColors[colorIndex]);
      particle.material.opacity = 0.9;
    } else {
      // Create new particle if none in pool
      isNewParticle = true;
      
      // Size based on particle type
      let size;
      if (particleType === 'droplet') {
        size = 0.01 + Math.random() * 0.015;
      } else if (particleType === 'medium') {
        size = 0.02 + Math.random() * 0.02;
      } else {
        size = 0.025 + Math.random() * 0.025;
      }
      
      // Create geometry - varied for different particle types
      let geometry;
      if (BLOOD_POOL.geometries.length > 0) {
        geometry = BLOOD_POOL.geometries.pop();
      } else {
        if (particleType === 'chunk') {
          // Use icosahedron for chunks (more irregular shape)
          geometry = new THREE.IcosahedronGeometry(size, 0);
        } else {
          // Use sphere for droplets (smaller faces for better performance)
          geometry = new THREE.SphereGeometry(size, 3, 2);
        }
      }
      
      // Create material with varied color
      const colorIndex = Math.floor(Math.random() * bloodColors.length);
      const material = new THREE.MeshBasicMaterial({
        color: bloodColors[colorIndex],
        transparent: true,
        opacity: 0.9,
        depthWrite: false
      });
      
      // Create the particle
      particle = new THREE.Mesh(geometry, material);
    }
    
    // Add particle to group
    effectGroup.add(particle);
    
    // Initial position offset for more natural spray formation
    // Offset more along the impact direction
    const dirComponent = 0.015 * Math.random(); 
    const radialComponent = 0.01;
    
    // Create a position that favors the impact direction
    particle.position.copy(negatedDir.clone().multiplyScalar(dirComponent));
    
    // Add randomness to position
    particle.position.x += (Math.random() - 0.5) * radialComponent;
    particle.position.y += (Math.random() - 0.5) * radialComponent;
    particle.position.z += (Math.random() - 0.5) * radialComponent;
    
    // Random rotation
    if (isNewParticle) {
      particle.rotation.set(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2
      );
    }
    
    // Create velocity vector based on particle type and impact direction
    const velocity = new THREE.Vector3();
    velocity.copy(negatedDir);
    
    // Speed varies by particle type
    let speed;
    let speedRandomness;
    
    if (particleType === 'droplet') {
      // Droplets move fastest with most randomness
      speed = 0.1;
      speedRandomness = 0.15;
    } else if (particleType === 'medium') {
      // Medium particles have moderate speed
      speed = 0.08;
      speedRandomness = 0.12;
    } else {
      // Chunks are slowest
      speed = 0.06;
      speedRandomness = 0.1;
    }
    
    // Apply speed
    const finalSpeed = speed + Math.random() * speedRandomness;
    velocity.multiplyScalar(finalSpeed);
    
    // Create spread pattern based on particle type
    const spread = particleType === 'droplet' ? 0.1 : 0.07;
    
    // Create a cone-shaped pattern mostly in the impact direction
    // but allow some particles to go more perpendicular for better spray effect
    const angleMultiplier = Math.random() < 0.3 ? 1.5 : 0.7;
    velocity.x += (Math.random() - 0.5) * spread * angleMultiplier;
    velocity.y += (Math.random() - 0.5) * spread * angleMultiplier;
    velocity.z += (Math.random() - 0.5) * spread * angleMultiplier;
    
    // Add some upward bias for more pleasing arcs
    if (Math.random() < 0.4) {
      velocity.y += 0.04 * Math.random();
    }
    
    // Different gravity strength based on particle type
    // Smaller particles affected more by air resistance
    let gravityStrength;
    if (particleType === 'droplet') {
      gravityStrength = 0.0035;
    } else if (particleType === 'medium') {
      gravityStrength = 0.0025;
    } else {
      gravityStrength = 0.002;
    }
    
    // Gravity vector always points down
    const gravity = new THREE.Vector3(0, -gravityStrength, 0);
    
    // Lifetimes vary by type
    let lifetime;
    if (particleType === 'droplet') {
      lifetime = 15 + Math.floor(Math.random() * 15);
    } else if (particleType === 'medium') {
      lifetime = 20 + Math.floor(Math.random() * 15);
    } else {
      lifetime = 25 + Math.floor(Math.random() * 15);
    }
    
    // Store particle info for animation
    particles.push({
      mesh: particle,
      velocity: velocity,
      gravity: gravity,
      life: lifetime,
      type: particleType,
      initialLife: lifetime,
      stretchAxis: new THREE.Vector3(),
      // Save initial position for trail calculation
      lastPos: particle.position.clone()
    });
  }

  // Duration in ms - allow more time for gravity arcs
  const duration = 600;
  const startTime = performance.now();
  let lastTime = startTime;

  // Function to animate the blood particles
  function animateEffect(currentTime) {
    // Time delta calculation
    const deltaTime = Math.min(currentTime - lastTime, 20) / 1000;
    lastTime = currentTime;
    
    const elapsed = currentTime - startTime;
    
    // Animation update
    let anyAlive = false;
    
    // Reduced physics frequency - helps performance 
    const dt = deltaTime * 60;
    
    // Update each particle in a single loop pass
    for (const particle of particles) {
      if (particle.life > 0) {
        anyAlive = true;
        
        // Different animation based on particle type
        if (particle.type === 'burst') {
          // Initial burst expands quickly then fades
          const lifeRatio = particle.life / 8;
          const scale = 1 + (1 - lifeRatio) * 3; 
          particle.mesh.scale.set(scale, scale, scale);
          particle.mesh.material.opacity = lifeRatio * 0.8;
        } 
        else if (particle.type === 'spray') {
          // Spray expands and fades
          const lifeRatio = particle.life / 12;
          const scale = 1 + (1 - lifeRatio) * 2;
          particle.mesh.scale.set(scale, scale, 1);
          particle.mesh.material.opacity = lifeRatio * 0.7;
        }
        else {
          // Save previous position for proper stretching
          particle.lastPos.copy(particle.mesh.position);
          
          // Apply gravity to velocity
          particle.velocity.add(particle.gravity);
          
          // Move particle based on velocity
          particle.mesh.position.x += particle.velocity.x;
          particle.mesh.position.y += particle.velocity.y;
          particle.mesh.position.z += particle.velocity.z;
          
          // Apply stretching in direction of movement
          // Only if moving fast enough
          const speedSq = particle.velocity.lengthSq();
          
          if (speedSq > 0.0005) {
            // Calculate movement vector
            particle.stretchAxis.subVectors(particle.mesh.position, particle.lastPos).normalize();
            
            // Different stretch factors based on type
            let stretchAmount;
            if (particle.type === 'droplet') {
              stretchAmount = 1 + speedSq * 35;
              // Extra stretch for small fast particles
              if (speedSq > 0.001) {
                stretchAmount *= 1.3;
              }
            } else if (particle.type === 'medium') {
              stretchAmount = 1 + speedSq * 25;
            } else {
              stretchAmount = 1 + speedSq * 15;
            }
            
            // Find dominant axis for optimized stretching
            const absX = Math.abs(particle.stretchAxis.x);
            const absY = Math.abs(particle.stretchAxis.y);
            const absZ = Math.abs(particle.stretchAxis.z);
            
            // Apply stretch primarily along dominant axis
            if (absX > absY && absX > absZ) {
              particle.mesh.scale.set(stretchAmount, 1, 1);
            } else if (absY > absX && absY > absZ) {
              particle.mesh.scale.set(1, stretchAmount, 1);
            } else {
              particle.mesh.scale.set(1, 1, stretchAmount);
            }
          }
          
          // Apply drag based on particle type
          let drag;
          if (particle.type === 'droplet') {
            drag = 0.97; // Less drag for small particles
          } else if (particle.type === 'medium') {
            drag = 0.96;
          } else {
            drag = 0.95; // More drag for larger chunks
          }
          
          particle.velocity.multiplyScalar(drag);
          
          // Fade out as particles get older
          const lifeRatio = particle.life / particle.initialLife;
          
          // Different fade behavior based on type
          if (particle.type === 'droplet' && lifeRatio < 0.5) {
            // Droplets fade faster
            particle.mesh.material.opacity = lifeRatio * 2 * 0.9;
          } else if (lifeRatio < 0.3) {
            // All particles fade in final phase
            particle.mesh.material.opacity = lifeRatio / 0.3 * 0.9;
          }
        }
        
        // Decrement life
        particle.life--;
      } else if (particle.mesh.visible) {
        // Hide expired particles
        particle.mesh.visible = false;
        
        // Return to pool for reuse
        if (particle.type !== 'burst' && particle.type !== 'spray' && 
            BLOOD_POOL.particles.length < 50) {
          BLOOD_POOL.particles.push(particle.mesh);
          effectGroup.remove(particle.mesh);
        }
      }
    }
    
    // Continue animation if any particles are alive and within duration
    if (anyAlive && elapsed < duration) {
      requestAnimationFrame(animateEffect);
    } else {
      // Clean up
      for (const particle of particles) {
        if (particle.type === 'burst' || particle.type === 'spray') {
          // Clean up spray and burst
          if (particle.mesh.geometry) {
            if (BLOOD_POOL.geometries.length < 10) {
              BLOOD_POOL.geometries.push(particle.mesh.geometry);
            } else {
              particle.mesh.geometry.dispose();
            }
          }
          if (particle.mesh.material) {
            particle.mesh.material.dispose();
          }
        } 
        else if (!BLOOD_POOL.particles.includes(particle.mesh)) {
          // Pool materials and geometries from other particles
          if (BLOOD_POOL.materials.length < 20 && particle.mesh.material) {
            BLOOD_POOL.materials.push(particle.mesh.material);
          } else if (particle.mesh.material) {
            particle.mesh.material.dispose();
          }
          
          if (BLOOD_POOL.geometries.length < 10 && particle.mesh.geometry) {
            BLOOD_POOL.geometries.push(particle.mesh.geometry);
          } else if (particle.mesh.geometry) {
            particle.mesh.geometry.dispose();
          }
        }
      }
      
      // Remove effect group
      scene.remove(effectGroup);
    }
  }
  
  // Start animation
  requestAnimationFrame(animateEffect);
}

/**
 * Apply recoil effect to the player's camera.
 * @param {Player} player - The player instance.
 * @param {number} multiplier - Recoil strength multiplier (default: 1.0).
 */
export function applyRecoil(player, multiplier = 1.0) {
  const originalAimOffset = player.aimOffset.clone();
  const originalFOV = player.camera.fov;
  const originalCameraPos = player.camera.position.clone();
  const originalRotation = player.camera.rotation.clone();

  // Initial recoil changes.
  player.camera.rotation.x -= 0.08 * multiplier;
  player.camera.rotation.z += 0.01 * multiplier;
  player.aimOffset.z += 0.4 * multiplier;
  player.aimOffset.y += 0.15 * multiplier;
  player.aimOffset.x += 0.05 * multiplier;
  player.camera.fov -= 5 * multiplier;
  player.camera.updateProjectionMatrix();

  // Apply physical recoil force for shotgun
  if (player.activeWeapon === 'shotgun') {
    // Get the direction the player is aiming in WORLD space
    const lookDir = new THREE.Vector3(0, 0, -1); // Forward in camera local space
    lookDir.applyQuaternion(player.camera.getWorldQuaternion(new THREE.Quaternion()));
    lookDir.normalize();
    
    // Calculate recoil direction - inverse of look direction
    const recoilDir = lookDir.clone().negate();
    
    // Enable recoil boost mode to prevent normal movement dampening
    player.recoilBoosted = true;
    player.recoilBoostTime = player.recoilBoostDuration;
    
    // Get player's world rotation 
    const playerRotationY = player.group.rotation.y;
    
    // Determine if looking down (for rocket jump)
    if (lookDir.y < -0.3) {
      // Player is aiming down, apply RIDICULOUS upward force
      player.velocity.y = 50.0; // Extreme upward force
      
      // Apply horizontal force aligned with player forward direction
      // This ensures the recoil pushes you in the correct direction
      player.velocity.x = Math.sin(playerRotationY) * -30.0 * recoilDir.z;
      player.velocity.z = Math.cos(playerRotationY) * -30.0 * recoilDir.z;
      
      console.log("🚀 SHOTGUN UPWARD BLAST!", player.velocity);
    } else {
      // Apply force directly opposed to look direction in world space
      // These are applied directly as world-space velocities
      player.velocity.x = recoilDir.x * 50.0;
      player.velocity.z = recoilDir.z * 50.0;
      player.velocity.y = 15.0 + Math.abs(recoilDir.y * 30.0); // Add upward boost
      
      console.log("💥 EXTREME SHOTGUN KNOCKBACK!", player.velocity, "Look dir:", lookDir);
    }
    
    // Disable gravity for a short moment to allow full force expression
    const originalGravity = player.gravity;
    player.gravity = 0;
    setTimeout(() => {
      player.gravity = originalGravity;
    }, 150); // 150ms of zero gravity for maximum effect
    
    // Force jump state regardless of ground contact
    player.canJump = false;
    player.isJumping = true;
    
    // Play an extra sound for the force feedback
    if (player.soundManager) {
      player.soundManager.playSound("recoiljump", 0); // Remove delay for immediacy
      
      // Also play an extra impact sound for drama
      player.soundManager.playSound("shotgunshot", 0, 1.5); // Higher volume
    }
  }

  const recoilSteps = [
    { time: 20, cameraX: -0.04, cameraZ: 0.005, offsetZ: 0.2, offsetY: 0.08, offsetX: 0.03 },
    { time: 40, cameraX: -0.06, cameraZ: 0.008, offsetZ: 0.3, offsetY: 0.12, offsetX: 0.04 },
    { time: 60, cameraX: -0.03, cameraZ: 0.006, offsetZ: 0.25, offsetY: 0.1, offsetX: 0.02 },
    { time: 80, cameraX: -0.02, cameraZ: 0.004, offsetZ: 0.18, offsetY: 0.07, offsetX: 0.01 },
    { time: 100, cameraX: -0.01, cameraZ: 0.002, offsetZ: 0.1, offsetY: 0.05, offsetX: 0.005 }
  ];

  recoilSteps.forEach(step => {
    setTimeout(() => {
      player.camera.rotation.x = originalRotation.x + step.cameraX * multiplier;
      player.camera.rotation.z = originalRotation.z + step.cameraZ * multiplier;
      player.aimOffset.z = originalAimOffset.z + step.offsetZ * multiplier;
      player.aimOffset.y = originalAimOffset.y + step.offsetY * multiplier;
      player.aimOffset.x = originalAimOffset.x + step.offsetX * multiplier;
    }, step.time);
  });

  let shakeIntensity = 0.03 * multiplier;
  const shakeDecay = 0.9;
  const shakeInterval = setInterval(() => {
    if (shakeIntensity > 0.002) {
      player.camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
      player.camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity *= shakeDecay;
    } else {
      clearInterval(shakeInterval);
      player.camera.position.copy(originalCameraPos);
    }
  }, 16);

  let progress = 0;
  const duration = 400;
  const startTime = performance.now();

  function recoverFromRecoil(timestamp) {
    progress = (timestamp - startTime) / duration;
    if (progress < 1) {
      const t = progress * 4;
      player.camera.rotation.x = springInterpolation(
        player.camera.rotation.x,
        originalRotation.x,
        t,
        0.4,
        8
      );
      player.camera.rotation.z = springInterpolation(
        player.camera.rotation.z,
        originalRotation.z,
        t,
        0.4,
        8
      );
      player.aimOffset.x = springInterpolation(
        player.aimOffset.x,
        originalAimOffset.x,
        t,
        0.4,
        8
      );
      player.aimOffset.y = springInterpolation(
        player.aimOffset.y,
        originalAimOffset.y,
        t,
        0.4,
        8
      );
      player.aimOffset.z = springInterpolation(
        player.aimOffset.z,
        originalAimOffset.z,
        t,
        0.4,
        8
      );
      player.camera.fov = THREE.MathUtils.lerp(
        player.camera.fov,
        originalFOV,
        progress * 0.3
      );
      player.camera.updateProjectionMatrix();
      requestAnimationFrame(recoverFromRecoil);
    } else {
      player.camera.rotation.copy(originalRotation);
      player.aimOffset.copy(originalAimOffset);
      player.camera.fov = originalFOV;
      player.camera.updateProjectionMatrix();
      player.camera.position.copy(originalCameraPos);
    }
  }
  requestAnimationFrame(recoverFromRecoil);
}

/**
 * Preloads the smoke effect by creating a disposable instance
 * This forces Three.js to compile shaders and cache necessary resources
 * @param {THREE.Scene} scene - The scene where the preloaded effect will be created
 */
export function preloadSmokeEffect(scene) {
  // Create a dummy position far below the scene where it won't be visible
  const dummyPosition = new THREE.Vector3(0, -1000, 0);
  const dummyDirection = new THREE.Vector3(0, 1, 0);
  
  // Create a fully realized smoke effect to warm up all rendering pathways
  // This will ensure the first visible effect doesn't cause frame drops
  const smokeEffect = createSmokeEffect(dummyPosition, dummyDirection, scene, true);
  
  // Force a few animation frames to ensure shaders are compiled
  const fakeTimestamps = [0, 16, 32, 48, 64, 80, 96];
  let frameIndex = 0;
  
  function simulateFrames() {
    if (frameIndex < fakeTimestamps.length) {
      // Manually advance the animation
      smokeEffect.animateSmoke(performance.now() + fakeTimestamps[frameIndex]);
      frameIndex++;
      setTimeout(simulateFrames, 0); // Use setTimeout to avoid blocking the main thread
    } else {
      // Clean up after simulation is complete
      setTimeout(() => {
        scene.remove(smokeEffect.smokeGroup);
        smokeEffect.particles.forEach(p => {
          p.mesh.geometry.dispose();
          p.mesh.material.dispose();
        });
      }, 100);
    }
  }
  
  // Start simulating frames immediately
  simulateFrames();
}

/**
 * Preloads the muzzle flash effect by creating a full instance and running its animation
 * @param {THREE.Scene} scene - The scene to add the preloaded effect
 */
export function preloadMuzzleFlash(scene) {
  // Create a dummy position far below the scene
  const dummyPosition = new THREE.Vector3(0, -1000, 0);
  const dummyDirection = new THREE.Vector3(0, 1, 0);
  
  // Create a full muzzle flash effect - and capture the returned animation function
  const flashEffect = createMuzzleFlash(dummyPosition, dummyDirection, scene, null, true);
  
  // Force a few animation frames to ensure shaders are compiled
  const fakeTimestamps = [0, 16, 32, 48, 64];
  let frameIndex = 0;
  
  function simulateFrames() {
    if (frameIndex < fakeTimestamps.length) {
      // Manually advance the animation using the function from the returned effect
      flashEffect.animateFlash(performance.now() + fakeTimestamps[frameIndex]);
      frameIndex++;
      setTimeout(simulateFrames, 0); // Use setTimeout to avoid blocking the main thread
    } else {
      // Clean up after simulation is complete
      setTimeout(() => {
        scene.remove(flashEffect.flashGroup);
        if (flashEffect.flash) {
          flashEffect.flash.geometry.dispose();
          flashEffect.flash.material.dispose();
        }
        if (flashEffect.glow) {
          flashEffect.glow.geometry.dispose();
          flashEffect.glow.material.dispose();
        }
      }, 100);
    }
  }
  
  // Start simulating frames immediately
  simulateFrames();
}

// Export the SmokeRingEffect class
export { SmokeRingEffect };

/**
 * DrunkennessEffect - Creates a drunkenness camera effect
 * with various visual and motion effects that intensify and fade over time
 */
export class DrunkennessEffect {
  constructor(player, camera) {
    this.player = player;
    this.camera = camera;
    this.active = false;
    this.startTime = 0;
    // Adjust timing as requested - total 30s
    this.duration = 30000; // 30 seconds total
    this.intensifyDuration = 5000; // 5 seconds to intensify
    this.fullIntensityDuration = 20000; // 20 seconds at full intensity
    this.fadeoutDuration = 5000; // 5 seconds to fade out
    this.lastUpdate = 0;
    
    // Original camera values to restore
    this.originalFOV = 0;
    this.originalPosition = new THREE.Vector3();
    this.originalRotation = new THREE.Euler();
    
    // Effect parameters - smoother intensity
    this.maxIntensity = 1.2; // More moderate intensity
    this.currentIntensity = 0;
    
    // Camera wobble parameters - slower frequency for more sway
    this.wobblePhase = 0;
    this.wobbleFrequency = 1.2; // Reduced from 2.5 to 1.2 for slower sway
    this.maxPositionWobble = 0.25; // Increased from 0.13 for more intense swaying
    this.maxRotationWobble = 0.12; // Increased from 0.06 for more intense swaying
    
    // Camera smoothing parameters
    this.targetCameraPosition = new THREE.Vector3();
    this.targetCameraRotation = new THREE.Euler();
    this.cameraLerpFactor = 0.1; // Adjust for smoother/faster transitions
    this.lastPlayerInput = new THREE.Euler();
    
    // Movement jitter parameters
    this.jitterAmount = 0;
    this.jitterDecay = 0.9;
    this.directionShiftAmount = 0;
    this.directionShiftPhase = 0;
    
    // Visual effects
    this.effectsContainer = null;
    this.doubleVisionEnabled = false;
    this.doubleVisionCanvas = null;
    this.doubleVisionCtx = null;
    this.doubleVisionOffset = 0;
    
    // Create visual effects container
    this.createVisualEffects();
    
    // Set to window for access from other modules
    window.drunkennessEffect = this;
  }
  
  /**
   * Creates the DOM elements for visual effects
   */
  createVisualEffects() {
    // Create container for visual effects - minimal approach
    this.effectsContainer = document.createElement('div');
    this.effectsContainer.id = 'drunkenness-effects';
    this.effectsContainer.style.position = 'absolute';
    this.effectsContainer.style.top = '0';
    this.effectsContainer.style.left = '0';
    this.effectsContainer.style.width = '100%';
    this.effectsContainer.style.height = '100%';
    this.effectsContainer.style.pointerEvents = 'none';
    this.effectsContainer.style.zIndex = '10';
    this.effectsContainer.style.display = 'none';
    this.effectsContainer.style.background = 'transparent';
    
    // Create filter layer with NO filters
    this.filterLayer = document.createElement('div');
    this.filterLayer.id = 'drunkenness-filter';
    this.filterLayer.style.position = 'absolute';
    this.filterLayer.style.top = '0';
    this.filterLayer.style.left = '0';
    this.filterLayer.style.width = '100%';
    this.filterLayer.style.height = '100%';
    this.filterLayer.style.backgroundColor = 'rgba(0,0,0,0)';
    this.filterLayer.style.backdropFilter = 'none';
    this.filterLayer.style.pointerEvents = 'none';
    this.filterLayer.style.mixBlendMode = 'normal';
    
    // Add filter layer to container
    this.effectsContainer.appendChild(this.filterLayer);
    
    // Add container to document
    document.body.appendChild(this.effectsContainer);
    
    // Double vision canvas will be created on demand
    this.doubleVisionEnabled = false;
    this.doubleVisionCanvas = null;
    this.doubleVisionCtx = null;
  }
  
  /**
   * Activates the drunkenness effect
   */
  activate() {
    if (this.active) return; // Already active
    
    console.log('Activating drunkenness effect');
    
    // Store original camera values
    this.originalFOV = this.camera.fov;
    this.originalPosition.copy(this.camera.position);
    this.originalRotation.copy(this.camera.rotation);
    
    // Reset effect parameters
    this.currentIntensity = 0;
    this.wobblePhase = 0;
    this.jitterAmount = 0;
    this.directionShiftPhase = 0;
    
    // Start the effect
    this.active = true;
    this.startTime = performance.now();
    this.lastUpdate = this.startTime;
    
    // Show visual effects container
    this.effectsContainer.style.display = 'block';
    
    // Start update loop
    this.update();
  }
  
  /**
   * Deactivates the drunkenness effect and cleans up all elements
   */
  deactivate() {
    if (!this.active) return;
    
    console.log('Deactivating drunkenness effect');
    
    // Restore original camera values
    this.camera.fov = this.originalFOV;
    this.camera.updateProjectionMatrix();
    this.camera.position.copy(this.originalPosition);
    this.camera.rotation.copy(this.originalRotation);
    
    // Hide effects container
    this.effectsContainer.style.display = 'none';
    
    // THOROUGH CLEANUP OF ALL ELEMENTS:
    
    // 1. Remove all style elements
    const styleElements = [
      document.getElementById('drunk-chromatic-aberration'),
      document.getElementById('drunk-brightness-fix')
    ];
    
    styleElements.forEach(element => {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // 2. Remove all overlay elements
    const overlayElements = [
      document.querySelector('.drunk-red-overlay'),
      document.querySelector('.drunk-cyan-overlay')
    ];
    
    overlayElements.forEach(element => {
      if (element && element.parentNode) {
        element.parentNode.removeChild(element);
      }
    });
    
    // 3. Remove double vision canvas
    if (this.doubleVisionCanvas && this.doubleVisionCanvas.parentNode) {
      this.doubleVisionCanvas.parentNode.removeChild(this.doubleVisionCanvas);
      this.doubleVisionCanvas = null;
      this.doubleVisionCtx = null;
    }
    this.doubleVisionEnabled = false;
    
    // End the effect
    this.active = false;
  }
  
  /**
   * Updates the drunkenness effect
   */
  update() {
    if (!this.active) return;
    
    const now = performance.now();
    const deltaTime = (now - this.lastUpdate) / 1000; // in seconds
    this.lastUpdate = now;
    
    // Calculate elapsed time and overall progress
    const elapsed = now - this.startTime;
    
    // Check if effect should end
    if (elapsed >= this.duration) {
      this.deactivate();
      return;
    }
    
    // Calculate intensity based on phase of effect
    if (elapsed < this.intensifyDuration) {
      // Intensifying phase - increase intensity
      this.currentIntensity = (elapsed / this.intensifyDuration) * this.maxIntensity;
    } else if (elapsed < this.intensifyDuration + this.fullIntensityDuration) {
      // Full intensity phase - maintain max intensity
      this.currentIntensity = this.maxIntensity;
    } else {
      // Fadeout phase - decrease intensity
      const fadeOutElapsed = elapsed - (this.intensifyDuration + this.fullIntensityDuration);
      this.currentIntensity = this.maxIntensity * (1 - (fadeOutElapsed / this.fadeoutDuration));
    }
    
    // Capture player's input before applying drunk effects
    this.capturePlayerInput();
    
    // Calculate wobble effect target values
    this.calculateWobbleTargets(deltaTime);
    
    // Smoothly blend camera movement
    this.smoothCameraBlend(deltaTime);
    
    // Apply movement jitter effect
    this.applyMovementJitter(deltaTime);
    
    // Update visual effects
    this.updateVisualEffects();
    
    // Continue update loop
    requestAnimationFrame(() => this.update());
  }
  
  /**
   * Captures the player's current input to blend with drunk wobble
   */
  capturePlayerInput() {
    // Store player's intended camera rotation
    this.lastPlayerInput.copy(this.camera.rotation);
  }
  
  /**
   * Calculates the wobble effect target values
   * @param {number} deltaTime - Time since last update in seconds
   */
  calculateWobbleTargets(deltaTime) {
    // Update wobble phase - slower progression
    this.wobblePhase += deltaTime * this.wobbleFrequency;
    
    // Calculate wobble offsets using smoother sine waves
    const posXOffset = Math.sin(this.wobblePhase * 0.8) 
      * this.maxPositionWobble * this.currentIntensity;
    
    const posYOffset = Math.sin(this.wobblePhase * 0.9) 
      * this.maxPositionWobble * this.currentIntensity;
    
    const posZOffset = Math.sin(this.wobblePhase * 0.7) 
      * this.maxPositionWobble * this.currentIntensity;
    
    // Set target position with wobble applied
    this.targetCameraPosition.set(
      this.originalPosition.x + posXOffset,
      this.originalPosition.y + posYOffset,
      this.originalPosition.z + posZOffset
    );
    
    // Calculate rotation wobble
    const rotYOffset = Math.sin(this.wobblePhase * 0.7)
      * this.maxRotationWobble * this.currentIntensity;
    
    const rotZOffset = Math.sin(this.wobblePhase * 0.8)
      * this.maxRotationWobble * 1.5 * this.currentIntensity;
    
    // Set target rotation with wobble applied, respecting player X rotation
    this.targetCameraRotation.set(
      this.lastPlayerInput.x, // Keep player's up/down look intact
      this.originalRotation.y + rotYOffset,
      this.originalRotation.z + rotZOffset
    );
    
    // Calculate FOV effect
    const fovOffset = Math.sin(this.wobblePhase * 0.4) * 5 * this.currentIntensity;
    this.camera.fov = this.originalFOV + fovOffset;
    this.camera.updateProjectionMatrix();
  }
  
  /**
   * Smoothly blends camera between player input and drunk wobble
   * @param {number} deltaTime - Time since last update in seconds
   */
  smoothCameraBlend(deltaTime) {
    // Adjust lerp factor based on intensity and deltaTime
    const lerpStrength = this.cameraLerpFactor * (1 + this.currentIntensity * 2);
    const lerpFactor = Math.min(1.0, lerpStrength * deltaTime * 60); // Normalize for 60fps
    
    // Smoothly interpolate position
    this.camera.position.lerp(this.targetCameraPosition, lerpFactor);
    
    // Smoothly interpolate Y and Z rotation while preserving player X rotation
    // We only lerp Y and Z because X is controlled directly by player look
    this.camera.rotation.y = THREE.MathUtils.lerp(
      this.camera.rotation.y,
      this.targetCameraRotation.y,
      lerpFactor
    );
    
    this.camera.rotation.z = THREE.MathUtils.lerp(
      this.camera.rotation.z,
      this.targetCameraRotation.z,
      lerpFactor
    );
  }
  
  /**
   * Applies movement jitter to player controls
   * @param {number} deltaTime - Time since last update in seconds
   */
  applyMovementJitter(deltaTime) {
    if (!this.player) return;
    
    // Update direction shift phase - slower
    this.directionShiftPhase += deltaTime * 0.6; // Reduced from 0.9
    
    // Calculate direction shift with smoother curve
    this.directionShiftAmount = Math.sin(this.directionShiftPhase) 
      * 0.6 * this.currentIntensity; // Reduced from 0.8
    
    // Apply random jitter to movement
    if (this.player.isMoving && typeof this.player.isMoving === 'function' && this.player.isMoving()) {
      // Apply random movement jitter - reduced intensity
      const jitterX = (Math.random() - 0.5) * 0.25 * this.currentIntensity; // Reduced from 0.35
      const jitterZ = (Math.random() - 0.5) * 0.25 * this.currentIntensity; // Reduced from 0.35
      
      // Apply jitter to velocity
      if (this.player.velocity) {
        if (this.player.moveForward || this.player.moveBackward) {
          this.player.velocity.x += jitterX;
        }
        if (this.player.moveLeft || this.player.moveRight) {
          this.player.velocity.z += jitterZ;
        }
      }
      
      // Apply direction shift (makes the player veer slightly left/right when moving)
      if (this.player.moveForward || this.player.moveBackward || 
          this.player.moveLeft || this.player.moveRight) {
        this.player.group.rotation.y += this.directionShiftAmount * deltaTime;
      }
      
      // Occasionally apply a rotation push - reduced frequency
      if (Math.random() < 0.02 * this.currentIntensity) { // Reduced from 0.03
        this.player.group.rotation.y += (Math.random() - 0.5) * 0.1 * this.currentIntensity; // Reduced from 0.15
      }
    }
  }
  
  /**
   * Updates visual effects based on current intensity
   */
  updateVisualEffects() {
    // EMERGENCY FIX: Remove all filters/effects that could cause darkening
    
    // Remove any existing overlay elements that might be causing darkening
    const overlaysToRemove = [
      document.querySelector('.drunk-red-overlay'), 
      document.querySelector('.drunk-cyan-overlay'),
      document.querySelector('.drunk-chromatic-red'),
      document.querySelector('.drunk-chromatic-blue')
    ];
    
    overlaysToRemove.forEach(overlay => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
      }
    });
    
    // Remove any existing style elements that might be adding filters
    const stylesToRemove = [
      document.getElementById('drunk-chromatic-aberration'),
      document.getElementById('drunk-brightness-fix')
    ];
    
    stylesToRemove.forEach(style => {
      if (style && style.parentNode) {
        style.parentNode.removeChild(style);
      }
    });
    
    // Set filter layer to completely transparent
    this.filterLayer.style.backgroundColor = 'rgba(0,0,0,0)';
    this.filterLayer.style.backdropFilter = 'none';
    
    // Add chromatic aberration effect as actual DOM elements
    if (this.currentIntensity > 0.1) {
      const gameCanvas = document.querySelector('canvas');
      if (gameCanvas) {
        const aberrationAmount = this.currentIntensity * 10; // Increased intensity
        const redOffset = Math.sin(this.wobblePhase * 0.7) * aberrationAmount;
        const blueOffset = Math.sin(this.wobblePhase * 0.9) * -aberrationAmount; // Opposite direction
        
        // Create red channel overlay
        const redOverlay = document.createElement('div');
        redOverlay.className = 'drunk-chromatic-red';
        redOverlay.style.position = 'absolute';
        redOverlay.style.top = '0';
        redOverlay.style.left = '0';
        redOverlay.style.width = '100%';
        redOverlay.style.height = '100%';
        redOverlay.style.pointerEvents = 'none';
        redOverlay.style.zIndex = '90';
        redOverlay.style.opacity = '0.5';
        redOverlay.style.mixBlendMode = 'screen';
        redOverlay.style.backgroundColor = 'transparent';
        
        // Clone the game canvas into this div
        const redClone = gameCanvas.cloneNode(true);
        redClone.style.position = 'absolute';
        redClone.style.filter = 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><filter id="red"><feColorMatrix type="matrix" values="1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0"/></filter></svg>#red\')';
        redClone.style.transform = `translate(${redOffset}px, 0)`;
        redClone.style.opacity = '0.8';
        redOverlay.appendChild(redClone);
        
        // Create blue channel overlay
        const blueOverlay = document.createElement('div');
        blueOverlay.className = 'drunk-chromatic-blue';
        blueOverlay.style.position = 'absolute';
        blueOverlay.style.top = '0';
        blueOverlay.style.left = '0';
        blueOverlay.style.width = '100%';
        blueOverlay.style.height = '100%';
        blueOverlay.style.pointerEvents = 'none';
        blueOverlay.style.zIndex = '91';
        blueOverlay.style.opacity = '0.5';
        blueOverlay.style.mixBlendMode = 'screen';
        blueOverlay.style.backgroundColor = 'transparent';
        
        // Clone the game canvas into this div
        const blueClone = gameCanvas.cloneNode(true);
        blueClone.style.position = 'absolute';
        blueClone.style.filter = 'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><filter id="blue"><feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0"/></filter></svg>#blue\')';
        blueClone.style.transform = `translate(${blueOffset}px, 0)`;
        blueClone.style.opacity = '0.8';
        blueOverlay.appendChild(blueClone);
        
        // Add the overlays to document
        document.body.appendChild(redOverlay);
        document.body.appendChild(blueOverlay);
      }
    }
    
    // Simplified double vision effect without CSS filters
    // Only show double vision above certain intensity
    if (this.currentIntensity > 0.1) {
      // Calculate double vision offset based on intensity
      const baseOffset = this.currentIntensity * 25; // Increased from 15 for more intense effect
      const wobbleOffset = Math.sin(this.wobblePhase) * 10 * this.currentIntensity; // Increased from 5 for more intense effect
      this.doubleVisionOffset = baseOffset + wobbleOffset;
      
      // Get game canvas for double vision effect
      const gameCanvas = document.querySelector('canvas');
      if (gameCanvas && !this.doubleVisionEnabled) {
        // Create a very simple double vision using plain canvas
        // (without any filter that could cause darkening)
        this.doubleVisionCanvas = document.createElement('canvas');
        this.doubleVisionCanvas.width = window.innerWidth;
        this.doubleVisionCanvas.height = window.innerHeight;
        this.doubleVisionCanvas.style.position = 'absolute';
        this.doubleVisionCanvas.style.top = '0';
        this.doubleVisionCanvas.style.left = '0';
        this.doubleVisionCanvas.style.width = '100%';
        this.doubleVisionCanvas.style.height = '100%';
        this.doubleVisionCanvas.style.pointerEvents = 'none';
        this.doubleVisionCanvas.style.opacity = '0.2';
        this.doubleVisionCanvas.style.zIndex = '100';
        this.doubleVisionCanvas.style.mixBlendMode = 'lighten';
        
        // Only add the canvas once
        document.body.appendChild(this.doubleVisionCanvas);
        this.doubleVisionCtx = this.doubleVisionCanvas.getContext('2d');
        this.doubleVisionEnabled = true;
      }
      
      // Draw the double vision effect if canvas is ready
      if (this.doubleVisionEnabled && this.doubleVisionCtx && gameCanvas) {
        // Clear previous content
        this.doubleVisionCtx.clearRect(0, 0, this.doubleVisionCanvas.width, this.doubleVisionCanvas.height);
        
        // Use simple drawImage for offset vision, with no compositing
        this.doubleVisionCtx.drawImage(
          gameCanvas, 
          this.doubleVisionOffset, 
          -this.doubleVisionOffset / 2
        );
        
        // Force canvas to be fully visible
        this.doubleVisionCanvas.style.display = 'block';
      }
    } else if (this.doubleVisionEnabled) {
      // Hide double vision canvas when intensity is too low
      if (this.doubleVisionCanvas) {
        this.doubleVisionCanvas.style.display = 'none';
      }
      this.doubleVisionEnabled = false;
    }
    
    // Add a single style element that ONLY forces brightness to 100%
    const brightnessStyle = document.createElement('style');
    brightnessStyle.id = 'drunk-brightness-fix';
    brightnessStyle.textContent = `
      * { filter: brightness(100%) !important; }
      body { filter: brightness(100%) !important; }
      canvas { filter: brightness(100%) !important; }
      div { filter: brightness(100%) !important; }
      #game-container { filter: brightness(100%) !important; }
      #game-container * { filter: brightness(100%) !important; }
    `;
    document.head.appendChild(brightnessStyle);
  }
}

================================================
File: /public/js/flyingEagle.js
================================================
/**
 * FlyingEagle class - Loads and manages the eagle model that follows a circular path
 * with camera attached for POV view
 */
export class FlyingEagle {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene - The scene to add the eagle to
   * @param {THREE.Camera} config.camera - The camera to attach to the eagle
   */
  constructor({ scene, camera }) {
    this.scene = scene;
    this.camera = camera;
    this.model = null;
    this.animationMixer = null;
    this.animations = {};

    // Create a group to hold the eagle
    this.group = new THREE.Group();
    
    // Add to scene
    scene.add(this.group);
    
    // Create a camera target point slightly ahead of the eagle
    this.lookAhead = new THREE.Object3D();
    this.group.add(this.lookAhead);
    this.lookAhead.position.set(0, 0, -10); // 10 units ahead of eagle
    
    // Reusable objects for calculations to avoid creating new objects each frame
    this._tmpVec3 = new THREE.Vector3();
    this._lookAtPoint = new THREE.Vector3();
    this._forwardDir = new THREE.Vector3();
    
    // Load the eagle model
    this.loadEagleModel();
    
    // Flight path parameters
    this.center = new THREE.Vector3(0, 0, 0); // Will be set to duel center
    this.radius = 20; // Radius of circular flight path
    this.height = 10; // Height above the ground
    this.currentAngle = 0; // Current angle in the circle
    this.flightSpeed = 0.3; // Speed of circular flight
    
    // Flag for tracking if the model is loaded
    this.isLoaded = false;
    
    // Flag to indicate if we're in aerial camera mode
    this.aerialCameraActive = false;

    // Set a default town center position
    this.townCenter = new THREE.Vector3(0, 0, 0);
    
    // Initialize the eagle with a default flight path
    this.setDefaultFlightPath();
    
    // Flag to indicate if we're in a quickdraw match
    this.inQuickdraw = false;

    // Hitbox and state
    this.hitbox = new THREE.Sphere(this.group.position.clone(), 2.0); // Generous hitbox radius
    this.isHit = false;
    this.hitTime = 0;
    this.fallSpeed = 0;
    this.rotationSpeed = 0;
    this.groundTime = 0;
    this.sinkTime = 0;
    this.isSinking = false;
    this.originalHeight = 0;
    this.originalRotation = new THREE.Euler();
    
    // Add random rotation parameters
    this.tumbleSpeeds = {
      x: 0,
      y: 0,
      z: 0
    };
    this.tumbleAcceleration = {
      x: 0,
      y: 0,
      z: 0
    };
    this.lastTumbleUpdate = 0;
  }

  /**
   * Sets a default circular flight path above the town center
   */
  setDefaultFlightPath() {
    // Default town center coordinates - should be updated once we have actual town data
    this.townCenter = new THREE.Vector3(0, 0, 0);
    const defaultHeight = 25; // Higher altitude when patrolling
    const defaultRadius = 40; // Wider circle when patrolling
    
    this.setCircularFlightPath(this.townCenter, defaultHeight, defaultRadius);
    console.log('Eagle default flight path set');
  }

  /**
   * Loads the eagle model and animations
   */
  loadEagleModel() {
    const loader = new THREE.GLTFLoader();
    
    loader.load('models/eagle.glb', 
      // Success callback
      (gltf) => {
        this.model = gltf.scene;
        
        // Position at origin
        this.model.position.set(0, 0, 0);
        
        // Add the model to the group
        this.group.add(this.model);
        
        // Setup shadows and materials
        this.model.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            
            // Ensure materials are set up correctly
            if (child.material) {
              if (child.isSkinnedMesh) {
                child.material.skinning = true;
              }
              child.material.needsUpdate = true;
            }
          }
        });
        
        // Set up animations if they exist
        if (gltf.animations && gltf.animations.length > 0) {
          this.setupAnimations(gltf.animations);
        }
        
        // Create camera mount point at the eagle's head
        this.createCameraMount();
        
        console.log('Eagle model loaded successfully');
        this.isLoaded = true;
      }, 
      // Progress callback - silent
      undefined,
      // Error callback
      (error) => {
        console.error('Error loading eagle.glb model:', error);
      }
    );
  }

  /**
   * Creates a mount point for the camera at the eagle's head
   */
  createCameraMount() {
    // Create a mount point that's attached to the group, not the model
    // This prevents it from inheriting the up/down motion of wing flapping
    this.cameraMount = new THREE.Object3D();
    this.group.add(this.cameraMount);
    
    // Position the camera mount at an offset angle from the eagle
    // This gives a view from outside showing the bird at an angle
    this.cameraMount.position.set(3, 2, -2); // Right, up, and slightly behind
    
    // Rotate to face the eagle at an angle
    this.cameraMount.lookAt(0, 0, 0); // Look at the center of the group
  }

  /**
   * Sets up animations from the loaded model
   * @param {Array} animations - The animations from the GLB file
   */
  setupAnimations(animations) {
    if (!animations || animations.length === 0) {
      console.warn('No animations found in eagle model');
      return;
    }
    
    // Create animation mixer
    this.animationMixer = new THREE.AnimationMixer(this.model);
    
    // Store animations and start playing flycycle
    animations.forEach(animation => {
      this.animations[animation.name] = this.animationMixer.clipAction(animation);
      
      // If this is the flycycle animation, play it on loop
      if (animation.name === 'flycycle') {
        console.log('Found flycycle animation, playing on loop');
        this.animations[animation.name].setLoop(THREE.LoopRepeat);
        this.animations[animation.name].play();
      }
    });
    
    if (!this.animations['flycycle']) {
      console.warn('Flycycle animation not found in eagle model');
    }
  }

  /**
   * Sets target position for circular flight
   * @param {THREE.Vector3} centerPos - Center position to circle around
   * @param {number} height - Height above the ground
   * @param {number} radius - Radius of the circle
   */
  setCircularFlightPath(centerPos, height = 10, radius = 20) {
    this.center = centerPos.clone();
    this.height = height;
    this.radius = radius;
    
    // Position immediately on the circle
    this.updateCircularPosition();
    
    console.log(`Eagle circular flight path set around ${centerPos.x.toFixed(1)}, ${centerPos.y.toFixed(1)}, ${centerPos.z.toFixed(1)}`);
  }

  /**
   * Switch to quickdraw mode with closer flight path to players
   * @param {THREE.Vector3} duelCenter - Center position between the two players
   * @param {number} distanceBetweenPlayers - Distance between the two dueling players
   */
  setQuickdrawFlightPath(duelCenter, distanceBetweenPlayers) {
    this.inQuickdraw = true;
    
    // Save the duel center
    this.duelCenter = duelCenter.clone();
    
    // Calculate flight radius based on player distance
    // Adjusted for more balanced view with reduced player distance
    const flightRadius = Math.max(25, distanceBetweenPlayers * 1.2); // Reduced from 40 to 25 minimum and multiplier from 2.5 to 1.2
    const flightHeight = 18; // Reduced from 25 to 18
    
    // Set a slower flight speed for QuickDraw aerial view
    this.flightSpeed = 0.15; // Reduced from 0.3 to 0.15 for slower circling
    
    // Set the circular path around the duel
    this.setCircularFlightPath(duelCenter, flightHeight, flightRadius);
    
    console.log(`Eagle quickdraw flight path set - radius: ${flightRadius.toFixed(1)}, height: ${flightHeight.toFixed(1)}, speed: ${this.flightSpeed}`);
  }
  
  /**
   * Return to default flight path (after quickdraw)
   */
  returnToDefaultPath() {
    this.inQuickdraw = false;
    
    // Reset to default flight speed
    this.flightSpeed = 0.3;
    
    // Reset to default flight path
    this.setDefaultFlightPath();
    
    console.log('Eagle returned to default flight path');
  }

  /**
   * Updates the eagle's position on its circular path
   */
  updateCircularPosition() {
    // Calculate new position on the circle
    const x = this.center.x + Math.cos(this.currentAngle) * this.radius;
    const z = this.center.z + Math.sin(this.currentAngle) * this.radius;
    
    // Set eagle position
    this.group.position.set(x, this.center.y + this.height, z);
    
    // Calculate forward direction (tangent to circle)
    this._forwardDir.set(
      -Math.sin(this.currentAngle),
      0,
      Math.cos(this.currentAngle)
    ).normalize();
    
    // Make the eagle always face tangent to the circle (direction of movement)
    this._lookAtPoint.set(
      x + this._forwardDir.x * 10,
      this.center.y + this.height,
      z + this._forwardDir.z * 10
    );
    
    this.group.lookAt(this._lookAtPoint);
    
    // Apply a slight bank toward the center of the circle
    const bankAngle = 0.2; // Radians - a slight bank
    this.group.rotateZ(bankAngle);
    
    // Update the camera orientation to always look at the duel center
    if (this.cameraMount && this.inQuickdraw && this.duelCenter) {
      // Make the camera always point at the duel center
      this.cameraMount.lookAt(this.duelCenter);
    }
  }

  /**
   * Activates aerial camera mode, attaching camera to the eagle
   */
  activateAerialCamera() {
    if (!this.isLoaded) return;
    
    // Enable letterbox effect for cinematic view, but only on desktop
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    if (!isMobile) {
      document.body.classList.add('letterbox-active');
    }
    
    // Ensure the camera is properly parented to the mount
    if (this.camera.parent) {
      this.camera.parent.remove(this.camera);
    }
    
    // Add camera to the mount point
    if (this.cameraMount) {
      this.cameraMount.add(this.camera);
      // Reset camera position relative to mount
      this.camera.position.set(0, 0, 0);
      this.camera.rotation.set(0, 0, 0);
      
      // Ensure camera looks at the eagle
      this.camera.lookAt(0, 0, 0);
    } else {
      console.error('Camera mount not available');
    }
    
    this.aerialCameraActive = true;
    console.log('Eagle angled camera activated with letterbox effect');
  }

  /**
   * Deactivates aerial camera mode, detaching camera from eagle
   */
  deactivateAerialCamera() {
    // Remove letterbox effect
    document.body.classList.remove('letterbox-active');
    
    if (this.camera.parent === this.cameraMount || 
        this.camera.parent === this.model) {
      this.camera.parent.remove(this.camera);
    }
    
    this.aerialCameraActive = false;
    console.log('Eagle POV camera deactivated');
  }

  /**
   * Handles collision with a bullet
   * @returns {boolean} True if hit was successful
   */
  hit() {
    if (!this.isLoaded || this.isHit) return false;
    
    this.isHit = true;
    this.hitTime = performance.now() / 1000.0;
    this.fallSpeed = 0;
    
    // Use a single random call and derive values (more efficient)
    const randomValues = [
      Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5,
      Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5
    ];
    
    // Initialize random tumble speeds with higher values for more dramatic effect
    this.tumbleSpeeds = {
      x: randomValues[0] * 8, 
      y: randomValues[1] * 8,
      z: randomValues[2] * 8
    };
    
    // Initialize random tumble accelerations with higher values
    this.tumbleAcceleration = {
      x: randomValues[3] * 4,
      y: randomValues[4] * 4,
      z: randomValues[5] * 4
    };
    
    this.lastTumbleUpdate = this.hitTime;
    this.originalHeight = this.group.position.y;
    this.originalRotation.copy(this.group.rotation);
    
    // Stop the fly animation if it exists
    if (this.animations['flycycle']) {
      this.animations['flycycle'].stop();
    }
    
    // Play eagle hit sound
    if (window.soundManager) {
      // Play eagle death sound only
      window.soundManager.playSound('eagledeath', 0, 1.0);
    } else if (window.localPlayer && window.localPlayer.soundManager) {
      // Play eagle death sound only
      window.localPlayer.soundManager.playSound(
        'eagledeath',
        0,
        0.8 + Math.random() * 0.4,
        false
      );
    }
    
    return true;
  }

  /**
   * Updates the eagle's position and animations
   * @param {number} deltaTime - Time elapsed since last frame in seconds
   */
  update(deltaTime) {
    if (!this.isLoaded) return;
    
    // Update hitbox position
    this.hitbox.center.copy(this.group.position);
    
    // Handle normal eagle logic when not hit
    if (!this.isHit) {
      // Always update position - eagle always flies regardless of camera state
      this.currentAngle += this.flightSpeed * deltaTime;
      
      // Update position on the circle
      this.updateCircularPosition();
      
      // Update animations with adjusted speed for quickdraw mode
      if (this.animationMixer) {
        // Use half animation speed when in quickdraw mode to match the flight speed
        const animationTimeScale = this.inQuickdraw ? 0.5 : 1.0;
        
        // Set the time scale for each animation
        if (this.animations['flycycle']) {
          this.animations['flycycle'].setEffectiveTimeScale(animationTimeScale);
        }
        
        this.animationMixer.update(deltaTime);
      }
    } else {
      // Handle falling animation
      const currentTime = performance.now() / 1000.0;
      const timeSinceHit = currentTime - this.hitTime;
      
      if (!this.isSinking) {
        // Apply gravity and rotation during fall
        this.fallSpeed += 9.8 * deltaTime; // Gravity
        this.group.position.y -= this.fallSpeed * deltaTime;
        
        // Update tumble speeds less frequently to improve performance
        if (currentTime - this.lastTumbleUpdate > 0.1) {
          // Pre-calculate random values in a batch (more efficient)
          const randomX = (Math.random() - 0.5) * 4;
          const randomY = (Math.random() - 0.5) * 4;
          const randomZ = (Math.random() - 0.5) * 4;
          
          this.tumbleAcceleration.x = randomX;
          this.tumbleAcceleration.y = randomY;
          this.tumbleAcceleration.z = randomZ;
          
          this.lastTumbleUpdate = currentTime;
        }
        
        // Calculate rotation factors once to avoid redundant calculations
        const rotationFactor = deltaTime * 2;
        const dampingFactor = 0.99;
        
        // Apply tumble accelerations with higher impact
        this.tumbleSpeeds.x = (this.tumbleSpeeds.x + this.tumbleAcceleration.x * deltaTime * 2) * dampingFactor;
        this.tumbleSpeeds.y = (this.tumbleSpeeds.y + this.tumbleAcceleration.y * deltaTime * 2) * dampingFactor;
        this.tumbleSpeeds.z = (this.tumbleSpeeds.z + this.tumbleAcceleration.z * deltaTime * 2) * dampingFactor;
        
        // Apply rotations with higher magnitude
        this.group.rotation.x += this.tumbleSpeeds.x * rotationFactor;
        this.group.rotation.y += this.tumbleSpeeds.y * rotationFactor;
        this.group.rotation.z += this.tumbleSpeeds.z * rotationFactor;
        
        // Add more pronounced forward tilt based on fall speed
        const forwardTilt = Math.min(this.fallSpeed * 0.1, 1.0);
        this.group.rotation.x += forwardTilt * deltaTime;
        
        // Add some side-to-side sway based on fall speed (pre-calculated)
        const sineValue = Math.sin(timeSinceHit * 2);
        const swayAmount = Math.min(this.fallSpeed * 0.05, 0.3) * deltaTime;
        this.group.rotation.z += sineValue * swayAmount;
        
        // Check if we've hit the ground
        if (this.group.position.y <= 0.1) {
          this.group.position.y = 0.1;
          this.groundTime = currentTime;
          this.isSinking = true;
          
          // Stop all rotations
          this.tumbleSpeeds.x = 0;
          this.tumbleSpeeds.y = 0;
          this.tumbleSpeeds.z = 0;
          this.tumbleAcceleration.x = 0;
          this.tumbleAcceleration.y = 0;
          this.tumbleAcceleration.z = 0;
        }
      } else {
        // Handle sinking into ground
        const timeSinceGround = currentTime - this.groundTime;
        
        if (timeSinceGround >= 3.0) { // Wait 3 seconds before sinking
          if (!this.sinkTime) {
            this.sinkTime = currentTime;
          }
          
          const sinkProgress = (currentTime - this.sinkTime) / 2.0; // 2 second sink animation
          if (sinkProgress >= 1.0) {
            // Reset eagle
            this.reset();
            return;
          }
          
          // Calculate rotation adjustment once
          const rotFactor = (1 - sinkProgress * 0.1);
          
          // Sink into ground
          this.group.position.y = -sinkProgress * 0.5;
          this.group.rotation.z *= rotFactor;
          this.group.rotation.x *= rotFactor;
        }
      }
    }
  }

  /**
   * Resets the eagle after being hit
   */
  reset() {
    this.isHit = false;
    this.hitTime = 0;
    this.fallSpeed = 0;
    this.rotationSpeed = 0;
    this.groundTime = 0;
    this.sinkTime = 0;
    this.isSinking = false;
    
    // Reset position and rotation
    this.group.position.y = this.originalHeight;
    this.group.rotation.copy(this.originalRotation);
    
    // Restart fly animation
    if (this.animations['flycycle']) {
      this.animations['flycycle'].reset();
      this.animations['flycycle'].play();
    }
    
    // Reset to default flight path
    this.setDefaultFlightPath();
  }
} 

================================================
File: /public/js/input.js
================================================
/**
 * Initializes game input (keyboard + mouse) and pointer lock.
 * @param {THREE.WebGLRenderer} renderer - The renderer instance.
 * @param {Player} player - The local Player instance (first-person).
 * @param {SoundManager} soundManager - The SoundManager for audio feedback.
 * @returns {Object} The mobile controls interface if on mobile, otherwise null.
 */

import { isChatInputActive } from './chat.js';

export function initInput(renderer, player, soundManager) {
  // Track if device is mobile
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Variable to store the mobile controls interface
  let mobileControls = null;
  
  // Create touch controls for mobile
  if (isMobile) {
    mobileControls = createMobileControls(player, soundManager);
    
    // Hide all instruction elements on mobile
    hideInstructionsOnMobile();
  }
  
  // Request pointer lock on click (desktop only)
  document.body.addEventListener('click', () => {
    if (!isMobile && document.pointerLockElement !== renderer.domElement) {
      renderer.domElement.requestPointerLock();
    }
  });

  // Mouse look
  document.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === renderer.domElement) {
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;

      // Slightly lower sensitivity when aiming
      const sensitivity = player.isAiming ? 0.001 : 0.002;

      // Yaw
      player.group.rotation.y -= movementX * sensitivity;

      // Pitch (limit to avoid flipping)
      player.camera.rotation.x -= movementY * sensitivity;
      player.camera.rotation.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, player.camera.rotation.x)
      );
    }
  });

  // Keyboard down
  document.addEventListener('keydown', (event) => {
    // Skip game input if chat is active
    if (isChatInputActive()) return;
    
    // Check for NPC interaction first
    if (event.code === 'KeyE') {
      // Try to handle NPC interaction first - highest priority
      if (window.npcManager && window.npcManager.instance) {
        // Check if there's a bartender or other NPC nearby
        if (window.npcManager.instance.isBartenderNearby || window.npcManager.instance.nearbyNpc) {
          // Handle the interaction with the NPC
          window.npcManager.instance.handleInteraction(event, player);
          return; // Exit early, don't process QuickDraw
        }
      }
      
      // If no NPC interaction was handled, check if it's for QuickDraw challenge
      if (window.quickDraw) {
        window.quickDraw.handleChallengeKeypress(event);
        return;
      }
    }
    
    // Weapon switching with number keys
    if (event.code === 'Digit1') {
      player.switchWeapon('revolver');
      return;
    }
    if (event.code === 'Digit2') {
      player.switchWeapon('shotgun');
      return;
    }
    
    switch (event.code) {
      case 'KeyW':
        player.moveForward = true;
        break;
      case 'KeyS':
        player.moveBackward = true;
        break;
      case 'KeyA':
        player.moveLeft = true;
        break;
      case 'KeyD':
        player.moveRight = true;
        break;
      case 'KeyF':
        // Alternative aiming method - holding F to aim
        if (player.canAim && !player.isFAiming) {
          player.isFAiming = true;
          player.isAiming = true;
          
          // Optionally show arms in first-person
          if (player.arms) {
            player.arms.setVisible(true);
          }
          
          // Show and prepare crosshair for animation
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing animation classes
            crosshair.classList.remove('contract', 'expand', 'expanded');
            crosshair.style.display = 'block';
          }

          if (soundManager) {
            soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
          }
        }
        break;
      case 'Space':
        if (player.canJump) {
          // If sprinting, jump higher
          player.velocity.y = player.isSprinting ? 15 : 10;
          player.canJump = false;
          player.isJumping = true;
          
          // Play jump sound
          if (player.soundManager) {
            console.log("Playing jumpup sound from space key");
            player.soundManager.playSound("jumpup", 0, 1.5);
          }
        }
        break;
      case 'KeyR':
        // Start reload
        player.startReload();
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Enable sprinting
        player.isSprinting = true;
        break;
      default:
        break;
    }
  });

  // Keyboard up
  document.addEventListener('keyup', (event) => {
    // Skip game input if chat is active
    if (isChatInputActive()) return;
    
    switch (event.code) {
      case 'KeyW':
        player.moveForward = false;
        break;
      case 'KeyS':
        player.moveBackward = false;
        break;
      case 'KeyA':
        player.moveLeft = false;
        break;
      case 'KeyD':
        player.moveRight = false;
        break;
      case 'KeyF':
        // Stop aiming when F is released (only if F aiming was active)
        if (player.isFAiming) {
          player.isFAiming = false;
          player.isAiming = false;
          
          if (player.arms) {
            player.arms.setVisible(false);
          }
          
          // Play contraction animation before hiding crosshair
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing classes
            crosshair.classList.remove('expand', 'expanded');
            
            // Add contraction animation
            crosshair.classList.add('contract');
            
            // Hide crosshair after animation completes
            setTimeout(() => {
              crosshair.style.display = 'none';
              crosshair.classList.remove('contract');
            }, 250); // Match animation duration
          }
        }
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Disable sprinting
        player.isSprinting = false;
        break;
      default:
        break;
    }
  });

  // Mouse down
  document.addEventListener('mousedown', (event) => {
    // Right-click => Aim (only if canAim is true)
    if (event.button === 2) {
      if (player.canAim && !player.isFAiming) {
        // Traditional right-click aiming (only if not already F-aiming)
        player.isAiming = true;
        
        // Optionally show arms in first-person
        if (player.arms) {
          player.arms.setVisible(true);
        }
        
        // Show and prepare crosshair for animation
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing animation classes
          crosshair.classList.remove('contract', 'expand', 'expanded');
          crosshair.style.display = 'block';
          // Animation will be handled in updateAiming
        }

        if (soundManager) {
          soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
        }
      } else if (player.isFAiming) {
        // RMB pressed while F-aiming - prepare for shoot on release
        player.isFRmbPressed = true;
      }
    }
    // Left-click handling
    else if (event.button === 0) {
      if (player.isAiming && !player.isReloading) {
        // Only use hold-to-shoot when F key is being held (F-aiming mode)
        if (player.isFAiming) {
          // F is being held - use hold-to-shoot mode
          player.isLmbPressed = true;
        } else {
          // Standard aiming - shoot immediately on click
          player.shoot();
        }
      }
    }
  });

  // Mouse up
  document.addEventListener('mouseup', (event) => {
    // Handle right mouse button release
    if (event.button === 2) {
      if (player.isFAiming && player.isFRmbPressed) {
        // F + RMB shoot mechanic: shoot on RMB release while holding F
        player.isFRmbPressed = false;
        
        if (!player.isReloading) {
          player.shoot();
        }
      } else if (!player.isFAiming) {
        // Traditional right-click aim release (only if not F-aiming)
        player.isAiming = false;
        
        if (player.arms) {
          player.arms.setVisible(false);
        }
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250); // Match animation duration
        }
      }
    }
    // Left mouse button release
    else if (event.button === 0) {
      if (player.isLmbPressed && player.isAiming && !player.isReloading) {
        // Only shoot on release when in F-aiming mode
        if (player.isFAiming) {
          player.shoot();
        }
        player.isLmbPressed = false;
      }
    }
  });

  // Prevent context menu on right-click
  document.addEventListener('contextmenu', (event) => {
    event.preventDefault();
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    player.camera.aspect = window.innerWidth / window.innerHeight;
    player.camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // Check for device orientation
    checkOrientation();
  });
  
  // Handle orientation change for mobile
  window.addEventListener('orientationchange', checkOrientation);
  
  // Initial orientation check
  checkOrientation();

  // Ensure fullscreen with no white bars
  ensureFullscreen();
  
  // Set up a resize listener to maintain fullscreen when orientation changes
  window.addEventListener('resize', ensureFullscreen);

  // Return the mobile controls interface if on mobile
  return mobileControls;
}

/**
 * Hide all instruction elements and portals on mobile
 */
function hideInstructionsOnMobile() {
  // Hide all instruction elements
  const instructionElements = [
    document.getElementById('portal-instructions'),
    document.getElementById('proper-shootout-instructions'),
    document.getElementById('reload-message'),
    document.getElementById('quick-draw-message'),
    document.getElementById('quick-draw-countdown'),
    document.getElementById('health-counter'),
    document.getElementById('health-bar-container')
  ];
  
  // Hide each element if it exists
  instructionElements.forEach(element => {
    if (element) {
      element.style.display = 'none';
    }
  });
  
  // Create a mutation observer to catch any new instruction elements
  const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
      if (mutation.addedNodes && mutation.addedNodes.length > 0) {
        for (let i = 0; i < mutation.addedNodes.length; i++) {
          const node = mutation.addedNodes[i];
          if (node.nodeType === 1) { // Element node
            if (node.id && instructionElements.includes(node.id)) {
              node.style.display = 'none';
            } else if (node.className && node.className.includes('portal-instructions')) {
              node.style.display = 'none';
            }
          }
        }
      }
    });
  });
  
  // Start observing the document
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
}

/**
 * Create touch controls for mobile devices with improved handling
 * @param {Player} player - The Player instance
 * @param {SoundManager} soundManager - The SoundManager instance for audio feedback
 */
function createMobileControls(player, soundManager) {
  // Position constants for easy adjustment
  const CONSTANTS = {
    // Jump button positioning
    JUMP_BUTTON: {
      BOTTOM: 100,  // Distance from bottom edge
      RIGHT: 40,   // Distance from right edge
      SIZE: 60     // Button size
    },
    // Left control hint (movement joystick)
    LEFT_JOYSTICK: {
      BOTTOM: 30,  // Distance from bottom edge
      LEFT: 90,    // Distance from left edge
      SIZE: 120    // Joystick size
    },
    // Right control hint (aim/shoot joystick)
    RIGHT_JOYSTICK: {
      BOTTOM: 30,  // Distance from bottom edge
      RIGHT: 135,   // Distance from right edge
      SIZE: 100    // Joystick size
    },
    // Camera area - not using a dedicated button, instead using the area above the aim joystick
    CAMERA_AREA: {
      Y_OFFSET: 130,  // Distance above the aim joystick
      HEIGHT: 150,    // Height of the camera area
      WIDTH: 120      // Width of the camera area (matching the aim joystick)
    },
    // Sensitivities
    MOVE_THRESHOLD: 10,                // Minimum movement in pixels before registering movement
    MOVE_SENSITIVITY: 0.15,            // Movement speed multiplier
    LOOK_SENSITIVITY: 0.4,             // Look speed multiplier for aiming
    CAMERA_ROTATION_SENSITIVITY: 0.7   // Camera rotation sensitivity for view changes
  };

  // Single large invisible overlay for touch input
  const touchOverlay = document.createElement('div');
  touchOverlay.id = 'touch-overlay';
  touchOverlay.style.position = 'fixed';
  touchOverlay.style.top = '0';
  touchOverlay.style.left = '0';
  touchOverlay.style.width = '100%';
  touchOverlay.style.height = '100%';
  touchOverlay.style.zIndex = '999';
  touchOverlay.style.touchAction = 'none'; // Prevents browser handling of touches
  touchOverlay.style.backgroundColor = 'transparent';
  document.body.appendChild(touchOverlay);
  
  // Create jump button
  const jumpButton = document.createElement('div');
  jumpButton.id = 'jump-button';
  jumpButton.className = 'mobile-button';
  jumpButton.innerText = '↑';
  jumpButton.style.position = 'fixed';
  jumpButton.style.bottom = `${CONSTANTS.JUMP_BUTTON.BOTTOM}px`;
  jumpButton.style.right = `${CONSTANTS.JUMP_BUTTON.RIGHT}px`;
  jumpButton.style.width = `${CONSTANTS.JUMP_BUTTON.SIZE}px`;
  jumpButton.style.height = `${CONSTANTS.JUMP_BUTTON.SIZE}px`;
  jumpButton.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
  jumpButton.style.border = '2px solid rgba(255, 255, 255, 0.5)';
  jumpButton.style.borderRadius = '50%';
  jumpButton.style.display = 'flex';
  jumpButton.style.justifyContent = 'center';
  jumpButton.style.alignItems = 'center';
  jumpButton.style.fontSize = '24px';
  jumpButton.style.fontWeight = 'bold';
  jumpButton.style.color = 'white';
  jumpButton.style.zIndex = '1000'; // Ensure it's above other elements
  
  // Create reload button (initially hidden, shows when out of ammo)
  const reloadButton = document.createElement('div');
  reloadButton.id = 'reload-button';
  reloadButton.className = 'mobile-button';
  reloadButton.innerText = 'R';
  reloadButton.style.position = 'fixed';
  reloadButton.style.top = '50%';
  reloadButton.style.left = '50%';
  reloadButton.style.transform = 'translate(-50%, -50%)';
  reloadButton.style.width = '80px';
  reloadButton.style.height = '80px';
  reloadButton.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
  reloadButton.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  reloadButton.style.borderRadius = '50%';
  reloadButton.style.display = 'none'; // Hidden by default
  reloadButton.style.justifyContent = 'center';
  reloadButton.style.alignItems = 'center';
  reloadButton.style.fontSize = '28px';
  reloadButton.style.fontWeight = 'bold';
  reloadButton.style.color = 'white';
  reloadButton.style.zIndex = '1002';
  
  // Create quickdraw invite button (initially hidden, shows when near players)
  const inviteButton = document.createElement('div');
  inviteButton.id = 'invite-button';
  inviteButton.className = 'mobile-button';
  inviteButton.innerText = 'E';
  inviteButton.style.position = 'fixed';
  inviteButton.style.top = '50%'; // Center vertically
  inviteButton.style.left = '50%'; // Center horizontally
  inviteButton.style.transform = 'translate(-50%, -50%)'; // Perfect centering
  inviteButton.style.width = '80px';
  inviteButton.style.height = '80px';
  inviteButton.style.backgroundColor = 'rgba(0, 128, 0, 0.5)';
  inviteButton.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  inviteButton.style.borderRadius = '50%';
  inviteButton.style.display = 'none'; // Hidden by default
  inviteButton.style.justifyContent = 'center';
  inviteButton.style.alignItems = 'center';
  inviteButton.style.fontSize = '32px';
  inviteButton.style.fontWeight = 'bold';
  inviteButton.style.color = 'white';
  inviteButton.style.zIndex = '1001';
  
  // Create quickdraw accept button (initially hidden, shows when receiving invites)
  const acceptButton = document.createElement('div');
  acceptButton.id = 'accept-button';
  acceptButton.className = 'mobile-button';
  acceptButton.innerHTML = '<span style="font-size: 14px; position: absolute; top: -20px; color: white;">accept</span>A';
  acceptButton.style.position = 'fixed';
  acceptButton.style.top = '40%';
  acceptButton.style.left = '40%';
  acceptButton.style.width = '70px';
  acceptButton.style.height = '70px';
  acceptButton.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
  acceptButton.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  acceptButton.style.borderRadius = '50%';
  acceptButton.style.display = 'none'; // Hidden by default
  acceptButton.style.justifyContent = 'center';
  acceptButton.style.alignItems = 'center';
  acceptButton.style.fontSize = '28px';
  acceptButton.style.fontWeight = 'bold';
  acceptButton.style.color = 'white';
  acceptButton.style.zIndex = '1003';
  
  // Create quickdraw decline button (initially hidden, shows when receiving invites)
  const declineButton = document.createElement('div');
  declineButton.id = 'decline-button';
  declineButton.className = 'mobile-button';
  declineButton.innerHTML = '<span style="font-size: 14px; position: absolute; top: -20px; color: white;">decline</span>D';
  declineButton.style.position = 'fixed';
  declineButton.style.top = '40%';
  declineButton.style.left = '60%';
  declineButton.style.width = '70px';
  declineButton.style.height = '70px';
  declineButton.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
  declineButton.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  declineButton.style.borderRadius = '50%';
  declineButton.style.display = 'none'; // Hidden by default
  declineButton.style.justifyContent = 'center';
  declineButton.style.alignItems = 'center';
  declineButton.style.fontSize = '28px';
  declineButton.style.fontWeight = 'bold';
  declineButton.style.color = 'white';
  declineButton.style.zIndex = '1003';
  
  // Create bartender interaction button (initially hidden, shows when near bartender)
  const bartenderButton = document.createElement('div');
  bartenderButton.id = 'bartender-button';
  bartenderButton.className = 'mobile-button';
  bartenderButton.innerText = '🥃';
  bartenderButton.style.position = 'fixed';
  bartenderButton.style.top = '50%';
  bartenderButton.style.left = '50%';
  bartenderButton.style.transform = 'translate(-50%, -50%)';
  bartenderButton.style.width = '80px';
  bartenderButton.style.height = '80px';
  bartenderButton.style.backgroundColor = 'rgba(139, 69, 19, 0.7)'; // Brown color for whiskey/drink theme
  bartenderButton.style.border = '2px solid rgba(255, 215, 0, 0.8)'; // Gold border
  bartenderButton.style.borderRadius = '50%';
  bartenderButton.style.display = 'none'; // Hidden by default
  bartenderButton.style.justifyContent = 'center';
  bartenderButton.style.alignItems = 'center';
  bartenderButton.style.fontSize = '32px';
  bartenderButton.style.fontWeight = 'bold';
  bartenderButton.style.color = 'white';
  bartenderButton.style.zIndex = '1004';
  
  // Create weapon indicator UI (toggle buttons)
  const weaponContainer = document.createElement('div');
  weaponContainer.id = 'weapon-indicator-container';
  weaponContainer.style.position = 'fixed';
  weaponContainer.style.bottom = '240px';
  weaponContainer.style.right = '20px';
  weaponContainer.style.display = 'flex';
  weaponContainer.style.flexDirection = 'row';
  weaponContainer.style.gap = '10px';
  weaponContainer.style.zIndex = '1000';
  
  // Revolver indicator
  const revolverIndicator = document.createElement('div');
  revolverIndicator.id = 'revolver-indicator';
  revolverIndicator.className = 'weapon-indicator active'; // Start with revolver active
  revolverIndicator.style.width = '40px';
  revolverIndicator.style.height = '40px';
  revolverIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
  revolverIndicator.style.border = '2px solid rgba(255, 255, 255, 0.7)';
  revolverIndicator.style.borderRadius = '5px';
  revolverIndicator.style.display = 'flex';
  revolverIndicator.style.justifyContent = 'center';
  revolverIndicator.style.alignItems = 'center';
  
  // Set revolver icon (can be replaced with image)
  const revolverImg = document.createElement('img');
  revolverImg.src = 'models/revolverindicator.png';
  revolverImg.style.width = '80%';
  revolverImg.style.height = '80%';
  revolverImg.style.objectFit = 'contain';
  revolverIndicator.appendChild(revolverImg);
  
  // Shotgun indicator
  const shotgunIndicator = document.createElement('div');
  shotgunIndicator.id = 'shotgun-indicator';
  shotgunIndicator.className = 'weapon-indicator';
  shotgunIndicator.style.width = '40px';
  shotgunIndicator.style.height = '40px';
  shotgunIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
  shotgunIndicator.style.border = '2px solid rgba(255, 255, 255, 0.5)';
  shotgunIndicator.style.borderRadius = '5px';
  shotgunIndicator.style.display = 'flex';
  shotgunIndicator.style.justifyContent = 'center';
  shotgunIndicator.style.alignItems = 'center';
  
  // Set shotgun icon (can be replaced with image)
  const shotgunImg = document.createElement('img');
  shotgunImg.src = 'models/shotgunindicator.png';
  shotgunImg.style.width = '80%';
  shotgunImg.style.height = '80%';
  shotgunImg.style.objectFit = 'contain';
  shotgunIndicator.appendChild(shotgunImg);
  
  // Add indicators to container
  weaponContainer.appendChild(revolverIndicator);
  weaponContainer.appendChild(shotgunIndicator);
  
  // Add CSS for active weapon
  const style = document.createElement('style');
  style.textContent = `
    .weapon-indicator.active {
      border-color: #ffcc00 !important;
      box-shadow: 0 0 10px #ffcc00;
    }
  `;
  document.head.appendChild(style);
  
  // Add touch event listeners for weapon switching
  revolverIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (player.activeWeapon !== 'revolver') {
      player.switchWeapon('revolver');
      revolverIndicator.className = 'weapon-indicator active';
      shotgunIndicator.className = 'weapon-indicator';
    }
  });
  
  shotgunIndicator.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (player.activeWeapon !== 'shotgun') {
      player.switchWeapon('shotgun');
      shotgunIndicator.className = 'weapon-indicator active';
      revolverIndicator.className = 'weapon-indicator';
    }
  });
  
  // Create visual joystick hint for movement (left side)
  const leftControlHint = document.createElement('div');
  leftControlHint.id = 'left-control-hint';
  leftControlHint.className = 'control-hint';
  leftControlHint.style.position = 'fixed';
  leftControlHint.style.bottom = `${CONSTANTS.LEFT_JOYSTICK.BOTTOM}px`;
  leftControlHint.style.left = `${CONSTANTS.LEFT_JOYSTICK.LEFT}px`;
  leftControlHint.style.width = `${CONSTANTS.LEFT_JOYSTICK.SIZE}px`;
  leftControlHint.style.height = `${CONSTANTS.LEFT_JOYSTICK.SIZE}px`;
  leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
  leftControlHint.style.borderRadius = '50%';
  leftControlHint.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
  leftControlHint.style.zIndex = '998';
  leftControlHint.style.pointerEvents = 'none';
  
  // Create inner knob for left joystick (walk)
  const leftJoystickKnob = document.createElement('div');
  leftJoystickKnob.id = 'left-joystick-knob';
  leftJoystickKnob.className = 'joystick-knob';
  leftJoystickKnob.style.position = 'absolute';
  leftJoystickKnob.style.width = `${CONSTANTS.LEFT_JOYSTICK.SIZE * 0.4}px`; // 40% of the size of the outer circle
  leftJoystickKnob.style.height = `${CONSTANTS.LEFT_JOYSTICK.SIZE * 0.4}px`;
  leftJoystickKnob.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
  leftJoystickKnob.style.borderRadius = '50%';
  leftJoystickKnob.style.top = '50%';
  leftJoystickKnob.style.left = '50%';
  leftJoystickKnob.style.transform = 'translate(-50%, -50%)';
  leftJoystickKnob.style.zIndex = '999';
  leftJoystickKnob.style.pointerEvents = 'none';
  leftControlHint.appendChild(leftJoystickKnob);
  
  // Create visual joystick hint for aiming (right side)
  const rightControlHint = document.createElement('div');
  rightControlHint.id = 'right-control-hint';
  rightControlHint.className = 'control-hint';
  rightControlHint.style.position = 'fixed';
  rightControlHint.style.bottom = `${CONSTANTS.RIGHT_JOYSTICK.BOTTOM}px`;
  rightControlHint.style.right = `${CONSTANTS.RIGHT_JOYSTICK.RIGHT}px`;
  rightControlHint.style.width = `${CONSTANTS.RIGHT_JOYSTICK.SIZE}px`;
  rightControlHint.style.height = `${CONSTANTS.RIGHT_JOYSTICK.SIZE}px`;
  rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
  rightControlHint.style.borderRadius = '50%';
  rightControlHint.style.border = '2px dashed rgba(255, 255, 255, 0.3)';
  rightControlHint.style.zIndex = '998';
  rightControlHint.style.pointerEvents = 'none';
  
  // Create inner knob for right joystick (aim)
  const rightJoystickKnob = document.createElement('div');
  rightJoystickKnob.id = 'right-joystick-knob';
  rightJoystickKnob.className = 'joystick-knob';
  rightJoystickKnob.style.position = 'absolute';
  rightJoystickKnob.style.width = `${CONSTANTS.RIGHT_JOYSTICK.SIZE * 0.4}px`; // 40% of the size of the outer circle
  rightJoystickKnob.style.height = `${CONSTANTS.RIGHT_JOYSTICK.SIZE * 0.4}px`;
  rightJoystickKnob.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
  rightJoystickKnob.style.borderRadius = '50%';
  rightJoystickKnob.style.top = '50%';
  rightJoystickKnob.style.left = '50%';
  rightJoystickKnob.style.transform = 'translate(-50%, -50%)';
  rightJoystickKnob.style.zIndex = '999';
  rightJoystickKnob.style.pointerEvents = 'none';
  
  // Add bullet image to right joystick knob
  const bulletImg = document.createElement('img');
  bulletImg.src = 'models/aimjoystick.png';
  bulletImg.style.width = '70%';
  bulletImg.style.height = '70%';
  bulletImg.style.position = 'absolute';
  bulletImg.style.top = '50%';
  bulletImg.style.left = '50%';
  bulletImg.style.transform = 'translate(-50%, -50%)';
  bulletImg.style.pointerEvents = 'none';
  rightJoystickKnob.appendChild(bulletImg);
  
  rightControlHint.appendChild(rightJoystickKnob);
  
  // Create visual indicator for the camera area (above the aim joystick)
  const cameraControlHint = document.createElement('div');
  cameraControlHint.id = 'camera-control-hint';
  cameraControlHint.style.position = 'fixed';
  cameraControlHint.style.top = '0';
  cameraControlHint.style.left = '0';
  cameraControlHint.style.width = '100%';
  cameraControlHint.style.height = '100%';
  cameraControlHint.style.backgroundColor = 'transparent';
  cameraControlHint.style.border = 'none';
  cameraControlHint.style.zIndex = '900'; // Below other controls
  cameraControlHint.style.pointerEvents = 'none';
  cameraControlHint.innerText = '';
  
  // Create orientation message
  const orientationMsg = document.createElement('div');
  orientationMsg.id = 'orientation-message';
  orientationMsg.innerText = 'Please rotate to landscape mode';
  orientationMsg.style.position = 'fixed';
  orientationMsg.style.top = '0';
  orientationMsg.style.left = '0';
  orientationMsg.style.width = '100%';
  orientationMsg.style.height = '100%';
  orientationMsg.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
  orientationMsg.style.color = 'white';
  orientationMsg.style.display = 'flex';
  orientationMsg.style.justifyContent = 'center';
  orientationMsg.style.alignItems = 'center';
  orientationMsg.style.fontSize = '24px';
  orientationMsg.style.zIndex = '2000';
  orientationMsg.style.display = 'none';
  
  // Add elements to document
  document.body.appendChild(weaponContainer);
  document.body.appendChild(jumpButton);
  document.body.appendChild(reloadButton);
  document.body.appendChild(inviteButton);
  document.body.appendChild(acceptButton);
  document.body.appendChild(declineButton);
  document.body.appendChild(bartenderButton);
  document.body.appendChild(leftControlHint);
  document.body.appendChild(rightControlHint);
  document.body.appendChild(cameraControlHint);
  document.body.appendChild(orientationMsg);
  
  // Variables to track touch state
  let leftSideTouchId = null;
  let rightSideTouchId = null;
  let cameraTouchId = null;
  let leftStartPos = { x: 0, y: 0 };
  let rightStartPos = { x: 0, y: 0 };
  let cameraStartPos = { x: 0, y: 0 };
  let rightTouchStartTime = 0;
  let screenWidth = window.innerWidth;
  let isAimingWithTouch = false;
  
  // Initial state of player
  player.moveForward = false;
  player.moveBackward = false;
  player.moveLeft = false;
  player.moveRight = false;
  player.isAiming = false;
  
  // Mobile users should be sprinting by default
  player.isSprinting = true;
  
  // Override auto-reload with manual reload for mobile
  const originalShoot = player.shoot;
  player.shoot = function() {
    const result = originalShoot.apply(this, arguments);
    
    // Show reload button when out of bullets instead of auto-reloading
    if (this.bullets <= 0 && !this.isReloading) {
      reloadButton.style.display = 'flex';
    }
    
    return result;
  };
  
  // Function to check if player is near another player for quickdraw
  function checkForNearbyPlayers() {
    // This function should be called from the game loop to show/hide the invite button
    // For now, we'll just add the interface - the actual implementation will need
    // to be connected to the multiplayer system
  }
  
  // Function to handle incoming quickdraw invites
  function showQuickdrawInvite() {
    acceptButton.style.display = 'flex';
    declineButton.style.display = 'flex';
  }
  
  // Function to hide quickdraw invite buttons
  function hideQuickdrawInvite() {
    acceptButton.style.display = 'none';
    declineButton.style.display = 'none';
  }
  
  // Ensure audio context is resumed for mobile
  function ensureAudioContextResumed() {
    if (soundManager && soundManager.audioContext && 
        soundManager.audioContext.state !== 'running') {
      // Resume the audio context on first user interaction
      soundManager.audioContext.resume().then(() => {
        console.log('AudioContext resumed successfully');
        // Play a silent sound to fully activate audio
        if (soundManager.buffers['revolverdraw']) {
          const silentSound = soundManager.playSound('revolverdraw', 0, 0.01);
          if (silentSound && silentSound.gainNode) {
            silentSound.gainNode.gain.value = 0.01;
          }
        }
      }).catch(err => {
        console.error('Failed to resume AudioContext:', err);
      });
    }
  }
  
  // Touch start handler
  touchOverlay.addEventListener('touchstart', (e) => {
    // Ensure audio is activated on first touch
    ensureAudioContextResumed();
    
    // Dismiss any instructions/info banner that might be visible
    const instructionsElement = document.getElementById('instructions');
    if (instructionsElement && instructionsElement.parentNode) {
      instructionsElement.parentNode.removeChild(instructionsElement);
    }
    
    // Get joystick element positions for accurate activation areas
    const leftJoystickRect = leftControlHint.getBoundingClientRect();
    const rightJoystickRect = rightControlHint.getBoundingClientRect();
    const jumpButtonRect = jumpButton.getBoundingClientRect();
    
    // Get chat area if it exists
    let chatRect = null;
    const chatContainer = document.getElementById('chat-container');
    if (chatContainer) {
      chatRect = chatContainer.getBoundingClientRect();
    }
    
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      const x = touch.clientX;
      const y = touch.clientY;
      
      // Get the screen dimensions
      const screenHeight = window.innerHeight;
      
      // Skip if touch is on jump button to avoid interfering with its handler
      if (x >= jumpButtonRect.left && 
          x <= jumpButtonRect.right &&
          y >= jumpButtonRect.top && 
          y <= jumpButtonRect.bottom) {
        continue;
      }
      
      // Skip if touch is in chat area
      if (chatRect && 
          x >= chatRect.left && 
          x <= chatRect.right && 
          y >= chatRect.top && 
          y <= chatRect.bottom) {
        continue;
      }
      
      // Check if touch is in left joystick area (movement)
      if (x >= leftJoystickRect.left && 
          x <= leftJoystickRect.right &&
          y >= leftJoystickRect.top && 
          y <= leftJoystickRect.bottom) {
        
        if (leftSideTouchId === null) {
          leftSideTouchId = touch.identifier;
          leftStartPos.x = x;
          leftStartPos.y = y;
          
          // Visual feedback - highlight active control
          leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
          leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
          
          // Do not move the entire joystick anymore
          // Just keep it in place and let only the knob move
        }
      } 
      // Check if touch is in right joystick area (aim/shoot)
      else if (x >= rightJoystickRect.left && 
               x <= rightJoystickRect.right &&
               y >= rightJoystickRect.top && 
               y <= rightJoystickRect.bottom) {
        
        if (rightSideTouchId === null) {
          rightSideTouchId = touch.identifier;
          rightStartPos.x = x;
          rightStartPos.y = y;
          rightTouchStartTime = Date.now();
          
          // Visual feedback - highlight active control
          rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.7)';
          rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.4)';
          
          // Do not move the entire joystick anymore
          // Just keep it in place and let only the knob move
          
          // Start aiming immediately on touch
          player.isAiming = true;
          isAimingWithTouch = true;
          player.isLmbPressed = true; // Mark that touch is being held for shooting
          
          // Show and prepare crosshair for animation
          const crosshair = document.getElementById('crosshair');
          if (crosshair) {
            // Reset any existing animation classes
            crosshair.classList.remove('contract', 'expand', 'expanded');
            crosshair.style.display = 'block';
          }
          
          if (soundManager) {
            soundManager.playSound(player.activeWeapon === 'shotgun' ? "shotgundraw" : "revolverdraw");
          }
        }
      }
      // If not on any specific control, use touch for camera control
      else if (cameraTouchId === null) {
        cameraTouchId = touch.identifier;
        cameraStartPos.x = x;
        cameraStartPos.y = y;
      }
    }
    e.preventDefault();
  });
  
  // Touch move handler
  touchOverlay.addEventListener('touchmove', (e) => {
    // Dismiss any instructions/info banner that might be visible
    const instructionsElement = document.getElementById('instructions');
    if (instructionsElement && instructionsElement.parentNode) {
      instructionsElement.parentNode.removeChild(instructionsElement);
    }
    
    for (let i = 0; i < e.touches.length; i++) {
      const touch = e.touches[i];
      
      // Handle left side touch (movement)
      if (touch.identifier === leftSideTouchId) {
        const deltaX = touch.clientX - leftStartPos.x;
        const deltaY = touch.clientY - leftStartPos.y;
        
        // Move the joystick knob
        const leftJoystickKnob = document.getElementById('left-joystick-knob');
        if (leftJoystickKnob) {
          // Calculate the distance from center
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          // Get the max distance the knob can move (radius of outer circle - radius of knob)
          const maxDistance = CONSTANTS.LEFT_JOYSTICK.SIZE * 0.3; // 30% of the outer circle size
          
          if (distance > 0) {
            // Normalize the position to the max distance
            const normalizedDistance = Math.min(distance, maxDistance);
            const normalizedX = deltaX * (normalizedDistance / distance);
            const normalizedY = deltaY * (normalizedDistance / distance);
            
            // Move the knob from center position
            leftJoystickKnob.style.transform = `translate(calc(-50% + ${normalizedX}px), calc(-50% + ${normalizedY}px))`;
          }
        }
        
        // Only apply movement if joystick is moved beyond threshold
        if (Math.abs(deltaX) > CONSTANTS.MOVE_THRESHOLD || Math.abs(deltaY) > CONSTANTS.MOVE_THRESHOLD) {
          // Forward/backward based on vertical movement
          player.moveForward = deltaY < -CONSTANTS.MOVE_THRESHOLD;
          player.moveBackward = deltaY > CONSTANTS.MOVE_THRESHOLD;
          
          // Left/right based on horizontal movement
          player.moveLeft = deltaX < -CONSTANTS.MOVE_THRESHOLD;
          player.moveRight = deltaX > CONSTANTS.MOVE_THRESHOLD;
        }
      }
      
      // Handle right side touch (aiming + camera rotation)
      if (touch.identifier === rightSideTouchId) {
        const deltaX = touch.clientX - rightStartPos.x;
        const deltaY = touch.clientY - rightStartPos.y;
        
        // Move the joystick knob
        const rightJoystickKnob = document.getElementById('right-joystick-knob');
        if (rightJoystickKnob) {
          // Calculate the distance from center
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          // Get the max distance the knob can move (radius of outer circle - radius of knob)
          const maxDistance = CONSTANTS.RIGHT_JOYSTICK.SIZE * 0.3; // 30% of the outer circle size
          
          if (distance > 0) {
            // Normalize the position to the max distance
            const normalizedDistance = Math.min(distance, maxDistance);
            const normalizedX = deltaX * (normalizedDistance / distance);
            const normalizedY = deltaY * (normalizedDistance / distance);
            
            // Move the knob from center position
            rightJoystickKnob.style.transform = `translate(calc(-50% + ${normalizedX}px), calc(-50% + ${normalizedY}px))`;
          }
        }
        
        // Apply camera rotation - allow for 360° movement
        player.group.rotation.y -= deltaX * CONSTANTS.LOOK_SENSITIVITY * 0.01;
        player.camera.rotation.x -= deltaY * CONSTANTS.LOOK_SENSITIVITY * 0.01;
        
        // Limit vertical rotation to avoid flipping
        player.camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, player.camera.rotation.x)
        );
        
        // Update starting position to prevent continuous rotation
        rightStartPos.x = touch.clientX;
        rightStartPos.y = touch.clientY;
      }
      
      // Handle camera area touch (separate from aiming)
      if (touch.identifier === cameraTouchId) {
        const deltaX = touch.clientX - cameraStartPos.x;
        const deltaY = touch.clientY - cameraStartPos.y;
        
        // Apply full 360° camera rotation based on touch movement
        player.group.rotation.y -= deltaX * CONSTANTS.CAMERA_ROTATION_SENSITIVITY * 0.01;
        player.camera.rotation.x -= deltaY * CONSTANTS.CAMERA_ROTATION_SENSITIVITY * 0.01;
        
        // Limit vertical rotation to avoid flipping
        player.camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, player.camera.rotation.x)
        );
        
        // Update starting position to prevent continuous rotation
        cameraStartPos.x = touch.clientX;
        cameraStartPos.y = touch.clientY;
      }
    }
    e.preventDefault();
  });
  
  // Touch end handler
  touchOverlay.addEventListener('touchend', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      
      // Handle left side touch end (movement)
      if (touch.identifier === leftSideTouchId) {
        leftSideTouchId = null;
        
        // Reset movement flags
        player.moveForward = false;
        player.moveBackward = false;
        player.moveLeft = false;
        player.moveRight = false;
        
        // Reset visual feedback
        leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const leftJoystickKnob = document.getElementById('left-joystick-knob');
        if (leftJoystickKnob) {
          leftJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
      }
      
      // Handle right side touch end (shooting on release)
      if (touch.identifier === rightSideTouchId) {
        // Shoot when releasing the touch if still aiming
        if (isAimingWithTouch && player.isAiming && !player.isReloading) {
          player.shoot();
        }
        player.isLmbPressed = false;
        
        // Stop aiming
        player.isAiming = false;
        isAimingWithTouch = false;
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250); // Match animation duration
        }
        
        // Reset visual feedback
        rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const rightJoystickKnob = document.getElementById('right-joystick-knob');
        if (rightJoystickKnob) {
          rightJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
        
        rightSideTouchId = null;
      }
      
      // Handle camera touch end
      if (touch.identifier === cameraTouchId) {
        cameraTouchId = null;
      }
    }
    e.preventDefault();
  });
  
  // Touch cancel handler - similar updates
  touchOverlay.addEventListener('touchcancel', (e) => {
    for (let i = 0; i < e.changedTouches.length; i++) {
      const touch = e.changedTouches[i];
      
      // Reset left side touch (movement)
      if (touch.identifier === leftSideTouchId) {
        leftSideTouchId = null;
        player.moveForward = false;
        player.moveBackward = false;
        player.moveLeft = false;
        player.moveRight = false;
        
        // Reset visual feedback
        leftControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        leftControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const leftJoystickKnob = document.getElementById('left-joystick-knob');
        if (leftJoystickKnob) {
          leftJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
      }
      
      // Reset right side touch (aiming)
      if (touch.identifier === rightSideTouchId) {
        rightSideTouchId = null;
        player.isAiming = false;
        isAimingWithTouch = false;
        
        // Clear any pressed state
        if (player.isLmbPressed) {
          player.isLmbPressed = false;
        }
        
        // Reset visual feedback
        rightControlHint.style.borderColor = 'rgba(255, 255, 255, 0.3)';
        rightControlHint.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        
        // Reset joystick knob position
        const rightJoystickKnob = document.getElementById('right-joystick-knob');
        if (rightJoystickKnob) {
          rightJoystickKnob.style.transform = 'translate(-50%, -50%)';
        }
        
        // Play contraction animation before hiding crosshair
        const crosshair = document.getElementById('crosshair');
        if (crosshair) {
          // Reset any existing classes
          crosshair.classList.remove('expand', 'expanded');
          
          // Add contraction animation
          crosshair.classList.add('contract');
          
          // Hide crosshair after animation completes
          setTimeout(() => {
            crosshair.style.display = 'none';
            crosshair.classList.remove('contract');
          }, 250);
        }
      }
      
      // Reset camera rotation touch
      if (touch.identifier === cameraTouchId) {
        cameraTouchId = null;
      }
    }
    e.preventDefault();
  });
  
  // Reload button handler
  reloadButton.addEventListener('touchstart', (e) => {
    if (!player.isReloading && player.bullets < player.maxBullets) {
      player.startReload();
      reloadButton.style.display = 'none';
    }
    e.preventDefault();
  });
  
  // Quickdraw invite button handler
  inviteButton.addEventListener('touchstart', (e) => {
    // Send quickdraw invite to nearby player
    if (window.quickDraw && typeof window.quickDraw.sendChallenge === 'function') {
      window.quickDraw.sendChallenge();
    }
    e.preventDefault();
  });
  
  // Quickdraw accept button handler
  acceptButton.addEventListener('touchstart', (e) => {
    // Accept quickdraw invite
    if (window.quickDraw && typeof window.quickDraw.acceptChallenge === 'function') {
      window.quickDraw.acceptChallenge();
    }
    hideQuickdrawInvite();
    e.preventDefault();
  });
  
  // Quickdraw decline button handler
  declineButton.addEventListener('touchstart', (e) => {
    // Decline quickdraw invite
    if (window.quickDraw && typeof window.quickDraw.declineChallenge === 'function') {
      window.quickDraw.declineChallenge();
    }
    hideQuickdrawInvite();
    e.preventDefault();
  });
  
  // Jump button handler
  jumpButton.addEventListener('touchstart', (e) => {
    if (player.canJump) {
      // Original jump behavior
      player.velocity.y = player.isSprinting ? 15 : 10;
      player.canJump = false;
      player.isJumping = true;
      
      // Play jump sound
      if (player.soundManager) {
        player.soundManager.playSound("jumpup", 0, 1.5);
      }
    }
    e.preventDefault();
  });
  
  // Bartender button handler
  bartenderButton.addEventListener('touchstart', (e) => {
    e.preventDefault();
    
    // Trigger the interaction with bartender via the NPC manager
    if (window.npcManager && window.npcManager.instance) {
      // Call the interaction handler with null event (indicating mobile trigger)
      window.npcManager.instance.handleInteraction(null, player);
      
      // Hide the button after it's used
      hideBartenderButton();
    }
  });
  
  // Handle window resize to update the screen width calculation
  window.addEventListener('resize', () => {
    screenWidth = window.innerWidth;
  });
  
  // Function to show bartender interaction button
  function showBartenderButton() {
    bartenderButton.style.display = 'flex';
  }

  // Function to hide bartender interaction button
  function hideBartenderButton() {
    bartenderButton.style.display = 'none';
  }

  // Return methods to be called from the game loop
  return {
    checkForNearbyPlayers: function(nearbyPlayersExist) {
      // Show/hide the invite button based on whether there are nearby players
      inviteButton.style.display = nearbyPlayersExist ? 'flex' : 'none';
    },
    showQuickdrawInvite: showQuickdrawInvite,
    hideQuickdrawInvite: hideQuickdrawInvite,
    // Export constants so they can be adjusted externally if needed
    getConstants: function() {
      return CONSTANTS;
    },
    showBartenderButton: showBartenderButton,
    hideBartenderButton: hideBartenderButton
  };
}

/**
 * Check device orientation and display warning if not in landscape mode on mobile
 */
function checkOrientation() {
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  if (isMobile) {
    const orientationMsg = document.getElementById('orientation-message');
    
    // Check if we're in portrait mode
    if (window.innerHeight > window.innerWidth) {
      orientationMsg.style.display = 'flex';
    } else {
      orientationMsg.style.display = 'none';
    }
  }
}

// Function to update health display - modified to handle missing health counter
function updateHealthDisplay(health, maxHealth) {
  // Skip the health counter update since we removed it from the UI
  
  // Only update health bar if it exists
  const healthBar = document.getElementById('health-bar');
  if (healthBar) {
    const healthPercent = Math.max(0, health / maxHealth * 100);
    healthBar.style.width = `${healthPercent}%`;
    
    // Change color based on health level
    if (healthPercent > 66) {
      healthBar.style.backgroundColor = '#4CAF50'; // Green
    } else if (healthPercent > 33) {
      healthBar.style.backgroundColor = '#FFC107'; // Yellow
    } else {
      healthBar.style.backgroundColor = '#F44336'; // Red
    }
  }
}

function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0);
}

// This function ensures the game takes up the full screen space with no white bars
function ensureFullscreen() {
  // Set body and html to full viewport dimensions
  document.documentElement.style.width = '100%';
  document.documentElement.style.height = '100%';
  document.body.style.width = '100%';
  document.body.style.height = '100%';
  document.body.style.margin = '0';
  document.body.style.padding = '0';
  document.body.style.overflow = 'hidden';
  document.body.style.backgroundColor = '#000';
  document.body.style.position = 'fixed';
  
  // Set game container to full viewport
  const gameContainer = document.getElementById('game-container');
  if (gameContainer) {
    gameContainer.style.position = 'fixed';
    gameContainer.style.top = '0';
    gameContainer.style.left = '0';
    gameContainer.style.right = '0';
    gameContainer.style.bottom = '0';
    gameContainer.style.width = '100%';
    gameContainer.style.height = '100%';
    gameContainer.style.margin = '0';
    gameContainer.style.padding = '0';
    gameContainer.style.overflow = 'hidden';
    gameContainer.style.backgroundColor = '#000';
  }
  
  // Make sure canvas fills the screen
  const canvas = document.querySelector('canvas');
  if (canvas) {
    canvas.style.position = 'fixed';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.right = '0';
    canvas.style.bottom = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.margin = '0';
    canvas.style.padding = '0';
    canvas.style.display = 'block';
    canvas.style.backgroundColor = '#000';
    
    // iOS Safari specific fixes
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
      // Fix for iOS notch and home indicator
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      
      // Prevent elastic scrolling
      document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, { passive: false });
      
      // Force scroll to top on resize/orientation change
      window.addEventListener('resize', () => {
        window.scrollTo(0, 0);
        document.body.style.height = window.innerHeight + 'px';
        canvas.style.height = window.innerHeight + 'px';
      });
      
      // Initial height fix
      setTimeout(() => {
        window.scrollTo(0, 0);
        document.body.style.height = window.innerHeight + 'px';
        canvas.style.height = window.innerHeight + 'px';
      }, 300);
    }
  }
}

/**
 * Create optimized smoke effect for mobile
 * @param {HTMLElement} drawCircle - The draw circle element
 */
function createOptimizedSmokeEffect(drawCircle) {
  if (isMobileDevice()) {
    // Use mobile-optimized version
    drawCircle.style.display = 'block';
    drawCircle.style.width = '150px';
    drawCircle.style.height = '150px';
    drawCircle.style.borderWidth = '4px';
    drawCircle.style.opacity = '0.7';
    drawCircle.style.boxShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
    // Remove desktop animation and add mobile-optimized animation
    drawCircle.classList.remove('draw-circle-animation');
    drawCircle.classList.add('draw-circle-animation-mobile');
  } else {
    // Desktop full version
    drawCircle.style.display = 'block';
    drawCircle.style.width = '300px';
    drawCircle.style.height = '300px';
    drawCircle.style.borderWidth = '8px';
    drawCircle.style.opacity = '1';
    drawCircle.style.boxShadow = '0 0 20px #FF0000';
    drawCircle.classList.add('draw-circle-animation');
  }
}

// Export the smoke effect function so it can be used in game logic
export { createOptimizedSmokeEffect };

================================================
File: /public/js/logger.js
================================================
/**
 * Logger - A simple configurable logging system for the game
 * Allows toggling debug logs globally to reduce console spam
 */
export class Logger {
  constructor() {
    // Default log levels
    this.levels = {
      error: true,   // Always show errors
      warn: true,    // Always show warnings
      info: false,   // Toggle general info logs
      debug: false,  // Toggle verbose debug logs
      physics: false // Toggle physics-related logs
    };
    
    // Production mode - don't load from localStorage
  }
  
  /**
   * Load logger settings from localStorage
   */
  loadSettings() {
    // Disabled for production
  }
  
  /**
   * Save current settings to localStorage
   */
  saveSettings() {
    // Disabled for production
  }
  
  /**
   * Set a specific log level
   * @param {string} level - Level name
   * @param {boolean} enabled - Whether to enable it
   */
  setLevel(level, enabled) {
    if (level in this.levels) {
      this.levels[level] = enabled;
      this.saveSettings();
    }
  }
  
  /**
   * Log an error message (always shown)
   * @param {...any} args - Arguments to log
   */
  error(...args) {
    console.error(...args);
  }
  
  /**
   * Log a warning message (always shown)
   * @param {...any} args - Arguments to log
   */
  warn(...args) {
    console.warn(...args);
  }
  
  /**
   * Log an info message (can be toggled)
   * @param {...any} args - Arguments to log
   */
  info(...args) {
    if (this.levels.info) {
      console.log(...args);
    }
  }
  
  /**
   * Log a debug message (can be toggled)
   * @param {...any} args - Arguments to log
   */
  debug(...args) {
    if (this.levels.debug) {
      console.log(...args);
    }
  }
  
  /**
   * Log a physics-related message (can be toggled)
   * @param {...any} args - Arguments to log
   */
  physics(...args) {
    if (this.levels.physics) {
      console.log(...args);
    }
  }
  
  /**
   * Create a simple UI for toggling log levels
   * @param {HTMLElement} container - Container element
   */
  createUI(container) {
    const div = document.createElement('div');
    div.className = 'logger-controls';
    div.style.position = 'fixed';
    div.style.bottom = '10px';
    div.style.right = '10px';
    div.style.backgroundColor = 'rgba(0,0,0,0.7)';
    div.style.padding = '10px';
    div.style.borderRadius = '5px';
    div.style.color = 'white';
    div.style.zIndex = '1000';
    div.style.fontSize = '12px';
    
    const title = document.createElement('div');
    title.textContent = 'Debug Logs';
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '5px';
    div.appendChild(title);
    
    // Create toggle for each log level
    Object.keys(this.levels).forEach(level => {
      const label = document.createElement('label');
      label.style.display = 'block';
      label.style.marginBottom = '3px';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = this.levels[level];
      checkbox.addEventListener('change', () => {
        this.setLevel(level, checkbox.checked);
      });
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(` ${level}`));
      div.appendChild(label);
    });
    
    container.appendChild(div);
  }
}

// Create global logger instance
const logger = new Logger();

// Replace console functions with logger if enabled
if (typeof window !== 'undefined') {
  window.logger = logger;
}

export default logger; 

================================================
File: /public/js/main.js
================================================
import { initScene, updateFPS, scene } from './scene.js';
import { initInput } from './input.js';
import { SoundManager } from './soundManager.js';
import { Player } from './player.js';
import { networkManager } from './network.js';
import { MultiplayerManager } from './multiplayerManager.js';
import { Bullet } from './bullet.js';
import { ThirdPersonModel } from './playerModel.js';
import { PhysicsSystem } from './physics.js';
import { createMuzzleFlash, createSmokeEffect, createImpactEffect, preloadMuzzleFlash, preloadSmokeEffect, SmokeRingEffect, DrunkennessEffect } from './effects.js';
import { QuickDraw } from './quickDraw.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { Viewmodel } from './viewmodel.js';
import { initPlayerIdentity, verifyIdentityWithServer } from './playerIdentity.js';
import logger from './logger.js';
import { FlyingEagle } from './flyingEagle.js';
import { initChat, handleChatMessage, addSystemMessage } from './chat.js';
import { initNpcManager, npcManager } from './npcManager.js';
console.log("NPC Manager module loaded");
import './viewmodel-config.js';

// Check if device is mobile
function isMobileDevice() {
  return (window.innerWidth <= 1024 || 'ontouchstart' in window || navigator.maxTouchPoints > 0 || 
         /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));
}

// Set global flag for mobile
window.isMobile = isMobileDevice();

// Keep track of all bullets in the game, both local and remote
let bullets = [];

// Anti-cheat: Map bullets by ID for server authority
let bulletMap = new Map(); // bulletId -> Bullet object

// We'll keep references to local player, remote players, and a combined map
let localPlayer;
let remotePlayers = new Map();  // (playerId => ThirdPersonModel)
let playersMap = new Map();     // Master map including local + remote

// Scenes, camera, etc.
let renderer, camera;
let multiplayerManager;
let quickDraw;
let physics;
let lastTime = 0;

// Smoke ring effects
let smokeRings = [];
let maxSmokeRings = 10; // Limit to prevent performance issues

// Add a flag to track debug visualization mode
window.showHitZoneDebug = false;
window.showTownColliders = false; // Disable for production

// Create a global renderer object to allow camera switching
window.renderer = {
  instance: null,
  camera: null,
  setCamera: function(newCamera) {
    this.camera = newCamera;
  }
};

// Initialize the application
async function init() {
  try {
    // Start the init process without waiting for player identity
    
    // Set debug mode flag
    window.debugMode = false; // Disabled for production
    
    // Initialize logger UI if in debug mode
    if (window.debugMode) {
      const gameContainer = document.getElementById('gameContainer') || document.body;
      logger.createUI(gameContainer);
    }
    
    // Detect if we're on a mobile device
    window.isMobile = isMobileDevice();
    
    // Setup viewport detection and handling
    setupViewportHandling();
    
    // Initialize scene - use the scene from initScene instead of creating a new one
    const sceneSetup = initScene();
    camera = sceneSetup.camera;
    renderer = sceneSetup.renderer;
    
    // Initialize NPC manager with the scene
    const npcManagerInstance = initNpcManager(scene);
    
    // Make NPC manager globally accessible
    window.npcManager = npcManager;
    
    // Set up global renderer access for camera switching
    window.renderer.instance = renderer;
    window.renderer.camera = camera;
    
    // Initialize physics system first so it's available for the scene
    physics = new PhysicsSystem();
    window.physics = physics; // Make physics globally accessible

    const soundManager = new SoundManager();
    
    // Start loading sounds while the user is entering their name
    // Load shot sounds
    soundManager.loadSound("shot", "sounds/shot.mp3");
    soundManager.loadSound("revolverdraw", "sounds/revolverdraw.mp3");
    // replacing shellejection with the combined reloading sound
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    // Load the bell start sound for Quick Draw start signal
    soundManager.loadSound("bellstart", "sounds/bellstart.mp3");
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    soundManager.loadSound("fleshimpact", "sounds/fleshimpact.mp3");
    
    // Load footstep and jump sounds
    soundManager.loadSound("leftstep", "sounds/leftstep.mp3");
    soundManager.loadSound("rightstep", "sounds/rightstep.mp3");
    soundManager.loadSound("jumpup", "sounds/jumpup.mp3");
    soundManager.loadSound("jumpland", "sounds/jumpland.mp3");
    soundManager.loadSound("recoiljump", "sounds/recoiljump.mp3");
    
    // Load headshot marker sound
    soundManager.loadSound("headshotmarker", "sounds/headshotmarker.mp3");
    
    // Load hitmarker sound
    soundManager.loadSound("hitmarker", "sounds/hitmarker.mp3");
    
    // Load new sound effects
    soundManager.loadSound("dramatic", "sounds/dramatic.mp3");
    soundManager.loadSound("eaglescream", "sounds/eaglescream.mp3");
    soundManager.loadSound("eagledeath", "sounds/eagledeath.mp3");
    soundManager.loadSound("quickdrawending", "sounds/quickdrawending.mp3");
    soundManager.loadSound("playerfall", "sounds/playerfall.mp3");
    soundManager.loadSound("ambience", "sounds/ambience.mp3");
    
    // Load gun sounds
    soundManager.loadSound("shot", "sounds/shot.mp3");
    soundManager.loadSound("revolverdraw", "sounds/revolverdraw.mp3");
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    soundManager.loadSound("shotgunempty", "sounds/shotgunempty.mp3");
    soundManager.loadSound("revolverholstering", "sounds/revolverholstering.mp3");
    
    // Load shotgun sounds
    soundManager.loadSound("shotgundraw", "sounds/shotgundraw.mp3");
    soundManager.loadSound("shotgunshot", "sounds/shotgunshot.mp3");
    soundManager.loadSound("shotgunreloading", "sounds/shotgunreloading.mp3");
    soundManager.loadSound("shotgunholstering", "sounds/shotgunholstering.mp3");
    
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    
    // Start background ambient music loop
    setTimeout(() => {
      soundManager.playSound("ambience", 0, 0.4, true); // Play at lower volume in a loop
    }, 1000); // Slight delay to ensure the sound is loaded
    
    // In parallel, initialize player identity
    // This will show the name prompt for first-time users if needed
    // but won't block the rest of the initialization
    const playerIdentityPromise = initPlayerIdentity().then(playerIdentity => {
      console.log(`Welcome back, ${playerIdentity.username}! Player ID: ${playerIdentity.id}`);
      
      // Check if this was a first-time user to determine when to show instructions
      const isFirstTimeUser = playerIdentity.lastLogin === playerIdentity.createdAt;
      
      // Verify identity with server (will be used in future server-side validation)
      return verifyIdentityWithServer(playerIdentity).then(verificationResult => {
        if (!verificationResult.verified) {
          console.warn('Identity verification failed, using local identity only');
        }
        
        // Expose player identity to window for easy access from other modules
        window.playerIdentity = playerIdentity;
        
        return playerIdentity;
      });
    });

    // Preload all visual effects to prevent FPS drops on first use
    if (!window.isMobile) {
      console.log("Preloading visual effects...");
      // Preload muzzle flash effect
      preloadMuzzleFlash(scene);
      // Preload smoke effect
      preloadSmokeEffect(scene);
      
      // Initialize a smoke ring effect pool for reuse
      for (let i = 0; i < 3; i++) {
        const smokeRing = new SmokeRingEffect(scene);
        smokeRing.active = false;
        // Preload resources to prevent fps drop on first use
        smokeRing.preload();
        smokeRings.push(smokeRing);
      }
      
      // Simulate a complete dummy shot cycle in a hidden area
      // This ensures all shaders are compiled and resources are allocated
      console.log("Pre-rendering a dummy shot to warm up rendering pipeline...");
      const dummyPosition = new THREE.Vector3(0, -1000, 0);
      const dummyDirection = new THREE.Vector3(0, 0, 1);
      
      // Create all effects that happen during a shot
      createMuzzleFlash(dummyPosition, dummyDirection, scene);
      createSmokeEffect(dummyPosition, dummyDirection, scene);
      
      // Create a few impact effects of different types
      createImpactEffect(dummyPosition, dummyDirection, scene, 'wood');
      createImpactEffect(dummyPosition, dummyDirection, scene, 'metal');
      createImpactEffect(dummyPosition, dummyDirection, scene, 'dirt');
      
      // Create a dummy bullet - but don't track it since this is just preloading
      const dummyBullet = new Bullet(dummyPosition, dummyDirection);
      scene.add(dummyBullet.mesh);
      // Remove after a short delay
      setTimeout(() => {
        scene.remove(dummyBullet.mesh);
      }, 100);
    }

    // Set up multiplayer manager to handle other players
    multiplayerManager = new MultiplayerManager(scene, soundManager, remotePlayers);
    
    // Wait for player identity to be resolved before continuing with network/player setup
    const playerIdentity = await playerIdentityPromise;
    
    // Initialize the phantom wallet adapter with network manager for NFT verification
    if (typeof phantomWalletAdapter !== 'undefined') {
      console.log('Initializing Phantom wallet adapter');
      phantomWalletAdapter.init(networkManager);
      
      // Listen for wallet connection events to apply skins
      document.addEventListener('walletConnected', (e) => {
        console.log('Wallet connected event received in main.js');
      });
    } else {
      console.warn('Phantom wallet adapter not available');
    }
    
    // Make multiplayerManager globally accessible
    window.multiplayerManager = multiplayerManager;

    // Create flying eagle that follows the camera
    window.flyingEagle = new FlyingEagle({
      scene: scene,
      camera: camera
    });
    
    // Set the default town center for the eagle to fly around
    const townCenter = new THREE.Vector3(0, 0, 0); // Center of the town
    window.flyingEagle.townCenter = townCenter;
    window.flyingEagle.setDefaultFlightPath();

    // Initialize the local player
    localPlayer = new Player({
      scene: scene,
      camera: camera,
      soundManager: soundManager,
      onShoot: handleLocalPlayerShoot  // callback for local shooting
    });
    // Make localPlayer globally accessible for hit updates.
    window.localPlayer = localPlayer;

    // Initialize UI elements - desktop weapon indicators
    createDesktopWeaponIndicators();
    
    // Initialize first-person controls
    const mobileControls = initInput(renderer, localPlayer, soundManager);
    
    // Make mobile controls globally accessible
    if (isMobileDevice()) {
      window.mobileControls = mobileControls;
    }
    
    // Make scene globally accessible for physics visualization
    window.scene = scene;

    // Function to check for nearby players for quickdraw on mobile
    window.checkNearestPlayerForQuickdraw = function(player) {
      if (!remotePlayers || !player) return null;
      
      const minDistance = 5; // Distance threshold to show invite button
      let nearestPlayer = null;
      let nearestDistance = Infinity;
      
      // Check all remote players
      for (const [id, remotePlayer] of remotePlayers.entries()) {
        // Skip if no position
        if (!remotePlayer || !remotePlayer.group || !remotePlayer.group.position) continue;
        
        // Calculate distance to remote player
        const distance = player.group.position.distanceTo(remotePlayer.group.position);
        
        // Update nearest player if closer
        if (distance < minDistance && distance < nearestDistance) {
          nearestPlayer = remotePlayer;
          nearestDistance = distance;
        }
      }
      
      return nearestPlayer;
    };

    // Initialize Quick Draw game mode after the local player is created
    quickDraw = new QuickDraw(scene, localPlayer, networkManager, soundManager);
    
    // Initialize drunkenness effect - pass both player and camera arguments
    const drunkennessEffect = new DrunkennessEffect(localPlayer, camera);
    console.log('Drunkenness effect initialized');
    
    // Initialize the QuickDraw game mode
    quickDraw.init();
    
    // Make quickDraw globally accessible for debugging
    window.quickDraw = quickDraw;
    
    // Share the main physics system with game modes
    quickDraw.physics = physics;
    
    // Make updateHealthUI globally accessible for the Quick Draw mode to use
    window.updateHealthUI = updateHealthUI;

    // Show connection status
    const networkStatus = document.createElement('div');
    networkStatus.id = 'network-status';
    networkStatus.textContent = 'Connecting...';
    document.getElementById('game-container').appendChild(networkStatus);

    // Update player count UI when server broadcasts the count.
    networkManager.onPlayerCount = (count) => {
      const playerCountEl = document.getElementById('player-count');
      if (playerCountEl) {
        playerCountEl.textContent = `Players: ${count}`;
      }
    };

    // Listen for network open/close
    networkManager.socket.addEventListener('open', () => {
      networkStatus.textContent = 'Connected';
      networkStatus.style.backgroundColor = 'rgba(0,128,0,0.5)';
      setTimeout(() => { networkStatus.style.opacity = '0'; }, 2000);
    });
    networkManager.socket.addEventListener('close', () => {
      networkStatus.textContent = 'Disconnected';
      networkStatus.style.backgroundColor = 'rgba(255,0,0,0.5)';
      networkStatus.style.opacity = '1';
    });

    // Listen for remote players shooting
    networkManager.onPlayerShoot = (playerId, bulletData, bulletId) => {
      handleRemotePlayerShoot(playerId, bulletData, bulletId);
    };

    // Anti-cheat: Listen for bullet impact notifications from server
    networkManager.onBulletImpact = (bulletId, hitType, targetId, position, hitZone) => {
      handleBulletImpact(bulletId, hitType, targetId, position, hitZone);
    };

    // Anti-cheat: Listen for position corrections from server
    networkManager.onPositionCorrection = (correctedPosition) => {
      if (localPlayer) {
        // Store the server position for reconciliation
        localPlayer.serverPosition = new THREE.Vector3(
          correctedPosition.x,
          correctedPosition.y,
          correctedPosition.z
        );
        localPlayer.isReconciling = true;
      }
    };
    
    // Train synchronization: Handle initial train state
    networkManager.onTrainInit = (data) => {
      // Import the train functions from scene.js
      import('./scene.js').then(sceneModule => {
        sceneModule.setTrainInitialState(data);
      });
    };
    
    // Train synchronization: Handle ongoing train state updates
    // We only process the first trainState message if we haven't received trainInit yet
    networkManager.onTrainState = (data) => {
      // Import the train functions from scene.js
      import('./scene.js').then(sceneModule => {
        sceneModule.updateTrainState(data);
      });
    };
    
    // Anti-cheat: Listen for server-initiated respawn
    networkManager.onRespawn = (position, health, bullets) => {
      if (localPlayer) {
        // Set position
        localPlayer.group.position.copy(position);
        localPlayer.previousPosition.copy(position);
        
        // Update health and bullets
        localPlayer.health = health || 100;
        localPlayer.bullets = bullets || localPlayer.maxBullets;
        
        // Reset states
        localPlayer.isReloading = false;
        localPlayer.isAiming = false;
        localPlayer.velocity.y = 0;
        localPlayer.canAim = true;
        
        // Update UI
        updateHealthUI(localPlayer);
        updateAmmoUI(localPlayer);
      }
    };

    // Handle local player death
    networkManager.onDeath = (killerId) => {
      console.log(`You were killed by player ${killerId}`);
      
      // Skip death message if in QuickDraw duel (defeat message is shown instead)
      if (window.quickDraw && window.quickDraw.inDuel) {
        console.log('In QuickDraw duel, skipping automatic death message');
        return;
      }
      
      // Show death message
      const deathMessage = document.createElement('div');
      deathMessage.innerText = 'YOU DIED';
      deathMessage.style.position = 'fixed';
      deathMessage.style.top = '50%';
      deathMessage.style.left = '50%';
      deathMessage.style.transform = 'translate(-50%, -50%)';
      deathMessage.style.color = '#FF0000';
      deathMessage.style.fontSize = '36px';
      deathMessage.style.fontWeight = 'bold';
      deathMessage.style.zIndex = '1000';
      document.getElementById('game-container').appendChild(deathMessage);
      
      // Create a red overlay effect
      const deathOverlay = document.createElement('div');
      deathOverlay.style.position = 'fixed';
      deathOverlay.style.top = '0';
      deathOverlay.style.left = '0';
      deathOverlay.style.width = '100%';
      deathOverlay.style.height = '100%';
      deathOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
      deathOverlay.style.zIndex = '999';
      document.getElementById('game-container').appendChild(deathOverlay);
      
      // Store original mouse handler for later restoration
      const origMouseMove = document.onmousemove;
      
      // Disable player controls during death animation
      if (localPlayer) {
        localPlayer.canMove = false;
        localPlayer.canAim = false;
        
        // Save original camera rotation
        const originalRotation = localPlayer.camera.rotation.clone();
        
        // Apply death camera rotation - rotate camera to look down at the ground
        // Start a smooth rotation animation from current position to looking down
        const deathCameraDuration = 1000; // 1 second for the rotation animation
        const startTime = Date.now();
        const targetRotationX = Math.PI / 2; // Looking down at the ground (90 degrees) instead of up
        
        // Create an animation function that rotates the camera over time
        const rotateCameraUp = () => {
          const elapsed = Date.now() - startTime;
          const progress = Math.min(elapsed / deathCameraDuration, 1);
          
          // Use an easing function (ease-out) for smoother animation
          const easeOut = 1 - Math.pow(1 - progress, 2);
          
          // Interpolate between original and target rotation
          localPlayer.camera.rotation.x = originalRotation.x * (1 - easeOut) + targetRotationX * easeOut;
          
          // Continue the animation until complete
          if (progress < 1) {
            requestAnimationFrame(rotateCameraUp);
          }
        };
        
        // Start the camera rotation animation
        rotateCameraUp();
        
        // Disable mouse look temporarily to prevent camera movement
        document.onmousemove = (e) => {
          // Block mouse movement during death animation
          e.stopPropagation();
          return false;
        };
        
        // Play death animation on local player model if it exists
        if (localPlayer.model && typeof localPlayer.model.playDeathAnimation === 'function') {
          localPlayer.model.playDeathAnimation();
        }
        
        // Play death sound
        if (localPlayer.soundManager) {
          localPlayer.soundManager.playSound("playerfall", 0, 0.8);
        }
      }
      
      // Remove message and overlay after animation
      // Also restore mouse control
      setTimeout(() => {
        if (deathMessage.parentNode) {
          deathMessage.parentNode.removeChild(deathMessage);
        }
        if (deathOverlay.parentNode) {
          deathOverlay.parentNode.removeChild(deathOverlay);
        }
        
        // Restore mouse movement control
        document.onmousemove = origMouseMove;
      }, 2000); // Match the server respawn delay
    };
    
    // Handle when the local player kills someone
    networkManager.onKill = (targetId) => {
      console.log(`You killed player ${targetId}`);
      
      // Skip kill message if in QuickDraw duel (victory message is shown instead)
      if (window.quickDraw && window.quickDraw.inDuel) {
        console.log('In QuickDraw duel, skipping kill message');
        return;
      }
      
      // Show kill message
      const killMessage = document.createElement('div');
      killMessage.innerText = 'KILL!';
      killMessage.style.position = 'fixed';
      killMessage.style.top = '50%';
      killMessage.style.left = '50%';
      killMessage.style.transform = 'translate(-50%, -50%)';
      killMessage.style.color = '#00FF00';
      killMessage.style.fontSize = '36px';
      killMessage.style.fontWeight = 'bold';
      killMessage.style.zIndex = '1000';
      document.getElementById('game-container').appendChild(killMessage);
      
      // Remove message after a short time
      setTimeout(() => {
        if (killMessage.parentNode) {
          killMessage.parentNode.removeChild(killMessage);
        }
      }, 1500);
    };

    // Listen for updates to the remotePlayers map so we can refresh the master map
    multiplayerManager.onRemotePlayersUpdated = () => {
      updatePlayersMap();
      
      // If debug mode is on, make sure new players have hit zone debug boxes
      if (window.showHitZoneDebug && physics && physics.debugMode) {
        setTimeout(() => {
          if (physics.refreshHitZoneDebug && typeof physics.refreshHitZoneDebug === 'function') {
            physics.refreshHitZoneDebug();
          }
        }, 100);
      }
    };

    // Add a keyboard handler for showing town colliders (T key)
    window.addEventListener('keydown', function(event) {
      // Toggle town collider visualization with T key
      if (event.code === 'KeyT') {
        window.showTownColliders = !window.showTownColliders;
        
        // Show/hide collider meshes
        if (window.townColliders) {
          window.townColliders.forEach(({ node }) => {
            node.visible = window.showTownColliders;
          });
        }
        
        console.log(`Town collider visualization: ${window.showTownColliders ? 'ENABLED' : 'DISABLED'}`);
      }
      
      // Toggle debug mode with P key
      if (event.code === 'KeyP') {
        window.debugMode = !window.debugMode;
        
        // Synchronize physics debug mode with window debug mode
        if (physics) {
          physics.setDebugMode(window.debugMode);
        }
        
        // Set the hit zone debug flag
        window.showHitZoneDebug = window.debugMode;
        
        console.log(`Debug mode: ${window.debugMode ? 'ENABLED' : 'DISABLED'}`);
        
        // Update debug visualization
        updateDebugVisualization();
        
        // If turning on debug mode, update hit zone debug for all existing players with a delay
        if (window.debugMode) {
          setTimeout(() => {
            // First trigger hit zone debugging on the local player
            if (localPlayer && localPlayer.model && typeof localPlayer.model.createHitZoneVisualizers === 'function') {
              // Use the new method for visualization
              localPlayer.model.createHitZoneVisualizers(true);
            }
            
            // Then create debug boxes for all remote players
            for (const [playerId, remotePlayer] of remotePlayers.entries()) {
              if (remotePlayer && typeof remotePlayer.createHitZoneVisualizers === 'function') {
                // Use the new method
                remotePlayer.createHitZoneVisualizers(true);
              }
            }
            
            console.log("Hit zone debug boxes created for all players");
          }, 50);
        }
      }
      
      // Reload weapon with the R key
      if (event.code === 'KeyR' && !quickDraw.inDuel) {
        localPlayer.startReload();
      }
      
      // No longer spawn bots with the B key as NPCs are now server-controlled
      if (event.code === 'KeyB' && !event.ctrlKey && !event.shiftKey) {
        console.log("NPCs are now server-controlled and cannot be spawned from the client");
      }
    });

    // Make Bullet constructor globally available for hit zone debug creation
    window.Bullet = Bullet;
    
    // Install the improved hitbox system (after Bullet is globally available)
    initImprovedHitboxSystem();
    
    // Add debug command to console for troubleshooting
    window.printHitboxDebugInfo = function() {
      console.log("--- Hitbox System Debug Info ---");
      if (window.playersMap) {
        console.log(`Players map size: ${window.playersMap.size}`);
        window.playersMap.forEach((model, id) => {
          console.log(`Player ${id}:`, {
            hasCheckBulletHit: typeof model.checkBulletHit === 'function',
            headHitbox: model.headHitbox ? 'present' : 'missing',
            bodyHitbox: model.bodyHitbox ? 'present' : 'missing',
            limbsHitbox: model.limbsHitbox ? 'present' : 'missing'
          });
        });
      } else {
        console.log("Players map not found");
      }
    };
    
    // Initialize chat system
    initChat(networkManager);
    
    // Set up chat message handler
    networkManager.onChatMessage = (senderId, username, message) => {
      // Ignore messages from ourselves to prevent duplicates
      if (senderId === localPlayer.id) return;
      
      // Only handle messages from other players
      handleChatMessage({ username, message });
    };

    // Listen for skin permission updates
    networkManager.handleMessage = (originalHandleMessage => {
      return function(message) {
        // Call the original handler first
        originalHandleMessage.call(this, message);
        
        // Handle skin permission updates
        if (message.type === 'skinPermissionUpdate') {
          // Store the skin permission update in a global cache to prevent duplicate processing
          if (!window.skinPermissionCache) {
            window.skinPermissionCache = new Map();
          }
          
          // Create a cache key for this update
          const updateKey = JSON.stringify(message.skins);
          
          // Check if we've already processed this exact update
          if (window.skinPermissionCache.has(updateKey)) {
            console.log('Skipping duplicate skin permission update');
            return;
          }
          
          // Store this update in the cache
          window.skinPermissionCache.set(updateKey, true);
          
          console.log('Received skin permission update:', message);
          
          // Update local player's skin permissions
          if (localPlayer && localPlayer.model) {
            console.log('Updating skin permissions for local player model');
            localPlayer.model.updateSkinPermissions(message.skins);
            
            // Apply banana skin if permission granted
            if (message.skins.bananaSkin) {
              console.log('Local player has bananaSkin permission, applying skin to model');
              localPlayer.model.updateSkin('bananaSkin');
            }
          } else {
            console.warn('Could not update local player model - model not available');
          }
          
          // Update viewmodel skin to match
          if (localPlayer && localPlayer.viewmodel) {
            console.log('Updating skin permissions for viewmodel');
            localPlayer.viewmodel.updateSkinPermissions(message.skins);
            
            // Apply banana skin if permission granted
            if (message.skins.bananaSkin) {
              console.log('Local player has bananaSkin permission, applying skin to viewmodel');
              localPlayer.viewmodel.updateSkin('bananaSkin');
            }
          } else {
            console.warn('Could not update viewmodel - viewmodel not available');
          }
        }
      };
    })(networkManager.handleMessage);
    
    // Set up separate handler for skin updates
    networkManager.onPlayerSkinUpdate = (message) => {
      // Create a cache key for this update
      const playerUpdateKey = `${message.playerId}_${JSON.stringify(message.skins)}`;
      
      // Check if we've already processed this exact update
      if (window.skinPermissionCache && window.skinPermissionCache.has(playerUpdateKey)) {
        console.log(`Skipping duplicate skin update for player ${message.playerId}`);
        return;
      }
      
      // Store this update in the cache
      if (!window.skinPermissionCache) {
        window.skinPermissionCache = new Map();
      }
      window.skinPermissionCache.set(playerUpdateKey, true);
      
      console.log('Received player skin update:', message);
      
      const remotePlayer = remotePlayers.get(message.playerId);
      if (remotePlayer) {
        console.log(`Updating skin permissions for remote player ${message.playerId}`);
        
        // First, update the permissions in the player model
        remotePlayer.updateSkinPermissions(message.skins);
        
        // Apply banana skin if permission granted
        if (message.skins.bananaSkin) {
          console.log(`Remote player ${message.playerId} has bananaSkin permission, applying skin`);
          
          // Force the skinPermission to be set directly as well (to avoid race condition)
          remotePlayer.skinPermissions.bananaSkin = true;
          
          // Apply the skin
          if (remotePlayer.activeSkin !== 'bananaSkin') {
            remotePlayer.updateSkin('bananaSkin');
          } else {
            console.log(`Skin already applied to player ${message.playerId}`);
          }
          
          // Store skin state to prevent redundant updates in the player model
          if (!remotePlayer._cachedNetworkData) {
            remotePlayer._cachedNetworkData = {};
          }
          remotePlayer._cachedNetworkData.skins = message.skins;
          remotePlayer._initialSkinApplied = true;
          remotePlayer._lastSkinUpdate = JSON.stringify(message.skins);
        }
      } else {
        console.warn(`Could not update remote player ${message.playerId} - player not found in remotePlayers map`);
      }
    };

    // Start the animation loop
    animate(0);
    
    // Show game instructions for all users, first-time users will see it after name entry
    showGameInstructions();
    
    // Done loading, hide the loading screen
    setTimeout(() => {
      const loadingScreen = document.getElementById('loading-screen');
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
    }, 500);
    
  } catch (error) {
    console.error('Error during initialization:', error);
    // Show a user-friendly error message
    const errorElement = document.createElement('div');
    errorElement.className = 'error-message';
    errorElement.textContent = 'Failed to initialize the game. Please try refreshing the page.';
    document.body.appendChild(errorElement);
  }
}

/**
 * The main animation loop.
 */
function animate(time) {
  requestAnimationFrame(animate);
  const deltaTime = (time - lastTime) / 1000;
  lastTime = time;

  // Update physics system
  if (physics) {
    physics.update(deltaTime);
  }

  // Update local player
  localPlayer.update(deltaTime);
  
  // Update nearby NPCs for interaction
  if (npcManager && npcManager.instance) {
    npcManager.instance.updateNearbyNpcs(localPlayer);
  }
  
  // Update remote players (animations, movement interpolation, etc.)
  multiplayerManager.update(deltaTime);
  
  // Update Quick Draw game mode
  if (quickDraw) {
    quickDraw.update(deltaTime);
    
    // Camera safety check for QuickDraw
    if (quickDraw.duelState === 'draw') {
      // In draw phase, ALWAYS use the player's camera directly
      if (localPlayer && localPlayer.camera) {
        // For render call below - temporarily save which camera to use
        window._renderWithCamera = localPlayer.camera;
        
        // Also update renderer references to be extra safe
        window.renderer.camera = localPlayer.camera;
        if (window.renderer.instance) {
          window.renderer.instance.camera = localPlayer.camera;
        }
      }
    }
  }

  // Update smoke ring effects
  for (let i = smokeRings.length - 1; i >= 0; i--) {
    // If the smoke ring is inactive after update, we can remove it
    // But keep at least 3 in the pool for reuse
    if (!smokeRings[i].update(deltaTime) && smokeRings.length > 3) {
      smokeRings[i].dispose();
      smokeRings.splice(i, 1);
    }
  }

  // Update bullets (both local & remote)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    const result = bullet.update(deltaTime, null, scene, playersMap);
    if (!result.active) {
      // If bullet hit something or traveled too far
      if (result.hit && result.hit.type === 'player') {
        // Use logger for bullet hits
        if (window.logger) {
          window.logger.info(`Bullet hit player ${result.hit.playerId} in the ${result.hit.zone || 'body'} for ${result.hit.damage || 'unknown'} damage`);
        }
        
        // Set the last hit zone for server validation
        if (bullet.bulletId !== null && result.hit.zone) {
          bullet.setLastHitZone(result.hit.zone);
        }
      }
      scene.remove(bullet.mesh);
      bullets.splice(i, 1);
      
      // Anti-cheat: Remove from bullet map if it has an ID
      if (bullet.bulletId !== null) {
        bulletMap.delete(bullet.bulletId);
      }
    }
  }

  // Update FPS display
  updateFPS(renderer, camera, deltaTime);

  // Update flying eagle if it exists
  if (window.flyingEagle) {
    window.flyingEagle.update(deltaTime);
  }

  // Update NPCs through npc manager
  if (window.npcManager) {
    // NPC manager handles its own internal updates
  }

  // CAMERA SELECTION LOGIC:
  // 1. First priority: Use special flag camera if set in QuickDraw draw phase
  // 2. Second priority: Use window.renderer.camera
  // 3. Fallback: Use default camera
  let renderCamera;
  
  if (window._renderWithCamera) {
    // Use the camera explicitly set by QuickDraw draw phase
    renderCamera = window._renderWithCamera;
    // Clear the flag after use
    window._renderWithCamera = null;
  } else if (window.renderer && window.renderer.camera) {
    // Use the window.renderer camera
    renderCamera = window.renderer.camera;
  } else {
    // Use default camera as last resort
    renderCamera = camera;
  }
  
  // Render with selected camera
  renderer.render(scene, renderCamera);
}

/**
 * Called whenever the local player fires.
 * Spawns a bullet locally and also notifies the server.
 * @param {THREE.Vector3} bulletStart 
 * @param {THREE.Vector3} shootDir 
 */
function handleLocalPlayerShoot(bulletStart, shootDir) {
  // Spawn bullet in our local game (client-side prediction)
  const bullet = spawnBullet(localPlayer.id, bulletStart, shootDir);
  
  // Create an array to track local bullet IDs if it doesn't exist
  if (!window.localPlayer.lastFiredBulletIds) {
    window.localPlayer.lastFiredBulletIds = [];
  }
  
  // Add this bullet's ID to our tracking array (if it has one)
  if (bullet && bullet.bulletId) {
    window.localPlayer.lastFiredBulletIds.push(bullet.bulletId);
    
    // Keep the array size manageable (only store last 20 bullet IDs)
    if (window.localPlayer.lastFiredBulletIds.length > 20) {
      window.localPlayer.lastFiredBulletIds.shift();
    }
  }

  // Send bullet data over network
  networkManager.sendShoot({
    position: {
      x: bulletStart.x,
      y: bulletStart.y,
      z: bulletStart.z
    },
    direction: {
      x: shootDir.x,
      y: shootDir.y,
      z: shootDir.z
    }
  });
  
  // Add this section to check for Quick Draw hit
  if (quickDraw && quickDraw.inDuel && quickDraw.duelState === 'draw' && quickDraw.duelOpponentId) {
    // We'll handle this in the bullet collision code instead
  }

  // Create smoke ring effect - only if not mobile
  if (!window.isMobile) {
    const availableSmokeRing = smokeRings.find(ring => !ring.active);
    if (availableSmokeRing) {
      // Get the effect positioning options from the viewmodel if available
      let smokeRingOptions = null;
      if (localPlayer.viewmodel && localPlayer.viewmodel.EFFECTS && localPlayer.viewmodel.EFFECTS.SMOKE_RING) {
        smokeRingOptions = localPlayer.viewmodel.EFFECTS.SMOKE_RING;
      }
      availableSmokeRing.create(bulletStart.clone(), shootDir.clone(), smokeRingOptions);
    }
  }
}

/**
 * Called whenever a remote player fires (based on network data).
 * @param {number} playerId 
 * @param {Object} bulletData 
 * @param {string|number} bulletId - Server-assigned bullet ID
 */
function handleRemotePlayerShoot(playerId, bulletData, bulletId) {
  // Check if this is a shotgun pellet from the metadata
  const isShotgunPellet = bulletData.isShotgunPellet || false;
  
  // Skip effect creation if this is our own shot coming back from the server
  if (playerId === localPlayer.id) {
    // Just create the bullet with the server's ID without spawning effects again
    const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
    const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);
    
    const bullet = new Bullet(startPos, dir, bulletId, isShotgunPellet);
    
    // Track this bullet ID so we can identify it when impact comes back
    if (!window.localPlayer.lastFiredBulletIds) {
      window.localPlayer.lastFiredBulletIds = [];
    }
    window.localPlayer.lastFiredBulletIds.push(bulletId);
    
    // Keep the array size manageable
    if (window.localPlayer.lastFiredBulletIds.length > 20) {
      window.localPlayer.lastFiredBulletIds.shift();
    }
    
    // Add to bullets array but skip the sound and effects
    bullet.isLocalBullet = true;
    bullet.sourcePlayerId = playerId;
    bullets.push(bullet);
    bulletMap.set(bulletId, bullet);
    
    return;
  }
  
  // For other players' shots, spawn the bullet with full effects
  const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
  const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);
  
  spawnBullet(playerId, startPos, dir, bulletId, isShotgunPellet);
}

/**
 * Handles a bullet impact notification from the server.
 * @param {string|number} bulletId - The bullet ID
 * @param {string} hitType - Type of impact (player, npc, ground, etc.)
 * @param {string|number|null} targetId - Target ID (for player hits)
 * @param {Object} position - Impact position {x, y, z}
 * @param {string} hitZone - Hit zone (head, body, limbs)
 */
function handleBulletImpact(bulletId, hitType, targetId, position, hitZone) {
  // Convert position to THREE.Vector3 if provided
  let impactPosition = null;
  if (position) {
    impactPosition = new THREE.Vector3(position.x, position.y, position.z);
  }
  
  // Find the bullet in our bullet map
  const bullet = bulletMap.get(bulletId);
  
  if (bullet) {
    // Store hit zone information for potential headshot sound
    if (hitZone) {
      bullet.setLastHitZone(hitZone);
    }
    
    // Create appropriate visual effect and deactivate bullet
    const result = bullet.handleServerImpact(hitType, targetId, impactPosition, scene);
    
    // Find and remove bullet from main array
    const bulletIndex = bullets.findIndex(b => b === bullet);
    if (bulletIndex !== -1) {
      scene.remove(bullet.mesh);
      bullets.splice(bulletIndex, 1);
    }
    
    // Remove from bullet map
    bulletMap.delete(bulletId);
  } else {
    // Use logger instead of console.log
    if (window.logger) {
      window.logger.debug(`Bullet ${bulletId} not found for impact event`);
    }
    
    // If we don't have the bullet object, still create visual effect at impact position
    if (impactPosition) {
      // Create a default direction vector (upward)
      const defaultDir = new THREE.Vector3(0, 1, 0);
      createImpactEffect(impactPosition, defaultDir, scene, hitType);
      
      // Only play headshot sound if it was a headshot from another player (not local)
      // Prevents double hitmarker sounds when a bullet is not found for a local hit
      const isFromLocalPlayer = (window.localPlayer && 
                              window.localPlayer.lastFiredBulletIds && 
                              window.localPlayer.lastFiredBulletIds.includes(bulletId));
      
      if (hitZone === 'head' && localPlayer && localPlayer.soundManager && !isFromLocalPlayer) {
        // For headshots, play both a spatialized and a direct sound for better feedback
        // Direct non-spatialized sound for clear feedback
        localPlayer.soundManager.playSound("headshotmarker", 100, 0.8);
        // Spatial sound for immersion
        localPlayer.soundManager.playSoundAt("headshotmarker", impactPosition, 100, 0.5, false);
      }
    }
  }
}

/**
 * Actually spawns a bullet in the world, complete with muzzle flash, etc.
 * @param {string|number} sourcePlayerId 
 * @param {THREE.Vector3} position 
 * @param {THREE.Vector3} direction 
 * @param {string|number} bulletId - Optional server-assigned ID (for remote bullets)
 * @param {boolean} isShotgunPellet - Whether this bullet is a shotgun pellet
 * @returns {Bullet} The created bullet object
 */
function spawnBullet(sourcePlayerId, position, direction, bulletId = null, isShotgunPellet = false) {
  // For local player, determine if this is a shotgun pellet based on their weapon
  const isLocalShotgunPellet = sourcePlayerId === localPlayer.id && localPlayer.activeWeapon === 'shotgun';
  
  // Use the provided flag or infer from local player weapon
  const isPellet = isShotgunPellet || isLocalShotgunPellet;
  
  const bullet = new Bullet(position, direction, bulletId, isPellet);
  bullet.setSourcePlayer(sourcePlayerId);
  
  // Make shotgun pellets smaller
  if (isPellet) {
    bullet.mesh.scale.set(0.5, 0.5, 0.5);
  }
  
  bullets.push(bullet);
  scene.add(bullet.mesh);
  
  // Anti-cheat: Store bullet in map if it has a bulletId
  if (bulletId !== null) {
    bulletMap.set(bulletId, bullet);
  }

  // Get the effect positioning options from the local player viewmodel if available
  let muzzleFlashOptions = null;
  let smokeEffectOptions = null;
  
  // Only use viewmodel options for the local player's effects
  if (sourcePlayerId === localPlayer.id && localPlayer.viewmodel && localPlayer.viewmodel.EFFECTS) {
    if (localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH) {
      muzzleFlashOptions = localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH;
    }
    if (localPlayer.viewmodel.EFFECTS.SMOKE_RING) {
      smokeEffectOptions = localPlayer.viewmodel.EFFECTS.SMOKE_RING;
    }
  }

  // For shotgun pellets after the first one, skip visual effects to avoid overwhelming 
  // the system with too many effects at once
  const showEffects = !isPellet || (isPellet && bullets.length % 3 === 0);
  
  // Visual effects - only for non-pellets or occasionally for pellets
  if (showEffects) {
    createMuzzleFlash(position, direction, scene, muzzleFlashOptions);
    createSmokeEffect(position, direction, scene);
    
    // Add smoke ring effect
    let smokeRing = null;
    
    // Try to reuse an inactive smoke ring first
    for (let i = 0; i < smokeRings.length; i++) {
      if (!smokeRings[i].active) {
        smokeRing = smokeRings[i];
        break;
      }
    }
    
    // If no inactive smoke ring found, create a new one if under the limit
    if (!smokeRing && smokeRings.length < maxSmokeRings) {
      smokeRing = new SmokeRingEffect(scene);
      smokeRings.push(smokeRing);
    }
    
    // Activate the smoke ring
    if (smokeRing) {
      smokeRing.create(position, direction, smokeEffectOptions);
    }
    
    // Sound effects - only play for non-pellets or the first pellet
    if (!isPellet || (isPellet && bullets.length <= 1)) {
      if (localPlayer.soundManager) {
        // Determine weapon type - try to get from source player or fallback to local player
        let weaponType = 'revolver'; // Default fallback
        
        // If it's the local player, use their active weapon
        if (sourcePlayerId === localPlayer.id) {
          weaponType = localPlayer.activeWeapon;
        } 
        // If it's a remote player, try to get their weapon type from the remote players map
        else if (remotePlayers && remotePlayers.has(sourcePlayerId)) {
          const remotePlayer = remotePlayers.get(sourcePlayerId);
          if (remotePlayer && remotePlayer.activeWeapon) {
            weaponType = remotePlayer.activeWeapon;
          }
        }
        
        // Use appropriate sound based on weapon type
        const soundName = weaponType === 'shotgun' ? "shotgunshot" : "shot";
        
        if (sourcePlayerId === localPlayer.id) {
          // Special handling for mobile to prevent audio duplication/sync issues
          if (window.isMobile) {
            // On mobile, use immediate playback with no delay and higher volume
            // This ensures only one clean sound plays
            localPlayer.soundManager.playSound(soundName, 0, 1.0);
          } else {
            // On desktop, play a non-spatialized gunshot for the local player
            localPlayer.soundManager.playSound(soundName, 50, 1.0);
          }
        } else if (!window.isMobile) {
          // For remote players on desktop, use full spatialized audio
          localPlayer.soundManager.playSoundAt(soundName, position, 50, 0.8);
        } else {
          // For remote players on mobile, use non-spatialized audio to prevent issues
          localPlayer.soundManager.playSound(soundName, 0, 0.8);
        }
      }
    }
  }
  
  // Return the bullet
  return bullet;
}

/**
 * Rebuilds a master map of all remote players.
 * This map is passed to bullet collision checks so bullets can hit any remote player.
 */
function updatePlayersMap() {
  playersMap.clear();
  // Only add remote players so that the local (shooter's) model isn't processed in bullet collisions.
  for (const [pid, remoteModel] of remotePlayers.entries()) {
    playersMap.set(pid, remoteModel);
  }
}

function showGameInstructions() {
  // Determine if on mobile or desktop
  const isMobile = window.isMobile || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Set dimensions based on device type
  const bannerWidth = isMobile ? '250px' : '1000px'; // Wider for desktop to accommodate two images
  const bannerHeight = isMobile ? '250px' : '500px';
  const startPosition = isMobile ? '-250px' : '-500px';
  
  // Create the instruction banner element
  const instructionBanner = document.createElement('div');
  instructionBanner.id = 'instruction-banner';
  instructionBanner.style.position = 'fixed';
  instructionBanner.style.left = '50%';
  instructionBanner.style.transform = 'translateX(-50%)';
  instructionBanner.style.width = bannerWidth;
  instructionBanner.style.height = bannerHeight;
  instructionBanner.style.zIndex = '2000';
  instructionBanner.style.transition = 'bottom 0.5s ease-out';
  instructionBanner.style.bottom = startPosition; // Start completely off-screen
  instructionBanner.style.display = 'flex'; // Use flex for side-by-side layout
  instructionBanner.style.justifyContent = 'center'; // Center the images
  
  if (isMobile) {
    // For mobile, just add the single mobile manual image
    const instructionImage = document.createElement('img');
    instructionImage.src = 'models/mobilemanual.png';
    instructionImage.style.width = '100%';
    instructionImage.style.height = '100%';
    instructionImage.style.objectFit = 'contain';
    instructionBanner.appendChild(instructionImage);
  } else {
    // For desktop, add both images side by side
    const desktopManualImage = document.createElement('img');
    desktopManualImage.src = 'models/desktopmanual.png';
    desktopManualImage.style.width = '50%';
    desktopManualImage.style.height = '100%';
    desktopManualImage.style.objectFit = 'contain';
    
    const trackpadManualImage = document.createElement('img');
    trackpadManualImage.src = 'models/trackpadmanual.png';
    trackpadManualImage.style.width = '50%';
    trackpadManualImage.style.height = '100%';
    trackpadManualImage.style.objectFit = 'contain';
    
    // Add both images to banner
    instructionBanner.appendChild(desktopManualImage);
    instructionBanner.appendChild(trackpadManualImage);
  }
  
  // Add banner to game container
  document.getElementById('game-container').appendChild(instructionBanner);
  
  // Animate the banner sliding in after a short delay
  setTimeout(() => {
    // Slide up to show the full image
    instructionBanner.style.bottom = '0px';
  }, 100);
  
  // Global function to remove instructions
  window.removeInstructions = () => {
    // Animate the banner sliding out
    instructionBanner.style.bottom = startPosition;
    
    // Remove from DOM after animation completes
    setTimeout(() => {
      if (instructionBanner.parentNode) {
        instructionBanner.parentNode.removeChild(instructionBanner);
      }
    }, 500);
  };
  
  // Add event listener to close banner on any click
  document.addEventListener('click', window.removeInstructions, {once: true});
  document.addEventListener('touchstart', window.removeInstructions, {once: true, passive: false});
}

/**
 * Updates debug visualization for all players.
 * Called when debug mode is toggled.
 */
function updateDebugVisualization() {
  // Local player visualization
  if (localPlayer && localPlayer.model) {
    if (typeof localPlayer.model.createHitZoneVisualizers === 'function') {
      localPlayer.model.createHitZoneVisualizers(window.debugMode);
    }
    
    // Clean up old helpers if debug mode is off
    if (!window.debugMode) {
      const helpers = ["headHelper", "bodyHelper", "leftLegHelper", "rightLegHelper"];
      
      helpers.forEach(helper => {
        if (localPlayer.model[helper]) {
          localPlayer.model.group.remove(localPlayer.model[helper]);
          localPlayer.model[helper] = null;
        }
      });
    }
  }
  
  // Remote players visualization
  if (remotePlayers && remotePlayers.size > 0) {
    remotePlayers.forEach((model, id) => {
      if (model && typeof model.createHitZoneVisualizers === 'function') {
        model.createHitZoneVisualizers(window.debugMode);
        
        // Clean up old helpers if debug mode is off
        if (!window.debugMode) {
          const helpers = ["headHelper", "bodyHelper", "leftLegHelper", "rightLegHelper"];
          
          helpers.forEach(helper => {
            if (model[helper]) {
              model.group.remove(model[helper]);
              model[helper] = null;
            }
          });
        }
      }
    });
  }
  
  // Also check the playersMap (which might contain additional players)
  if (window.playersMap) {
    window.playersMap.forEach((model, id) => {
      if (model && typeof model.createHitZoneVisualizers === 'function' &&
          !remotePlayers.has(id)) { // Only process if not already processed above
        model.createHitZoneVisualizers(window.debugMode);
        
        // Clean up old helpers if debug mode is off
        if (!window.debugMode) {
          const helpers = ["headHelper", "bodyHelper", "leftLegHelper", "rightLegHelper"];
          
          helpers.forEach(helper => {
            if (model[helper]) {
              model.group.remove(model[helper]);
              model[helper] = null;
            }
          });
        }
      }
    });
  }
  
  // Sync physics debug state
  if (physics) {
    physics.setDebugMode(window.debugMode);
  }
}

// Handle window unload to cleanup game mode resources
window.addEventListener('beforeunload', () => {
  if (quickDraw) {
    quickDraw.cleanup();
  }
  
  if (physics) {
    physics.cleanup();
  }
  
  // Clean up smoke rings
  for (let i = 0; i < smokeRings.length; i++) {
    smokeRings[i].dispose();
  }
  smokeRings = [];
});

/**
 * Initializes the improved hitbox detection system.
 * This completely overwrites the old checkPlayerHitZones method in Bullet.prototype.
 */
function initImprovedHitboxSystem() {
  if (!window.Bullet || !window.Bullet.prototype) {
    console.error("Cannot install improved hitbox system - Bullet class not available");
    return false;
  }

  // Store a reference to the original method for backup
  const originalCheckPlayerHitZones = window.Bullet.prototype.checkPlayerHitZones;

  // Replace the checkPlayerHitZones method with our improved version
  window.Bullet.prototype.checkPlayerHitZones = function(playerObj, bulletPos) {
    // Better local player detection (handle both Player objects and models)
    if (playerObj === localPlayer) {
      if (localPlayer.model && typeof localPlayer.model.checkBulletHit === 'function') {
        return localPlayer.model.checkBulletHit(bulletPos);
      }
    }
    
    // For ThirdPersonModel players, use their built-in hit detection
    if (playerObj && typeof playerObj.checkBulletHit === 'function') {
      return playerObj.checkBulletHit(bulletPos);
    }
    
    // For remote players in the players map
    if (window.playersMap && playerObj.id) {
      const playerModel = window.playersMap.get(playerObj.id);
      if (playerModel && typeof playerModel.checkBulletHit === 'function') {
        return playerModel.checkBulletHit(bulletPos);
      }
    }
    
    // Local player might have a model reference
    if (playerObj.model && typeof playerObj.model.checkBulletHit === 'function') {
      return playerObj.model.checkBulletHit(bulletPos);
    }
    
    // Special case for QuickDraw mode
    if (window.quickDraw && window.quickDraw.inDuel) {
      const opponentId = window.quickDraw.duelOpponentId;
      if (opponentId && window.playersMap) {
        const opponentModel = window.playersMap.get(opponentId.toString());
        if (opponentModel && typeof opponentModel.checkBulletHit === 'function') {
          return opponentModel.checkBulletHit(bulletPos);
        }
      }
    }
    
    // Last resort: fall back to original implementation
    console.warn("Using fallback hit detection for player", playerObj);
    return originalCheckPlayerHitZones.call(this, playerObj, bulletPos);
  };

  // We also need to disable the old hitzone debug visualization
  // This will prevent the old hitboxes from appearing during gameplay
  window.Bullet.prototype.createHitZoneDebugBoxes = function() {
    // Do nothing - this effectively disables the old debug boxes
  };

  console.log("✅ Improved hitbox system successfully installed");
  return true;
}

/**
 * Setup viewport detection and handling, especially for iOS devices
 * where fullscreen is not available by default
 */
function setupViewportHandling() {
  // Store initial viewport dimensions
  updateViewportDimensions();
  
  // Listen for orientation changes and resize events
  window.addEventListener('orientationchange', () => {
    // Small delay to allow browser to complete orientation change
    setTimeout(updateViewportDimensions, 300);
  });
  
  window.addEventListener('resize', () => {
    updateViewportDimensions();
  });
  
  // Initial call to apply any needed viewport adjustments
  applyViewportAdjustments();
  
  // Add keyboard shortcut for toggling debug mode (Alt+D)
  window.addEventListener('keydown', (e) => {
    if (e.altKey && e.key === 'd') {
      window.debugMode = !window.debugMode;
      console.log(`Debug mode ${window.debugMode ? 'enabled' : 'disabled'}`);
      
      // When debug mode is enabled, show a small indicator
      let debugIndicator = document.getElementById('debug-indicator');
      if (window.debugMode) {
        if (!debugIndicator) {
          debugIndicator = document.createElement('div');
          debugIndicator.id = 'debug-indicator';
          debugIndicator.style.position = 'fixed';
          debugIndicator.style.top = '10px';
          debugIndicator.style.right = '10px';
          debugIndicator.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
          debugIndicator.style.color = 'white';
          debugIndicator.style.padding = '5px';
          debugIndicator.style.borderRadius = '3px';
          debugIndicator.style.fontSize = '12px';
          debugIndicator.style.zIndex = '1000';
          document.body.appendChild(debugIndicator);
        }
        debugIndicator.textContent = 'DEBUG MODE';
        debugIndicator.style.display = 'block';
      } else if (debugIndicator) {
        debugIndicator.style.display = 'none';
      }
    }
  });
}

/**
 * Update the viewport dimensions when orientation or size changes
 */
function updateViewportDimensions() {
  // Get current viewport and device dimensions
  const visualWidth = window.innerWidth;
  const visualHeight = window.innerHeight;
  const deviceWidth = window.screen.width;
  const deviceHeight = window.screen.height;
  
  // Store these values globally for access by other modules
  window.viewportInfo = {
    visualWidth,
    visualHeight,
    deviceWidth,
    deviceHeight,
    isLandscape: visualWidth > visualHeight,
    // Calculate ratio of visual height to full device height
    viewportRatio: visualHeight / deviceHeight
  };
  
  // Log information for iOS devices
  if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {
    console.log(`Viewport updated - Visual: ${visualWidth}x${visualHeight}, Device: ${deviceWidth}x${deviceHeight}`);
    
    if (window.viewportInfo.viewportRatio < 1) {
      console.log(`Unused screen space detected. Viewport ratio: ${window.viewportInfo.viewportRatio.toFixed(2)}`);
    }
  }
  
  // Apply adjustments based on new dimensions
  applyViewportAdjustments();
}

/**
 * Apply necessary adjustments based on viewport dimensions
 */
function applyViewportAdjustments() {
  // If we have a renderer, update the camera aspect ratio
  if (window.renderer && window.renderer.camera) {
    window.renderer.camera.aspect = window.innerWidth / window.innerHeight;
    window.renderer.camera.updateProjectionMatrix();
  }
  
  // Resize renderer if available
  if (window.renderer && window.renderer.instance) {
    window.renderer.instance.setSize(window.innerWidth, window.innerHeight);
  }
}

/**
 * Creates weapon indicator UI for desktop
 */
function createDesktopWeaponIndicators() {
  if (isMobileDevice()) return; // Mobile has its own indicators
  
  // Add styles for weapon indicators
  const style = document.createElement('style');
  style.textContent = `
    .desktop-weapon-indicator {
      position: fixed;
      left: 20px;
      width: 40px;
      height: 40px;
      background-color: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 5px;
      margin-bottom: 5px;
      opacity: 0.7;
      transition: opacity 0.3s, border-color 0.3s, box-shadow 0.3s;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .desktop-weapon-indicator:hover {
      opacity: 1;
    }
    .desktop-weapon-indicator.active {
      border-color: #ffcc00 !important;
      box-shadow: 0 0 10px #ffcc00;
      opacity: 1;
    }
    #revolver-indicator-desktop {
      bottom: 150px;
    }
    #shotgun-indicator-desktop {
      bottom: 120px;
    }
    .weapon-number {
      position: absolute;
      top: -8px;
      right: -8px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 12px;
      padding: 2px 5px;
      border-radius: 10px;
      font-family: 'Courier New', monospace;
    }
  `;
  document.head.appendChild(style);
  
  // Create container for both indicators
  const container = document.createElement('div');
  container.id = 'desktop-weapon-indicators';
  
  // Create revolver indicator
  const revolverIndicator = document.createElement('div');
  revolverIndicator.id = 'revolver-indicator-desktop';
  revolverIndicator.className = 'desktop-weapon-indicator active';
  
  // Add revolver icon (same as mobile)
  const revolverImg = document.createElement('img');
  revolverImg.src = 'models/revolverindicator.png';
  revolverImg.style.width = '80%';
  revolverImg.style.height = '80%';
  revolverImg.style.objectFit = 'contain';
  revolverIndicator.appendChild(revolverImg);
  
  // Add number indicator
  const revolverNum = document.createElement('div');
  revolverNum.className = 'weapon-number';
  revolverNum.textContent = '1';
  revolverIndicator.appendChild(revolverNum);
  
  // Create shotgun indicator
  const shotgunIndicator = document.createElement('div');
  shotgunIndicator.id = 'shotgun-indicator-desktop';
  shotgunIndicator.className = 'desktop-weapon-indicator';
  
  // Add shotgun icon (same as mobile)
  const shotgunImg = document.createElement('img');
  shotgunImg.src = 'models/shotgunindicator.png';
  shotgunImg.style.width = '80%';
  shotgunImg.style.height = '80%';
  shotgunImg.style.objectFit = 'contain';
  shotgunIndicator.appendChild(shotgunImg);
  
  // Add number indicator
  const shotgunNum = document.createElement('div');
  shotgunNum.className = 'weapon-number';
  shotgunNum.textContent = '2';
  shotgunIndicator.appendChild(shotgunNum);
  
  // Add click handlers
  revolverIndicator.addEventListener('click', () => {
    if (window.localPlayer) {
      window.localPlayer.switchWeapon('revolver');
    }
  });
  
  shotgunIndicator.addEventListener('click', () => {
    if (window.localPlayer) {
      window.localPlayer.switchWeapon('shotgun');
    }
  });
  
  // Add to DOM
  document.body.appendChild(revolverIndicator);
  document.body.appendChild(shotgunIndicator);
}

// Call init() to start the application
init().catch(err => {
  console.error('Error during initialization:', err);
  // Show error to user
  const errorElement = document.createElement('div');
  errorElement.style.position = 'fixed';
  errorElement.style.top = '10px';
  errorElement.style.left = '10px';
  errorElement.style.color = 'red';
  errorElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
  errorElement.style.padding = '10px';
  errorElement.style.borderRadius = '5px';
  errorElement.textContent = 'Failed to initialize the game. Please refresh the page.';
  document.body.appendChild(errorElement);
});

================================================
File: /public/js/multiplayerManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';
import { networkManager } from './network.js';
import { updateHealthUI, showDamageIndicator } from './ui.js';

/**
 * Manages all remote players (their models, animations, etc.) but NOT bullets.
 * Bullets are now handled in main.js.
 */
export class MultiplayerManager {
  constructor(scene, soundManager, remotePlayersMap) {
    /**
     * @param remotePlayersMap {Map<number,ThirdPersonModel>}
     * A shared map that main.js also references. We'll update it here.
     */
    this.scene = scene;
    this.soundManager = soundManager;
    
    // This map is passed in from main.js; we mutate it
    this.remotePlayers = remotePlayersMap;

    // Map to track username labels
    this.playerLabels = new Map(); // playerId -> { sprite, div }
    
    // Initialize nametag visibility - visible by default
    this._nametagsVisible = true;
    
    // Create a container for the username labels
    this.createLabelContainer();

    // Callback that main.js uses to know we changed remotePlayers
    this.onRemotePlayersUpdated = null;

    this.localPlayerId = null;

    // Initialize network handlers
    this.initNetwork();
  }
  
  /**
   * Creates the container for player username labels
   */
  createLabelContainer() {
    // Check if container already exists
    let container = document.getElementById('player-labels-container');
    
    if (!container) {
      // Create a new container
      container = document.createElement('div');
      container.id = 'player-labels-container';
      container.style.position = 'absolute';
      container.style.top = '0';
      container.style.left = '0';
      container.style.width = '100%';
      container.style.height = '100%';
      container.style.pointerEvents = 'none';
      container.style.overflow = 'hidden';
      container.style.zIndex = '10';
      
      // Add to the game container
      const gameContainer = document.getElementById('game-container');
      if (gameContainer) {
        gameContainer.appendChild(container);
      } else {
        document.body.appendChild(container);
      }
    }
    
    // Store the reference to the container
    this.labelContainer = container;
  }
  
  initNetwork() {
    // When we get the "init" message, set local player ID and add any existing players
    networkManager.onInit = (initData) => {
      this.localPlayerId = initData.id;
      console.log(`Local player initialized with ID: ${this.localPlayerId}`);

      // Remove any existing duplicate of the local player (safety check)
      this.removeLocalPlayerDuplicates();

      // Add all existing players (these are remote from our POV)
      if (initData.players && Array.isArray(initData.players)) {
        initData.players.forEach(playerData => {
          this.addPlayer(playerData.id, playerData);
        });
        this.notifyPlayersUpdated();
      }
      
      // Request train state explicitly after a short delay to ensure it's received
      setTimeout(() => {
        if (networkManager && typeof networkManager.requestTrainState === 'function') {
          console.log("Requesting train state from server after initialization");
          networkManager.requestTrainState();
        }
      }, 1000);
    };

    networkManager.onPlayerJoined = (playerData) => {
      if (playerData && playerData.id !== this.localPlayerId) {
        console.log(`Player joined: ${playerData.id}${playerData.isNpc ? ' (NPC)' : (playerData.isBot ? ' (BOT)' : '')}`);
        this.addPlayer(playerData.id, playerData);
        this.notifyPlayersUpdated();
      }
    };

    networkManager.onPlayerLeft = (playerId) => {
      console.log(`Player left: ${playerId}`);
      this.removePlayer(playerId);
      this.notifyPlayersUpdated();
    };

    // Add handler for player death events
    networkManager.onPlayerDeath = (playerId, killedById) => {
      console.log(`Player ${playerId} was killed by player ${killedById}`);
      
      // Find the player model and play death animation
      const playerModel = this.remotePlayers.get(playerId);
      if (playerModel && typeof playerModel.playDeathAnimation === 'function') {
        console.log(`Playing death animation for player ${playerId}`);
        playerModel.playDeathAnimation();
      }
    };

    networkManager.onPlayerUpdate = (playerId, updatedData) => {
      if (playerId === this.localPlayerId) return; // skip ourself
      
      const playerModel = this.remotePlayers.get(playerId);
      
      // Check if this is a full reset request
      if (updatedData && updatedData.fullReset === true) {
        console.log(`[MultiplayerManager] Received full reset for player ${playerId}`);
        
        // If we have this player model, remove it completely
        if (playerModel) {
          playerModel.dispose();
          this.remotePlayers.delete(playerId);
          
          // Remove username label
          this.removePlayerLabel(playerId);
        }
        
        // Create a fresh player model
        this.addPlayer(playerId, updatedData);
        this.notifyPlayersUpdated();
        return;
      }
      
      // Check if player is dying and should play death animation
      if (updatedData && updatedData.isDying === true && playerModel && playerModel.playDeathAnimation && !playerModel.isDying) {
        console.log(`[MultiplayerManager] Playing death animation for remote player ${playerId}`);
        playerModel.playDeathAnimation();
        return; // Skip normal update as death animation takes precedence
      }
      
      // Check if player animation state should be reset (after respawn)
      if (updatedData && updatedData.resetAnimationState === true && playerModel && typeof playerModel.resetAnimationState === 'function') {
        console.log(`[MultiplayerManager] Resetting animation state for player ${playerId}`);
        playerModel.resetAnimationState();
        // Continue with normal update
      }
      
      // Normal update
      if (playerModel) {
        // For NPCs/Bots, cache the latest network data to use in the animation update
        if (updatedData && (playerModel.isBot || playerModel.isNpc || (updatedData.isNpc || updatedData.isBot))) {
          // Cache the network data for use in the animation update
          playerModel._cachedNetworkData = {
            ...updatedData,
            isNpc: updatedData.isNpc || playerModel.isNpc,
            isBot: updatedData.isBot || playerModel.isBot
          };
          
          // Ensure isNpc/isBot flags are set on the model
          playerModel.isNpc = playerModel._cachedNetworkData.isNpc;
          playerModel.isBot = playerModel._cachedNetworkData.isBot;
          
          // If the NPC is walking, direct to walking animation immediately
          if (updatedData.isWalking && !playerModel.isWalking) {
            playerModel.isWalking = true;
            if (playerModel.directToWalking) {
              playerModel.directToWalking(false);
            }
          } else if (!updatedData.isWalking && playerModel.isWalking) {
            playerModel.isWalking = false;
            if (playerModel.directToIdle) {
              playerModel.directToIdle();
            }
          }
        }
        
        playerModel.update(updatedData);
      } else if (updatedData) {
        // If we don't have this model yet, create it
        this.addPlayer(playerId, updatedData);
      }
    };

    // Anti-cheat: Player got hit (local player) - server validated
    networkManager.onPlayerHit = (sourceId, hitData, newHealth, hitZone) => {
      console.log(`I was hit by player ${sourceId} in the ${hitZone || 'body'}!`);
      
      // Skip processing if this is a QuickDraw duel hit - QuickDraw will handle it separately
      const isQuickDrawDuel = window.quickDraw && window.quickDraw.inDuel && 
                              window.quickDraw.duelOpponentId === Number(sourceId);
      
      if (isQuickDrawDuel) {
        console.log(`[MultiplayerManager] Deferring hit handling to QuickDraw system`);
        return;
      }
      
      // This is a regular hit, not in QuickDraw mode
      this.showHitFeedback();
      
      // Play headshot sound if appropriate
      if (hitZone === 'head' && this.soundManager) {
        this.soundManager.playSound("headshotmarker", 100);
      }
      
      // Reduce local player's health (using value from server)
      if (window.localPlayer) {
        // Calculate damage based on the health difference or hit zone
        let damage = 20; // Default damage
        
        // Check if hitData contains a damage value directly
        if (hitData && typeof hitData.damage === 'number') {
          damage = hitData.damage;
        } else if (newHealth !== undefined) {
          // Calculate damage from previous health
          damage = window.localPlayer.health - newHealth;
          window.localPlayer.health = newHealth;
        } else {
          // Calculate damage based on hit zone if provided
          if (hitZone === 'head') {
            damage = 100;
          } else if (hitZone === 'body') {
            damage = 40;
          } else if (hitZone === 'limbs') {
            damage = 20;
          }
          
          // Apply damage
          window.localPlayer.takeDamage(damage, hitZone);
        }
        
        // Make sure damage is a number
        damage = Number(damage) || 40; // Default to 40 if conversion fails
        
        // Show damage indicator with proper hit zone
        if (typeof showDamageIndicator === 'function') {
          console.log(`Showing damage indicator: ${damage} damage to ${hitZone}`);
          showDamageIndicator(damage, hitZone);
        }
        
        // Ensure health UI is updated
        if (typeof updateHealthUI === 'function') {
          updateHealthUI(window.localPlayer);
        }
      }
    };

    // Anti-cheat: Broadcast that some player was hit (server validated)
    networkManager.onPlayerHitBroadcast = (targetId, sourceId, hitPos, newHealth, hitZone) => {
      console.log(`Player ${targetId} was hit by ${sourceId} in the ${hitZone || 'body'}`);
      
      // Skip processing if this is a QuickDraw duel hit
      const isQuickDrawHit = window.quickDraw && window.quickDraw.inDuel && 
                            (window.quickDraw.duelOpponentId === Number(targetId) || 
                             window.localPlayer.id === Number(targetId));
      
      if (isQuickDrawHit) {
        console.log(`[MultiplayerManager] Skipping hit broadcast for QuickDraw duel`);
        return;
      }
      
      // Convert targetId to integer if it's a string
      const playerId = typeof targetId === 'string' ? parseInt(targetId, 10) : targetId;
      const tPlayer = this.remotePlayers.get(playerId);
      
      if (tPlayer) {
        tPlayer.showHitFeedback();
        
        // Play headshot sound if appropriate
        if (hitZone === 'head' && this.soundManager) {
          this.soundManager.playSound("headshotmarker", 100);
        }
        
        // Calculate damage based on hit zone
        let damage = 20; // Default damage
        if (hitZone === 'head') {
          damage = 100;
        } else if (hitZone === 'body') {
          damage = 40;
        } else if (hitZone === 'limbs') {
          damage = 20;
        }
        
        // Update health directly from server value if provided
        if (newHealth !== undefined) {
          tPlayer.health = newHealth;
        } else {
          // Apply damage
          if (typeof tPlayer.takeDamage === 'function') {
            tPlayer.takeDamage(damage, hitZone);
          } else {
            // If takeDamage is not defined, manually update health
            tPlayer.health = Math.max((tPlayer.health || 100) - damage, 0);
          }
        }
        
        // Create a hit marker or effect at the hit position if available
        if (hitPos && window.scene) {
          this.createHitMarker(hitPos, hitZone);
        }
      }
    };
  }

  showHitFeedback() {
    // Flash the screen red briefly
    const hitOverlay = document.createElement('div');
    hitOverlay.style.position = 'absolute';
    hitOverlay.style.top = '0';
    hitOverlay.style.left = '0';
    hitOverlay.style.width = '100%';
    hitOverlay.style.height = '100%';
    hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    hitOverlay.style.pointerEvents = 'none';
    hitOverlay.style.transition = 'opacity 0.5s ease-out';
    hitOverlay.style.zIndex = '1000';
    document.body.appendChild(hitOverlay);
    
    setTimeout(() => {
      hitOverlay.style.opacity = '0';
      setTimeout(() => {
        if (hitOverlay.parentNode) {
          hitOverlay.parentNode.removeChild(hitOverlay);
        }
      }, 500);
    }, 100);

    // Optional hit sound
    if (this.soundManager) {
      this.soundManager.playSound("revolverdraw");
    }
  }

  /**
   * Creates a visual hit marker at the hit position
   * @param {Object} position - The hit position
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   */
  createHitMarker(position, hitZone) {
    // Only create if we have THREE.js and a scene
    if (!window.THREE || !window.scene) return;
    
    // Choose color based on hit zone
    let color = 0xFFFFFF; // Default white
    if (hitZone === 'head') {
      color = 0xFF0000; // Red for headshots
    } else if (hitZone === 'body') {
      color = 0xFF6600; // Orange for body shots
    } else if (hitZone === 'limbs') {
      color = 0xFFFF00; // Yellow for limb shots
    }
    
    try {
      // Create a particle system for the hit marker
      const geometry = new window.THREE.BufferGeometry();
      const vertices = [];
      
      // Create particles in a small sphere
      const particleCount = 10;
      const radius = 0.1;
      
      for (let i = 0; i < particleCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        
        vertices.push(x, y, z);
      }
      
      geometry.setAttribute('position', new window.THREE.Float32BufferAttribute(vertices, 3));
      
      const material = new window.THREE.PointsMaterial({
        color: color,
        size: 0.05,
        transparent: true,
        opacity: 1
      });
      
      const particles = new window.THREE.Points(geometry, material);
      particles.position.copy(position);
      window.scene.add(particles);
      
      // Animate the particles
      const startTime = performance.now();
      const duration = 500; // ms
      
      function animateParticles() {
        const elapsed = performance.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress < 1) {
          // Expand particles
          particles.scale.set(1 + progress * 2, 1 + progress * 2, 1 + progress * 2);
          // Fade out
          material.opacity = 1 - progress;
          
          requestAnimationFrame(animateParticles);
        } else {
          // Clean up
          window.scene.remove(particles);
          geometry.dispose();
          material.dispose();
        }
      }
      
      requestAnimationFrame(animateParticles);
    } catch (error) {
      console.error("Error creating hit marker:", error);
    }
  }

  /**
   * Adds a remote player to the scene with proper model
   * @param {number} playerId - ID of the player to add
   * @param {Object} initialData - Initial player data from server
   */
  addPlayer(playerId, initialData = {}) {
    // Skip if we already have this player
    if (this.remotePlayers.has(playerId)) return;
    
    // Skip if this is the local player ID (safety check to prevent ghost duplicates)
    if (playerId === this.localPlayerId) {
      console.log(`MultiplayerManager: Skipping attempt to add local player (ID: ${playerId}) as remote player`);
      return null;
    }
    
    console.log(`Adding remote player ${playerId} to scene`);
    
    let playerModel;
    
    // Check if this is an NPC or bot
    const isNpc = initialData.isNpc || false;
    const isBot = initialData.isBot || false;
    
    // Use specialized NPC models for NPCs
    if (isNpc && window.npcManager && window.npcManager.instance) {
      // Let the NPC manager handle creating the appropriate model
      playerModel = window.npcManager.instance.createOrUpdateNpc(playerId, initialData);
    } else {
      // Create standard player model for regular players and bots
      playerModel = new ThirdPersonModel(this.scene, playerId);
    }
    
    // Set bot/NPC flag if this is not a human player
    playerModel.isBot = isBot;
    playerModel.isNpc = isNpc;
    
    // Track if this is an AI-controlled character
    const isAiControlled = playerModel.isBot || playerModel.isNpc;
    
    // Add to tracking map - used by main.js for bullet hit detection
    this.remotePlayers.set(playerId, playerModel);
    
    // Set initial position if provided
    if (initialData.position) {
      playerModel.targetPosition.set(
        initialData.position.x, 
        initialData.position.y, 
        initialData.position.z
      );
      playerModel.group.position.copy(playerModel.targetPosition);
    }
    
    // Set initial rotation if provided
    if (initialData.rotation && initialData.rotation.y !== undefined) {
      playerModel.targetRotation = initialData.rotation.y;
      playerModel.group.rotation.y = initialData.rotation.y;
    }
    
    // Apply skin information if provided and not an NPC/bot
    if (!isNpc && !isBot && initialData.skins) {
      console.log(`Applying initial skin data for player ${playerId}:`, initialData.skins);
      
      // Update skin permissions
      playerModel.updateSkinPermissions(initialData.skins);
      
      // Apply banana skin if permission is granted
      if (initialData.skins.bananaSkin) {
        console.log(`Player ${playerId} has bananaSkin permission, applying skin on initial join`);
        
        // Ensure the model is loaded first
        if (!playerModel.playerModel) {
          console.log(`Waiting for player model to load before applying skin for player ${playerId}`);
          // Add a delay to wait for model to load
          setTimeout(() => {
            if (playerModel.playerModel) {
              playerModel.updateSkin('bananaSkin');
              // Mark as initially applied to prevent duplicate application
              playerModel._initialSkinApplied = true;
              // Store the skin data to prevent redundant updates
              playerModel._lastSkinUpdate = JSON.stringify(initialData.skins);
            } else {
              console.warn(`Player model still not loaded for player ${playerId} after delay`);
            }
          }, 1500); // Longer delay to ensure model loads
        } else {
          playerModel.updateSkin('bananaSkin');
          // Mark as initially applied to prevent duplicate application
          playerModel._initialSkinApplied = true;
          // Store the skin data to prevent redundant updates
          playerModel._lastSkinUpdate = JSON.stringify(initialData.skins);
        }
      }
    }
    
    // For NPCs/Bots, ensure model is prepared correctly and animation is initialized
    if (isAiControlled) {
      // Store the network data for future updates
      playerModel._cachedNetworkData = { ...initialData };
      
      // Ensure animations load and initialize correctly
      setTimeout(() => {
        // Set initial animation state based on data
        if (initialData.isWalking && playerModel.directToWalking) {
          playerModel.isWalking = true;
          playerModel.directToWalking(false);
        } else if (playerModel.directToIdle) {
          playerModel.isWalking = false;
          playerModel.directToIdle();
        }
      }, 500); // Delay slightly to ensure model is loaded
    }
    
    // Create username label
    this.createPlayerLabel(playerId, initialData.username || `Player_${playerId}`, isAiControlled);
    
    return playerModel;
  }

  /**
   * Creates a floating username label for a player
   * @param {number} playerId - ID of the player
   * @param {string} username - Username to display
   * @param {boolean} isAiControlled - Whether this is a bot or NPC
   */
  createPlayerLabel(playerId, username, isAiControlled = false) {
    // Remove any existing label first
    this.removePlayerLabel(playerId);
    
    // Create label container
    const div = document.createElement('div');
    div.className = 'player-label';
    
    // Style the label
    div.style.position = 'absolute';
    div.style.color = 'white';
    div.style.fontFamily = 'Arial, sans-serif';
    div.style.fontSize = '14px';
    div.style.fontWeight = 'bold';
    div.style.textShadow = '1px 1px 2px black';
    div.style.padding = '3px 6px';
    div.style.borderRadius = '4px';
    div.style.pointerEvents = 'none';
    div.style.userSelect = 'none';
    div.style.zIndex = '10';
    
    // Add special styling for AI-controlled characters
    if (isAiControlled) {
      div.classList.add('ai-controlled');
      div.style.backgroundColor = 'rgba(50, 150, 255, 0.5)'; // Blue background for NPCs
      div.textContent = username; // Remove robot emoji, just use the name
    } else {
      div.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Regular background for players
      div.textContent = username;
    }
    
    // Add to DOM
    this.labelContainer.appendChild(div);
    
    // Create THREE.js object to position the label in 3D space
    const labelObject = new THREE.Object3D();
    labelObject.position.y = 2.8; // Increased position above player head (was 2.5)
    
    // Store references for updating
    this.playerLabels.set(playerId, { div, labelObject });
    
    // If we have this player model, add the label object to it
    const model = this.remotePlayers.get(playerId);
    if (model && model.group) {
      model.group.add(labelObject);
    }
  }

  removePlayer(playerId) {
    const playerModel = this.remotePlayers.get(playerId);
    if (playerModel) {
      playerModel.dispose();
      this.remotePlayers.delete(playerId);
    }
    
    // Remove username label
    this.removePlayerLabel(playerId);
  }
  
  removePlayerLabel(playerId) {
    const labelData = this.playerLabels.get(playerId);
    if (labelData) {
      // Remove the div from DOM
      if (labelData.div && labelData.div.parentNode) {
        labelData.div.parentNode.removeChild(labelData.div);
      }
      
      // Remove the 3D object from the player model
      const model = this.remotePlayers.get(playerId);
      if (model && model.group && labelData.labelObject) {
        model.group.remove(labelData.labelObject);
      }
      
      // Remove from tracking
      this.playerLabels.delete(playerId);
    }
  }

  update(deltaTime) {
    // Update player models
    for (const [id, playerModel] of this.remotePlayers.entries()) {
      if (playerModel) {
        // Always call animateMovement which handles the snapshot-based animations too
        if (playerModel.animateMovement) {
          playerModel.animateMovement(deltaTime);
        }
        
        // Also call the general update method if it exists
        if (playerModel.update) {
          // For NPCs/Bots, make sure we're passing the animation state correctly
          if (playerModel.isBot || playerModel.isNpc) {
            // Check for cached data that was received in onPlayerUpdate
            const cachedData = playerModel._cachedNetworkData;
            if (cachedData) {
              // Clone the data to avoid permanent modifications to cached data
              const clonedData = { ...cachedData };
              
              // Only include skin data on initial update or when it has actually changed
              if (!playerModel._initialSkinApplied) {
                playerModel._initialSkinApplied = true;
              } else {
                // Remove skin data from subsequent updates to prevent constant reapplication
                delete clonedData.skins;
              }
              
              playerModel.update(clonedData);
            }
          } else {
            // DON'T pass deltaTime to update when the player is in a frozen aim pose
            // This prevents animation mixer from resetting the animation each frame
            if (playerModel.isAiming && !playerModel.isShooting && !playerModel.isJumping) {
              // Skip sending deltaTime update which would reset the animation
            } else {
              playerModel.update(deltaTime);
            }
          }
        }
      }
    }
    
    // Update player labels
    this.updatePlayerLabels();
  }
  
  /**
   * Control visibility of ALL player nametags
   * @param {boolean} visible - Whether nametags should be visible
   */
  setAllNametagsVisible(visible) {
    console.log(`[MultiplayerManager] Setting all nametags visible: ${visible}`);
    
    this.playerLabels.forEach((labelData, playerId) => {
      if (labelData && labelData.div) {
        labelData.div.style.display = visible ? 'block' : 'none';
      }
    });
    
    // Store current global visibility setting
    this._nametagsVisible = visible;
  }
  
  updatePlayerLabels() {
    const tempVector = new THREE.Vector3();
    const canvas = document.querySelector('canvas');
    
    if (!canvas) return;
    
    // Get camera for projection
    const camera = window.renderer && window.renderer.camera ? 
                  window.renderer.camera : 
                  this.scene.getObjectByProperty('type', 'PerspectiveCamera');
    
    if (!camera) return;
    
    // If nametags are globally hidden, skip the update
    if (this._nametagsVisible === false) {
      return;
    }
    
    this.playerLabels.forEach((labelData, playerId) => {
      const { div, labelObject } = labelData;
      if (!div) return;
      
      const model = this.remotePlayers.get(playerId);
      if (!model || !model.group) return;
      
      // Get world position
      tempVector.setFromMatrixPosition(labelObject.matrixWorld);
      
      // Project to 2D screen coordinates
      tempVector.project(camera);
      
      // Convert to CSS coordinates
      const x = (tempVector.x * 0.5 + 0.5) * canvas.clientWidth;
      const y = (-(tempVector.y * 0.5) + 0.5) * canvas.clientHeight;
      
      // Check if label is in front of the camera
      if (tempVector.z > 1) {
        div.style.display = 'none';
      } else {
        div.style.display = 'block';
        div.style.transform = `translate(-50%, -50%)`;
        div.style.left = `${x}px`;
        div.style.top = `${y}px`;
      }
    });
  }

  notifyPlayersUpdated() {
    if (typeof this.onRemotePlayersUpdated === 'function') {
      this.onRemotePlayersUpdated(this.remotePlayers);
    }
  }

  /**
   * Removes any existing player models with the same ID as the local player
   * This prevents the "ghost player" issue where a player sees their own model
   */
  removeLocalPlayerDuplicates() {
    if (!this.localPlayerId) return;
    
    // Check if there's a model with our ID in the remote players map
    if (this.remotePlayers.has(this.localPlayerId)) {
      console.log(`Removing duplicate local player model with ID: ${this.localPlayerId}`);
      
      // Get the model
      const duplicateModel = this.remotePlayers.get(this.localPlayerId);
      
      // Dispose of the model properly
      if (duplicateModel) {
        duplicateModel.dispose();
      }
      
      // Remove from the map
      this.remotePlayers.delete(this.localPlayerId);
      
      // Remove username label
      this.removePlayerLabel(this.localPlayerId);
      
      // Notify that remote players have changed
      this.notifyPlayersUpdated();
    }
  }
}

================================================
File: /public/js/network.js
================================================
/**
 * NetworkManager class for WebSocket communication.
 * It provides event callbacks for multiplayer events and methods to send data.
 */
export class NetworkManager {
  constructor() {
    this.socket = null;
    this.playerId = null;
    this.otherPlayers = new Map(); // Maps playerId -> playerData from the server

    // Callbacks
    this.onInit = null;              // Called when we first receive 'init' from server
    this.onPlayerJoined = null;
    this.onPlayerLeft = null;
    this.onPlayerUpdate = null;
    this.onPlayerShoot = null;
    this.onPlayerCount = null;
    this.onPlayerHit = null;         // When this player is hit by someone
    this.onPlayerHitBroadcast = null;// When any player is hit
    this.onOpen = null;
    this.onClose = null;
    this.onError = null;
    this.onChatMessage = null;       // When a chat message is received

    // Train system callbacks
    this.onTrainInit = null;         // When initial train state is received
    this.onTrainState = null;        // When train state updates are received

    // Anti-cheat callbacks
    this.onPositionCorrection = null;// When server corrects client position
    this.onBulletImpact = null;      // When a bullet hits something
    this.onRespawn = null;           // When player respawns

    // Automatic reconnect attempts
    this.connectionAttempts = 0;
    this.maxConnectionAttempts = 5;
    this.reconnectTimer = null;

    // Unique sessionId to prevent multiple tabs from colliding
    this.sessionId = this._generateSessionId();
    
    // Anti-cheat: Sequence number for message ordering
    this.sequenceNumber = 0;
    
    // Anti-cheat: Map to track outgoing messages that need nonces
    this.pendingMessages = new Map();
  }

  /**
   * Generates a unique-ish session ID to detect duplicate connections from the same tab.
   */
  _generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }
  
  /**
   * Generates a unique nonce for secure actions.
   * @returns {string} A unique nonce
   */
  _generateNonce() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2) + 
           Math.random().toString(36).substring(2);
  }

  /**
   * Initiates a connection to the WebSocket server.
   */
  connect() {
    this._cleanupSocket();

    // Get persistent player identity information
    const playerIdentity = window.playerIdentity || {};
    
    // Create query parameters for the WebSocket connection
    const params = new URLSearchParams({
      sessionId: this.sessionId,
      clientId: playerIdentity.id || '',
      username: playerIdentity.username || '',
      token: playerIdentity.token || '' // Add token for auth
    });

    // Determine correct ws:// or wss:// based on current protocol
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = `${protocol}${window.location.host}?${params.toString()}`;

    console.log('Attempting to connect to:', wsUrl);
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = (event) => {
      console.log('WebSocket connected');
      this.connectionAttempts = 0;
      if (typeof this.onOpen === 'function') {
        this.onOpen(event);
      }
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        
        // Handle auth failures specifically
        if (message.type === 'authFailure') {
          console.error('Authentication failed:', message.reason);
          // If the server rejected our token, clear it and reload
          if (message.reason === 'invalidToken') {
            try {
              localStorage.removeItem('wildWestPlayerIdentity');
              sessionStorage.removeItem('wildWestPlayerSession');
              alert('Your session has expired. The game will reload.');
              window.location.reload();
            } catch (e) {
              console.error('Failed to clear invalid token:', e);
            }
          }
          return;
        }
        
        this.handleMessage(message);
      } catch (err) {
        console.error('Error parsing server message:', err);
      }
    };

    this.socket.onclose = (event) => {
      console.log(`WebSocket closed: ${event.code} ${event.reason}`);
      if (typeof this.onClose === 'function') {
        this.onClose(event);
      }
      this._scheduleReconnect();
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      if (typeof this.onError === 'function') {
        this.onError(error);
      }
    };
  }

  /**
   * Clean up any existing WebSocket connection.
   */
  _cleanupSocket() {
    if (this.socket) {
      this.socket.onopen = null;
      this.socket.onmessage = null;
      this.socket.onclose = null;
      this.socket.onerror = null;
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close();
      }
      this.socket = null;
    }

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * Schedules a reconnect attempt if under max attempts.
   */
  _scheduleReconnect() {
    if (this.connectionAttempts < this.maxConnectionAttempts) {
      this.connectionAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
      console.log(`Reconnecting in ${(delay / 1000).toFixed(1)}s... (Attempt ${this.connectionAttempts}/${this.maxConnectionAttempts})`);
      
      this.reconnectTimer = setTimeout(() => {
        console.log(`Reconnecting now (Attempt ${this.connectionAttempts})...`);
        this.connect();
      }, delay);
    } else {
      console.error('Max reconnect attempts reached. Please refresh the page.');
    }
  }

  /**
   * Handles all messages from the server.
   * @param {Object} message The parsed JSON message object.
   */
  handleMessage(message) {
    switch (message.type) {
      // New connection initialization
      case 'init':
        this.playerId = message.id;
        console.log(`Assigned player ID: ${this.playerId}`);

        // If there's a callback
        if (typeof this.onInit === 'function') {
          this.onInit(message);
        }

        // Add known players - exclude any with our own ID
        message.players.forEach(player => {
          // Skip if this is somehow our own ID
          if (player.id === this.playerId) {
            console.log(`Skipping duplicate player with our ID: ${player.id}`);
            return;
          }
          
          if (this.onPlayerJoined) {
            this.onPlayerJoined(player);
          }
          this.otherPlayers.set(player.id, player);
        });
        break;

      // Another player joined
      case 'playerJoined':
        console.log(`Player ${message.id} joined${message.isNpc ? ' (NPC)' : (message.isBot ? ' (BOT)' : '')}`);
        
        // Skip if this is our own ID
        if (message.id === this.playerId) {
          console.log(`Skipping player join for own player ID: ${message.id}`);
          break;
        }
        
        if (this.onPlayerJoined) {
          this.onPlayerJoined(message);
        }
        this.otherPlayers.set(message.id, {
          id: message.id,
          position: message.position,
          rotation: message.rotation,
          isAiming: false,
          isShooting: false,
          isReloading: false,
          quickDrawLobbyIndex: message.quickDrawLobbyIndex || -1,
          isBot: message.isBot || false, // Legacy bot flag
          isNpc: message.isNpc || false, // New NPC flag
          username: message.username || `Player_${message.id}`,
          skins: message.skins || { bananaSkin: false } // Include skin information
        });
        break;

      // Player left
      case 'playerLeft':
        console.log(`Player ${message.id} left`);
        if (this.onPlayerLeft) {
          this.onPlayerLeft(message.id);
        }
        this.otherPlayers.delete(message.id);
        break;

      // General player update (pos/rot/aiming/etc.)
      case 'playerUpdate':
        {
          // Skip if this is our own ID
          if (message.id === this.playerId) {
            console.log(`Skipping update for own player ID: ${message.id}`);
            break;
          }

          const existing = this.otherPlayers.get(message.id);
          if (existing) {
            existing.position = message.position || existing.position;
            existing.rotation = message.rotation || existing.rotation;
            existing.isAiming =
              message.isAiming !== undefined ? message.isAiming : existing.isAiming;
            existing.isShooting =
              message.isShooting !== undefined ? message.isShooting : existing.isShooting;
            existing.isReloading =
              message.isReloading !== undefined ? message.isReloading : existing.isReloading;
            existing.quickDrawLobbyIndex =
              message.quickDrawLobbyIndex !== undefined ? message.quickDrawLobbyIndex : existing.quickDrawLobbyIndex;
            existing.health =
              message.health !== undefined ? message.health : existing.health;
            existing.isDying =
              message.isDying !== undefined ? message.isDying : existing.isDying;
            existing.isBot =
              message.isBot !== undefined ? message.isBot : existing.isBot;
            existing.isNpc =
              message.isNpc !== undefined ? message.isNpc : existing.isNpc;
            existing.isWalking =
              message.isWalking !== undefined ? message.isWalking : existing.isWalking;
            
            // Always maintain skin state for syncing to new clients
            if (message.skins) {
              existing.skins = message.skins;
            }
          } else {
            // If this is a new player we hadn't seen before - skip if it's our own ID
            if (message.id !== this.playerId) {
              this.otherPlayers.set(message.id, {
                id: message.id,
                position: message.position || { x: 0, y: 0, z: 0 },
                rotation: message.rotation || { y: 0 },
                isAiming: message.isAiming || false,
                isShooting: message.isShooting || false,
                isReloading: message.isReloading || false, 
                quickDrawLobbyIndex: message.quickDrawLobbyIndex || -1,
                health: message.health || 100,
                isDying: message.isDying || false,
                isBot: message.isBot || false,
                isNpc: message.isNpc || false,
                isWalking: message.isWalking || false,
                username: message.username || `Player_${message.id}`,
                skins: message.skins || { bananaSkin: false } // Include skin information
              });
              
              // Notify about this newly discovered player
              if (this.onPlayerJoined) {
                this.onPlayerJoined(this.otherPlayers.get(message.id));
              }
            }
          }
          
          // Call onPlayerUpdate with the updated or new player data
          if (this.onPlayerUpdate && message.id !== this.playerId) {
            this.onPlayerUpdate(message.id, existing || this.otherPlayers.get(message.id));
          }
        }
        break;

      // Remote player fired
      case 'playerShoot':
        if (this.onPlayerShoot) {
          this.onPlayerShoot(message.id, message.bulletData, message.bulletId);
        }
        break;

      // Current total player count
      case 'playerCount':
        if (this.onPlayerCount) {
          this.onPlayerCount(message.count);
        }
        break;

      // This client was hit by another player
      case 'hit':
        console.log(`I was hit by player ${message.sourceId} in the ${message.hitZone || 'body'} for ${message.hitData?.damage || 20} damage`);
        
        // Check if this is a QuickDraw duel hit - if so, let QuickDraw system handle it
        const isQuickDrawDuel = window.quickDraw && window.quickDraw.inDuel && 
                               window.quickDraw.duelOpponentId === Number(message.sourceId);
        
        if (!isQuickDrawDuel && this.onPlayerHit) {
          // Only handle non-QuickDraw hits here
          
          // Add damage to hitData if it's missing (for NPC hits)
          let damage = 40; // Default body shot damage
          if (message.hitZone === 'head') {
            damage = 100;
          } else if (message.hitZone === 'limbs') {
            damage = 20;
          }
          
          // If hitData is missing (from NPC), create it
          if (!message.hitData) {
            message.hitData = {
              damage: damage,
              hitZone: message.hitZone || 'body'
            };
          }
          
          // Ensure damage property exists in hitData
          if (message.hitData && !message.hitData.damage) {
            message.hitData.damage = damage;
          }
          
          this.onPlayerHit(message.sourceId, message.hitData, message.health, message.hitZone);
        } else if (isQuickDrawDuel) {
          console.log(`[Network] Deferring hit handling to QuickDraw system`);
          // Mark the message so QuickDraw knows this came from network.js
          message._from_network = true;
        }
        break;

      // Player hit - broadcast to all players
      case 'playerHitBroadcast':
        if (this.onPlayerHitBroadcast) {
          this.onPlayerHitBroadcast(message.hitData);
        }
        break;
        
      // Anti-cheat: Server correction of client position
      case 'positionCorrection':
        console.log(`Received position correction:`, message.position);
        if (this.onPositionCorrection) {
          this.onPositionCorrection(message.position);
        }
        break;
        
      // Anti-cheat: Bullet impact notification
      case 'bulletImpact':
        if (this.onBulletImpact) {
          this.onBulletImpact(
            message.bulletId, 
            message.hitType, 
            message.targetId, 
            message.position,
            message.hitZone
          );
        }
        break;
        
      // Anti-cheat: Player respawn notification
      case 'respawn':
        console.log(`Respawning at:`, message.position);
        if (this.onRespawn) {
          this.onRespawn(
            message.position, 
            message.health, 
            message.bullets, 
            message.maxBullets, 
            message.activeWeapon
          );
        }
        break;

      // Player death notification - when this player is killed
      case 'death':
        console.log(`You were killed by player ${message.killerId}`);
        if (this.onDeath) {
          this.onDeath(message.killerId);
        }
        break;
        
      // Kill notification - when this player kills another player
      case 'kill':
        console.log(`You killed player ${message.targetId}`);
        if (this.onKill) {
          this.onKill(message.targetId);
        }
        break;
        
      // Player death notification - for other players in the game
      case 'playerDeath':
        console.log(`Player ${message.id} was killed by player ${message.killedById}`);
        if (this.onPlayerDeath) {
          this.onPlayerDeath(message.id, message.killedById);
        }
        break;

      // Generic error from server
      case 'error':
        console.error('Server error:', message.message);
        if (message.fatal) {
          this.connectionAttempts = this.maxConnectionAttempts; // block further reconnect
          alert(`Fatal error: ${message.message}`);
        }
        break;

      // Chat message received
      case 'chatMessage':
        if (this.onChatMessage) {
          this.onChatMessage(message.senderId, message.username, message.message);
        }
        break;

      // Player skin update
      case 'playerSkinUpdate':
        // Update the stored player data for skins
        const playerToUpdate = this.otherPlayers.get(message.playerId);
        if (playerToUpdate) {
          playerToUpdate.skins = message.skins;
        }
        
        // Call the skin update handler in main.js
        if (this.onPlayerSkinUpdate) {
          this.onPlayerSkinUpdate(message);
        }
        break;

      // Train system: Initial train state
      case 'trainInit':
        if (this.onTrainInit) {
          this.onTrainInit(message);
        }
        break;

      // Train system: Ongoing train state updates
      case 'trainState':
        if (this.onTrainState) {
          this.onTrainState(message);
        }
        break;

      default:
        console.warn('Unhandled message:', message);
        break;
    }
  }

  /**
   * Sends local player position/rotation etc. to the server.
   * @param {Object} playerData - { position, rotation, isAiming, isReloading, isSprinting, isShooting, quickDrawLobbyIndex }
   */
  sendUpdate(playerData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'update',
          sequenceNumber: this.sequenceNumber,
          ...playerData
        })
      );
    }
  }

  /**
   * Notifies server that we fired a bullet.
   * @param {Object} bulletData - { position: {x,y,z}, direction: {x,y,z} }
   */
  sendShoot(bulletData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'shoot',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          bulletData
        })
      );
    }
  }

  /**
   * Notifies server that we hit another player.
   * @param {number|string} hitPlayerId
   * @param {Object} hitData - { position: {x,y,z}, sourcePlayerId: ..., hitZone: 'head'|'body'|'limbs', damage: number }
   * @param {number|string} bulletId - Optional bulletId if known
   */
  sendPlayerHit(hitPlayerId, hitData, bulletId = null) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      this.socket.send(
        JSON.stringify({
          type: 'playerHit',
          sequenceNumber: this.sequenceNumber,
          nonce: nonce,
          targetId: hitPlayerId,
          bulletId: bulletId,
          hitData
        })
      );
    }
  }
  
  /**
   * Notifies server that player is starting to reload.
   */
  sendReload() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'reload',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }
  
  /**
   * Sends a request to join a specific Quick Draw arena queue.
   * @param {number} arenaIndex - The arena index (0-4)
   */
  sendQuickDrawJoin(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawJoin',
          sequenceNumber: this.sequenceNumber,
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Sends a request to leave the Quick Draw queue.
   */
  sendQuickDrawLeave() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawLeave',
          sequenceNumber: this.sequenceNumber
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player is ready for a Quick Draw duel.
   * @param {number} arenaIndex - The arena index for the duel
   */
  sendQuickDrawReady(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number for message ordering
      this.sequenceNumber++;
      
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawReady',
          sequenceNumber: this.sequenceNumber,
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player has shot their opponent in a Quick Draw duel.
   * @param {number|string} opponentId - The opponent's player ID
   * @param {number} arenaIndex - The arena index for the duel
   * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
   * @param {number} damage - The damage amount
   */
  sendQuickDrawShoot(opponentId, arenaIndex, hitZone = 'body', damage = 40) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      // Anti-cheat: Add sequence number and nonce for replay protection
      this.sequenceNumber++;
      const nonce = this._generateNonce();
      
      console.log(`Sending Quick Draw hit notification to server: player ${this.playerId} hit player ${opponentId} in the ${hitZone} for ${damage} damage`);
      this.socket.send(JSON.stringify({
        type: 'quickDrawShoot',
        sequenceNumber: this.sequenceNumber,
        nonce: nonce,
        opponentId: opponentId,
        arenaIndex: arenaIndex,
        hitZone: hitZone,
        damage: damage
      }));
    }
  }

  /**
   * Closes the connection manually.
   */
  disconnect() {
    this._cleanupSocket();
  }
  
  /**
   * Send a chat message to all players
   * @param {string} message - The chat message to send
   */
  sendChatMessage(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({
        type: 'chat',
        message: message
      }));
    }
  }

  /**
   * Explicitly requests current train state from the server
   */
  requestTrainState() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      console.log("Requesting train state from server");
      this.socket.send(JSON.stringify({
        type: 'requestTrainState'
      }));
    } else {
      console.warn("Cannot request train state, not connected to server");
    }
  }
}

// Export a singleton instance
export const networkManager = new NetworkManager();
// Make it globally accessible
window.networkManager = networkManager;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  networkManager.disconnect();
});

================================================
File: /public/js/networkManager.js
================================================
/**
 * Network Manager for handling server communications
 */
export class NetworkManager {
  constructor(serverUrl) {
    this.serverUrl = serverUrl;
    this.socket = null;
    this.connected = false;
    this.playerId = null;
    this.otherPlayers = new Map();
    this.onPlayerJoin = null;
    this.onPlayerLeave = null;
    this.onPlayerUpdate = null;
    this.onMessageReceived = null;
    
    // Initialize connection
    this.connect();
  }
  
  /**
   * Connect to the game server
   */
  connect() {
    try {
      this.socket = new WebSocket(this.serverUrl);
      
      this.socket.onopen = () => {
        console.log("Connected to server");
        this.connected = true;
      };
      
      this.socket.onclose = () => {
        console.log("Disconnected from server");
        this.connected = false;
        
        // Attempt to reconnect after a delay
        setTimeout(() => this.connect(), 5000);
      };
      
      this.socket.onerror = (error) => {
        console.error("WebSocket error:", error);
      };
      
      this.socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.handleMessage(message);
        } catch (err) {
          console.error("Error parsing message:", err);
        }
      };
    } catch (err) {
      console.error("Failed to connect to server:", err);
    }
  }
  
  /**
   * Handle incoming messages from the server
   * @param {Object} message - The message from the server
   */
  handleMessage(message) {
    // Handle debug visualization messages
    if (message.type === 'debugBoxVisualization') {
      this.createDebugBox(message.box, message.color || 0xFF0000, message.duration || 5000);
    }
    
    if (message.type === 'debugSphereVisualization') {
      this.createDebugSphere(message.position, message.radius || 0.5, message.color || 0xFF0000, message.duration || 5000);
    }
    
    // Call the onMessageReceived callback if defined
    if (this.onMessageReceived) {
      this.onMessageReceived(message);
    }
  }
  
  /**
   * Send a message to the server
   * @param {Object} message - The message to send
   */
  sendMessage(message) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn("Cannot send message, not connected to server");
    }
  }
  
  /**
   * Creates a debug box for visualization
   * @param {Object} box - Box parameters {x, y, z, width, height, length}
   * @param {number} color - Color in hex format
   * @param {number} duration - Duration in ms before removal
   */
  createDebugBox(box, color = 0xFF0000, duration = 5000) {
    if (!window.scene) return;
    
    console.log(`Creating debug box at (${box.x.toFixed(2)}, ${box.y.toFixed(2)}, ${box.z.toFixed(2)}) with dimensions ${box.width.toFixed(2)}x${box.height.toFixed(2)}x${box.length.toFixed(2)}`);
    
    // Create geometry and material
    const geometry = new THREE.BoxGeometry(box.width, box.height, box.length);
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.5,
      wireframe: false
    });
    
    // Create mesh and add to scene
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(box.x, box.y, box.z);
    window.scene.add(mesh);
    
    // Create wireframe for better visibility
    const wireGeometry = new THREE.BoxGeometry(box.width, box.height, box.length);
    const wireMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFFFF,
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    const wireMesh = new THREE.Mesh(wireGeometry, wireMaterial);
    mesh.add(wireMesh);
    
    // Schedule removal after duration
    setTimeout(() => {
      if (window.scene) {
        window.scene.remove(mesh);
        geometry.dispose();
        material.dispose();
        wireGeometry.dispose();
        wireMaterial.dispose();
      }
    }, duration);
    
    return mesh;
  }
  
  /**
   * Creates a debug sphere for visualization
   * @param {Object} position - Position {x, y, z}
   * @param {number} radius - Sphere radius
   * @param {number} color - Color in hex format
   * @param {number} duration - Duration in ms before removal
   */
  createDebugSphere(position, radius = 0.5, color = 0xFF0000, duration = 5000) {
    if (!window.scene) return;
    
    console.log(`Creating debug sphere at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}) with radius ${radius.toFixed(2)}`);
    
    // Create geometry and material
    const geometry = new THREE.SphereGeometry(radius, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 0.7
    });
    
    // Create mesh and add to scene
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(position.x, position.y, position.z);
    window.scene.add(mesh);
    
    // Schedule removal after duration
    setTimeout(() => {
      if (window.scene) {
        window.scene.remove(mesh);
        geometry.dispose();
        material.dispose();
      }
    }, duration);
    
    return mesh;
  }
  
  /**
   * Disconnect from the server
   */
  disconnect() {
    if (this.socket) {
      this.socket.close();
    }
  }
} 

================================================
File: /public/js/npcManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';

/**
 * NPC Manager - Responsible for handling server-controlled NPCs
 * The actual NPC logic is now controlled by the server
 */
export class NpcManager {
  /**
   * Initialize the NPC Manager
   * @param {THREE.Scene} scene - The scene to add NPCs to
   */
  constructor(scene) {
    this.scene = scene;
    this.npcs = new Map(); // npcId -> NPC instances
    
    // NPC interaction system
    this.interactionPrompt = null;
    this.proximityRadius = 3.5; // How close the player needs to be to interact
    this.nearbyNpc = null; // Current NPC the player is near
    this.isBartenderNearby = false; // Specifically tracking if near the bartender
    
    console.log("NPC Manager initialized - NPCs are now server-controlled");
    
    // Create interaction prompt
    this.createInteractionUI();
  }

  /**
   * Get an NPC by ID
   * @param {string} npcId - The ID of the NPC to get
   * @returns {Object|null} The NPC instance or null if not found
   */
  getNpc(npcId) {
    return this.npcs.get(npcId);
  }

  /**
   * Check if an entity is an NPC
   * @param {string} entityId - The ID to check
   * @returns {boolean} True if the entity is an NPC
   */
  isNpc(entityId) {
    return typeof entityId === 'string' && (
      entityId.startsWith('npc_') || // New server-controlled NPC format
      entityId.startsWith('bot_')     // Legacy bot format for backward compatibility
    );
  }
  
  /**
   * Creates or updates a specific type of NPC based on username
   * @param {string} npcId - The NPC's ID
   * @param {Object} npcData - NPC data including username and position
   * @returns {ThirdPersonModel} - The created or updated NPC model
   */
  createOrUpdateNpc(npcId, npcData) {
    // Check if we already have this NPC
    let npcModel = this.npcs.get(npcId);
    
    // If we already have it, just return it
    if (npcModel) {
      return npcModel;
    }
    
    // Create a specialized ID for sheriff or bartender to help with model loading
    let specializedId = npcId;
    
    // Check if this is the sheriff or bartender based on username
    if (npcData && npcData.username) {
      if (npcData.username.toLowerCase().includes('sheriff')) {
        specializedId = `Sheriff_${npcId}`;
      } else if (npcData.username.toLowerCase().includes('bartender')) {
        specializedId = `Bartender_${npcId}`;
      }
    }
    
    // Create the NPC model with specialized ID to trigger proper model loading
    npcModel = new ThirdPersonModel(this.scene, specializedId);
    npcModel.isNpc = true;
    
    // Add to our tracking map
    this.npcs.set(npcId, npcModel);
    
    console.log(`Created NPC model for ${npcData.username || 'Unknown NPC'}`);
    return npcModel;
  }
  
  /**
   * Creates UI elements for NPC interaction
   */
  createInteractionUI() {
    // Create interaction prompt
    this.interactionPrompt = document.createElement('div');
    this.interactionPrompt.id = 'npc-interaction-prompt';
    this.interactionPrompt.style.position = 'absolute';
    this.interactionPrompt.style.bottom = '20%';
    this.interactionPrompt.style.left = '50%';
    this.interactionPrompt.style.transform = 'translate(-50%, 0) rotate(-2deg)';
    this.interactionPrompt.style.width = '350px';
    this.interactionPrompt.style.height = '100px';
    this.interactionPrompt.style.background = 'url("/textures/wooden_sign.png") no-repeat center center';
    this.interactionPrompt.style.backgroundSize = 'contain';
    this.interactionPrompt.style.display = 'flex';
    this.interactionPrompt.style.alignItems = 'center';
    this.interactionPrompt.style.justifyContent = 'center';
    this.interactionPrompt.style.zIndex = '1000';
    
    // Create text element
    this.promptText = document.createElement('div');
    this.promptText.style.fontFamily = 'Western, "Wanted M54", serif';
    this.promptText.style.fontSize = '28px';
    this.promptText.style.fontWeight = 'bold';
    this.promptText.style.color = '#FFD700';
    this.promptText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
    
    this.interactionPrompt.appendChild(this.promptText);
    document.getElementById('game-container').appendChild(this.interactionPrompt);
    this.interactionPrompt.style.display = 'none'; // Hide initially
    
    // Add gentle swing animation
    const promptAnimation = document.createElement('style');
    promptAnimation.textContent = `
      @keyframes swingSign {
        0% { transform: translate(-50%, 0) rotate(-2deg); }
        50% { transform: translate(-50%, 0) rotate(2deg); }
        100% { transform: translate(-50%, 0) rotate(-2deg); }
      }
      #npc-interaction-prompt {
        animation: swingSign 3s ease-in-out infinite;
      }
    `;
    document.head.appendChild(promptAnimation);
  }
  
  /**
   * Updates the list of nearby NPCs for interaction
   * @param {Player} player - The local player
   */
  updateNearbyNpcs(player) {
    if (!player) return;
    
    const playerPos = player.group.position.clone();
    this.nearbyNpc = null;
    this.isBartenderNearby = false;
    
    let closestDistance = this.proximityRadius;
    
    // Check each NPC for proximity
    for (const [npcId, npcModel] of this.npcs) {
      if (!npcModel.group) continue;
      
      // Get NPC position
      const npcPos = npcModel.group.position.clone();
      
      // Calculate distance to player
      const distance = playerPos.distanceTo(npcPos);
      
      // If within proximity radius and closer than any previous NPC
      if (distance <= closestDistance) {
        closestDistance = distance;
        this.nearbyNpc = npcModel;
        
        // Check if it's the bartender specifically
        if (npcId.includes('Bartender') || 
            (npcModel.playerId && npcModel.playerId.includes('Bartender'))) {
          this.isBartenderNearby = true;
          console.log('Near bartender, can get drunk!');
        }
      }
    }
    
    // Update UI based on nearby NPCs
    this.updateInteractionUI();
  }
  
  /**
   * Updates the interaction UI based on nearby NPCs
   */
  updateInteractionUI() {
    if (this.nearbyNpc && this.isBartenderNearby) {
      // Show bartender interaction prompt
      this.promptText.textContent = 'Press E to get drunk';
      this.interactionPrompt.style.display = 'flex';
      
      // Check if we're on mobile and show mobile bartender button if available
      if (window.mobileControls && typeof window.mobileControls.showBartenderButton === 'function') {
        window.mobileControls.showBartenderButton();
      }
    } else {
      // Hide interaction prompt
      this.interactionPrompt.style.display = 'none';
      
      // Hide mobile bartender button if available
      if (window.mobileControls && typeof window.mobileControls.hideBartenderButton === 'function') {
        window.mobileControls.hideBartenderButton();
      }
    }
  }
  
  /**
   * Handle interaction with NPCs
   * @param {KeyboardEvent|null} event - The keyboard event (null if triggered directly by mobile)
   * @param {Player} player - The local player
   * @returns {boolean} True if interaction was handled
   */
  handleInteraction(event, player) {
    // For keyboard events, only proceed if it's the E key
    if (event && event.code !== 'KeyE') return false;
    
    // Check if player is near the bartender
    if (this.isBartenderNearby) {
      console.log('Interacting with bartender - getting drunk!');
      
      // Trigger drunkenness effect
      if (window.drunkennessEffect) {
        window.drunkennessEffect.activate();
      }
      
      return true;
    }
    
    return false;
  }
}

// Create a simple placeholder that will be initialized properly in main.js
let npcManagerInstance = null;

export function initNpcManager(scene) {
  if (!npcManagerInstance) {
    npcManagerInstance = new NpcManager(scene);
  }
  return npcManagerInstance;
}

export const npcManager = {
  get instance() {
    return npcManagerInstance;
  }
}; 

================================================
File: /public/js/phantom-wallet.js
================================================
// Phantom Wallet Adapter for Solana
const phantomWalletAdapter = {
    // Keep track of connected wallet and public key
    wallet: null,
    publicKey: null,
    isConnected: false,
    
    // Event callback handlers
    onConnect: null,
    onDisconnect: null,
    onError: null,
    
    // Network manager reference for sending wallet data to server
    networkManager: null,
    
    // Initialize the adapter
    init(networkManager) {
        // Store network manager reference if provided
        if (networkManager) {
            this.networkManager = networkManager;
        }
        
        // Create the UI components
        this.createConnectButton();
        
        // Check if Phantom is installed
        if (!this.isPhantomInstalled()) {
            console.warn("Phantom wallet is not installed");
            this.updateConnectButtonStatus(false, "Install Phantom");
            return false;
        }
        
        // Setup event listeners for Phantom provider
        const provider = window.phantom?.solana;
        if (provider) {
            provider.on('connect', (publicKey) => {
                this.handleConnect(publicKey);
            });
            
            provider.on('disconnect', () => {
                this.handleDisconnect();
            });
            
            provider.on('accountChanged', (publicKey) => {
                if (publicKey) {
                    this.handleConnect(publicKey);
                } else {
                    this.handleDisconnect();
                }
            });
        }
        
        return true;
    },
    
    // Set the network manager after initialization (if needed)
    setNetworkManager(networkManager) {
        this.networkManager = networkManager;
        
        // If we're already connected, send the wallet address to the server
        if (this.isConnected && this.publicKey && this.networkManager) {
            this.sendWalletAddressToServer();
        }
    },
    
    // Send the wallet address to the server for NFT verification
    sendWalletAddressToServer() {
        if (!this.networkManager || !this.publicKey) return;
        
        console.log(`Sending wallet address to server: ${this.publicKey}`);
        
        // Use the network manager to send the wallet address
        if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
            this.networkManager.socket.send(JSON.stringify({
                type: 'walletConnect',
                walletAddress: this.publicKey
            }));
        } else {
            console.warn('Unable to send wallet address: WebSocket not connected');
        }
    },
    
    // Check if Phantom wallet is installed
    isPhantomInstalled() {
        const provider = window.phantom?.solana;
        return provider && provider.isPhantom;
    },
    
    // Connect to the wallet
    async connect() {
        try {
            if (!this.isPhantomInstalled()) {
                // Check if mobile device
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (isMobile) {
                    // Try direct protocol link only - no automatic redirects
                    window.location.href = 'solana-wallet://';
                    
                    // No timeouts or additional redirects
                    return;
                } else {
                    // On desktop, open the Phantom website
                    window.open('https://phantom.app/', '_blank');
                }
                return;
            }
            
            // Connect to the wallet
            const provider = window.phantom?.solana;
            const response = await provider.connect();
            
            // Handle connection
            this.handleConnect(response.publicKey);
            
            return this.publicKey;
        } catch (error) {
            console.error("Error connecting to Phantom wallet:", error);
            this.updateConnectButtonStatus(false);
            
            // Fire error event
            if (typeof this.onError === 'function') {
                this.onError(error);
            }
            
            // Dispatch custom error event
            document.dispatchEvent(new CustomEvent('walletError', {
                detail: { error }
            }));
            
            return null;
        }
    },
    
    // Handle successful wallet connection
    handleConnect(publicKey) {
        const provider = window.phantom?.solana;
        this.wallet = provider;
        this.publicKey = publicKey.toString();
        this.isConnected = true;
        
        // Update button status
        this.updateConnectButtonStatus(true);
        
        console.log("Connected to wallet:", this.publicKey);
        
        // Send the wallet address to the server
        this.sendWalletAddressToServer();
        
        // Fire connect callback
        if (typeof this.onConnect === 'function') {
            this.onConnect(this.publicKey);
        }
        
        // Dispatch custom connect event
        document.dispatchEvent(new CustomEvent('walletConnected', {
            detail: { publicKey: this.publicKey }
        }));
    },
    
    // Disconnect from the wallet
    async disconnect() {
        if (this.wallet) {
            await this.wallet.disconnect();
            this.handleDisconnect();
        }
    },
    
    // Handle wallet disconnection
    handleDisconnect() {
        this.wallet = null;
        this.publicKey = null;
        this.isConnected = false;
        
        // Update button status
        this.updateConnectButtonStatus(false);
        console.log("Disconnected from wallet");
        
        // Fire disconnect callback
        if (typeof this.onDisconnect === 'function') {
            this.onDisconnect();
        }
        
        // Dispatch custom disconnect event
        document.dispatchEvent(new CustomEvent('walletDisconnected'));
    },
    
    // Create the connect button UI
    createConnectButton() {
        // Create the button container
        const container = document.createElement('div');
        container.id = 'phantom-connect-container';
        container.style.position = 'fixed';
        container.style.top = '10px';
        container.style.right = '10px';
        container.style.zIndex = '999999'; // Much higher z-index
        
        // Create the button
        const button = document.createElement('button');
        button.id = 'phantom-connect-button';
        button.textContent = 'Connect';
        button.style.backgroundColor = 'transparent'; // Transparent background
        button.style.color = 'white'; // White text color
        button.style.border = '2px solid #8c5cf5'; // Purple outline
        button.style.borderRadius = '20px';
        button.style.padding = '8px 16px';
        button.style.cursor = 'pointer';
        button.style.fontFamily = 'Arial, sans-serif';
        button.style.fontWeight = 'bold';
        button.style.fontSize = '14px';
        button.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
        button.style.transition = 'all 0.2s ease';
        button.style.pointerEvents = 'auto'; // Ensure clicks are registered
        
        // Add click event
        button.onclick = async (event) => {
            // For desktop gaming, prevent automatic pointer lock after clicking
            if (!(/iPhone|iPad|iPod|Android/i.test(navigator.userAgent))) {
                // Store that user clicked wallet button
                document.body.setAttribute('data-wallet-clicked', 'true');
                
                // If document has pointer lock, release it
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
                
                // Prevent default to stop any automatic pointer lock
                event.preventDefault();
                event.stopPropagation();
            }
            
            if (this.isConnected) {
                await this.disconnect();
            } else {
                await this.connect();
            }
        };
        
        // Add responsive sizing for mobile
        const checkMobileAndResize = () => {
            if (window.innerWidth <= 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
                // More moderate size for mobile
                button.style.cssText += `
                    padding: 3px 8px !important;
                    font-size: 10px !important;
                    border-width: 1px !important;
                    border-radius: 14px !important;
                    opacity: 0.8 !important;
                    background-color: transparent !important;
                    color: white !important;
                `;
                container.style.cssText += `
                    top: 5px !important;
                    right: 5px !important;
                `;
                button.style.boxShadow = 'none !important';
            } else {
                button.style.cssText += `
                    padding: 8px 16px !important;
                    font-size: 14px !important;
                    border-width: 2px !important;
                    border-radius: 20px !important;
                    opacity: 1 !important;
                    background-color: transparent !important;
                    color: white !important;
                `;
                container.style.cssText += `
                    top: 10px !important;
                    right: 10px !important;
                `;
                button.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
            }
        };
        
        // Initial check
        checkMobileAndResize();
        
        // Add resize listener
        window.addEventListener('resize', checkMobileAndResize);
        
        // Force check on mobile devices
        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
            setTimeout(checkMobileAndResize, 100);
        }
        
        // Add button to container
        container.appendChild(button);
        
        // Add container to document
        document.body.appendChild(container);
    },
    
    // Update the connect button status
    updateConnectButtonStatus(connected, text) {
        const button = document.getElementById('phantom-connect-button');
        if (!button) return;
        
        if (connected) {
            button.textContent = this.publicKey 
                ? `${this.publicKey.slice(0, 4)}...${this.publicKey.slice(-4)}`
                : 'Connected';
            button.style.borderColor = '#4caf50'; // Green border
            button.style.color = 'white'; // White text
            button.style.backgroundColor = 'transparent';
        } else {
            button.textContent = 'Connect'; // Always use "Connect" regardless of device or install status
            button.style.borderColor = '#8c5cf5'; // Purple border
            button.style.color = 'white'; // White text
            button.style.backgroundColor = 'transparent';
        }
    },
    
    // Sign and send transaction
    async signAndSendTransaction(transaction) {
        if (!this.isConnected || !this.wallet) {
            console.error("Wallet not connected");
            return null;
        }
        
        try {
            // Sign the transaction
            const signedTransaction = await this.wallet.signTransaction(transaction);
            
            // Send the transaction
            const signature = await window.solana.request({
                method: "sendTransaction",
                params: {
                    transaction: signedTransaction.serialize(),
                },
            });
            
            return signature;
        } catch (error) {
            console.error("Error signing transaction:", error);
            
            // Fire error event
            if (typeof this.onError === 'function') {
                this.onError(error);
            }
            
            // Dispatch custom error event
            document.dispatchEvent(new CustomEvent('walletError', {
                detail: { error }
            }));
            
            return null;
        }
    },
    
    // Get the connected wallet balance
    async getBalance() {
        if (!this.isConnected || !this.publicKey) {
            console.error("Wallet not connected");
            return null;
        }
        
        try {
            // Create a connection to the Solana network
            const connection = new solanaWeb3.Connection(
                solanaWeb3.clusterApiUrl('mainnet-beta'),
                'confirmed'
            );
            
            // Get the wallet balance
            const balance = await connection.getBalance(
                new solanaWeb3.PublicKey(this.publicKey)
            );
            
            // Convert lamports to SOL
            return balance / 1000000000; // 1 SOL = 1,000,000,000 lamports
        } catch (error) {
            console.error("Error getting balance:", error);
            return null;
        }
    }
};

// Export the adapter
export default phantomWalletAdapter; 

================================================
File: /public/js/physics.js
================================================
/**
 * Physics system using cannon.js for collision detection and physics simulation.
 * Focused on creating invisible boundaries for the QuickDraw arenas.
 */
export class PhysicsSystem {
  constructor() {
    // Create a physics world with gravity
    this.world = new CANNON.World();
    this.world.gravity.set(0, -9.8, 0);
    
    // Set default contact material properties
    this.defaultMaterial = new CANNON.Material('default');
    const defaultContactMaterial = new CANNON.ContactMaterial(
      this.defaultMaterial,
      this.defaultMaterial,
      {
        friction: 0.3,
        restitution: 0.3 // Slightly bouncy
      }
    );
    this.world.addContactMaterial(defaultContactMaterial);
    this.world.defaultContactMaterial = defaultContactMaterial;
    
    // Collection of bodies
    this.bodies = [];
    
    // Debug helper for visualizing physics bodies
    this.debugMeshes = [];
    this.debugMode = false;
    
    // Track arena boundaries separately
    this.arenaBoundaryBodies = [];
    
    // Initialize ground
    this.initGround();
  }
  
  /**
   * Initialize the ground plane
   */
  initGround() {
    const groundBody = new CANNON.Body({
      mass: 0, // Static body
      shape: new CANNON.Plane(),
      material: this.defaultMaterial
    });
    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be flat
    
    // Tag as ground for quick identification
    groundBody.isGround = true;
    
    this.world.addBody(groundBody);
    this.bodies.push(groundBody);
  }
  
  /**
   * Gets the terrain height at a specific world position
   * @param {number} x - World x coordinate
   * @param {number} z - World z coordinate
   * @returns {number} - Height at that point (0 if terrain not available)
   */
  getTerrainHeightAt(x, z) {
    // If desert terrain is available, use its height
    if (window.desertTerrain) {
      // Get blend factor - 0 means town (flat), 1 means desert
      const townBlend = window.desertTerrain.getTownBlendFactor(x, z);
      
      if (townBlend > 0) {
        // If outside town area, calculate terrain height
        const baseNoise = window.desertTerrain.baseNoise.noise(
          x * window.desertTerrain.config.noiseScale.base, 
          z * window.desertTerrain.config.noiseScale.base
        ) * window.desertTerrain.config.heightScale.base;
        
        const duneHeight = window.desertTerrain.getDirectionalDuneHeight(x, z);
        
        // Scale by blend factor for smooth transition
        return (baseNoise + duneHeight * townBlend) * townBlend;
      }
    }
    
    // Default height for town area or if terrain not available
    return 0;
  }
  
  /**
   * Creates an invisible cylindrical boundary for a QuickDraw arena
   * @param {THREE.Vector3} center - Center position of the arena
   * @param {number} radius - Radius of the cylindrical arena
   * @param {number} height - Height of the cylindrical arena
   * @param {number} arenaIndex - Index of the arena (0-4)
   * @returns {CANNON.Body} - The created physics body
   */
  createQuickDrawArenaBoundary(center, radius, height, arenaIndex = 0) {
    // First remove any existing arena boundary for this index
    this.removeQuickDrawArenaBoundaryByIndex(arenaIndex);
    
    // Create a physics body for the arena boundary
    const arenaBody = new CANNON.Body({
      mass: 0, // Static body
      material: this.defaultMaterial
    });
    
    // Position at the center
    arenaBody.position.set(center.x, center.y + height/2, center.z);
    
    // Use a hollow cylinder (cylinder + inverted cylinder)
    // We make the walls a bit thick (0.5 units) to ensure reliable collision detection
    const wallThickness = 0.5;
    
    // Outer cylinder (pushing inward)
    const outerRadius = radius + wallThickness;
    const segments = 16; // Number of sides for the cylinder approximation
    
    // Create segments around the circle to approximate the cylinder
    for (let i = 0; i < segments; i++) {
      const angle1 = (i / segments) * Math.PI * 2;
      const angle2 = ((i + 1) / segments) * Math.PI * 2;
      
      const x1 = Math.cos(angle1) * radius;
      const z1 = Math.sin(angle1) * radius;
      const x2 = Math.cos(angle2) * radius;
      const z2 = Math.sin(angle2) * radius;
      
      // Calculate the position and orientation of this wall segment
      const segCenter = {
        x: (x1 + x2) / 2,
        z: (z1 + z2) / 2
      };
      
      const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
      
      // Create a box shape for this wall segment
      const halfExtents = new CANNON.Vec3(length/2, height/2, wallThickness/2);
      const wallShape = new CANNON.Box(halfExtents);
      
      // Get the angle to rotate this wall segment
      const rotationY = Math.atan2(z2 - z1, x2 - x1) + Math.PI/2;
      
      // Add the shape to the body with the appropriate offset and rotation
      const offset = new CANNON.Vec3(segCenter.x, 0, segCenter.z);
      const quaternion = new CANNON.Quaternion();
      quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
      
      arenaBody.addShape(wallShape, offset, quaternion);
    }
    
    // Bottom circle to prevent falling through
    const bottomShape = new CANNON.Cylinder(radius, radius, wallThickness, segments);
    const bottomOffset = new CANNON.Vec3(0, -height/2, 0);
    const bottomQuaternion = new CANNON.Quaternion();
    bottomQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
    arenaBody.addShape(bottomShape, bottomOffset, bottomQuaternion);
    
    arenaBody.arenaBoundary = true; // Tag this body as an arena boundary
    arenaBody.arenaIndex = arenaIndex; // Store which arena this belongs to
    arenaBody.collisionFilterGroup = 2; // Group 2 for arena boundaries
    
    // Add the arena body to the world
    this.world.addBody(arenaBody);
    this.bodies.push(arenaBody);
    
    // Store in our array of arena boundaries
    this.arenaBoundaryBodies[arenaIndex] = arenaBody;
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(arenaBody);
    }
    
    console.log(`Created QuickDraw arena boundary ${arenaIndex + 1} at`, center, "with radius", radius, "and height", height);
    
    return arenaBody;
  }
  
  /**
   * Removes a QuickDraw arena boundary for a specific arena index
   * @param {number} arenaIndex - The index of the arena (0-4)
   */
  removeQuickDrawArenaBoundaryByIndex(arenaIndex) {
    if (this.arenaBoundaryBodies[arenaIndex]) {
      this.world.removeBody(this.arenaBoundaryBodies[arenaIndex]);
      
      // Remove from our bodies array
      const index = this.bodies.indexOf(this.arenaBoundaryBodies[arenaIndex]);
      if (index !== -1) {
        this.bodies.splice(index, 1);
      }
      
      // Clear the reference in our arena boundaries array
      this.arenaBoundaryBodies[arenaIndex] = null;
      console.log(`Removed QuickDraw arena boundary ${arenaIndex + 1}`);
    }
  }
  
  /**
   * Removes the QuickDraw arena boundary (legacy method for backward compatibility)
   */
  removeQuickDrawArenaBoundary() {
    // Remove all arena boundaries
    for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
      this.removeQuickDrawArenaBoundaryByIndex(i);
    }
  }
  
  /**
   * Create a physics body for a player
   * @param {THREE.Vector3} position - Initial position
   * @param {number} radius - Player collision radius
   * @param {number} height - Player height
   * @returns {CANNON.Body} - The created physics body
   */
  createPlayerBody(position, radius = 0.51, height = 3.06) {
    // Create a capsule shape (cylinder with spheres at ends)
    const playerBody = new CANNON.Body({
      mass: 70, // Player mass in kg
      material: this.defaultMaterial,
      fixedRotation: true, // Don't rotate the player when colliding
      linearDamping: 0.9 // Add some damping to prevent excessive sliding
    });
    
    // Use a cylinder for the body
    playerBody.addShape(new CANNON.Cylinder(radius, radius, height, 8));
    
    // Position the player body
    playerBody.position.set(position.x, position.y, position.z);
    
    // Add to world
    this.world.addBody(playerBody);
    this.bodies.push(playerBody);
    
    // If debug mode is enabled, create a visual representation
    if (this.debugMode) {
      this.createDebugMesh(playerBody);
    }
    
    return playerBody;
  }
  
  /**
   * Checks if a point is inside any active arena boundary
   * @param {THREE.Vector3} point - The point to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInArenaBoundary(point) {
    // Check all arena boundaries
    for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
      if (this.isPointInSpecificArenaBoundary(point, i)) {
        return true;
      }
    }
    return false;
  }
  
  /**
   * Checks if a point is inside a specific arena boundary
   * @param {THREE.Vector3} point - The point to check
   * @param {number} arenaIndex - The arena index to check
   * @returns {boolean} - True if inside, false if outside
   */
  isPointInSpecificArenaBoundary(point, arenaIndex) {
    // If no arena boundary exists for this index, return false
    if (!this.arenaBoundaryBodies[arenaIndex]) return false;
    
    // Get arena position
    const arenaPos = this.arenaBoundaryBodies[arenaIndex].position;
    const pointVec = new CANNON.Vec3(point.x, point.y, point.z);
    
    // Calculate horizontal distance (ignoring Y) from arena center
    const dx = pointVec.x - arenaPos.x;
    const dz = pointVec.z - arenaPos.z;
    const horizontalDist = Math.sqrt(dx * dx + dz * dz);
    
    // Get the radius - assuming 15 is the standard radius for all arenas
    const radius = 15;
    
    // Check if point is inside the cylinder horizontally
    return horizontalDist < radius;
  }

  /**
   * Creates a debug mesh to visualize a physics body
   * @param {CANNON.Body} body - The physics body to visualize
   */
  createDebugMesh(body) {
    // Only used in debug mode
    if (!this.debugMode) return;
    
    // For each shape in the body, create a wireframe mesh
    body.shapes.forEach((shape, i) => {
      let geometry;
      let mesh;
      
      // Get the shape's offset and orientation
      const offset = body.shapeOffsets[i];
      const orientation = body.shapeOrientations[i];
      
      // Create different geometries based on shape type
      if (shape instanceof CANNON.Box) {
        geometry = new THREE.BoxGeometry(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        mesh.quaternion.set(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
      }
      else if (shape instanceof CANNON.Sphere) {
        geometry = new THREE.SphereGeometry(shape.radius, 16, 16);
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Apply offset
        mesh.position.set(offset.x, offset.y, offset.z);
      }
      else if (shape instanceof CANNON.Cylinder) {
        geometry = new THREE.CylinderGeometry(
          shape.radiusTop,
          shape.radiusBottom,
          shape.height,
          shape.numSegments
        );
        
        mesh = new THREE.Mesh(
          geometry,
          new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
          })
        );
        
        // Rotate to match cannon.js cylinders
        mesh.rotation.x = Math.PI / 2;
        
        // Apply offset and orientation
        mesh.position.set(offset.x, offset.y, offset.z);
        const quat = new THREE.Quaternion(
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w
        );
        mesh.quaternion.multiply(quat);
      }
      
      if (mesh) {
        // Add to the body's group
        const group = new THREE.Group();
        group.add(mesh);
        
        // Store reference for updating
        this.debugMeshes.push({
          mesh: group,
          body: body
        });
        
        // Add to scene
        window.scene.add(group);
      }
    });
  }
  
  /**
   * Update the physics world
   * @param {number} deltaTime - Time step in seconds
   */
  update(deltaTime) {
    // Limit delta time to prevent large jumps
    const timeStep = Math.min(deltaTime, 0.1);
    
    // Update physics world
    this.world.step(timeStep);
    
    // Update debug meshes if in debug mode
    if (this.debugMode) {
      this.updateDebugMeshes();
    }
  }
  
  /**
   * Update debug mesh positions to match their physics bodies
   */
  updateDebugMeshes() {
    if (!this.debugMode) return;
    
    this.debugMeshes.forEach(item => {
      // Update position
      item.mesh.position.set(
        item.body.position.x,
        item.body.position.y,
        item.body.position.z
      );
      
      // Update orientation
      item.mesh.quaternion.set(
        item.body.quaternion.x,
        item.body.quaternion.y,
        item.body.quaternion.z,
        item.body.quaternion.w
      );
    });
  }
  
  /**
   * Enables or disables debug visualization
   * @param {boolean} enabled - Whether debug mode should be enabled
   */
  setDebugMode(enabled) {
    // Store previous debug mode to detect changes
    const previousDebugMode = this.debugMode;
    this.debugMode = enabled;
    
    // If enabling and we weren't previously in debug mode
    if (enabled && !previousDebugMode) {
      // Create meshes for existing physics bodies
      this.bodies.forEach(body => {
        this.createDebugMesh(body);
      });
      
      // Set a global flag to signal hit zone debug should be created
      window.showHitZoneDebug = true;
      
      console.log("Physics debug mode enabled - hit zones visible");
    }
    // If disabling and we were previously in debug mode
    else if (!enabled && previousDebugMode) {
      // Remove all physics debug meshes
      this.debugMeshes.forEach(item => {
        if (item.mesh && window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
      this.debugMeshes = [];
      
      // Remove any hit zone debug visualizations
      this.cleanupHitZoneDebug();
      
      // Clear the global flag for hit zone debugging
      window.showHitZoneDebug = false;
      
      console.log("Physics debug mode disabled - hit zones hidden");
    }
  }
  
  /**
   * Clean up hit zone debug visualizations
   */
  cleanupHitZoneDebug() {
    // Find and remove all hit zone debug objects
    if (window.scene) {
      const hitZoneObjects = [];
      window.scene.traverse(obj => {
        if (obj.name && obj.name.startsWith("hitZoneDebug_")) {
          hitZoneObjects.push(obj);
        }
      });
      
      // Remove each hit zone debug object
      hitZoneObjects.forEach(obj => {
        window.scene.remove(obj);
        // Clean up materials and geometries
        obj.traverse(child => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        });
      });
      
      if (hitZoneObjects.length > 0) {
        console.log(`Removed ${hitZoneObjects.length} hit zone debug visualizations`);
      }
    }
    
    // Clear player hit zone debug references
    // Find all player objects
    if (window.localPlayer) {
      window.localPlayer._hitZoneDebug = null;
    }
    // Remote players
    if (window.remotePlayers) {
      window.remotePlayers.forEach(player => {
        if (player) {
          player._hitZoneDebug = null;
        }
      });
    }
  }
  
  /**
   * Refreshes hit zone debug visualizations when debug mode is active
   */
  refreshHitZoneDebug() {
    console.log("Refreshing hit zone debug visualizations");
    
    // Don't do anything if debug mode isn't enabled
    if (!this.debugMode) return;
    
    // Create debug boxes for all existing player models
    if (window.playersMap) {
      for (const [playerId, playerModel] of window.playersMap.entries()) {
        if (playerModel && typeof playerModel.createHitZoneVisualizers === 'function') {
          // Use the new direct visualization method with forced visibility
          playerModel.createHitZoneVisualizers(true);
        } else {
          console.warn(`Player ${playerId} doesn't support improved hit zones`);
          // We no longer use the old fallback method
        }
      }
    }
    
    // Also check the local player's model if available
    if (window.localPlayer && window.localPlayer.model && 
        typeof window.localPlayer.model.createHitZoneVisualizers === 'function') {
      window.localPlayer.model.createHitZoneVisualizers(true);
    }
    
    // Print debug info to console
    if (typeof window.printHitboxDebugInfo === 'function') {
      window.printHitboxDebugInfo();
    }
  }
  
  /**
   * Cleans up all physics resources
   */
  cleanup() {
    // Remove all bodies
    this.bodies.forEach(body => {
      this.world.removeBody(body);
    });
    
    // Remove all debug meshes
    if (this.debugMode) {
      this.debugMeshes.forEach(item => {
        if (window.scene) {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        }
      });
    }
    
    // Clean up hit zone debug visualizations
    this.cleanupHitZoneDebug();
    
    this.bodies = [];
    this.debugMeshes = [];
    this.arenaBoundaryBodies = [];
  }
}

================================================
File: /public/js/player.js
================================================
import { Viewmodel } from './viewmodel.js';
import { updateAmmoUI, updateHealthUI, showDamageIndicator } from './ui.js';
import { applyRecoil } from './effects.js';
import { networkManager } from './network.js';

/**
 * The local Player class (first-person).
 */
export class Player {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene
   * @param {THREE.PerspectiveCamera} config.camera
   * @param {SoundManager} config.soundManager
   * @param {Function} config.onShoot - A callback function called when the player fires a bullet.
   */
  constructor({ scene, camera, soundManager, onShoot }) {
    // Enable ammo debugging by default
    window.debugAmmo = true;
    
    this.scene = scene;
    this.camera = camera;
    this.soundManager = soundManager;
    this.onShootCallback = onShoot;

    this.group = new THREE.Group();
    
    // Start at a random spawn point in the town street
    this.spawnPlayerRandomly();
    
    this.scene.add(this.group);
    this.camera.position.set(0, -0.7, 0);
    this.group.add(this.camera);

    this.id = null; // will be set by networkManager.onInit
    this.velocity = new THREE.Vector3();
    this.canJump = false;
    this.gravity = 25; // Increased from 15 for much stronger gravity pull

    // Add recoil boost flag to prevent normal velocity dampening
    this.recoilBoosted = false;
    this.recoilBoostTime = 0;
    this.recoilBoostDuration = 0.3; // How long the velocity boost lasts

    // Movement flags
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    
    // Movement control flags
    this.canMove = true; // Whether player can move at all
    this.forceLockMovement = false; // Complete movement override (quickdraw mode)
    this.chatActive = false; // Whether chat input is active
    
    // Sprinting flag - new addition
    this.isSprinting = false;
    this.normalSpeed = 3.5; // Reduced from 5 for slower movement
    this.sprintSpeed = 7; // Reduced from 12 for more realistic running
    this.sprintJumpBoost = 1.1; // Reduced further for more subtle sprint jumping effect

    // Aiming
    this.isAiming = false;
    this.defaultFOV = 75;
    this.aimFOV = 65;
    
    // Camera effects for sprinting - with smoothing parameters
    this.defaultCameraHeight = -0.7;
    this.bobPhase = 0; // Phase accumulator for bob effect
    this.bobIntensity = 0; // Current intensity of bobbing (interpolates)
    this.targetBobIntensity = 0; // Target bobbing intensity
    this.bobTransitionSpeed = 3; // Speed of transition to new bob intensity
    
    // Gun
    this.viewmodel = new Viewmodel();
    this.holsterOffset = new THREE.Vector3(0.6, -1.1, -0.8);
    this.aimOffset = new THREE.Vector3(0.3, -0.9, -0.5);
    this.currentGunOffset = this.holsterOffset.clone();
    
    // Add both models to camera, but we'll only show the viewmodel
    this.camera.add(this.viewmodel.group);
    
    // FOV transition smoothing
    this.currentFOV = this.defaultFOV;
    this.targetFOV = this.defaultFOV;
    this.fovTransitionSpeed = 5; // Speed of FOV transitions

    // Reload
    this.isReloading = false;
    this.reloadTime = 4000; // Changed from 2000ms to 4000ms (4 seconds)
    this.reloadProgress = 0;
    
    // Track bullets for each weapon type separately
    this.weaponAmmo = {
      revolver: 6,
      shotgun: 2
    };
    
    this.bullets = 6; // Current active weapon's bullets
    this.maxBullets = 6;
    this.canShoot = true;

    // Weapon types and switching
    this.activeWeapon = 'revolver'; // 'revolver' or 'shotgun'
    this.weaponStats = {
      revolver: {
        maxBullets: 6,
        reloadTime: 4000,
        bulletCount: 1, // Single bullet per shot
        bulletSpread: 0.0005 // Default spread
      },
      shotgun: {
        maxBullets: 2,
        reloadTime: 6000, // Longer reload for shotgun
        bulletCount: 10, // 10 pellets per shot
        bulletSpread: 0.08, // Increased spread from 0.03 to 0.08
        pelletDamage: {
          head: 10,    // Headshot damage per pellet
          body: 5,     // Body damage per pellet
          limbs: 5     // Limb damage per pellet
        }
      }
    };

    // Health
    this.health = 100;

    // Networking
    this.lastNetworkUpdate = 0;
    this.networkUpdateInterval = 33; // ~30 fps updates, balanced between responsiveness and bandwidth

    // Quick Draw mode
    this.canAim = true; // Whether the player is allowed to aim (used by Quick Draw)
    
    // Alternative aiming controls
    this.isFAiming = false; // Whether player is aiming using the F key
    this.isFRmbPressed = false; // Whether right mouse button is pressed during F-aiming
    this.isLmbPressed = false; // Whether left mouse button is being held (for hold-to-shoot)
    
    // Store previous position to detect collision with arena boundary
    this.previousPosition = new THREE.Vector3();

    // Quick Draw lobby information
    this.quickDrawLobbyIndex = -1; // -1 means not in a lobby
    
    // Anti-cheat: Server reconciliation
    this.serverPosition = new THREE.Vector3();
    this.isReconciling = false;
    this.reconciliationLerpFactor = 0.3; // How quickly to move to server position

    // Footstep sound system
    this.lastFootstepTime = 0; // Time of last footstep sound
    this.footstepInterval = 0.5; // Base interval in seconds between steps
    this.isLeftFoot = true; // Track which foot is next
    this.isMovingLastFrame = false; // Track if player was moving in the last frame
    this.isJumping = false; // Track jumping state
    
    // Hit zones for damage calculations
    this.hitZones = {
      head: { damage: 100 },
      body: { damage: 40 },
      limbs: { damage: 20 }
    };
    
    // Jump mechanics
    this.jumpCooldown = 0; // Cooldown timer to prevent jump spamming
    this.jumpCooldownTime = 0.3; // Time in seconds between allowed jumps
    
    // Initialize network & UI
    this.initNetworking();
    updateAmmoUI(this);
    updateHealthUI(this);
  }

  /**
   * Spawn the player at a random position along the main street
   */
  spawnPlayerRandomly() {
    // Try to find a valid spawn position with no collisions
    let spawnX, spawnY, spawnZ;
    let validSpawn = false;
    let attempts = 0;
    const maxAttempts = 20;
    
    while (!validSpawn && attempts < maxAttempts) {
      // Random position within the main street
      spawnX = (Math.random() - 0.5) * 10; // Random X between -5 and 5 (main street)
      spawnY = 2.72; // Eye level
      spawnZ = (Math.random() - 0.5) * 40; // Random Z between -20 and 20
      
      // Check if this position is valid (not colliding with anything)
      const testPosition = new THREE.Vector3(spawnX, spawnY, spawnZ);
      validSpawn = this.checkBoundaryCollision(testPosition);
      attempts++;
    }
    
    // If we couldn't find a valid position, use a safe fallback position
    if (!validSpawn) {
      console.warn(`Could not find valid spawn position after ${maxAttempts} attempts. Using fallback.`);
      spawnX = 0;
      spawnY = 2.72; // Consistent eye level
      spawnZ = 0;
    }

    this.group.position.set(spawnX, spawnY, spawnZ);
    
    // Random rotation (facing any direction)
    this.group.rotation.y = Math.random() * Math.PI * 2;
    
    console.log(`Player spawned at: X=${spawnX.toFixed(2)}, Z=${spawnZ.toFixed(2)}`);
  }

  /**
   * Initialize networking for the player
   */
  initNetworking() {
    // Start the WebSocket
    networkManager.connect();

    networkManager.onInit = (initData) => {
      this.id = initData.id;
      console.log(`Local player initialized with ID: ${this.id}`);
    };
    
    // Handle player hit
    networkManager.onPlayerHit = (sourceId, hitData, newHealth, hitZone) => {
      this.health = newHealth;
      updateHealthUI(this);
      
      // Show hit zone on screen for 100ms
      showDamageIndicator(hitData.damage, hitZone);
    };
    
    // Anti-cheat: Handle respawn from server
    networkManager.onRespawn = (position, health, bullets, maxBullets, activeWeapon) => {
      console.log("Server-initiated respawn");
      
      // Set position
      this.group.position.copy(position);
      this.previousPosition.copy(position);
      
      // Update health
      this.health = health || 100;
      
      // Set active weapon if provided by server
      if (activeWeapon && (activeWeapon === 'revolver' || activeWeapon === 'shotgun')) {
        // Only switch if different from current
        if (this.activeWeapon !== activeWeapon) {
          this.switchWeapon(activeWeapon);
        }
      }
      
      // Reset all weapon ammo to maximum
      this.weaponAmmo = {
        revolver: this.weaponStats.revolver.maxBullets,
        shotgun: this.weaponStats.shotgun.maxBullets
      };
      
      // Set active weapon's bullets
      this.bullets = this.weaponAmmo[this.activeWeapon];
      this.maxBullets = this.weaponStats[this.activeWeapon].maxBullets;
      
      // Cancel any ongoing reloading
      if (this.isReloading) {
        // Cancel reload animation
        if (this.viewmodel) {
          this.viewmodel.cancelReload();
        }
        
        // Hide reload UI elements
        const reloadProgressContainer = document.getElementById('reload-progress-container');
        if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
      }
      
      // Reset states
      this.isReloading = false;
      this.isAiming = false;
      this.velocity.y = 0;
      this.canAim = true;
      this.canShoot = true;
      
      // Update UI
      updateHealthUI(this);
      updateAmmoUI(this);
      
      console.log(`Respawn complete - Current weapon: ${this.activeWeapon}, Ammo: ${this.bullets}/${this.maxBullets}`);
      console.log(`Weapon ammo: Revolver: ${this.weaponAmmo.revolver}, Shotgun: ${this.weaponAmmo.shotgun}`);
    };
  }

  update(deltaTime) {
    // Skip update if paused
    if (window.isPaused) return;
    
    // Store the previous position for collision detection and footsteps
    this.previousPosition.copy(this.group.position);
    
    // Platform stability check - prevent falling through platforms 
    this.stabilizePlatformPosition();
    
    // Anti-cheat: Handle server reconciliation
    if (this.isReconciling) {
      // Calculate distance to server position
      const distance = this.group.position.distanceTo(this.serverPosition);
      
      // Only apply reconciliation if significant deviation exists
      if (distance > 0.1) {
        // For large corrections, blend gradually
        this.group.position.lerp(this.serverPosition, this.reconciliationLerpFactor);
      } else {
        // Close enough, stop reconciling
        this.isReconciling = false;
      }
    }
    
    // Smoothly interpolate the gun offset & FOV
    const targetOffset = this.isAiming && this.canAim ? this.aimOffset : this.holsterOffset;
    this.currentGunOffset.lerp(targetOffset, 0.1);
    
    // Update viewmodel animation - Ensure this is being called!
    if (this.viewmodel) {
      this.viewmodel.update(deltaTime);
    } else {
      console.warn("Viewmodel is not initialized!");
    }

    // Adjust FOV based on sprinting and aiming with smoother transitions
    if (this.isAiming && this.canAim) {
      this.targetFOV = this.aimFOV;
    } else if (this.isSprinting && this.isMoving() && !window.quickDraw?.inDuel) {
      // FOV effect when sprinting, but not in QuickDraw duel
      this.targetFOV = this.defaultFOV + 7; // Less extreme FOV increase (was 10)
    } else {
      this.targetFOV = this.defaultFOV;
    }
    
    // Smooth FOV transition
    this.currentFOV = THREE.MathUtils.lerp(
      this.currentFOV, 
      this.targetFOV, 
      deltaTime * this.fovTransitionSpeed
    );
    
    // Only update camera FOV if it has changed enough to be noticeable
    if (Math.abs(this.camera.fov - this.currentFOV) > 0.01) {
      this.camera.fov = this.currentFOV;
      this.camera.updateProjectionMatrix();
    }

    // Process movement
    this.move(deltaTime);
    
    // Footstep sounds logic based on movement
    const positionBeforeMovement = this.previousPosition.clone();
    
    // Check for nearest player for potential quickdraw on mobile
    if (window.mobileControls && typeof window.checkNearestPlayerForQuickdraw === 'function') {
      const nearbyPlayer = window.checkNearestPlayerForQuickdraw(this);
      // Update mobile UI if nearby player found
      if (window.mobileControls) {
        window.mobileControls.checkForNearbyPlayers(nearbyPlayer !== null);
      }
    }
    
    // Update camera bob (only if on ground)
    // Always update the head bob regardless of whether we're on ground
    this.updateHeadBob(deltaTime);
    
    // Update aiming effects including crosshair
    this.updateAiming(deltaTime);
    
    // Update footstep sounds based on movement
    this.updateFootstepSounds(deltaTime, positionBeforeMovement);
    
    // Send periodic network updates
    const now = performance.now();
    if (now - this.lastNetworkUpdate > this.networkUpdateInterval) {
      this.lastNetworkUpdate = now;
      this.sendNetworkUpdate();
    }

    if (this.soundManager) {
      // Update audio listener position to follow the player's camera
      // Use precise camera position rather than group position for better audio
      const cameraPosition = new THREE.Vector3();
      this.camera.getWorldPosition(cameraPosition);
      
      // Get forward direction vector from camera
      const cameraDirection = new THREE.Vector3(0, 0, -1);
      cameraDirection.applyQuaternion(this.camera.quaternion);
      
      // Get up vector from camera
      const upVector = new THREE.Vector3(0, 1, 0);
      upVector.applyQuaternion(this.camera.quaternion);
      
      // Update the audio listener position
      this.soundManager.updateListenerPosition(cameraPosition, cameraDirection, upVector);
    }
  }

  /**
   * Process player movement based on input - can be overridden to disable movement
   * @param {number} deltaTime - Time elapsed since last frame
   */
  move(deltaTime) {
    if (this.forceLockMovement) return; // Complete override for duel mode
    if (!this.canMove) return; // Movement lock (e.g. during Quick Draw)
    if (this.chatActive) return; // Don't move when chat is active

    // Update jump cooldown if it's active
    if (this.jumpCooldown > 0) {
      this.jumpCooldown = Math.max(0, this.jumpCooldown - deltaTime);
    }
    
    // Update recoil boost timer if active
    if (this.recoilBoosted) {
      this.recoilBoostTime -= deltaTime;
      if (this.recoilBoostTime <= 0) {
        this.recoilBoosted = false;
      }
    }

    // Only apply movement inputs if not in recoil boost mode
    if (!this.recoilBoosted) {
      if (this.moveForward) this.velocity.z = -this.getMoveSpeed();
      else if (this.moveBackward) this.velocity.z = this.getMoveSpeed();
      else this.velocity.z = 0;

      if (this.moveRight) this.velocity.x = this.getMoveSpeed();
      else if (this.moveLeft) this.velocity.x = -this.getMoveSpeed();
      else this.velocity.x = 0;
    }

    // Store previous position before movement for collision detection
    this.previousPosition.copy(this.group.position);

    // Store previous info for comparing changes
    const wasOnGround = this.group.position.y <= 2.72 || this.isOnObject;
    const wasJumping = this.isJumping;
    
    // Calculate new vertical position with gravity - always apply gravity unless in recoil boost
    if (!wasOnGround && (!this.recoilBoosted || this.velocity.y < 0)) {
      this.velocity.y -= this.gravity * deltaTime;
    }
    const newVerticalPos = {
      y: this.group.position.y + (this.velocity.y * deltaTime)
    };
    
    // Check if player will land on an object (like a crate)
    const feetPos = new THREE.Vector3(
      this.group.position.x,
      this.group.position.y - 2.72, // Adjust for player height
      this.group.position.z
    );
    const isOnObject = this.checkStandingOnObject(feetPos);
    
    // Get terrain height at current position
    let terrainHeight = 0;
    if (window.physics) {
      terrainHeight = window.physics.getTerrainHeightAt(this.group.position.x, this.group.position.z);
    }
    
    // Check if player would hit a ceiling
    const headPos = new THREE.Vector3(
      this.group.position.x,
      this.group.position.y + 0.3, // Adjust for player height
      this.group.position.z
    );
    const hitCeiling = this.checkCeilingCollision(headPos);
    
    // Handle vertical movement
    if (this.velocity.y <= 0 && (newVerticalPos.y <= 2.72 + terrainHeight || isOnObject)) {
      // Player landed on ground or object
      if (this.velocity.y < -3 && !wasOnGround) {
        // Play landing sound if falling fast enough
        if (this.soundManager) {
          this.soundManager.playSound("jumpland", 0, 1.2);
        }
      }
      
      // Set to ground or object height
      if (isOnObject && isOnObject.y > 2.72 + terrainHeight) {
        this.group.position.y = isOnObject.y;
      } else {
        this.group.position.y = 2.72 + terrainHeight; // Regular ground level + terrain
      }
      
      this.velocity.y = 0;
      this.canJump = true;
      this.isJumping = false;
    } else if (hitCeiling && this.velocity.y > 0) {
      // Hit ceiling, stop upward momentum
      this.velocity.y = 0;
      this.group.position.y = hitCeiling.y - 0.3; // Adjust position to be just below ceiling
    } else {
      // In air, apply vertical motion
      this.group.position.y = newVerticalPos.y;
      this.canJump = false;
    }
    
    // Apply horizontal movement to a test position (don't actually move yet)
    const movement = new THREE.Vector3();
    
    // Special handling for recoil boost - use absolute world direction
    if (this.recoilBoosted) {
      // For recoil, we use the velocity directly as world-space movement
      movement.x = this.velocity.x * deltaTime;
      movement.z = this.velocity.z * deltaTime;
    } else {
      // Normal movement - apply player rotation
      movement.x = this.velocity.x * deltaTime;
      movement.z = this.velocity.z * deltaTime;
      movement.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.group.rotation.y);
    }
    
    // Calculate desired new position
    const newPosition = this.group.position.clone().add(movement);
    
    // Auto-step detection - check if there's a small step in front of us that we can climb
    const stepHeight = 0.9;
    const stepPosition = this.checkForStep(newPosition, stepHeight);
    if (stepPosition) {
      // Found a step we can climb - adjust our position to step up onto it
      // Smooth the transition by interpolating current height and target height
      const stepUpLerpFactor = 0.5; // Controls how quickly we step up
      this.group.position.y = THREE.MathUtils.lerp(
        this.group.position.y,
        stepPosition.y,
        stepUpLerpFactor
      );
      this.velocity.y = 0; // Reset vertical velocity
      this.canJump = true; // Always can jump on top of a step
      this.isJumping = false;
    }
    
    // Use our enhanced collision system with sliding
    const finalPosition = this.handleCollisionSliding(newPosition);
    
    // Apply the horizontal position
    this.group.position.x = finalPosition.x;
    this.group.position.z = finalPosition.z;
    
    // We no longer need to handle jump sound here since it's handled in the jump() method
  }

  /**
   * Update footstep sounds based on movement
   * @param {number} deltaTime - Time elapsed since last frame
   * @param {THREE.Vector3} previousPosition - Position before movement this frame
   */
  updateFootstepSounds(deltaTime, previousPosition) {
    // Only play footstep sounds if we're on the ground and actually moving
    const isMovingNow = this.isMoving() && this.canJump;
    
    // Calculate how far we've moved this frame
    const distanceMoved = this.group.position.distanceTo(previousPosition);
    
    // Skip if not moving or not on ground
    if (!isMovingNow || distanceMoved < 0.001) {
      this.isMovingLastFrame = false;
      return;
    }
    
    // Calculate the appropriate footstep interval based on speed
    let currentInterval = this.footstepInterval;
    if (this.isSprinting) {
      currentInterval = 0.3; // Faster steps when sprinting
    } else {
      currentInterval = 0.5; // Normal walking pace
    }
    
    // Accumulate time since last footstep
    this.lastFootstepTime += deltaTime;
    
    // Check if it's time for a footstep sound
    if (this.lastFootstepTime >= currentInterval) {
      // Reset the timer, with a small random variation for naturalness
      this.lastFootstepTime = -0.05 + Math.random() * 0.1;
      
      // Determine which foot and play the appropriate sound
      if (this.soundManager) {
        // Use direct sound play instead of positional audio for now
        this.soundManager.playSound(
          this.isLeftFoot ? 'leftstep' : 'rightstep',
          0, // No cooldown
          this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
        );
        
        // Try positional audio as fallback
        try {
          this.soundManager.playSoundAt(
            this.isLeftFoot ? 'leftstep' : 'rightstep',
            this.group.position,
            0, // No cooldown
            this.isSprinting ? 1.2 : 0.8 // Adjust volume based on speed
          );
        } catch (err) {
          console.log("Fallback to positional audio failed:", err);
        }
      }
      
      // Switch feet for next step
      this.isLeftFoot = !this.isLeftFoot;
    }
    
    this.isMovingLastFrame = true;
  }

  /**
   * Updates camera head bobbing effect for walking/running with much smoother transitions
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateHeadBob(deltaTime) {
    // Update target bobbing intensity based on movement
    if (this.isMoving() && this.canJump) {
      // Very subtle bobbing values for higher camera position
      this.targetBobIntensity = this.isSprinting ? 0.022 : 0.011;
    } else {
      this.targetBobIntensity = 0;
    }
    
    // Smoothly transition bob intensity
    this.bobIntensity = THREE.MathUtils.lerp(
      this.bobIntensity,
      this.targetBobIntensity,
      Math.min(1, deltaTime * this.bobTransitionSpeed)
    );
    
    // Only calculate bob if intensity is significant
    if (this.bobIntensity > 0.001) {
      // Update phase at a speed proportional to movement
      // Use different frequencies for vertical and horizontal to create more natural movement
      this.bobPhase += deltaTime * (this.isSprinting ? 10 : 6);
      
      // Calculate vertical and horizontal components
      const verticalBob = Math.sin(this.bobPhase * 2) * this.bobIntensity;
      // Much smaller horizontal component
      const horizontalBob = Math.cos(this.bobPhase) * this.bobIntensity * 0.3;
      
      // Apply to camera position smoothly - ensure we're using defaultCameraHeight
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight + verticalBob,
        Math.min(1, deltaTime * 8)
      );
      
      // Extremely subtle horizontal movement
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        horizontalBob,
        Math.min(1, deltaTime * 3)
      );
    } else {
      // Smoothly return to default position when not moving
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight,
        Math.min(1, deltaTime * 4)
      );
      
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        0,
        Math.min(1, deltaTime * 3)
      );
    }
  }

  /**
   * Returns the current movement speed based on sprint state and location
   * @returns {number} The current movement speed
   */
  getMoveSpeed() {
    // Disable sprinting in QuickDraw duels
    if (window.quickDraw && window.quickDraw.inDuel) {
      return this.normalSpeed;
    }
    
    // Apply sprint speed if sprint key is pressed
    return this.isSprinting ? this.sprintSpeed : this.normalSpeed;
  }
  
  /**
   * Checks if the player is currently moving
   * @returns {boolean} True if any movement key is pressed
   */
  isMoving() {
    return this.moveForward || this.moveBackward || this.moveLeft || this.moveRight;
  }

  /**
   * Checks for collision with the arena boundary or town objects
   * @param {THREE.Vector3} position - The position to check
   * @returns {boolean} - true if no collision, false if colliding
   */
  checkBoundaryCollision(position) {
    // First check arena boundary if player is in a quickDraw arena
    if (this.quickDrawLobbyIndex >= 0 && window.quickDraw && window.quickDraw.physics) {
      const physics = window.quickDraw.physics;
      const arenaIndex = this.quickDrawLobbyIndex;
      
      if (!physics.isPointInSpecificArenaBoundary(position, arenaIndex)) {
        return false; // Colliding with arena boundary
      }
    }
    
    // Town border limits check removed - players can now leave town
    
    // Check collision with town objects/colliders
    if (window.physics && window.physics.bodies) {
      // Create a small sphere for collision detection
      const playerRadius = 0.68; // Increased radius from 0.4 to prevent getting too close
      
      // We'll check two points - one at "shoulder" height and one at "foot" height
      // to make collisions more realistic
      const shoulderPos = new THREE.Vector3(position.x, position.y - 0.5, position.z);
      const footPos = new THREE.Vector3(position.x, position.y - 1.5, position.z);
      
      // Check each physics body that's not a player or arena boundary
      for (const body of window.physics.bodies) {
        // Skip if this is an arena boundary
        if (body.arenaBoundary) continue;
        
        // Skip if mass > 0 (non-static body)
        if (body.mass > 0) continue;
        
        // Currently we only handle box shapes
        for (let i = 0; i < body.shapes.length; i++) {
          const shape = body.shapes[i];
          if (shape.type !== CANNON.Shape.types.BOX) continue;
          
          // Get the world position/rotation of this shape
          const shapePos = new CANNON.Vec3();
          const shapeQuat = new CANNON.Quaternion();
          body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
          body.quaternion.mult(body.shapeOrientations[i], shapeQuat);
          
          // Convert to THREE.js objects for easier collision check
          const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
          const boxSize = new THREE.Vector3(
            shape.halfExtents.x * 2,
            shape.halfExtents.y * 2,
            shape.halfExtents.z * 2
          );
          
          // Create box3 from position and size
          const box = new THREE.Box3().setFromCenterAndSize(boxPos, boxSize);
          
          // Skip floor-like objects for horizontal collision (if player is above them)
          // This helps with standing on roofs and floors
          if (boxSize.y < 1.0 && position.y > boxPos.y + boxSize.y/2 + 0.1) {
            // This is a thin box below the player - likely a floor, skip horizontal collision
            continue;
          }
          
          // Skip ceiling-like objects for horizontal collision (if player is below them)
          if (boxSize.y < 1.0 && position.y < boxPos.y - boxSize.y/2 - 0.1) {
            // This is a thin box above the player - likely a ceiling, skip horizontal collision
            continue;
          }
          
          // Check if player sphere intersects with box
          const distShoulder = box.distanceToPoint(shoulderPos);
          const distFoot = box.distanceToPoint(footPos);
          
          if (distShoulder < playerRadius || distFoot < playerRadius) {
            return false; // Collision detected
          }
        }
      }
    }
    
    return true; // No collision
  }
  
  /**
   * Handles sliding along walls when colliding
   * @param {THREE.Vector3} desiredPosition - Where player wants to move
   * @returns {THREE.Vector3} - Adjusted position with sliding if needed
   */
  handleCollisionSliding(desiredPosition) {
    // If no collision, return the desired position
    if (this.checkBoundaryCollision(desiredPosition)) {
      return desiredPosition;
    }
    
    // We have a collision, try to slide along the obstacle
    const currentPos = this.group.position.clone();
    
    // Calculate movement vector
    const movement = desiredPosition.clone().sub(currentPos);
    
    // If movement is very small, just return current position to avoid getting stuck
    if (movement.lengthSq() < 0.0001) {
      return currentPos;
    }
    
    // Scale down movement vector to find a non-colliding position
    const scaledMovement = movement.clone();
    let validPosition = false;
    
    // Try sliding along X and Z separately
    const slideX = currentPos.clone();
    slideX.x += movement.x;
    
    const slideZ = currentPos.clone();
    slideZ.z += movement.z;
    
    // Check if either sliding direction is valid
    const canSlideX = this.checkBoundaryCollision(slideX);
    const canSlideZ = this.checkBoundaryCollision(slideZ);
    
    if (canSlideX) {
      // X-axis movement is valid
      return slideX;
    } else if (canSlideZ) {
      // Z-axis movement is valid
      return slideZ;
    }
    
    // If we're really stuck, check if we're penetrating a collider and try to push out
    const escapeDist = 0.05; // Small escape distance
    
    // Try escaping in each cardinal direction
    const escapeVectors = [
      new THREE.Vector3(escapeDist, 0, 0),
      new THREE.Vector3(-escapeDist, 0, 0),
      new THREE.Vector3(0, 0, escapeDist),
      new THREE.Vector3(0, 0, -escapeDist)
    ];
    
    for (const escapeVec of escapeVectors) {
      const escapePos = currentPos.clone().add(escapeVec);
      if (this.checkBoundaryCollision(escapePos)) {
        console.log("Rescued player from being stuck");
        return escapePos;
      }
    }
    
    // If all else fails, return current position
    return currentPos;
  }

  /**
   * Send position/rotation updates to the server.
   */
  sendNetworkUpdate() {
    if (this.id == null) return;
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    networkManager.sendUpdate({
      position: {
        x: this.group.position.x,
        y: this.group.position.y,
        z: this.group.position.z
      },
      rotation: {
        y: this.group.rotation.y
      },
      isAiming: this.isAiming,
      isReloading: this.isReloading,
      isSprinting: this.isSprinting,
      isShooting: this.viewmodel && this.viewmodel.animationState === 'shoot',
      health: this.health,
      quickDrawLobbyIndex: this.quickDrawLobbyIndex
    });
  }

  /**
   * Handle shooting logic
   */
  shoot() {
    if (this.bullets <= 0 || !this.canShoot || this.isReloading) {
      // No bullets or can't shoot
      if (this.bullets === 0) {
        const reloadMessage = document.getElementById('reload-message');
        if (reloadMessage) reloadMessage.style.display = 'block';
        
        // If we're already in the empty animation, don't trigger it again
        if (this.viewmodel && 
            this.viewmodel.animationState !== `${this.activeWeapon}empty`) {
          // Play the empty gun animation when no ammo
          if (this.isAiming && this.viewmodel) {
            this.viewmodel.playFakeShootAnim();
            
            // Play empty gun click sound if sound manager exists
            if (this.soundManager && !window.isMobile) {
              // Only play empty click on desktop - skip on mobile to avoid sound issues
              if (this.activeWeapon === 'shotgun') {
                this.soundManager.playSound("shotgunempty");
              }
            }
          }
        }
      }
      return;
    }
    
    // Actually shoot
    this.bullets--;
    
    // Update weapon-specific ammo storage and ensure consistency
    this._syncWeaponAmmo();
    
    updateAmmoUI(this);

    this.canShoot = false;
    setTimeout(() => { this.canShoot = true; }, 250);

    // Play the shooting animation on the viewmodel if aiming
    if (this.isAiming) {
      this.viewmodel.playShootAnim();
    }

    // Find bullet spawn - use viewmodel instead of revolver
    const bulletStart = this.viewmodel.getBarrelTipWorldPosition();
    
    // Get weapon stats for spread and bullet count
    const weaponStats = this.weaponStats[this.activeWeapon];
    
    // Play the appropriate gunshot sound
    if (this.soundManager) {
      // Set a specific sound name based on weapon type
      const soundName = this.activeWeapon === 'shotgun' ? "shotgunshot" : "shot";
      
      // Play the sound (let the sound manager handle cooldowns internally)
      this.soundManager.playSound(soundName, 100, 0.8);
    }
    
    // For shotgun, create multiple pellets with spread
    for (let i = 0; i < weaponStats.bulletCount; i++) {
      const shootDir = new THREE.Vector3();
      this.camera.getWorldDirection(shootDir);
      
      // Apply spread - more spread for shotgun, less for revolver
      const spread = weaponStats.bulletSpread;
      shootDir.x += (Math.random() - 0.5) * spread;
      shootDir.y += (Math.random() - 0.5) * spread;
      shootDir.z += (Math.random() - 0.5) * spread;
      
      shootDir.normalize();
      
      // Call the callback to spawn bullet in main.js
      if (typeof this.onShootCallback === 'function') {
        this.onShootCallback(bulletStart, shootDir);
      }
    }

    // Recoil effect - stronger for shotgun
    const recoilMultiplier = this.activeWeapon === 'shotgun' ? 2.5 : 1.0;
    applyRecoil(this, recoilMultiplier);
    
    // If out of bullets, show reload hint
    if (this.bullets === 0) {
      const reloadMessage = document.getElementById('reload-message');
      if (reloadMessage) {
        reloadMessage.style.display = 'block';
      }
    }
  }

  /**
   * Called when the player takes damage.
   * @param {number} amount - Damage amount.
   * @param {string} hitZone - Hit zone ('head', 'body', 'limbs')
   */
  takeDamage(amount, hitZone) {
    const previousHealth = this.health;
    this.health = Math.max(this.health - amount, 0);
    console.log(`Player ${this.id} took ${amount} damage in the ${hitZone || 'body'}. Health is now ${this.health}`);
    
    // Show damage indicator with damage amount and hit zone
    if (typeof window.showDamageIndicator === 'function') {
      window.showDamageIndicator(amount, hitZone);
    }
    
    // Update health UI
    updateHealthUI(this);
    
    // Add screen flash effect based on damage amount
    this.showDamageEffect(amount);
    
    // If health reached zero, handle death
    if (previousHealth > 0 && this.health === 0) {
      console.log('Game Over');
      // Respawn after a delay
      setTimeout(() => {
        this.respawn();
      }, 1500);
    }
  }

  /**
   * Shows a screen flash effect when taking damage
   * @param {number} amount - The damage amount
   */
  showDamageEffect(amount) {
    // Create a full-screen flash effect
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.top = '0';
    flash.style.left = '0';
    flash.style.width = '100%';
    flash.style.height = '100%';
    flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    flash.style.opacity = '0';
    flash.style.transition = 'opacity 0.1s ease-in, opacity 0.4s ease-out';
    flash.style.pointerEvents = 'none';
    flash.style.zIndex = '900';
    document.getElementById('game-container').appendChild(flash);
    
    // Adjust intensity based on damage
    const intensity = Math.min(amount / 100, 0.8);
    flash.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;
    
    // Show and fade out
    setTimeout(() => {
      flash.style.opacity = '1';
      setTimeout(() => {
        flash.style.opacity = '0';
        setTimeout(() => {
          if (flash.parentNode) {
            flash.parentNode.removeChild(flash);
          }
        }, 400);
      }, 100);
    }, 0);
  }

  /**
   * Respawn the player after death
   */
  respawn() {
    // Reset health
    this.health = 100;
    updateHealthUI(this);
    
    // Spawn at a random position
    this.spawnPlayerRandomly();
    
    // Reset weapon state
    // Reset ammo for all weapons to their maximum values
    this.weaponAmmo = {
      revolver: this.weaponStats.revolver.maxBullets,
      shotgun: this.weaponStats.shotgun.maxBullets
    };
    
    // Set active weapon's bullets
    this.bullets = this.weaponAmmo[this.activeWeapon];
    this.maxBullets = this.weaponStats[this.activeWeapon].maxBullets;
    
    // Reset animation and interaction states
    this.isReloading = false;
    this.isAiming = false;
    this.velocity.y = 0;
    this.canAim = true;
    
    // Make sure UI is updated
    updateAmmoUI(this);
    
    // Reset vertical velocity
    this.velocity.y = 0;
    
    // Reset Quick Draw lobby information
    this.quickDrawLobbyIndex = -1;
    
    console.log('Player respawned');
    console.log(`Weapon ammo reset - Revolver: ${this.weaponAmmo.revolver}, Shotgun: ${this.weaponAmmo.shotgun}`);
  }

  /**
   * Start the reload process
   */
  startReload() {
    if (this.isReloading || this.bullets >= this.maxBullets) return;
    
    this.isReloading = true;
    this.reloadProgress = 0;
    
    // Use the current weapon's reload time
    const reloadTime = this.weaponStats[this.activeWeapon].reloadTime;
    
    const reloadMessage = document.getElementById('reload-message');
    const reloadProgressContainer = document.getElementById('reload-progress-container');
    if (reloadMessage) reloadMessage.style.display = 'none';
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'block';

    // Reset aim state tracking to ensure it's synchronized with reload
    if (this.updateAiming && typeof this.updateAiming.lastAimingState !== 'undefined') {
      this.updateAiming.lastAimingState = this.isAiming;
    }
    
    // Always make sure viewmodel is visible during reload
    if (this.viewmodel) {
      // Special handling: allow reload to interrupt empty animation
      const emptyAnimName = `${this.activeWeapon}empty`;
      if (this.viewmodel.animationState === emptyAnimName) {
        // Reset any blocking flags to ensure reload can play
        this.viewmodel.blockHolster = false;
      }
      
      this.viewmodel.group.visible = true;
      this.viewmodel.playReloadAnim();
    }
    
    // Play reload sound based on weapon type
    if (this.soundManager) {
      const soundName = this.activeWeapon === 'shotgun' ? "shotgunreloading" : "reloading";
      this.soundManager.playSound(soundName);
    }

    // Anti-cheat: Notify server about reload start
    networkManager.sendReload();
    
    // Animate the reload progress
    const startTime = performance.now();
    const updateReload = (currentTime) => {
      if (!this.isReloading) return;
      
      const elapsed = currentTime - startTime;
      this.reloadProgress = Math.min(100, (elapsed / reloadTime) * 100);
      
      const reloadProgressBar = document.getElementById('reload-progress-bar');
      if (reloadProgressBar) {
        reloadProgressBar.style.width = this.reloadProgress + '%';
      }
      
      if (elapsed < reloadTime) {
        requestAnimationFrame(updateReload);
      } else {
        this.completeReload();
      }
    };
    
    // Start reload progress animation
    requestAnimationFrame(updateReload);
    
    // Notify server about reload state
    this.sendNetworkUpdate();
  }

  /**
   * Complete the reload process
   */
  completeReload() {
    // Update bullets to max
    this.bullets = this.maxBullets;
    
    // Sync weapon ammo state
    this._syncWeaponAmmo();
    
    updateAmmoUI(this);

    const reloadProgressContainer = document.getElementById('reload-progress-container');
    const reloadProgressBar = document.getElementById('reload-progress-bar');
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
    if (reloadProgressBar) reloadProgressBar.style.width = '0%';
    
    this.isReloading = false;

    // After reload finishes, we don't need to do anything with animations
    // The viewmodel.playReloadAnim's onComplete already handles the transition to idle
    // Just ensure visibility is properly managed after the animation finishes
    if (this.viewmodel) {
      // Update aim state tracking to ensure aim toggle detection will work properly
      if (this.updateAiming && typeof this.updateAiming.lastAimingState !== 'undefined') {
        // Force aim state to be correctly tracked
        this.updateAiming.lastAimingState = this.isAiming;
      }
      
      // Let the animation system handle visibility
      if (!this.isAiming) {
        setTimeout(() => {
          if (!this.isAiming && this.viewmodel && !this.viewmodel.forceVisible) {
            this.viewmodel.group.visible = false;
          }
        }, 500);
      }
    }
    
    this.sendNetworkUpdate(); // let others know
  }
  
  /**
   * Set the Quick Draw lobby index for this player
   * @param {number} index - The lobby index (0-4) or -1 for none
   */
  setQuickDrawLobby(index) {
    this.quickDrawLobbyIndex = index;
    
    // Update UI indicator
    const lobbyIndicator = document.getElementById('lobby-indicator');
    if (lobbyIndicator) {
      if (index >= 0) {
        lobbyIndicator.textContent = `Arena ${index + 1}`;
        lobbyIndicator.style.display = 'block';
      } else {
        lobbyIndicator.style.display = 'none';
      }
    }
    
    // Send update to server
    this.sendNetworkUpdate();
  }

  /**
   * Updates aiming effects including crosshair animation
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateAiming(deltaTime) {
    // Static variable to track previous aiming state
    if (this.updateAiming.lastAimingState === undefined) {
      this.updateAiming.lastAimingState = false;
    }
    
    // Check if aiming state changed
    if (this.isAiming !== this.updateAiming.lastAimingState) {
      // State changed - handle animations
      if (this.isAiming) {
        // Starting to aim - play draw animation and show model
        this.viewmodel.group.visible = true;
        
        // In idle state (possibly after reload), always allow draw animation
        if (this.viewmodel.animationState === 'idle') {
          this.viewmodel.blockHolster = false;
          this.viewmodel.pendingHolster = false;
        }
        
        // Handle case when trying to aim during reload
        if (this.viewmodel.animationState === 'revolverreload') {
          // Don't play draw animation now, the reload onComplete will handle it
          // Just update state tracking
        } else {
          // Always play the draw animation when toggling aim for other states
          this.viewmodel.playDrawAim();
        }
      } else {
        // Stopping aim - handle holstering
        
        // If we're in draw animation, explicitly set pendingHolster to true to 
        // ensure the viewmodel knows we want to holster after draw completes
        if (this.viewmodel.animationState === 'revolverdraw') {
          this.viewmodel.pendingHolster = true;
        }
        
        // Handle case when toggling aim after reload or other animations
        // Make sure we can always holster after animations finish
        if (this.viewmodel.animationState === 'idle' || 
            this.viewmodel.animationState === 'revolveraim') {
          this.viewmodel.blockHolster = false;
          this.viewmodel.pendingHolster = false; // Reset any pending holster flag
        }
        
        // Reset any stuck flags in other states
        if (this.viewmodel.animationState === 'revolverreload' || 
            this.viewmodel.animationState === 'revolvershot' ||
            this.viewmodel.animationState === 'revolverempty') {
          this.viewmodel.pendingHolster = true;
        }
        
        // Only holster if not in a forced-visible state
        if (!this.viewmodel.blockHolster) {
          // Stopping aim - play holster animation
          this.viewmodel.playHolsterAnim();
          
          // When holster animation finishes, hide the model if needed
          const holsterDuration = this.viewmodel.actions.revolverholster._clip.duration * 1000;
          
          setTimeout(() => {
            if (!this.isAiming && !this.viewmodel.forceVisible) { 
              // Double-check we're still not aiming and not forced visible
              this.viewmodel.group.visible = false;
            }
          }, holsterDuration + 100); // Add a small buffer to ensure animation completes
        }
      }
      
      // Update the tracked state
      this.updateAiming.lastAimingState = this.isAiming;
    }
    
    // Special case: in aim state but stuck with blockHolster flag
    // This helps recover from cases where state gets out of sync after reload
    if (!this.isAiming && this.viewmodel.animationState === 'revolveraim' && 
        this.viewmodel.blockHolster) {
      // Force the blockHolster flag to false so we can holster
      this.viewmodel.blockHolster = false;
      this.viewmodel.playHolsterAnim();
    }
    
    // Always keep the gun visible if forceVisible is set
    if (this.viewmodel && this.viewmodel.forceVisible) {
      this.viewmodel.group.visible = true;
    }
    
    // Crosshair animation if aiming
    const crosshair = document.getElementById('crosshair');
    if (crosshair && this.isAiming) {
      // Add subtle size adjustment based on player movement
      const isMoving = this.isMoving();
      const movementFactor = isMoving ? 1.0 + (this.velocity.length() * 0.005) : 1.0;
      
      // Calculate scaled size based on movement (further reduced from 60 to 40)
      const size = 40 * movementFactor;
      crosshair.style.width = `${size}px`;
      crosshair.style.height = `${size}px`;
      
      // Set opacity based on movement
      const opacity = isMoving ? 0.7 : 0.8;
      
      // Update colors differently for paths and circle
      const circleColor = this.health < 30 
        ? `rgba(255, ${Math.floor(255 * (this.health/30))}, ${Math.floor(255 * (this.health/60))}, ${opacity})`
        : `rgba(255, 255, 255, ${opacity})`;
      
      // Use black for paths (arrows)
      const pathColor = `rgba(0, 0, 0, ${opacity})`;
      
      // Apply black color to all SVG paths (the arrows)
      const pathElements = crosshair.querySelectorAll('path');
      pathElements.forEach(el => {
        el.setAttribute('stroke', pathColor);
      });
      
      // Apply white color to the center dot
      const circleElement = crosshair.querySelector('circle');
      if (circleElement) {
        circleElement.setAttribute('fill', circleColor);
      }
      
      // Apply expansion animation class if not already applied
      if (!crosshair.classList.contains('expand') && !crosshair.classList.contains('expanded')) {
        crosshair.classList.add('expand');
        
        // After animation completes, mark as expanded
        setTimeout(() => {
          crosshair.classList.remove('expand');
          crosshair.classList.add('expanded');
        }, 250); // Match animation duration
      }
      
      // IMPORTANT: Don't modify transform - leave the inline style working
    }
  }

  /**
   * Checks if player is standing on an object
   * @param {THREE.Vector3} feetPosition - Position of player's feet
   * @returns {THREE.Vector3|false} The detected ground position or false
   */
  checkStandingOnObject(feetPosition) {
    // Early return if physics not initialized
    if (!window.physics || !window.physics.bodies) {
      return false;
    }
    
    // Create a ray starting slightly above feet and going down
    const rayStart = feetPosition.clone();
    rayStart.y += 0.2; // Start a bit above to ensure we detect even when slightly penetrating
    
    const rayLength = 0.4; // Detection distance
    
    // Check each physics body for ground
    for (const body of window.physics.bodies) {
      // Skip if this is an arena boundary
      if (body.arenaBoundary) continue;
      
      // Skip if mass > 0 (non-static body)
      if (body.mass > 0) continue;
      
      // Currently we only handle box shapes
      for (let i = 0; i < body.shapes.length; i++) {
        const shape = body.shapes[i];
        if (shape.type !== CANNON.Shape.types.BOX) continue;
        
        // Get the world position/rotation of this shape
        const shapePos = new CANNON.Vec3();
        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
        
        // Convert to THREE.js objects
        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
        const boxSize = new THREE.Vector3(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        // Create box3 from position and size
        const box = new THREE.Box3().setFromCenterAndSize(boxPos, boxSize);
        
        // Check if the ray intersects the box
        if (Math.abs(rayStart.x - boxPos.x) <= boxSize.x/2 + 0.5 && 
            Math.abs(rayStart.z - boxPos.z) <= boxSize.z/2 + 0.5) {
          // We're within the X-Z bounds of the box, check Y
          const topOfBox = boxPos.y + boxSize.y/2;
          
          // If the box top is between our ray start and end points
          if (topOfBox <= rayStart.y && topOfBox >= rayStart.y - rayLength) {
            // Return the position with the adjusted y-coordinate
            return new THREE.Vector3(rayStart.x, topOfBox + 2.72, rayStart.z);
          }
        }
      }
    }
    
    return false;
  }
  
  /**
   * Checks if player's head is hitting a ceiling
   * @param {THREE.Vector3} headPosition - Position of player's head
   * @returns {THREE.Vector3|false} The detected ceiling position or false
   */
  checkCeilingCollision(headPosition) {
    // Early return if physics not initialized
    if (!window.physics || !window.physics.bodies) {
      return false;
    }
    
    // Create a ray starting at head and going up
    const rayStart = headPosition.clone();
    const rayLength = 0.3; // Detection distance
    
    // Check each physics body for ceiling
    for (const body of window.physics.bodies) {
      // Skip if this is an arena boundary
      if (body.arenaBoundary) continue;
      
      // Skip if mass > 0 (non-static body)
      if (body.mass > 0) continue;
      
      // Currently we only handle box shapes
      for (let i = 0; i < body.shapes.length; i++) {
        const shape = body.shapes[i];
        if (shape.type !== CANNON.Shape.types.BOX) continue;
        
        // Get the world position/rotation of this shape
        const shapePos = new CANNON.Vec3();
        const shapeQuat = new CANNON.Quaternion();
        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
        body.quaternion.mult(body.shapeOrientations[i], shapeQuat);
        
        // Convert to THREE.js objects
        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
        const boxSize = new THREE.Vector3(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        // Create box3 from position and size
        const box = new THREE.Box3().setFromCenterAndSize(boxPos, boxSize);
        
        // Check if the ray intersects the box
        if (Math.abs(rayStart.x - boxPos.x) <= boxSize.x/2 + 0.5 && 
            Math.abs(rayStart.z - boxPos.z) <= boxSize.z/2 + 0.5) {
          // We're within the X-Z bounds of the box, check Y
          const bottomOfBox = boxPos.y - boxSize.y/2;
          
          // If the box bottom is between our ray start and end points
          if (bottomOfBox >= rayStart.y && bottomOfBox <= rayStart.y + rayLength) {
            // Return the position with the adjusted y-coordinate
            return new THREE.Vector3(rayStart.x, bottomOfBox, rayStart.z);
          }
        }
      }
    }
    
    return false;
  }

  /**
   * Prevents the player from falling through platforms by performing additional checks
   */
  stabilizePlatformPosition() {
    // If we're on the ground or jumping, no need for stabilization
    if (this.canJump || this.velocity.y > 0) return;
    
    // Cast a ray directly below the player to detect platforms we might be falling through
    const feetPos = new THREE.Vector3(
      this.group.position.x,
      this.group.position.y - 2.62, // Slightly higher than feet for early detection
      this.group.position.z
    );
    
    // Check if there's an object below
    const platformBelow = this.checkDirectlyBelow(feetPos, 1.0);
    
    // If we found a platform and we're falling, snap to it
    if (platformBelow && this.velocity.y < 0) {
      this.group.position.y = platformBelow.y;
      this.velocity.y = -0.01; // Very small downward force
      this.canJump = true;
      this.isJumping = false;
    }
  }
  
  /**
   * Checks for a platform directly below the player with a short ray
   * @param {THREE.Vector3} position - Starting position for ray
   * @param {number} maxDistance - Maximum distance to check below
   * @returns {THREE.Vector3|false} Position on top of platform or false
   */
  checkDirectlyBelow(position, maxDistance) {
    // Early return if physics not initialized
    if (!window.physics) return false;
    
    // Get all physics bodies
    const bodies = window.physics.bodies;
    
    // Check each physics body
    for (const body of bodies) {
      // Skip irrelevant bodies
      if (body.isGround || body.arenaBoundary || body.mass > 0) continue;
      
      // Check each shape
      for (let i = 0; i < body.shapes.length; i++) {
        const shape = body.shapes[i];
        if (shape.type !== CANNON.Shape.types.BOX) continue;
        
        // Get shape properties
        const shapePos = new CANNON.Vec3();
        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
        
        // Convert to THREE.js
        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
        const boxSize = new THREE.Vector3(
          shape.halfExtents.x * 2,
          shape.halfExtents.y * 2,
          shape.halfExtents.z * 2
        );
        
        // Check if we're above the box horizontally (with margin)
        const margin = 0.6; // Wide margin for safety
        if (Math.abs(position.x - boxPos.x) <= boxSize.x/2 + margin && 
            Math.abs(position.z - boxPos.z) <= boxSize.z/2 + margin) {
          
          // Get top of box
          const topOfBox = boxPos.y + boxSize.y/2;
          
          // If we're within maxDistance above the box
          if (position.y >= topOfBox && position.y - topOfBox <= maxDistance) {
            return new THREE.Vector3(this.group.position.x, topOfBox + 2.72, this.group.position.z);
          }
        }
      }
    }
    
    return false;
  }

  /**
   * Make the player jump.
   */
  jump() {
    // Don't allow jumping if on cooldown
    if (this.jumpCooldown > 0) {
      return;
    }
    
    // Double check for platforms first - ensures we can always jump on platforms
    if (!this.canJump) {
      const feetPos = new THREE.Vector3(
        this.group.position.x,
        this.group.position.y - 2.72,
        this.group.position.z
      );
      
      if (this.checkStandingOnObject(feetPos)) {
        this.canJump = true;
      }
    }
    
    if (this.canJump && !this.forceLockMovement && this.canMove) {
      // Much more realistic jump velocity (significantly reduced)
      this.velocity.y = this.isSprinting ? 5.2 * this.sprintJumpBoost : 5.2;
      this.canJump = false;
      this.isJumping = true;
      this.jumpCooldown = this.jumpCooldownTime; // Apply cooldown
      
      // Play jump sound - IMMEDIATELY with full volume
      if (this.soundManager) {
        console.log("Playing jumpup sound from jump method");
        this.soundManager.playSound("jumpup", 0, 1.5);
      }
      
      // Log for debugging
      console.log("Player jumped", this.velocity.y);
    }
  }

  /**
   * Checks if there's a small step or platform in front of the player that can be automatically climbed
   * @param {THREE.Vector3} targetPosition - The desired position to move to
   * @param {number} maxStepHeight - Maximum height difference allowed for auto-stepping
   * @returns {THREE.Vector3|false} The adjusted position with the correct height, or false
   */
  checkForStep(targetPosition, maxStepHeight) {
    // Early return if physics not initialized
    if (!window.physics) return false;
    
    // Calculate movement direction (normalized)
    const moveDir = new THREE.Vector3()
      .subVectors(targetPosition, this.group.position)
      .normalize();
    
    // Ignore if no horizontal movement
    if (Math.abs(moveDir.x) < 0.001 && Math.abs(moveDir.z) < 0.001) return false;
    
    // Cast multiple rays in the movement direction with different offsets
    const rayOffsets = [
      {x: 0, z: 0},            // Center of movement
      {x: moveDir.z*0.4, z: -moveDir.x*0.4},  // Perpendicular right
      {x: -moveDir.z*0.4, z: moveDir.x*0.4},  // Perpendicular left
      {x: moveDir.x*0.5, z: moveDir.z*0.5},   // Forward offset
      {x: moveDir.x*0.8, z: moveDir.z*0.8},   // Further forward
      {x: moveDir.x*1.0, z: moveDir.z*1.0},   // Even further forward
      {x: moveDir.x*1.2, z: moveDir.z*1.2}    // Maximum forward detection
    ];
    
    // Get all physics bodies
    const bodies = window.physics.bodies;
    
    let highestStep = null;
    let highestStepY = this.group.position.y - 10; // Start very low
    
    // Check each ray starting point
    for (const offset of rayOffsets) {
      // Create ray start position with offset
      const rayStart = new THREE.Vector3(
        targetPosition.x + offset.x, 
        this.group.position.y - 2.62, // Slightly above feet level
        targetPosition.z + offset.z
      );
      
      // Check each body with this ray
      for (const body of bodies) {
        // Skip if this is an arena boundary or moving object
        if (body.arenaBoundary || body.mass > 0) continue;
        
        // Currently we only handle box shapes
        for (let i = 0; i < body.shapes.length; i++) {
          const shape = body.shapes[i];
          if (shape.type !== CANNON.Shape.types.BOX) continue;
          
          // Get the world position/rotation of this shape
          const shapePos = new CANNON.Vec3();
          body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
          
          // Convert to THREE.js objects
          const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
          const boxSize = new THREE.Vector3(
            shape.halfExtents.x * 2,
            shape.halfExtents.y * 2,
            shape.halfExtents.z * 2
          );
          
          // Use much larger margin for step detection (especially for building entrances)
          const margin = 1.0; // Increased from 0.8 for better detection
          if (Math.abs(rayStart.x - boxPos.x) <= boxSize.x/2 + margin && 
              Math.abs(rayStart.z - boxPos.z) <= boxSize.z/2 + margin) {
            
            // Get the top of the box
            const topOfBox = boxPos.y + boxSize.y/2;
            
            // Check if it's a valid step height:
            // 1. The step must be higher than our current feet position
            // 2. But not too high to climb automatically
            const feetY = this.group.position.y - 2.72;
            const heightDiff = topOfBox - feetY;
            
            if (heightDiff > 0.05 && heightDiff <= maxStepHeight) {
              // Keep track of the highest valid step
              if (topOfBox > highestStepY) {
                highestStepY = topOfBox;
                highestStep = new THREE.Vector3(targetPosition.x, topOfBox + 2.72, targetPosition.z);
              }
            }
          }
        }
      }
    }
    
    // Return the highest step found, or false if none
    return highestStep;
  }

  /**
   * Syncs the weapon ammo state to ensure consistency
   * @private
   */
  _syncWeaponAmmo() {
    // Make sure weaponAmmo is initialized for all weapon types
    if (!this.weaponAmmo) {
      this.weaponAmmo = {
        revolver: this.weaponStats.revolver.maxBullets,
        shotgun: this.weaponStats.shotgun.maxBullets
      };
    }
    
    // Ensure both weapons have entries in the ammo object
    if (this.weaponAmmo.revolver === undefined) {
      this.weaponAmmo.revolver = this.weaponStats.revolver.maxBullets;
    }
    
    if (this.weaponAmmo.shotgun === undefined) {
      this.weaponAmmo.shotgun = this.weaponStats.shotgun.maxBullets;
    }
    
    // Ensure the current weapon's ammo in weaponAmmo matches bullets
    this.weaponAmmo[this.activeWeapon] = this.bullets;
    
    // Ensure max bullets is consistent with weapon stats
    this.maxBullets = this.weaponStats[this.activeWeapon].maxBullets;
    
    // Log ammo state for debugging
    if (window.debugAmmo) {
      console.log(`[AMMO] ${this.activeWeapon}: ${this.bullets}/${this.maxBullets} (Revolver: ${this.weaponAmmo.revolver}, Shotgun: ${this.weaponAmmo.shotgun})`);
    }
  }

  /**
   * Switch to a different weapon
   * @param {string} weaponType - The weapon type to switch to ('revolver' or 'shotgun')
   */
  switchWeapon(weaponType) {
    if (this.activeWeapon === weaponType || this.isReloading) {
      return; // Already using this weapon or currently reloading
    }
    
    // Force sync current weapon ammo to ensure it's saved correctly
    this._syncWeaponAmmo();
    
    // Remember previous weapon for animation transitions
    const prevWeapon = this.activeWeapon;
    
    // Log the current ammo state before switching
    if (window.debugAmmo) {
      console.log(`[SWITCH] FROM ${prevWeapon}(${this.bullets}) TO ${weaponType}(${this.weaponAmmo[weaponType]})`);
    }
    
    // Check if we're in a special animation state that might cause issues
    const currentAnimState = this.viewmodel ? this.viewmodel.animationState : 'idle';
    const isInBlockingAnimation = currentAnimState === `${prevWeapon}empty` || 
                                  currentAnimState === `${prevWeapon}shot` ||
                                  this.viewmodel.blockHolster;
    
    // Save current weapon's ammo state
    this.weaponAmmo[prevWeapon] = this.bullets;
    
    // Update weapon type
    this.activeWeapon = weaponType;
    
    // Update bullet count and max bullets based on new weapon
    this.maxBullets = this.weaponStats[weaponType].maxBullets;
    this.reloadTime = this.weaponStats[weaponType].reloadTime;
    
    // Restore the new weapon's ammo state
    this.bullets = this.weaponAmmo[weaponType];
    
    // Log the new ammo state after switching
    if (window.debugAmmo) {
      console.log(`[SWITCH] COMPLETE - Now ${this.activeWeapon} with ${this.bullets} bullets`);
    }
    
    // Update UI
    updateAmmoUI(this);
    
    // Update weapon indicators in UI
    this.updateWeaponIndicators();
    
    // Reset viewmodel animation flags if switching from a blocking animation state
    if (isInBlockingAnimation && this.viewmodel) {
      console.log(`Resetting viewmodel flags when switching from ${currentAnimState}`);
      this.viewmodel.blockHolster = false;
      this.viewmodel.pendingHolster = false;
      this.viewmodel.forceVisible = false;
      
      // Force animation state to idle to ensure clean transition
      this.viewmodel._transitionTo('idle', {
        resetTimeOnPlay: true,
        onComplete: () => {
          // After forcing idle, setup for the next animation
          if (this.isAiming) {
            // Small delay to ensure state is stable
            setTimeout(() => {
              if (this.isAiming) {
                this.viewmodel.playDrawAim();
              }
            }, 50);
          }
        }
      });
      
      // If not aiming, return early to avoid additional animation calls
      if (!this.isAiming) {
        console.log(`Switched to ${weaponType} (not aiming)`);
        return;
      }
    }
    
    // If currently aiming, transition to the new weapon's aim animation
    if (this.isAiming && this.viewmodel) {
      // If we just reset to idle, let the callback handle it
      if (isInBlockingAnimation) return;
      
      // For clean transition, first holster current weapon
      this.viewmodel.animationState = `${prevWeapon}aim`; // Force the correct state for holstering
      this.viewmodel.playHolsterAnim();
      
      // After holstering, draw new weapon
      setTimeout(() => {
        // Force viewmodel to be visible (might have been hidden during holster)
        this.viewmodel.group.visible = true;
        
        // Reset any animation state flags to ensure clean transition
        this.viewmodel.pendingHolster = false;
        this.viewmodel.blockHolster = false;
        
        // Play draw animation for new weapon
        this.viewmodel.playDrawAim();
      }, 400); // Allow slightly more time for holster animation to complete
    }
    
    console.log(`Switched to ${weaponType}`);
  }
  
  /**
   * Update the weapon indicators in the UI to match the current weapon
   */
  updateWeaponIndicators() {
    // Handle mobile UI weapon indicators
    const revolverIndicator = document.getElementById('revolver-indicator');
    const shotgunIndicator = document.getElementById('shotgun-indicator');
    
    if (revolverIndicator && shotgunIndicator) {
      if (this.activeWeapon === 'revolver') {
        revolverIndicator.className = 'weapon-indicator active';
        shotgunIndicator.className = 'weapon-indicator';
      } else {
        shotgunIndicator.className = 'weapon-indicator active';
        revolverIndicator.className = 'weapon-indicator';
      }
    }
    
    // Handle desktop UI weapon indicators
    const revolverDesktopIndicator = document.getElementById('revolver-indicator-desktop');
    const shotgunDesktopIndicator = document.getElementById('shotgun-indicator-desktop');
    
    if (revolverDesktopIndicator && shotgunDesktopIndicator) {
      if (this.activeWeapon === 'revolver') {
        revolverDesktopIndicator.className = 'desktop-weapon-indicator active';
        shotgunDesktopIndicator.className = 'desktop-weapon-indicator';
      } else {
        shotgunDesktopIndicator.className = 'desktop-weapon-indicator active';
        revolverDesktopIndicator.className = 'desktop-weapon-indicator';
      }
    }
  }
}

================================================
File: /public/js/playerIdentity.js
================================================
/**
 * Player Identity System
 * Handles player naming and identification with client-side persistence.
 * Includes token-based authentication and session recovery.
 */

// Generate a UUID v4 (random)
function generateUUID() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = crypto.getRandomValues(new Uint8Array(1))[0] % 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// Generate a secure token
function generateToken() {
  const buffer = new Uint8Array(32);
  crypto.getRandomValues(buffer);
  return Array.from(buffer)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// Check if we should bypass normal identity flow (for development/testing)
function shouldBypassIdentity() {
  const urlParams = new URLSearchParams(window.location.search);
  return urlParams.has('newplayer') || urlParams.has('dev');
}

// Get player data from storage or create new
function getPlayerIdentity() {
  try {
    // Development bypass: create a new identity if URL param is present
    if (shouldBypassIdentity()) {
      console.log('Development mode: Creating new player identity');
      return createNewPlayerIdentity();
    }
    
    // First try sessionStorage (for this browser tab only)
    const sessionData = sessionStorage.getItem('wildWestPlayerSession');
    if (sessionData) {
      const parsedData = JSON.parse(sessionData);
      console.log('Found session player data');
      return parsedData;
    }
    
    // Then try localStorage (for persistent storage)
    const storedData = localStorage.getItem('wildWestPlayerIdentity');
    if (storedData) {
      try {
        const parsedData = JSON.parse(storedData);
        
        // Verify data integrity
        if (!parsedData.id || !parsedData.token || !parsedData.username) {
          console.warn('Incomplete player identity found, creating new');
          return createNewPlayerIdentity();
        }
        
        // Update session storage for faster access in this tab
        sessionStorage.setItem('wildWestPlayerSession', storedData);
        
        console.log('Found stored player identity');
        return parsedData;
      } catch (e) {
        console.error('Error parsing stored player identity:', e);
        return createNewPlayerIdentity();
      }
    } else {
      return createNewPlayerIdentity();
    }
  } catch (e) {
    // Handle private browsing mode where storage might be unavailable
    console.error('Error accessing storage:', e);
    return createNewPlayerIdentity(true);
  }
}

// Create new player identity
function createNewPlayerIdentity(ephemeral = false) {
  // For development/testing, append timestamp to make usernames unique across tabs
  const devSuffix = shouldBypassIdentity() ? `-${Date.now().toString().slice(-4)}` : '';
  
  const newIdentity = {
    id: generateUUID(),
    token: generateToken(),
    username: generateRandomName() + devSuffix, // Start with a random name
    createdAt: Date.now(),
    lastLogin: Date.now(),
    ephemeral: ephemeral, // Flag for when storage isn't available
    devMode: shouldBypassIdentity() // Flag to mark dev identities
  };
  
  console.log('Created new player identity');
  return newIdentity;
}

// Generate a random western-themed name
function generateRandomName() {
  const firstParts = [
    // Titles
    "Sheriff", "Deputy", "Marshal", "Doc", "Judge", "Colonel", "General", "Captain", 
    "Ranger", "Bandit", "Outlaw", "Desperado", "Gunslinger", "Bounty", "Rustler",
    // Adjectives
    "Quick", "Fast", "Slick", "Dusty", "Rusty", "Wild", "Mad", "Crazy", "Lazy", 
    "Lucky", "Unlucky", "Smoky", "Grumpy", "Gritty", "Salty", "One-eye", "One-shot",
    "Crooked", "Sneaky", "Dead-eye", "Two-gun", "Lone", "Tall", "Short", "Big", "Little"
  ];
  
  const middleParts = [
    "Dog", "Cat", "Wolf", "Iron", "Steel", "Silver", "Gold", "Copper", "Tin", 
    "Hand", "Eye", "Shot", "Gun", "Draw", "Boot", "Hat", "Star", "Badge", 
    "River", "Canyon", "Mesa", "Valley", "Rock", "Stone", "Mountain", "Desert",
    "", "", "", "", "", "" // Empty strings to increase chance of 2-part names
  ];
  
  const lastParts = [
    // Names
    "Jack", "Jim", "Joe", "Bill", "Bob", "Sam", "Tom", "Will", "Frank", "Jesse",
    "Wyatt", "Doc", "Billy", "Butch", "Roy", "Tex", "Hank", "Pete", "Buck", "Duke",
    // Nouns
    "Kid", "Smith", "Jones", "McGraw", "James", "Cassidy", "Earp", "Holliday", 
    "Dalton", "Garrett", "Hickok", "Carson", "Crockett", "Walker", "Jackson"
  ];
  
  // Randomly decide if we want 2 or 3 parts
  const useMiddlePart = Math.random() > 0.5;
  
  const first = firstParts[Math.floor(Math.random() * firstParts.length)];
  const last = lastParts[Math.floor(Math.random() * lastParts.length)];
  
  if (useMiddlePart) {
    const middle = middleParts[Math.floor(Math.random() * middleParts.length)];
    return middle ? `${first} ${middle} ${last}` : `${first} ${last}`;
  } else {
    return `${first} ${last}`;
  }
}

// Save player data to storage
function savePlayerIdentity(playerData) {
  try {
    playerData.lastLogin = Date.now();
    
    // For development mode identities, only save to session storage
    // to avoid overwriting the main identity in localStorage
    if (playerData.devMode) {
      const dataStr = JSON.stringify(playerData);
      sessionStorage.setItem('wildWestPlayerSession', dataStr);
      console.log('Development mode: Saved player identity to session storage only');
      return true;
    }
    
    // Always save to session storage for this tab
    const dataStr = JSON.stringify(playerData);
    sessionStorage.setItem('wildWestPlayerSession', dataStr);
    
    // Save to localStorage if not ephemeral
    if (!playerData.ephemeral) {
      localStorage.setItem('wildWestPlayerIdentity', dataStr);
    }
    
    return true;
  } catch (e) {
    console.error('Failed to save player identity:', e);
    return false;
  }
}

// Preload game content in background while user sets their name
function preloadGameContent() {
  console.log("Starting background preload of game content...");
  // The actual preloading happens in parallel in main.js
  // We've removed the progress bar but kept the preloading logic
}

// Show username prompt
function promptForUsername(playerData) {
  // Get device info for responsive design
  const isMobile = window.innerWidth < 768;
  const isSmallMobile = window.innerWidth < 480;
  const isVerySmallMobile = window.innerWidth < 360;
  const isSmallScreen = window.innerWidth < 1024;
  
  // Constants for easy adjustments - responsive values based on screen size
  const UI_CONSTANTS = {
    // Image sizes (percentage of container width)
    TITLE_IMAGE_WIDTH: isVerySmallMobile ? '260px' : (isSmallMobile ? '300px' : (isMobile ? '350px' : (isSmallScreen ? '400px' : '450px'))),
    NAME_SUBMIT_WIDTH: isVerySmallMobile ? '260px' : (isSmallMobile ? '300px' : (isMobile ? '350px' : (isSmallScreen ? '400px' : '450px'))),
    ENTER_GAME_WIDTH: isVerySmallMobile ? '260px' : (isSmallMobile ? '300px' : (isMobile ? '350px' : (isSmallScreen ? '400px' : '450px'))),
    
    // Spacing
    VERTICAL_SPACING: isMobile ? '15px' : '20px',
    
    // Text input positioning and sizing
    TEXT_INPUT_WIDTH: isMobile ? '60%' : '65%',
    TEXT_INPUT_TOP: '50%',
    TEXT_INPUT_LEFT: isMobile ? '12%' : '9%',
    TEXT_INPUT_FONT_SIZE: isVerySmallMobile ? '14px' : (isSmallMobile ? '16px' : (isMobile ? '18px' : (isSmallScreen ? '24px' : '28px'))),
    
    // Regenerate button positioning and sizing
    REGEN_BUTTON_SIZE: isVerySmallMobile ? '28px' : (isSmallMobile ? '35px' : (isMobile ? '40px' : (isSmallScreen ? '60px' : '80px'))),
    REGEN_BUTTON_RIGHT: isMobile ? '10%' : '6%',
    REGEN_BUTTON_TOP: isMobile ? '50%' : '39%'
  };

  return new Promise((resolve) => {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'username-modal';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.65)';
    modal.style.zIndex = '2000'; // Higher than other game overlays
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    modal.style.pointerEvents = 'auto'; // Ensure it captures input
    
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.textAlign = 'center';
    modalContent.style.display = 'flex';
    modalContent.style.flexDirection = 'column';
    modalContent.style.alignItems = 'center';
    modalContent.style.width = '100%';
    modalContent.style.padding = isMobile ? '10px' : '20px';
    
    // Game title image
    const titleImage = document.createElement('img');
    titleImage.src = '/models/westweltbeta.png';
    titleImage.style.marginBottom = UI_CONSTANTS.VERTICAL_SPACING;
    titleImage.style.maxWidth = UI_CONSTANTS.TITLE_IMAGE_WIDTH;
    
    // Name submit image container
    const nameSubmitContainer = document.createElement('div');
    nameSubmitContainer.style.position = 'relative';
    nameSubmitContainer.style.marginBottom = UI_CONSTANTS.VERTICAL_SPACING;
    nameSubmitContainer.style.width = UI_CONSTANTS.NAME_SUBMIT_WIDTH;
    
    // Name submit image
    const nameSubmitImage = document.createElement('img');
    nameSubmitImage.src = '/models/namesubmit.png';
    nameSubmitImage.style.maxWidth = '100%';
    
    // Input field (positioned on top of namesubmit.png)
    const input = document.createElement('input');
    input.type = 'text';
    input.placeholder = isMobile ? 'Enter name...' : 'Your name, partner...';
    input.value = playerData.username || generateRandomName();
    input.maxLength = 16; // Restrict input to 16 characters
    input.style.position = 'absolute';
    input.style.top = UI_CONSTANTS.TEXT_INPUT_TOP;
    input.style.left = UI_CONSTANTS.TEXT_INPUT_LEFT;
    input.style.transform = 'translateY(-50%)'; // Only vertical centering
    input.style.width = UI_CONSTANTS.TEXT_INPUT_WIDTH;
    input.style.padding = isMobile ? '4px' : '8px';
    input.style.backgroundColor = 'transparent';
    input.style.border = 'none';
    input.style.outline = 'none';
    input.style.color = 'white';
    input.style.fontSize = UI_CONSTANTS.TEXT_INPUT_FONT_SIZE;
    input.style.textAlign = 'left'; // Left align text instead of center
    
    // Regenerate button (positioned on the right side of namesubmit.png)
    const regenButton = document.createElement('button');
    regenButton.textContent = ''; // Completely remove the symbol
    regenButton.title = "Generate new name";
    regenButton.style.position = 'absolute';
    regenButton.style.top = UI_CONSTANTS.REGEN_BUTTON_TOP;
    regenButton.style.right = UI_CONSTANTS.REGEN_BUTTON_RIGHT;
    regenButton.style.transform = 'translateY(-50%)';
    regenButton.style.width = UI_CONSTANTS.REGEN_BUTTON_SIZE;
    regenButton.style.height = UI_CONSTANTS.REGEN_BUTTON_SIZE;
    regenButton.style.backgroundColor = 'transparent';
    regenButton.style.color = 'white';
    regenButton.style.border = 'none';
    regenButton.style.borderRadius = '4px';
    regenButton.style.cursor = 'pointer';
    regenButton.style.fontSize = '18px';
    regenButton.style.display = 'flex';
    regenButton.style.justifyContent = 'center';
    regenButton.style.alignItems = 'center';
    
    // Add window resize handler for dynamic adjustments
    const handleResize = () => {
      const newIsMobile = window.innerWidth < 768;
      const newIsSmallMobile = window.innerWidth < 480;
      const newIsVerySmallMobile = window.innerWidth < 360;
      const newIsSmallScreen = window.innerWidth < 1024;
      
      // Update sizes based on new screen dimensions
      const titleWidth = newIsVerySmallMobile ? '260px' : (newIsSmallMobile ? '300px' : (newIsMobile ? '350px' : (newIsSmallScreen ? '400px' : '450px')));
      titleImage.style.maxWidth = titleWidth;
      nameSubmitContainer.style.width = titleWidth;
      enterGameImage.style.maxWidth = titleWidth;
      
      // Update font size
      input.style.fontSize = newIsVerySmallMobile ? '14px' : (newIsSmallMobile ? '16px' : (newIsMobile ? '18px' : (newIsSmallScreen ? '24px' : '28px')));
      input.style.left = newIsMobile ? '12%' : '9%';
      input.style.width = newIsMobile ? '60%' : '65%';
      
      // Update button size
      const buttonSize = newIsVerySmallMobile ? '28px' : (newIsSmallMobile ? '35px' : (newIsMobile ? '40px' : (newIsSmallScreen ? '60px' : '80px')));
      regenButton.style.width = buttonSize;
      regenButton.style.height = buttonSize;
      regenButton.style.right = newIsMobile ? '10%' : '6%';
      regenButton.style.top = newIsMobile ? '50%' : '39%';
    };
    
    window.addEventListener('resize', handleResize);
    
    // Regenerate button click handler
    regenButton.addEventListener('click', () => {
      input.value = generateRandomName();
      input.focus();
    });
    
    // Enter game button image
    const enterGameImage = document.createElement('img');
    enterGameImage.src = '/models/entergame.png';
    enterGameImage.style.maxWidth = UI_CONSTANTS.ENTER_GAME_WIDTH;
    enterGameImage.style.cursor = 'pointer';
    
    // Form handling
    const handleSubmit = () => {
      let username = input.value.trim();
      
      // Client-side validation to prevent XSS attacks
      if (username) {
        // Check for potentially malicious content
        const hasSuspiciousContent = /<[^>]*>|javascript:|on\w+=/i.test(username);
        
        if (hasSuspiciousContent) {
          // Clean the username for safety
          username = username
            .replace(/</g, '')
            .replace(/>/g, '')
            .replace(/javascript:/gi, '')
            .replace(/on\w+=/gi, '');
          
          // Show warning
          input.style.border = '2px solid orange';
          setTimeout(() => {
            input.style.border = 'none';
          }, 2000);
        }
        
        // Limit length
        if (username.length > 16) {
          username = username.substring(0, 16);
        }
        
        playerData.username = username;
        
        // Save immediately after username is set
        const saved = savePlayerIdentity(playerData);
        if (!saved && !playerData.ephemeral) {
          // Mark as ephemeral if save failed
          playerData.ephemeral = true;
          console.warn('Storage unavailable, using ephemeral player identity');
        }
        
        // Animate the modal fading out
        modal.style.transition = 'opacity 0.3s ease';
        modal.style.opacity = '0';
        
        setTimeout(() => {
          if (modal.parentNode) {
            document.body.removeChild(modal);
            // Remove resize listener when modal is closed
            window.removeEventListener('resize', handleResize);
          }
          resolve(playerData);
        }, 300);
      } else {
        input.style.border = '2px solid red';
        setTimeout(() => {
          input.style.border = 'none';
        }, 1000);
      }
    };
    
    // Add event listeners
    enterGameImage.addEventListener('click', handleSubmit);
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        handleSubmit();
      }
    });
    
    // Focus the input field when modal appears
    setTimeout(() => input.focus(), 100);
    
    // Assemble modal
    nameSubmitContainer.appendChild(nameSubmitImage);
    nameSubmitContainer.appendChild(input);
    nameSubmitContainer.appendChild(regenButton);
    
    modalContent.appendChild(titleImage);
    modalContent.appendChild(nameSubmitContainer);
    modalContent.appendChild(enterGameImage);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    // Add fade-in animation for a smooth appearance
    modal.style.opacity = '0';
    modal.style.transition = 'opacity 0.3s ease';
    setTimeout(() => {
      modal.style.opacity = '1';
    }, 10);
  });
}

// Prompt to recover saved identity
function promptIdentityRecovery(storedIdentity, newIdentity) {
  return new Promise((resolve) => {
    // Create modal container
    const modal = document.createElement('div');
    modal.className = 'identity-recovery-modal';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    modal.style.zIndex = '1000';
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    
    // Create modal content
    const modalContent = document.createElement('div');
    modalContent.style.backgroundColor = '#2c2c2c';
    modalContent.style.borderRadius = '8px';
    modalContent.style.padding = '20px';
    modalContent.style.width = '90%';
    modalContent.style.maxWidth = '450px';
    modalContent.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.5)';
    modalContent.style.textAlign = 'center';
    
    // Title
    const title = document.createElement('h2');
    title.textContent = 'Welcome Back, Partner!';
    title.style.color = '#f8bb00';
    title.style.marginBottom = '10px';
    title.style.fontFamily = 'Western, serif';
    
    // Message
    const message = document.createElement('p');
    message.textContent = `We found your saved gunslinger, ${storedIdentity.username}. Would you like to continue with this character?`;
    message.style.color = '#fff';
    message.style.marginBottom = '20px';
    
    // Buttons container
    const buttonsContainer = document.createElement('div');
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.justifyContent = 'center';
    buttonsContainer.style.gap = '15px';
    
    // Yes button
    const yesButton = document.createElement('button');
    yesButton.textContent = 'Yes, continue';
    yesButton.style.padding = '10px 20px';
    yesButton.style.backgroundColor = '#336633';
    yesButton.style.color = '#fff';
    yesButton.style.border = 'none';
    yesButton.style.borderRadius = '4px';
    yesButton.style.cursor = 'pointer';
    yesButton.style.fontWeight = 'bold';
    
    // No button
    const noButton = document.createElement('button');
    noButton.textContent = 'No, start fresh';
    noButton.style.padding = '10px 20px';
    noButton.style.backgroundColor = '#8b0000';
    noButton.style.color = '#fff';
    noButton.style.border = 'none';
    noButton.style.borderRadius = '4px';
    noButton.style.cursor = 'pointer';
    noButton.style.fontWeight = 'bold';
    
    // Button hover effects
    yesButton.onmouseover = () => { yesButton.style.backgroundColor = '#3c7a3c'; };
    yesButton.onmouseout = () => { yesButton.style.backgroundColor = '#336633'; };
    noButton.onmouseover = () => { noButton.style.backgroundColor = '#a00000'; };
    noButton.onmouseout = () => { noButton.style.backgroundColor = '#8b0000'; };
    
    // Button handlers
    yesButton.addEventListener('click', () => {
      document.body.removeChild(modal);
      resolve(storedIdentity);
    });
    
    noButton.addEventListener('click', () => {
      // Clear stored identity when user chooses to start fresh
      try {
        localStorage.removeItem('wildWestPlayerIdentity');
      } catch (e) {
        console.error('Error clearing stored identity:', e);
      }
      document.body.removeChild(modal);
      resolve(newIdentity);
    });
    
    // Assemble modal
    buttonsContainer.appendChild(yesButton);
    buttonsContainer.appendChild(noButton);
    modalContent.appendChild(title);
    modalContent.appendChild(message);
    modalContent.appendChild(buttonsContainer);
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
  });
}

// Check if there's a stored identity in another storage medium (like localStorage)
// that doesn't match our current session
async function checkForIdentityConflict(currentIdentity) {
  try {
    // Skip conflict resolution in development mode
    if (shouldBypassIdentity() || currentIdentity.devMode) {
      return currentIdentity;
    }
    
    // Only check if our current identity is new (no username yet)
    if (currentIdentity.username) {
      return currentIdentity;
    }
    
    const storedDataStr = localStorage.getItem('wildWestPlayerIdentity');
    if (!storedDataStr) {
      return currentIdentity;
    }
    
    const storedIdentity = JSON.parse(storedDataStr);
    
    // If stored identity has a username and doesn't match our current ID
    if (storedIdentity && 
        storedIdentity.username && 
        storedIdentity.id !== currentIdentity.id) {
      
      // Ask user if they want to recover the stored identity
      return await promptIdentityRecovery(storedIdentity, currentIdentity);
    }
    
    return currentIdentity;
  } catch (e) {
    console.error('Error checking for identity conflict:', e);
    return currentIdentity;
  }
}

// Initialize player identity system
async function initPlayerIdentity() {
  // Get the basic identity first
  let playerData = getPlayerIdentity();
  
  // Check if there's a conflict with stored identity
  playerData = await checkForIdentityConflict(playerData);
  
  // Start preloading game content in background
  preloadGameContent();
  
  // For first-time users, we'll show the username prompt but game continues loading
  const isFirstTime = playerData.createdAt === playerData.lastLogin || shouldBypassIdentity();
  
  if (isFirstTime) {
    // Return a promise that will resolve when the user submits their name
    return new Promise(resolve => {
      // Show username prompt immediately, but don't wait for it
      promptForUsername(playerData).then(updatedPlayerData => {
        // Update last login time and save
        updatedPlayerData.lastLogin = Date.now();
        savePlayerIdentity(updatedPlayerData);
        resolve(updatedPlayerData);
      });
    });
  } else {
    // For returning users, continue normally
    playerData.lastLogin = Date.now();
    savePlayerIdentity(playerData);
    return playerData;
  }
}

// Verify client identity with server
async function verifyIdentityWithServer(playerData) {
  // This would typically make a request to the server to verify the token
  // For now, we'll just simulate this process
  return new Promise(resolve => {
    setTimeout(() => {
      // Assume the verification was successful
      resolve({
        verified: true,
        playerData: playerData
      });
    }, 300);
  });
}

export { 
  initPlayerIdentity,
  getPlayerIdentity, 
  savePlayerIdentity, 
  promptForUsername,
  verifyIdentityWithServer
}; 

================================================
File: /public/js/playerModel.js
================================================
// /public/js/playerModel.js

/**
 * The third-person model used to represent remote players
 * (and possibly the local player in others' view).
 */
export class ThirdPersonModel {
  constructor(scene, playerId) {
    this.scene = scene;
    this.playerId = playerId;
    this.group = new THREE.Group();

    this.collisionBox = new THREE.Box3();
    this.hitboxSize = { width: 1.02, height: 3.06, depth: 1.02 };
    
    // Hit zones for damage calculations
    this.headHitbox = new THREE.Box3();
    this.bodyHitbox = new THREE.Box3();
    this.limbsHitbox = new THREE.Box3();
    
    // Define hit zone relative sizes - adjusted for better accuracy
    this.headSize = { width: 0.45, height: 0.45, depth: 0.45 }; // Slightly smaller head hitbox
    this.bodySize = { width: 0.8, height: 0.95, depth: 0.55 }; // Narrower and much shorter body
    this.limbsSize = { width: 1.02, height: 3.06, depth: 1.02 }; // Full character size
    
    // Vertical offsets for positioning hitboxes more accurately
    this.headOffset = 0.45; // Further increased to move head lower
    this.bodyOffset = 0.25; // Adjusted to prevent overlap with head

    // Health
    this.health = 100;

    // Target position/rotation for smooth interpolation
    this.targetPosition = new THREE.Vector3(0, 0, 0);
    this.targetRotation = 0;
    
    // Initialize the group position to match target position
    this.group.position.copy(this.targetPosition);
    this.group.rotation.y = this.targetRotation;

    // Animation states
    this.animationMixer = null;
    this.animations = {};
    this.currentAction = null;
    this.previousAction = null;
    
    // Movement state tracking
    this.isWalking = false;
    this.isRunning = false;
    this.isJumping = false;
    this.lastPosition = new THREE.Vector3();
    this.movementSpeed = 0;
    
    // Gun state tracking
    this.isAiming = false;
    this.isShooting = false;
    
    // Animation timing - reduced for faster transitions
    this.walkBlendTime = 0.15;     // Blend between walking animations
    this.jumpBlendTime = 0.01;     // Almost immediate jump animation
    this.gunBlendTime = 0.1;       // Gun animation blend time
    
    // Animation state protection - reduced for faster responsiveness
    this.animationCooldown = 0;
    this.minAnimationCooldown = 0.2; // Reduced from 0.5 seconds
    
    // Position adjustment to prevent sinking
    this.groundOffset = 0; // Reduced from 0.1 to make feet touch the ground
    
    // Skin system
    this.activeSkin = null;
    this.availableSkins = {
      default: null, // Default texture will be stored here after loading
      bananaSkin: null // Will be loaded on demand
    };
    this.skinPermissions = {
      bananaSkin: false // By default, skin is locked until verified with NFT
    };
    
    // Load the player model
    this.loadPlayerModel();
    
    // Add to scene
    scene.add(this.group);

    // To track active hit feedback timeout
    this.hitFeedbackTimeout = null;
  }

  loadPlayerModel() {
    // Get NPC type from playerId - this identifies specific NPCs like sheriff or bartender
    const isNpcSheriff = typeof this.playerId === 'string' && this.playerId.includes('Sheriff');
    const isNpcBartender = typeof this.playerId === 'string' && this.playerId.includes('Bartender');
    
    // Check if this is a special NPC that needs a custom model
    if (isNpcSheriff) {
      // Load sheriff model
      this._loadCustomNpcModel('models/sheriff.glb', 'sheriffidle');
      return;
    } else if (isNpcBartender) {
      // Load bartender model
      this._loadCustomNpcModel('models/bartender.glb', 'bartenderidle');
      return;
    }

    // Standard player model loading for all other entities
    // Check if we have a preloaded player model
    if (window.preloadedModels && (window.preloadedModels.playermodel || window.preloadedModels.playermodel_clone)) {
      console.log("Using preloaded playermodel");
      try {
        // Use the clone version to avoid reference issues
        const preloadedModel = window.preloadedModels.playermodel_clone || window.preloadedModels.playermodel;
        const gltf = {
          scene: preloadedModel.scene.clone(),
          animations: preloadedModel.animations
        };
        
        this.playerModel = gltf.scene;
        
        // Position at origin with no offset to make feet touch the ground
        this.playerModel.position.set(0, 0, 0);
        
        // Set scale - increased by 70%
        this.playerModel.scale.set(1.445, 1.445, 1.445);
        
        // Rotate model to face the right direction (might need adjustment)
        this.playerModel.rotation.y = Math.PI; // Rotate 180 degrees
    
        // Add the model to the group
        this.group.add(this.playerModel);
        
        // Set up meshes correctly
        this.playerModel.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            child.userData.isPlayerMesh = true;
            
            // Ensure materials are set up correctly
            if (child.material) {
              child.material.side = THREE.DoubleSide;
              
              // If this is a skinned mesh, ensure skinning is enabled
              if (child.isSkinnedMesh) {
                child.material.skinning = true;
              }
              
              child.material.needsUpdate = true;
            }
          }
        });
        
        // Set up animations - do this after model is loaded
        if (gltf.animations && gltf.animations.length > 0) {
          // Initialize animations immediately
          this.setupAnimations(gltf.animations);
        }
        
        // Initialize hit zone visualizers
        this.createHitZoneVisualizers();
        return; // Exit early since we've handled the model
      } catch (e) {
        console.error('Error using preloaded player model:', e);
        // Fall through to regular loading method if preloaded model fails
      }
    }
    
    // Create loader instance
    const loader = new THREE.GLTFLoader();
    
    // Load the playermodel.glb model
    loader.load('models/playermodel.glb', 
      // Success callback
      (gltf) => {
        try {
          this.playerModel = gltf.scene;
          
          // Position at origin with no offset to make feet touch the ground
          this.playerModel.position.set(0, 0, 0);
          
          // Set scale - increased by 70%
          this.playerModel.scale.set(1.445, 1.445, 1.445);
          
          // Rotate model to face the right direction (might need adjustment)
          this.playerModel.rotation.y = Math.PI; // Rotate 180 degrees
      
          // Add the model to the group
          this.group.add(this.playerModel);
          
          // Set up meshes correctly
          this.playerModel.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              child.userData.isPlayerMesh = true;
              
              // Ensure materials are set up correctly
              if (child.material) {
                child.material.side = THREE.DoubleSide;
                
                // If this is a skinned mesh, ensure skinning is enabled
                if (child.isSkinnedMesh) {
                  child.material.skinning = true;
                }
                
                child.material.needsUpdate = true;
              }
            }
          });
          
          // Set up animations - do this after model is loaded
          if (gltf.animations && gltf.animations.length > 0) {
            // Initialize animations immediately
            this.setupAnimations(gltf.animations);
          }
          
          // Initialize hit zone visualizers
          this.createHitZoneVisualizers();
        } catch (e) {
          console.error('Error setting up player model:', e);
        }
      }, 
      // Progress callback - silent
      () => {},
      // Error callback
      (error) => {
        console.error('Error loading playermodel.glb model:', error);
        
        // If model fails to load, create a fallback cube
        const geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0, 0.9, 0);  // Position at center, accounting for height
        this.group.add(cube);
        
        // Add hit zone visualizers even for fallback model
        this.createHitZoneVisualizers();
      }
    );
  }

  /**
   * Loads a custom NPC model with specific idle animation
   * @param {string} modelPath - Path to the GLB model file
   * @param {string} idleAnimationName - Name of the idle animation to play in a loop
   * @private
   */
  _loadCustomNpcModel(modelPath, idleAnimationName) {
    // Create loader instance
    const loader = new THREE.GLTFLoader();
    
    // Load the custom NPC model
    loader.load(modelPath, 
      // Success callback
      (gltf) => {
        try {
          this.playerModel = gltf.scene;
          
          // Position at origin with no offset to make feet touch the ground
          this.playerModel.position.set(0, 0, 0);
          
          // Set appropriate scale (may need adjustment per model)
          this.playerModel.scale.set(1.445, 1.445, 1.445);
          
          // Rotate model to face the right direction (might need adjustment per model)
          this.playerModel.rotation.y = Math.PI; // Rotate 180 degrees
      
          // Add the model to the group
          this.group.add(this.playerModel);
          
          // Set up meshes correctly
          this.playerModel.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              child.userData.isPlayerMesh = true;
              
              // Ensure materials are set up correctly
              if (child.material) {
                child.material.side = THREE.DoubleSide;
                
                // If this is a skinned mesh, ensure skinning is enabled
                if (child.isSkinnedMesh) {
                  child.material.skinning = true;
                }
                
                child.material.needsUpdate = true;
              }
            }
          });
          
          // Set up animations - do this after model is loaded
          if (gltf.animations && gltf.animations.length > 0) {
            // Initialize animations immediately
            this.setupAnimations(gltf.animations);
            
            // Play the specific idle animation if it exists (after a small delay to ensure it's loaded)
            setTimeout(() => {
              if (this.animations[idleAnimationName]) {
                // Play the custom idle animation in a loop
                this.playAnimation(idleAnimationName, 0.5);
                console.log(`Playing ${idleAnimationName} animation for NPC`);
              } else {
                console.warn(`${idleAnimationName} animation not found for NPC`);
                
                // Fall back to regular idle animation if specific one not found
                if (this.animations['idle']) {
                  this.playAnimation('idle', 0.5);
                }
              }
            }, 100);
          }
          
          // Initialize hit zone visualizers
          this.createHitZoneVisualizers();
          
          console.log(`Custom NPC model ${modelPath} loaded successfully`);
        } catch (e) {
          console.error(`Error setting up custom NPC model ${modelPath}:`, e);
        }
      }, 
      // Progress callback - silent
      () => {},
      // Error callback
      (error) => {
        console.error(`Error loading custom NPC model ${modelPath}:`, error);
        
        // Fall back to regular player model if custom model fails to load
        console.log("Falling back to regular player model for NPC");
        
        // Load the regular player model as fallback
        if (window.preloadedModels && window.preloadedModels.playermodel) {
          const preloadedModel = window.preloadedModels.playermodel;
          const gltf = {
            scene: preloadedModel.scene.clone(),
            animations: preloadedModel.animations
          };
          
          this.playerModel = gltf.scene;
          this.group.add(this.playerModel);
          
          // Setup player model
          this.playerModel.position.set(0, 0, 0);
          this.playerModel.scale.set(1.445, 1.445, 1.445);
          this.playerModel.rotation.y = Math.PI;
          
          // Set up meshes correctly
          this.playerModel.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              child.userData.isPlayerMesh = true;
              
              if (child.material) {
                child.material.side = THREE.DoubleSide;
                if (child.isSkinnedMesh) child.material.skinning = true;
                child.material.needsUpdate = true;
              }
            }
          });
          
          // Set up animations
          if (gltf.animations && gltf.animations.length > 0) {
            this.setupAnimations(gltf.animations);
          }
          
          // Initialize hit zone visualizers
          this.createHitZoneVisualizers();
        } else {
          // Last resort fallback - create a colored cube
          const geometry = new THREE.BoxGeometry(0.5, 1.8, 0.5);
          const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
          const cube = new THREE.Mesh(geometry, material);
          cube.position.set(0, 0.9, 0);
          this.group.add(cube);
          
          // Add hit zone visualizers even for fallback model
          this.createHitZoneVisualizers();
        }
      }
    );
  }

  setupAnimations(animations) {
    if (!animations || animations.length === 0) {
      return;
    }
    
    try {
      // Create animation mixer
      this.animationMixer = new THREE.AnimationMixer(this.playerModel);
      
      // Store all animations from the model
      animations.forEach(animation => {
        try {
          this.animations[animation.name] = this.animationMixer.clipAction(animation);
          
          // Configure animation properties
          this.animations[animation.name].setEffectiveTimeScale(1);
          this.animations[animation.name].setEffectiveWeight(1);
          
          // Set loop mode based on animation type
          if (animation.name === 'idle' || animation.name === 'walking' || animation.name === 'running') {
            this.animations[animation.name].setLoop(THREE.LoopRepeat);
          } else if (animation.name === 'jump' || animation.name === 'playerholstering' || 
                     animation.name === 'playershoot' || animation.name === 'death') {
            this.animations[animation.name].setLoop(THREE.LoopOnce);
            this.animations[animation.name].clampWhenFinished = true;
          } else if (animation.name === 'playeraim') {
            // Special handling for aim animation to ensure it freezes correctly
            this.animations[animation.name].setLoop(THREE.LoopOnce, 1);
            this.animations[animation.name].clampWhenFinished = true;
            
            // Pre-configure the animation to be easier to freeze at the end
            const aimAction = this.animations[animation.name];
            aimAction.zeroSlopeAtEnd = true; // Ensure smooth stop at end
            aimAction.zeroSlopeAtStart = true; // Better blending
          }
        } catch (e) {
          console.error(`Error setting up animation ${animation.name}:`, e);
        }
      });
      
      // Initialize with idle animation if available
      if (this.animations['idle']) {
        this.playAnimation('idle');
      }
    } catch (e) {
      console.error('Failed to set up animations:', e);
    }
  }

  // Cross-fade between animations with specific blend time
  fadeToAction(actionName, duration = 0.5) {
    // Don't proceed if animations aren't loaded yet
    if (!this.animations || !this.animations[actionName]) {
      return null;
    }
    
    // Don't interrupt if same animation already playing
    if (this.currentAction && this.currentAction._clip.name === actionName) {
      return this.currentAction;
    }
    
    // Get the requested animation
    const nextAction = this.animations[actionName];
    
    // Store previous action
    this.previousAction = this.currentAction;
    this.currentAction = nextAction;
    
    // If a previous action exists, cross-fade to the new action
    if (this.previousAction) {
      this.currentAction.reset();
      this.currentAction.setEffectiveWeight(1);
      this.currentAction.play();
      
      this.currentAction.crossFadeFrom(this.previousAction, duration, true);
    } else {
      // First animation - just play it
      this.currentAction.play();
    }
    
    return this.currentAction;
  }

  // Play animation with appropriate fade time
  playAnimation(animationName, customFadeTime = null) {
    let fadeTime = customFadeTime;
    
    // Set specific fade times based on animation if not explicitly provided
    if (fadeTime === null) {
      switch (animationName) {
        case 'jump':
          fadeTime = this.jumpBlendTime;
          break;
        default:
          fadeTime = this.walkBlendTime;
      }
    }
    
    // Special handling for aim animation to ensure it gets frozen properly
    if (animationName === 'playeraim') {
      const action = this.fadeToAction(animationName, fadeTime);
      
      if (action) {
        // Configure it for freezing at the end
        action.clampWhenFinished = true;
        action.setLoop(THREE.LoopOnce, 1);
        action.zeroSlopeAtEnd = true;
      }
      
      return action;
    }
    
    // Play the animation with the determined fade time
    return this.fadeToAction(animationName, fadeTime);
  }

  // Simpler directToWalking implementation
  directToWalking(isRunning = false) {
    // Prevent rapid animation changes by enforcing a cooldown
    if (this.animationCooldown > 0) {
      return;
    }
    
    // Set walking state
    this.isWalking = true;
    
    // Set animation based on speed
    if (isRunning) {
      this.isRunning = true;
      this.playAnimation('running', 0.1);
    } else {
      this.isRunning = false;
      this.playAnimation('walking', 0.1);
    }
    
    // Set cooldown to prevent immediate state changes
    this.animationCooldown = this.minAnimationCooldown;
  }

  // Simpler directToIdle implementation
  directToIdle() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return;
    }
    
    // Only stop if we're actually walking
    if (!this.isWalking) {
      return;
    }
    
    // Mark as idle
    this.isWalking = false;
    this.isRunning = false;
    
    // Set cooldown to prevent immediate state changes
    this.animationCooldown = this.minAnimationCooldown;
    
    // Play idle animation
    this.playAnimation('idle', 0.1);
  }

  updateCollisionBox() {
    const halfWidth = this.hitboxSize.width / 2;
    const halfDepth = this.hitboxSize.depth / 2;

    this.collisionBox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - halfWidth,
        this.group.position.y,
        this.group.position.z - halfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + halfWidth,
        this.group.position.y + this.hitboxSize.height,
        this.group.position.z + halfDepth
      )
    ]);
    
    // Update hit zones with exact positioning
    
    // Head hitbox (top of the model but offset downward)
    const headHalfWidth = this.headSize.width / 2;
    const headHalfDepth = this.headSize.depth / 2;
    const headHeight = this.headSize.height;
    // Position head at the top of the model with offset
    const headY = this.group.position.y + this.hitboxSize.height - headHeight - this.headOffset;
    
    this.headHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - headHalfWidth,
        headY,
        this.group.position.z - headHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + headHalfWidth,
        headY + headHeight,
        this.group.position.z + headHalfDepth
      )
    ]);
    
    // Body hitbox (middle of the model)
    const bodyHalfWidth = this.bodySize.width / 2;
    const bodyHalfDepth = this.bodySize.depth / 2;
    const bodyHeight = this.bodySize.height;
    // Adjust body position to be just below the head with offset
    const topOfBody = headY; // Body starts where head ends
    const bodyBottom = topOfBody - bodyHeight - this.bodyOffset; // Apply the body offset
    
    this.bodyHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth,
        bodyBottom,
        this.group.position.z - bodyHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth,
        topOfBody,
        this.group.position.z + bodyHalfDepth
      )
    ]);
    
    // Limbs hitbox is everything not covered by head and body
    // Create a specific limbs hitbox for arms and legs with precise sizes
    
    // Define precise limb dimensions
    const legWidth = this.bodySize.width * 0.4; // Legs are narrower than body
    const armWidth = this.bodySize.width * 0.15; // Make arms thinner
    const armExtension = 0.35; // Extend arms further out
    const armHeight = bodyHeight * 0.7; // Make arms taller (70% of body height)
    
    // Left leg hitbox
    const leftLegHitbox = new THREE.Box3();
    leftLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth/2 - legWidth/2,
        this.group.position.y,
        this.group.position.z - bodyHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth/2 + legWidth/2,
        bodyBottom,
        this.group.position.z + bodyHalfDepth
      )
    ]);
    
    // Right leg hitbox
    const rightLegHitbox = new THREE.Box3();
    rightLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth/2 - legWidth/2,
        this.group.position.y,
        this.group.position.z - bodyHalfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth/2 + legWidth/2,
        bodyBottom,
        this.group.position.z + bodyHalfDepth
      )
    ]);
    
    // Left arm hitbox - positioned to not overlap with body
    const leftArmHitbox = new THREE.Box3();
    leftArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth - armExtension, // Start outside body
        bodyBottom + bodyHeight * 0.15, // Start lower (15% up)
        this.group.position.z - bodyHalfDepth/1.5 // Narrower depth
      ),
      new THREE.Vector3(
        this.group.position.x - bodyHalfWidth, // End exactly at body edge
        bodyBottom + bodyHeight * 0.85, // End higher (85% up)
        this.group.position.z + bodyHalfDepth/1.5 // Narrower depth
      )
    ]);
    
    // Right arm hitbox - positioned to not overlap with body
    const rightArmHitbox = new THREE.Box3();
    rightArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth, // Start exactly at body edge
        bodyBottom + bodyHeight * 0.15, // Start lower
        this.group.position.z - bodyHalfDepth/1.5 // Narrower depth
      ),
      new THREE.Vector3(
        this.group.position.x + bodyHalfWidth + armExtension, // End outside body
        bodyBottom + bodyHeight * 0.85, // End higher
        this.group.position.z + bodyHalfDepth/1.5 // Narrower depth
      )
    ]);
    
    // Combine the leg and arm hitboxes for the limbs hitbox
    this.limbsHitbox.makeEmpty();
    this.limbsHitbox.union(leftLegHitbox);
    this.limbsHitbox.union(rightLegHitbox);
    this.limbsHitbox.union(leftArmHitbox);
    this.limbsHitbox.union(rightArmHitbox);
  }

  /**
   * Determines which hit zone a ray intersects with
   * @param {THREE.Ray} ray - The ray to test
   * @returns {string|null} - 'head', 'body', 'limbs', or null if no hit
   */
  getHitZone(ray) {
    // Temporary variables for intersection checks
    const invMatrix = new THREE.Matrix4();
    invMatrix.copy(this.group.matrixWorld).invert();
    
    // Transform ray to model local space
    const localRay = ray.clone();
    localRay.applyMatrix4(invMatrix);
    
    // Check for intersection with head
    if (localRay.intersectsBox(this.headHitbox)) {
      return 'head';
    }
    
    // Check for intersection with body
    if (localRay.intersectsBox(this.bodyHitbox)) {
      return 'body';
    }
    
    // Check for intersection with limbs
    if (localRay.intersectsBox(this.limbsHitbox)) {
      return 'limbs';
    }
    
    // No hit
    return null;
  }

  /**
   * Check if a bullet hit this player model and determine which zone was hit
   * @param {THREE.Vector3} bulletPos - Position of the bullet
   * @param {boolean} isShotgunPellet - Whether this is a shotgun pellet hit
   * @return {object} - Hit result with zone and damage information
   */
  checkBulletHit(bulletPos, isShotgunPellet = false) {
    // Add a small tolerance to prevent edge cases and near-miss detections
    const PRECISION_EPSILON = 0.01;
    
    // First check if bullet is clearly within the overall collision box with precision adjustment
    // This prevents false positives at the edge of the collision box
    const strictCollisionBox = this.collisionBox.clone();
    strictCollisionBox.min.add(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    strictCollisionBox.max.sub(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    
    if (!strictCollisionBox.containsPoint(bulletPos)) {
      return { hit: false, zone: null, damage: 0 };
    }
    
    // Test hitboxes in priority order (head > body > limbs)
    // A bullet can only count as hitting ONE hitbox to prevent double-counting
    
    // 1. Head check (highest damage) - most important, so check first
    const strictHeadBox = this.headHitbox.clone();
    strictHeadBox.min.add(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    strictHeadBox.max.sub(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    
    if (strictHeadBox.containsPoint(bulletPos)) {
      // Apply appropriate damage based on weapon type
      const damage = isShotgunPellet ? 10 : 100;
      return { hit: true, zone: 'head', damage: damage };
    }
    
    // 2. Body check (medium damage)
    const strictBodyBox = this.bodyHitbox.clone();
    strictBodyBox.min.add(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    strictBodyBox.max.sub(new THREE.Vector3(PRECISION_EPSILON, PRECISION_EPSILON, PRECISION_EPSILON));
    
    if (strictBodyBox.containsPoint(bulletPos)) {
      // Apply appropriate damage based on weapon type
      const damage = isShotgunPellet ? 5 : 40;
      return { hit: true, zone: 'body', damage: damage };
    }
    
    // 3. Limbs check - we need to check each limb individually to prevent overlap issues
    
    // Create strict boxes for each individual limb
    const leftLegHitbox = new THREE.Box3();
    leftLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/4 - this.bodySize.width * 0.2,
        this.group.position.y + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/2 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/4 + this.bodySize.width * 0.2,
        this.bodyHitbox.min.y - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/2 - PRECISION_EPSILON
      )
    ]);
    
    const rightLegHitbox = new THREE.Box3();
    rightLegHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/4 - this.bodySize.width * 0.2,
        this.group.position.y + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/2 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/4 + this.bodySize.width * 0.2,
        this.bodyHitbox.min.y - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/2 - PRECISION_EPSILON
      )
    ]);
    
    const leftArmHitbox = new THREE.Box3();
    leftArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/2 - this.bodySize.width * 0.175,
        this.bodyHitbox.min.y + this.bodySize.height * 0.15 + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/3 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x - this.bodySize.width/2 + PRECISION_EPSILON,
        this.bodyHitbox.min.y + this.bodySize.height * 0.85 - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/3 - PRECISION_EPSILON
      )
    ]);
    
    const rightArmHitbox = new THREE.Box3();
    rightArmHitbox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/2 - PRECISION_EPSILON,
        this.bodyHitbox.min.y + this.bodySize.height * 0.15 + PRECISION_EPSILON,
        this.group.position.z - this.bodySize.depth/3 + PRECISION_EPSILON
      ),
      new THREE.Vector3(
        this.group.position.x + this.bodySize.width/2 + this.bodySize.width * 0.175,
        this.bodyHitbox.min.y + this.bodySize.height * 0.85 - PRECISION_EPSILON,
        this.group.position.z + this.bodySize.depth/3 - PRECISION_EPSILON
      )
    ]);
    
    // Check each limb individually
    if (leftLegHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    if (rightLegHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    if (leftArmHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    if (rightArmHitbox.containsPoint(bulletPos)) {
      const damage = isShotgunPellet ? 5 : 20;
      return { hit: true, zone: 'limbs', damage: damage };
    }
    
    // If we're here, the bullet is inside the overall collision box but not in any specific zone
    // Instead of returning no hit, we'll count it as a partial body hit with reduced damage
    const damage = isShotgunPellet ? 5 : 30;
    return { hit: true, zone: 'body', damage: damage };
  }

  /**
   * Smoothly updates the model's position and rotation toward target values.
   * @param {number} deltaTime - Time elapsed since last frame.
   */
  animateMovement(deltaTime) {
    // Ensure the model is visible
    if (this.playerModel) {
      this.playerModel.visible = true;
    }
    
    // Store position before movement for walking detection
    this.lastPosition.copy(this.group.position);
    
    // Special handling for when we're in a frozen aim pose
    if (this.isAiming && !this.isShooting && !this.isJumping && this._aimPoseSnapshot) {
      // Skip the animation mixer update entirely and just apply the saved pose
      this.maintainAimPose();
    } 
    // Regular animation updates for all other states
    else if (this.animationMixer && deltaTime > 0 && deltaTime < 1) {
      try {
        this.animationMixer.update(deltaTime);
        
        // If we need to aim but don't have a snapshot yet, create one
        if (this.isAiming && !this.isShooting && !this.isJumping && !this._aimPoseSnapshot) {
          this.maintainAimPose();
        }
      } catch (e) {
        console.warn("Error updating animation mixer:", e);
      }
    }
    
    // Normal interpolation for network movement
    this.group.position.lerp(this.targetPosition, 0.1);
    
    // Rotate the model
    this.group.rotation.y = THREE.MathUtils.lerp(this.group.rotation.y, this.targetRotation, 0.1);
    
    // Update cooldown timer
    if (this.animationCooldown > 0) {
      this.animationCooldown -= deltaTime;
      if (this.animationCooldown < 0) {
        this.animationCooldown = 0;
      }
    }
    
    // Update collision box
    this.updateCollisionBox();
  }

  /**
   * Updates the third-person model using data received from the server.
   * @param {Object} playerData
   */
  update(playerData) {
    if (!playerData) return;
    
    // Skip animation updates if animations aren't loaded yet
    const animationsLoaded = this.animations && Object.keys(this.animations).length > 0;
    
    // Check if this is an NPC or Bot
    const isAIControlled = this.isBot || this.isNpc || playerData.isBot || playerData.isNpc;

    // Handle death animation if the player is dying
    if (animationsLoaded && playerData.isDying && !this.isDying) {
      console.log(`Playing death animation for remote player ${this.playerId}`);
      this.playDeathAnimation();
      // Don't process any other animation states after playing death animation
      return;
    }
    
    // Handle jump animation first to ensure immediacy
    if (animationsLoaded && playerData.velocity && playerData.velocity.y > 2.5 && !this.isJumping) {
      this.playJumpAnimation();
    }

    // Handle landing from jump
    if (this.isJumping && (!playerData.velocity || playerData.velocity.y <= 0.1)) {
      this.isJumping = false;
    }
    
    // Special handling for aim state - we only want to process animation transitions
    // when there is an actual change in the aiming state
    if (animationsLoaded && !this.isJumping) {
      // Track if the aiming state has changed
      const wasAiming = this.isAiming;
      const isAimingNow = playerData.isAiming;
      
      // We only need to handle aim animation transitions when the state actually changes
      // or when we need to handle shooting while already aiming
      
      // Handle shooting animation - prioritize shooting over aim changes
      if (isAimingNow && playerData.isShooting && !this.isShooting) {
        this.playShootAnimation();
      }
      // Handle aiming animation start - only when state changes from not aiming to aiming
      else if (isAimingNow && !wasAiming) {
        this.playAimAnimation();
      }
      // Handle holstering animation - only when state changes from aiming to not aiming
      else if (!isAimingNow && wasAiming) {
        this.playHolsterAnimation();
      }
      // Maintain aim state - but don't restart the animation if already aiming
      else if (isAimingNow && wasAiming) {
        // If we have a snapshot, make sure it's applied
        if (this._aimPoseSnapshot) {
          // No need to call maintainAimPose() here as it will be called in animateMovement
        }
        // If we don't have a snapshot yet but should be aiming, create one
        else if (!this._aimPoseSnapshot && isAimingNow) {
          this.maintainAimPose();
        }
      }
    }
    
    // Update target position from network data
    if (playerData.position) {
      // Choose the right height adjustment based on entity type
      let heightAdjustment = 0;
      
      if (isAIControlled) {
        // NPCs/Bots need the same height adjustment as players to prevent floating
        heightAdjustment = -2.72; // Same as players to keep NPCs grounded
      } else {
        // Regular player adjustment to prevent sinking
        heightAdjustment = -2.72; // Adjusted for 70% taller player model (1.6 * 1.7)
      }
      
      // Position the model on the ground, with appropriate height adjustment
      const newPos = new THREE.Vector3(
        playerData.position.x,
        playerData.position.y + heightAdjustment,
        playerData.position.z
      );
      
      // Calculate distance before updating position
      const distance = newPos.distanceTo(this.targetPosition);
      
      // Only update if movement is significant (prevents jitter)
      if (distance > 0.01) {
        this.targetPosition.copy(newPos);
      }

      // Only process animation transitions if animations are loaded
      // and we're not in a special state (aiming/shooting/jumping)
      if (animationsLoaded && !this.isJumping && !this.isAiming && !this.isShooting) {
        // Check if moving based on position change or explicit walking flag
        const isMovingNow = isAIControlled ? 
                          (playerData.isWalking || false) : // Use isWalking flag for AI
                          (distance > 0.03);               // Reduced threshold for walking (was 0.05)
        
        const isRunningNow = distance > 0.2; // Reduced threshold for running (was 0.3)
        
        // Handle animation state transitions
        if (isMovingNow) {
          if (!this.isWalking) {
            // Start walking or running based on speed
            this.directToWalking(isRunningNow);
          } else {
            // Switch between walking and running based on speed
            if (isRunningNow && !this.isRunning) {
              this.isRunning = true;
              this.playAnimation('running', 0.1); 
            } else if (!isRunningNow && this.isRunning) {
              this.isRunning = false;
              this.playAnimation('walking', 0.1);
            }
          }
        } else if (!isMovingNow && this.isWalking) {
          // Transition directly to idle if not moving
          this.directToIdle();
        }
      }
    }

    // Update target rotation (with default value if missing)
    if (playerData.rotation !== undefined) {
      // For network data, rotation is typically just a y rotation value
      if (typeof playerData.rotation === 'number') {
        this.targetRotation = playerData.rotation;
      } 
      // Handle case where rotation might be an object with a y property
      else if (playerData.rotation && playerData.rotation.y !== undefined) {
        this.targetRotation = playerData.rotation.y;
      }
    }
    
    // Handle skin updates - only when skin data changes
    if (playerData.skins && (!this._lastSkinUpdate || JSON.stringify(playerData.skins) !== JSON.stringify(this._lastSkinUpdate))) {
      // Store current skin data to prevent redundant updates
      this._lastSkinUpdate = JSON.stringify(playerData.skins);
      
      // Update permissions
      this.updateSkinPermissions(playerData.skins);
      
      // Apply banana skin automatically if permission granted and not already applied
      if (playerData.skins.bananaSkin && this.activeSkin !== 'bananaSkin') {
        this.updateSkin('bananaSkin');
      }
    }
    // Force skin application during first update if it hasn't been applied yet
    else if (playerData.skins && playerData.skins.bananaSkin && !this._initialSkinApplied && this.activeSkin !== 'bananaSkin') {
      this._initialSkinApplied = true;
      this.updateSkin('bananaSkin');
      console.log(`Applied initial skin to player ${this.playerId} during first update`);
    }
  }

  /**
   * Removes the model from the scene (e.g. on player disconnect).
   * Fully disposes geometry and material.
   */
  remove() {
    this.scene.remove(this.group);
    this.group.traverse(child => {
      if (child.isMesh) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  }

  /**
   * Provides visual feedback (temporary red flash) when the model is hit.
   */
  showHitFeedback() {
    // Clear any existing hit feedback timeout
    if (this.hitFeedbackTimeout) {
      clearTimeout(this.hitFeedbackTimeout);
    }
    
    // Traverse the model and replace each mesh's material with a red flash
    this.group.traverse(child => {
      if (child.isMesh && child.material) {
        // Store the original material in userData if not already stored
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        
        // Create a new material for the flash effect
        const flashMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        
        // If this is a skinned mesh, enable skinning on the material
        if (child.isSkinnedMesh) {
          flashMaterial.skinning = true;
        }
        
        // Apply the flash material
        child.material = flashMaterial;
        child.material.needsUpdate = true;
      }
    });
    
    // After 200ms, restore the original materials
    this.hitFeedbackTimeout = setTimeout(() => {
      this.group.traverse(child => {
        if (child.isMesh && child.userData.originalMaterial) {
          child.material.dispose();
          child.material = child.userData.originalMaterial;
          child.material.needsUpdate = true;
          delete child.userData.originalMaterial;
        }
      });
      this.hitFeedbackTimeout = null;
    }, 200);
  }

  /**
   * Reduces health when hit.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Remote player ${this.playerId} took ${amount} damage. Health: ${this.health}`);
  }

  /**
   * Creates visual helpers for the hit zones (for debugging)
   * Call this method to see the hit zones visually
   * @param {boolean} forceVisible - Override default visibility setting
   */
  createHitZoneVisualizers(forceVisible = null) {
    const hitZoneVisible = forceVisible !== null ? forceVisible : false;
    
    if (!hitZoneVisible) return;
    
    // Clean up any existing helpers
    if (this.headHelper) this.group.remove(this.headHelper);
    if (this.bodyHelper) this.group.remove(this.bodyHelper);
    if (this.leftLegHelper) this.group.remove(this.leftLegHelper);
    if (this.rightLegHelper) this.group.remove(this.rightLegHelper);
    
    // Remove arm helpers and limbs helper if they exist
    if (this.leftArmHelper) this.group.remove(this.leftArmHelper);
    if (this.rightArmHelper) this.group.remove(this.rightArmHelper);
    if (this.limbsHelper) this.group.remove(this.limbsHelper);
    
    // Materials for different hitboxes
    const headMaterial = new THREE.MeshBasicMaterial({
      color: 0xff0000, // Red for head
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    
    const bodyMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ff00, // Green for body
      wireframe: true,
      transparent: true,
      opacity: 0.8
    });
    
    const legMaterial = new THREE.MeshBasicMaterial({
      color: 0x8800ff, // Purple for legs
      wireframe: true,
      transparent: true,
      opacity: 0.7
    });
    
    // Head helper - adjusted with offset
    const headGeometry = new THREE.BoxGeometry(
      this.headSize.width,
      this.headSize.height,
      this.headSize.depth
    );
    this.headHelper = new THREE.Mesh(headGeometry, headMaterial);
    this.headHelper.position.set(
      0,
      this.hitboxSize.height - this.headSize.height/2 - this.headOffset,
      0
    );
    this.group.add(this.headHelper);
    
    // Body helper with offset
    const bodyGeometry = new THREE.BoxGeometry(
      this.bodySize.width,
      this.bodySize.height,
      this.bodySize.depth
    );
    this.bodyHelper = new THREE.Mesh(bodyGeometry, bodyMaterial);
    
    // Position body below head with offset
    const headBottom = this.hitboxSize.height - this.headSize.height - this.headOffset;
    const bodyTop = headBottom;
    const bodyBottom = bodyTop - this.bodySize.height - this.bodyOffset;
    const bodyCenter = (bodyTop + bodyBottom) / 2;
    
    this.bodyHelper.position.set(
      0,
      bodyCenter,
      0
    );
    this.group.add(this.bodyHelper);
    
    // Create precise limb helpers matching our collision detection
    // Define precise limb dimensions - same as in updateCollisionBox
    const legWidth = this.bodySize.width * 0.4;
    
    // Left leg helper
    const leftLegGeometry = new THREE.BoxGeometry(
      legWidth,
      bodyBottom, // Height from ground to bottom of body
      this.bodySize.depth
    );
    this.leftLegHelper = new THREE.Mesh(leftLegGeometry, legMaterial);
    this.leftLegHelper.position.set(
      -this.bodySize.width/4, // Center of left leg
      bodyBottom/2, // Middle of leg
      0
    );
    this.group.add(this.leftLegHelper);
    
    // Right leg helper
    const rightLegGeometry = new THREE.BoxGeometry(
      legWidth,
      bodyBottom,
      this.bodySize.depth
    );
    this.rightLegHelper = new THREE.Mesh(rightLegGeometry, legMaterial);
    this.rightLegHelper.position.set(
      this.bodySize.width/4, // Center of right leg
      bodyBottom/2,
      0
    );
    this.group.add(this.rightLegHelper);
  }

  // Play the aiming animation when player draws their gun
  playAimAnimation() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return null;
    }
    
    this.isAiming = true;
    this.animationCooldown = this.minAnimationCooldown;
    
    const aimAction = this.playAnimation('playeraim', this.gunBlendTime);
    
    // If we successfully got the animation, set up to stay on the last frame
    if (aimAction && aimAction._clip) {
      const duration = aimAction._clip.duration;
      
      // After the aiming animation completes, freeze on the last frame
      setTimeout(() => {
        // If still aiming, make sure we're showing the last frame
        if (this.isAiming && !this.isShooting) {
          // Manually set to the end frame to show the gun aimed
          if (this.animations['playeraim']) {
            const aimAction = this.animations['playeraim'];
            
            // Ensure set to the end frame and frozen
            aimAction.reset();
            aimAction.time = aimAction._clip.duration - 0.01;
            aimAction.timeScale = 0; // Completely stop time advancement
            aimAction.enabled = true;
            aimAction.setEffectiveWeight(1);
            aimAction.clampWhenFinished = true;
            aimAction.setLoop(THREE.LoopOnce, 1); // Ensure it's set to loop once
            aimAction.paused = true; // Pause the action to prevent any updates
            aimAction.play();
            
            this.currentAction = aimAction;
          }
        }
      }, duration * 1000);
    }
    
    return aimAction;
  }
  
  // Maintain the aim pose at the last frame of the animation
  maintainAimPose() {
    // Only proceed if we have loaded animations and the playeraim animation exists
    if (!this.animations || !this.animations['playeraim']) return;
    
    const aimAction = this.animations['playeraim'];
    
    // If we don't have a snapshot yet, create one
    if (!this._aimPoseSnapshot) {
      // Stop all current actions to prevent interference
      this.animationMixer.stopAllAction();
      
      // Reset and prepare the aim action to capture the final pose
      aimAction.reset();
      aimAction.clampWhenFinished = true;
      aimAction.setLoop(THREE.LoopOnce, 1);
      aimAction.timeScale = 1; // Normal speed for setup
      aimAction.time = 0; // Start from beginning
      aimAction.enabled = true;
      aimAction.setEffectiveWeight(1);
      aimAction.play();
      
      // Skip to the end of the animation to capture final pose
      aimAction.time = aimAction._clip.duration - 0.01;
      
      // Force an update to apply the pose to the bones
      this.animationMixer.update(0);
      
      // Save a snapshot of all bone matrices in the model
      this._aimPoseSnapshot = {};
      this.playerModel.traverse(child => {
        if (child.isBone) {
          // Save position, rotation, scale for more accurate restoration
          this._aimPoseSnapshot[child.uuid] = {
            position: child.position.clone(),
            quaternion: child.quaternion.clone(),
            scale: child.scale.clone(),
            matrix: child.matrix.clone(),
            matrixWorld: child.matrixWorld.clone()
          };
        }
      });
      
      // Stop the animation to prevent further updates
      aimAction.stop();
      
      console.log(`Created detailed aim pose snapshot for player ${this.playerId}`);
      
      // Set the current action to aim so we know what state we're in
      this.currentAction = aimAction;
      this.isAiming = true;
    }
    
    // Apply the saved pose each frame to ensure it stays frozen
    if (this._aimPoseSnapshot) {
      this.playerModel.traverse(child => {
        if (child.isBone && this._aimPoseSnapshot[child.uuid]) {
          const snapshot = this._aimPoseSnapshot[child.uuid];
          
          // Apply the saved transform data directly
          child.position.copy(snapshot.position);
          child.quaternion.copy(snapshot.quaternion);
          child.scale.copy(snapshot.scale);
          child.matrix.copy(snapshot.matrix);
          
          // Also set the matrixWorld to ensure correct global pose
          child.matrixWorld.copy(snapshot.matrixWorld);
          
          // Ensure matrices are updated
          child.updateMatrix();
          child.updateMatrixWorld(true);
        }
      });
    }
  }
  
  // Play the jump animation
  playJumpAnimation() {
    // Interrupt any current animation for immediate jump
    this.isJumping = true;
    this.isWalking = false;
    this.isRunning = false;
    
    // Force immediate transition to jump
    this.animationCooldown = 0;
    const jumpAction = this.playAnimation('jump', 0.01);
    
    // Only proceed with timing if we successfully got the animation
    if (jumpAction && jumpAction._clip) {
      // Reset to walking or idle after jump animation completes
      const duration = jumpAction._clip.duration;
      
      // Shorten the jump animation to match faster gravity
      const adjustedDuration = duration * 0.8; // 20% shorter for quicker landing
      
      // Set immediate state transition when landing
      setTimeout(() => {
        if (this.isJumping) {
          this.isJumping = false;
          // Check if the player was moving before jumping
          const wasMoving = this.group.position.distanceTo(this.targetPosition) > 0.03; // Reduced from 0.05
          if (wasMoving) {
            this.isWalking = true;
            this.playAnimation('walking', 0.05);
            // Check if should be running with higher threshold
            if (this.group.position.distanceTo(this.targetPosition) > 0.2) { // Reduced from 0.3
              this.isRunning = true;
              this.playAnimation('running', 0.05);
            }
          } else {
            this.playAnimation('idle', 0.05);
          }
        }
      }, adjustedDuration * 1000);
    } else {
      // Fallback if jump animation fails
      setTimeout(() => {
        this.isJumping = false;
      }, 700); // Reduced from 1000ms to match faster jump
    }
  }
  
  // Play the holstering animation when player stops aiming
  playHolsterAnimation() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return null;
    }
    
    this.isAiming = false;
    this.isShooting = false;
    this.animationCooldown = this.minAnimationCooldown;
    
    // Clear any aim pose snapshot when transitioning to holstering
    this._aimPoseSnapshot = null;
    
    return this.playAnimation('playerholstering', this.gunBlendTime);
  }
  
  // Play the shooting animation
  playShootAnimation() {
    // Prevent rapid animation changes
    if (this.animationCooldown > 0) {
      return null;
    }
    
    this.isShooting = true;
    this.animationCooldown = this.minAnimationCooldown;
    
    // Clear aim pose snapshot during shooting
    this._aimPoseSnapshot = null;
    
    // IMPORTANT: NO SOUNDS are played here!
    // All gunshot sounds are centrally managed in main.js to prevent duplication
    // This is especially critical for mobile devices which can have audio sync issues
    
    const shootAction = this.playAnimation('playershoot', this.gunBlendTime);
    
    // If we successfully got the animation, set up the transition back to aim
    if (shootAction && shootAction._clip) {
      const duration = shootAction._clip.duration;
      
      // After the shooting animation completes, return to aim
      setTimeout(() => {
        this.isShooting = false;
        
        // If still aiming, create a new aim pose snapshot
        if (this.isAiming) {
          // Clear any existing snapshot so we can create a fresh one
          this._aimPoseSnapshot = null;
          this.maintainAimPose();
        }
      }, duration * 1000);
    }
    
    return shootAction;
  }
  
  // Play the death animation when player is killed
  playDeathAnimation() {
    // Set death state
    this.isDying = true;
    
    // Reset other animation states
    this.isAiming = false;
    this.isShooting = false;
    this.isWalking = false;
    this.isRunning = false;
    this.isJumping = false;
    
    // Play the death animation with fast transition
    const deathAction = this.playAnimation('death', 0.1);
    
    // Return the action and its duration if available
    if (deathAction && deathAction._clip) {
      return {
        action: deathAction,
        duration: deathAction._clip.duration * 1000 // Duration in milliseconds
      };
    }
    
    // Return a default duration if animation couldn't be played
    return {
      action: null,
      duration: 1500 // Default fallback duration in milliseconds
    };
  }

  /**
   * Resets all animation states - useful when respawning or between matches
   */
  resetAnimationState() {
    console.log(`Resetting animation state for player ${this.playerId}`);
    
    // Reset all animation state flags
    this.isDying = false;
    this.isAiming = false;
    this.isShooting = false;
    this.isWalking = false;
    this.isRunning = false;
    this.isJumping = false;
    
    // Clear aim pose snapshot
    this._aimPoseSnapshot = null;
    
    // Stop all active animations and reset mixer
    if (this.animationMixer) {
      this.animationMixer.stopAllAction();
    }
    
    // Reset all animations
    if (this.animations) {
      for (const name in this.animations) {
        const action = this.animations[name];
        if (action) {
          action.reset();
          if (action.isRunning()) {
            action.stop();
          }
        }
      }
    }
    
    // Reset current and previous actions
    this.currentAction = null;
    this.previousAction = null;
    
    // Play idle animation if available
    if (this.animations && this.animations['idle']) {
      this.playAnimation('idle', 0.1);
    }
  }

  /**
   * Disposes of all resources
   */
  dispose() {
    // First reset animation state
    this.resetAnimationState();
    
    // Remove all models
    if (this.playerModel) {
      this.group.remove(this.playerModel);
    }
    
    // Remove any helpers
    if (this.headHelper) this.group.remove(this.headHelper);
    if (this.bodyHelper) this.group.remove(this.bodyHelper);
    if (this.leftArmHelper) this.group.remove(this.leftArmHelper);
    if (this.rightArmHelper) this.group.remove(this.rightArmHelper);
    if (this.leftLegHelper) this.group.remove(this.leftLegHelper);
    if (this.rightLegHelper) this.group.remove(this.rightLegHelper);
    
    // Remove from scene
    if (this.group.parent) {
      this.group.parent.remove(this.group);
    }
  }

  /**
   * Updates the model's skin based on skin ID
   * @param {string} skinId - The skin ID to apply
   * @returns {boolean} - Whether the skin was successfully applied
   */
  updateSkin(skinId) {
    // Check if this is a valid skin
    if (!skinId || !this.availableSkins.hasOwnProperty(skinId)) {
      console.warn(`Invalid skin ID: ${skinId}`);
      return false;
    }
    
    // Check if player has permission for this skin
    if (skinId !== 'default' && !this.skinPermissions[skinId]) {
      console.warn(`Player ${this.playerId} does not have permission for skin: ${skinId}`);
      return false;
    }
    
    // Check if model is loaded before attempting to apply skins
    if (!this.playerModel) {
      console.warn(`Cannot apply skin - player model not loaded yet for player ${this.playerId}`);
      // Schedule another attempt after a short delay
      setTimeout(() => {
        if (this.playerModel) {
          console.log(`Retrying skin application for player ${this.playerId}`);
          this.updateSkin(skinId);
        }
      }, 500);
      return false;
    }
    
    // TEMPORARY: Debug the model structure to help identify meshes and materials
    this._debugModelStructure();
    
    // Check if the texture was already loaded for this skin
    if (!this.availableSkins[skinId]) {
      // Load the skin texture
      this.loadSkinTexture(skinId);
      return false; // Will be applied once loaded
    }
    
    // Apply the skin texture to the model
    this.applyTextureToModel(this.availableSkins[skinId]);
    this.activeSkin = skinId;
    
    console.log(`Applied skin '${skinId}' to player ${this.playerId}`);
    return true;
  }
  
  /**
   * TEMPORARY: Debug helper to print model hierarchy and materials
   * @private
   */
  _debugModelStructure() {
    if (!this.playerModel) return;
    
    console.log(`=== DEBUG: Model structure for player ${this.playerId} ===`);
    let meshCount = 0;
    let skinnedMeshCount = 0;
    let materialCount = 0;
    
    this.playerModel.traverse(child => {
      if (child.isMesh) {
        meshCount++;
        if (child.isSkinnedMesh) skinnedMeshCount++;
        
        console.log(`Mesh: ${child.name}`);
        
        if (child.material) {
          materialCount++;
          console.log(`  Material: ${child.material.name || 'unnamed'}`);
          console.log(`  Has map: ${child.material.map ? 'YES' : 'NO'}`);
          console.log(`  Side: ${child.material.side}`);
          if (child.isSkinnedMesh) {
            console.log(`  Skinning enabled: ${child.material.skinning ? 'YES' : 'NO'}`);
          }
        }
      }
    });
    
    console.log(`Total meshes: ${meshCount}, Skinned meshes: ${skinnedMeshCount}, Materials: ${materialCount}`);
    console.log(`=== END DEBUG ===`);
  }
  
  /**
   * Loads a skin texture by ID
   * @param {string} skinId - The skin ID to load
   */
  loadSkinTexture(skinId) {
    if (!skinId || skinId === 'default') return;
    
    const texturePath = `models/textures/${skinId}.png`;
    const textureLoader = new THREE.TextureLoader();
    
    // Store that we have permission before the async load starts
    const hasPermission = this.skinPermissions[skinId];
    
    console.log(`Loading skin texture for playermodel: ${texturePath}`);
    
    textureLoader.load(
      texturePath,
      (texture) => {
        console.log(`Successfully loaded texture: ${texturePath}`, texture);
        
        // Store the loaded texture
        this.availableSkins[skinId] = texture;
        
        // Use the stored permission value rather than checking again
        // This prevents race conditions where permissions might change during load
        if (hasPermission) {
          this.applyTextureToModel(texture);
          this.activeSkin = skinId;
          console.log(`Applied newly loaded skin '${skinId}' to player ${this.playerId}`);
        } else {
          console.log(`Texture loaded but not applied - no permission for skin: ${skinId}`);
        }
      },
      (progressEvent) => {
        console.log(`Texture loading progress: ${progressEvent.loaded} / ${progressEvent.total}`);
      },
      (error) => {
        console.error(`Error loading skin texture '${skinId}':`, error);
      }
    );
  }
  
  /**
   * Applies a texture to the player model
   * @param {THREE.Texture} texture - The texture to apply
   */
  applyTextureToModel(texture) {
    if (!this.playerModel || !texture) return;
    
    // List of revolver part names to look for (with different variations to match all cases)
    const revolverParts = ['barrel', 'drum', 'grip', 'revolver', 'gun', 'barrel.001', 'drum.001', 'grip.001'];
    
    // Count how many parts we modify for a single summary log instead of per-part logs
    let modifiedPartsCount = 0;
    
    // Debug mode to log all mesh names and material names to help identify parts
    const debugMode = false;
    
    // Apply the texture to all relevant meshes in the model
    this.playerModel.traverse(child => {
      if (child.isMesh && child.material) {
        if (debugMode) {
          console.log(`Found mesh: ${child.name} with material: ${child.material.name || 'unnamed'}`);
        }
        
        // Use Material.003 as primary check, but also check for revolver part names
        const isRevolverMaterial = child.material.name && child.material.name.includes('Material.003');
        const isRevolverPart = revolverParts.some(part => 
          child.name.toLowerCase().includes(part.toLowerCase())
        );
        
        // Also check for gun parts by looking at Pistol parts
        const isPistolPart = child.name.toLowerCase().includes('pistol');
        
        // Extra check for model materials that might be eligible for skins
        const isEligibleMaterial = child.material.name && 
          (child.material.name.includes('gun') || 
           child.material.name.includes('pistol') || 
           child.material.name.includes('revolver'));
        
        if (isRevolverMaterial || isRevolverPart || isPistolPart || isEligibleMaterial) {
          // Increment counter
          modifiedPartsCount++;
          
          // Store the original/default texture if not already stored
          if (!this.availableSkins.default && child.material.map) {
            this.availableSkins.default = child.material.map.clone();
          }
          
          // Clone the original material to preserve all properties
          if (child.material._originalMaterial === undefined) {
            child.material._originalMaterial = child.material.clone();
          }
          
          // Proper creation of new texture - maintaining UVs
          if (child.material._originalMaterial && child.material._originalMaterial.map) {
            const originalTexture = child.material._originalMaterial.map;
            
            // Copy ALL texture properties
            texture.wrapS = originalTexture.wrapS;
            texture.wrapT = originalTexture.wrapT;
            texture.repeat.copy(originalTexture.repeat);
            texture.offset.copy(originalTexture.offset);
            texture.center.copy(originalTexture.center);
            texture.rotation = originalTexture.rotation;
            
            // Copy any additional properties that might affect UV mapping
            texture.flipY = originalTexture.flipY;
            texture.encoding = originalTexture.encoding;
            
            // Handle mipmaps and filtering
            texture.generateMipmaps = originalTexture.generateMipmaps;
            texture.minFilter = originalTexture.minFilter;
            texture.magFilter = originalTexture.magFilter;
            
            // Also ensure texture is fully loaded before applying
            texture.needsUpdate = true;
          }
          
          // Apply the new texture
          child.material.map = texture;
          child.material.needsUpdate = true;
          
          if (debugMode) {
            console.log(`Applied texture to part: ${child.name}`);
          }
        }
      }
    });
    
    // Single summary log instead of multiple per-part logs
    if (modifiedPartsCount > 0) {
      console.log(`Applied texture to ${modifiedPartsCount} player model parts for player ${this.playerId}`);
    } else {
      console.warn(`No suitable parts found to apply texture for player ${this.playerId}`);
    }
  }
  
  /**
   * Updates skin permissions based on server data
   * @param {Object} skinData - Skin permission data from server
   */
  updateSkinPermissions(skinData) {
    if (!skinData) return;
    
    let skinChanged = false;
    
    // Update permissions for each skin
    Object.keys(skinData).forEach(skinId => {
      if (this.skinPermissions.hasOwnProperty(skinId)) {
        const oldPermission = this.skinPermissions[skinId];
        const newPermission = skinData[skinId];
        
        this.skinPermissions[skinId] = newPermission;
        
        // If permission was granted, preload the skin
        if (!oldPermission && newPermission) {
          this.loadSkinTexture(skinId);
          skinChanged = true;
        }
      }
    });
    
    // If permission changes might affect current skin, check if we need to reset
    if (skinChanged && this.activeSkin && !this.skinPermissions[this.activeSkin]) {
      // Reset to default skin if current skin is no longer permitted
      this.updateSkin('default');
    }
  }
}

================================================
File: /public/js/quickDraw.js
================================================
/**
 * Quick Draw game mode implementation
 * Players face off in a wild west duel where they must wait for the "draw" signal
 * before pulling their revolvers and shooting at each other.
 * Now with direct player-to-player challenges directly on the town map.
 */

import { PhysicsSystem } from './physics.js';
import { createOptimizedSmokeEffect } from './input.js';
import { updateHealthUI } from './ui.js';
import { FlyingEagle } from './flyingEagle.js';

export class QuickDraw {
    constructor(scene, localPlayer, networkManager, soundManager) {
        // Assign passed parameters
        this.scene = scene;
        this.localPlayer = localPlayer;
        this.networkManager = networkManager;
        this.soundManager = soundManager;
        
        // Initialize state variables
        this.inDuel = false;
        this.inLobby = false;
        this.duelState = 'none';
        this.duelOpponentId = null;
        this.pendingChallenge = null;
        this.duelActive = false;
        
        // Initialize nametag tracking
        this.originalLabelDisplays = new Map();
        
        // Ensure window.multiplayerManager is set
        this.ensureMultiplayerManagerAccess();
        
        // Aerial camera properties
        this.aerialCamera = null;
        this.aerialCameraAngle = 0;
        this.aerialCameraActive = false;
        this.aerialCameraPathSet = false;
        this.originalCamera = null;
        
        // Flag to track when player is in death/kill animation
        this.inDeathOrKillAnimation = false;
        
        // Create UI elements
        this.createUI();
        
        // Detect mobile devices if not already set
        if (window.isMobileDevice === undefined) {
            window.isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Initialize mouse tracking for right-click detection
        if (!window.mouseDown) {
            window.mouseDown = { left: false, right: false };
            
            document.addEventListener('mousedown', (event) => {
                if (event.button === 0) {
                    window.mouseDown.left = true;
                } else if (event.button === 2) {
                    window.mouseDown.right = true;
                }
            });
            
            document.addEventListener('mouseup', (event) => {
                if (event.button === 0) {
                    window.mouseDown.left = false;
                } else if (event.button === 2) {
                    window.mouseDown.right = false;
                }
            });
            
            // Also track when pointer leaves window
            document.addEventListener('pointerleave', () => {
                window.mouseDown.left = false;
                window.mouseDown.right = false;
            });
        }
        
        // Game state
        this.gunLocked = false;
        this.originalCanAim = true;
        // Record the time (in ms) until which the gun remains locked
        this.penaltyEndTime = 0;
        
        // Direct challenge system
        this.playerProximityRadius = 5; // 5 units radius for challenge detection
        this.nearbyPlayers = new Map(); // Map of nearby player IDs to their data
        this.challengePromptActive = false; // Whether the challenge prompt is active
        
        // Initialize physics system for collision detection
        this.physics = new PhysicsSystem();
        
        // Initialize the network handlers and challenge UI
        this.initNetworkHandlers();
        this.createUI();
        this.createChallengeUI();

        // Make this instance globally accessible for network handlers
        window.quickDraw = this;

        // Third-person model for local player (only visible during aerial view)
        this.localPlayerModel = null;

        // Initialize collections
        this.outgoingChallenges = new Map(); // Track outgoing challenges by playerId
        this.inviteCooldowns = new Map(); // Track cooldowns for accepted invites
    }
    
    /**
     * Create UI elements for Quick Draw game mode.
     */
    createUI() {
        // Text overlay for messages
        this.messageOverlay = document.createElement('div');
        this.messageOverlay.id = 'quick-draw-message';
        this.messageOverlay.style.position = 'absolute';
        this.messageOverlay.style.top = '50%';
        this.messageOverlay.style.left = '50%';
        this.messageOverlay.style.transform = 'translate(-50%, -50%)';
        this.messageOverlay.style.color = 'white';
        this.messageOverlay.style.fontSize = '48px';
        this.messageOverlay.style.fontWeight = 'bold';
        this.messageOverlay.style.textAlign = 'center';
        this.messageOverlay.style.display = 'none';
        this.messageOverlay.style.fontFamily = 'Western, Arial, sans-serif';
        this.messageOverlay.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
        this.messageOverlay.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(this.messageOverlay);
        
        // Draw circle animation
        this.drawCircle = document.createElement('div');
        this.drawCircle.id = 'draw-circle';
        this.drawCircle.style.position = 'absolute';
        this.drawCircle.style.top = '50%';
        this.drawCircle.style.left = '50%';
        this.drawCircle.style.transform = 'translate(-50%, -50%) scale(0)';
        this.drawCircle.style.width = '600px';
        this.drawCircle.style.height = '600px';
        this.drawCircle.style.borderRadius = '50%';
        this.drawCircle.style.border = '8px solid #FF0000';
        this.drawCircle.style.boxShadow = '0 0 20px #FF0000';
        this.drawCircle.style.opacity = '0';
        this.drawCircle.style.transition = 'transform 0.3s, opacity 0.3s';
        this.drawCircle.style.pointerEvents = 'none';
        this.drawCircle.style.zIndex = '999';
        this.drawCircle.style.display = 'none';
        document.getElementById('game-container').appendChild(this.drawCircle);
        
        // Add status indicator
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.id = 'quick-draw-status';
        this.statusIndicator.style.position = 'absolute';
        this.statusIndicator.style.top = '120px';
        this.statusIndicator.style.left = '20px';
        this.statusIndicator.style.color = 'white';
        this.statusIndicator.style.fontSize = '16px';
        this.statusIndicator.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.statusIndicator.style.padding = '5px';
        this.statusIndicator.style.borderRadius = '5px';
        this.statusIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.statusIndicator);
        
        // Health bar container
        this.healthBarContainer = document.createElement('div');
        this.healthBarContainer.id = 'health-bar-container';
        this.healthBarContainer.style.position = 'absolute';
        this.healthBarContainer.style.top = '20px';
        this.healthBarContainer.style.left = '50%';
        this.healthBarContainer.style.transform = 'translateX(-50%)';
        this.healthBarContainer.style.width = '300px';
        this.healthBarContainer.style.height = '30px';
        this.healthBarContainer.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.healthBarContainer.style.borderRadius = '5px';
        this.healthBarContainer.style.padding = '5px';
        this.healthBarContainer.style.display = 'none';
        this.healthBarContainer.style.zIndex = '1000';
        
        // Health bar
        this.healthBar = document.createElement('div');
        this.healthBar.id = 'health-bar';
        this.healthBar.style.width = '100%';
        this.healthBar.style.height = '100%';
        this.healthBar.style.backgroundColor = '#00FF00';
        this.healthBar.style.borderRadius = '3px';
        this.healthBar.style.transition = 'width 0.3s ease-in-out';
        
        // Health text
        this.healthText = document.createElement('div');
        this.healthText.id = 'health-text';
        this.healthText.style.position = 'absolute';
        this.healthText.style.top = '50%';
        this.healthText.style.left = '50%';
        this.healthText.style.transform = 'translate(-50%, -50%)';
        this.healthText.style.color = 'white';
        this.healthText.style.fontSize = '14px';
        this.healthText.style.fontWeight = 'bold';
        this.healthText.style.textShadow = '1px 1px 2px black';
        this.healthText.textContent = '100 HP';
        
        // Assemble health bar
        this.healthBarContainer.appendChild(this.healthBar);
        this.healthBarContainer.appendChild(this.healthText);
        document.getElementById('game-container').appendChild(this.healthBarContainer);
    }
    
    /**
     * Create UI elements specific to the direct challenge system
     */
    createChallengeUI() {
        // Challenge prompt - shown when near another player
        this.challengePrompt = document.createElement('div');
        this.challengePrompt.id = 'quick-draw-challenge-prompt';
        this.challengePrompt.style.position = 'absolute';
        this.challengePrompt.style.bottom = '20%';
        this.challengePrompt.style.left = '50%';
        this.challengePrompt.style.transform = 'translate(-50%, 0) rotate(-2deg)';
        this.challengePrompt.style.width = '350px';
        this.challengePrompt.style.height = '100px';
        this.challengePrompt.style.background = 'url("/textures/wooden_sign.png") no-repeat center center';
        this.challengePrompt.style.backgroundSize = 'contain';
        this.challengePrompt.style.display = 'flex';
        this.challengePrompt.style.alignItems = 'center';
        this.challengePrompt.style.justifyContent = 'center';
        this.challengePrompt.style.zIndex = '1000';
        
        const promptText = document.createElement('div');
        promptText.textContent = 'Press E to DUEL';
        promptText.style.fontFamily = 'Western, "Wanted M54", serif';
        promptText.style.fontSize = '28px';
        promptText.style.fontWeight = 'bold';
        promptText.style.color = '#FFD700';
        promptText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        
        this.challengePrompt.appendChild(promptText);
        document.getElementById('game-container').appendChild(this.challengePrompt);
        this.challengePrompt.style.display = 'none'; // Hide initially
        
        // Add gentle swing animation
        const promptAnimation = document.createElement('style');
        promptAnimation.textContent = `
            @keyframes prompt-swing {
                0% { transform: translate(-50%, 0) rotate(-2deg); }
                50% { transform: translate(-50%, 0) rotate(1deg); }
                100% { transform: translate(-50%, 0) rotate(-2deg); }
            }
            #quick-draw-challenge-prompt {
                animation: prompt-swing 3s ease-in-out infinite;
            }
        `;
        document.head.appendChild(promptAnimation);
        
        // Add responsive styles for the invitation panel
        const inviteStyles = document.createElement('style');
        inviteStyles.textContent = `
            @media screen and (max-width: 768px) {
                #quick-draw-invitation {
                    width: 90% !important;
                    height: auto !important;
                    aspect-ratio: 500/333;
                }
            }
        `;
        document.head.appendChild(inviteStyles);
        
        // Create the invitation panel - just using the image
        this.challengeInvitation = document.createElement('div');
        this.challengeInvitation.id = 'quick-draw-invitation';
        this.challengeInvitation.style.position = 'absolute';
        this.challengeInvitation.style.top = '50%';
        this.challengeInvitation.style.left = '50%';
        this.challengeInvitation.style.transform = 'translate(-50%, -50%)';
        this.challengeInvitation.style.width = '500px';
        this.challengeInvitation.style.height = '333px';
        this.challengeInvitation.style.background = 'url("/models/invitepanel.png") no-repeat center center';
        this.challengeInvitation.style.backgroundSize = 'contain';
        this.challengeInvitation.style.zIndex = '1100';
        this.challengeInvitation.style.display = 'none'; // Hide initially
        
        document.getElementById('game-container').appendChild(this.challengeInvitation);
        
        // Add keyboard event listener for challenge interactions
        document.addEventListener('keydown', (event) => this.handleChallengeKeypress(event));
    }
    
    /**
     * Handle keypresses for the challenge system
     * @param {KeyboardEvent} event - The keyboard event
     */
    handleChallengeKeypress(event) {
        // Skip if not in game or if player is in lobby/duel
        if (!this.localPlayer || this.inLobby || this.inDuel) return;
        
        // Remove excessive key press logging
        
        switch (event.code) {
            case 'KeyE':
                // Send challenge when near a player
                if (this.challengePromptActive) {
                    console.log('[QuickDraw] E key pressed - sending challenge');
                    this.sendChallenge();
                }
                break;
                
            case 'Enter':
            case 'NumpadEnter': // Also handle numpad enter
                // Accept invitation
                if (this.pendingChallenge) {
                    console.log('[QuickDraw] Enter key pressed - accepting challenge');
                    this.acceptChallenge();
                }
                break;
                
            case 'KeyT':
                // Decline invitation
                if (this.pendingChallenge) {
                    console.log('[QuickDraw] T key pressed - declining challenge');
                    this.declineChallenge();
                }
                break;
        }
    }
    
    /**
     * Initialize network handlers for Quick Draw game mode.
     */
    initNetworkHandlers() {
        if (!this.networkManager || !this.networkManager.socket) return;
        
        // Methods for direct challenges and server communication
        this.networkManager.sendQuickDrawChallenge = (targetPlayerId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawChallenge',
                    targetPlayerId: targetPlayerId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawAccept = (challengerId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawAccept',
                    challengerId: challengerId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawDecline = (challengerId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawDecline',
                    challengerId: challengerId
                }));
            }
        };
        
        this.networkManager.sendQuickDrawShoot = (opponentId, arenaIndex, hitZone = 'body', damage = 40, hitDetected = false) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                // Use logger instead of console.log
                if (window.logger) {
                    window.logger.debug(`Sending Quick Draw hit notification to server: player ${this.localPlayer.id} hit player ${opponentId} in the ${hitZone} for ${damage} damage`);
                }
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawShoot',
                    opponentId: opponentId,
                    arenaIndex: arenaIndex,
                    hitZone: hitZone,
                    damage: damage,
                    hitDetected: hitDetected // Add this flag to let server know a hit was properly detected
                }));
            }
        };
        
        this.networkManager.sendQuickDrawReady = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawReady'
                }));
            }
        };
        
        this.networkManager.sendQuickDrawPenalty = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawPenalty'
                }));
            }
        };
        
        // Hook into the existing socket onmessage handler
        const originalOnMessage = this.networkManager.socket.onmessage;
        this.networkManager.socket.onmessage = (event) => {
            // Call original handler
            if (originalOnMessage) {
                originalOnMessage(event);
            }
            
            try {
                const message = JSON.parse(event.data);
                
                // Debug log for QuickDraw related messages
                if (message.type && message.type.startsWith('quickDraw')) {
                    console.log(`[QuickDraw] Received message: ${message.type}`, message);
                }
                
                // Handle Quick Draw specific messages
                switch (message.type) {
                    case 'quickDrawMatchFound':
                    case 'quickDrawMatch':  // Handle both formats for compatibility
                        console.log('[QuickDraw] Match found!', message);
                        this.handleMatchFound(message);
                        
                        // Clear any pending challenge since we're now in a match
                        this.pendingChallenge = null;
                        break;
                        
                    case 'quickDrawReady':
                        console.log('[QuickDraw] Ready signal received');
                        this.showReadyMessage();
                        break;
                        
                    case 'quickDrawCountdown':
                        console.log('[QuickDraw] Countdown signal received');
                        this.handleCountdown(message);
                        break;
                        
                    case 'quickDrawDraw':
                        console.log('[QuickDraw] Received DRAW command from server');
                        
                        // Set duel state to draw phase
                        this.duelState = 'draw';
                        
                        // Stop any countdown timer
                        if (this._countdownInterval) {
                            clearInterval(this._countdownInterval);
                            this._countdownInterval = null;
                        }
                        
                        // CRITICAL: Enable player aiming to allow drawing weapon
                        if (this.localPlayer) {
                            console.log('[QuickDraw] Enabling player aiming for draw phase');
                            this.localPlayer.canAim = true;
                        }
                        
                        // Switch to first person view (emergency direct camera switch)
                        if (this.localPlayer && this.localPlayer.camera) {
                            // Force camera to player's view
                            if (this.scene && this.scene.renderer) {
                                this.scene.renderer.camera = this.localPlayer.camera;
                                this.scene.renderer.overrideCamera = null;
                            }
                        }
                        
                        // Ensure gun is visible but holstered
                        if (this.localPlayer && this.localPlayer.viewmodel) {
                            // Make gun visible
                            this.localPlayer.viewmodel.visible = true;
                            
                            // Update gun state (without forcing aiming to false)
                            if (this.localPlayer.currentGunOffset && this.localPlayer.holsterOffset && !this.localPlayer.isAiming) {
                                this.localPlayer.currentGunOffset.copy(this.localPlayer.holsterOffset);
                            }
                        }
                        
                        // Hide local player model in first person
                        if (this.localPlayerModel && this.localPlayerModel.group) {
                            this.localPlayerModel.group.visible = false;
                        }
                        
                        // Play eagle scream for the draw command
                        if (this.soundManager) {
                            this.soundManager.playSound("eaglescream", 0, 1.0);
                        }
                        
                        // Check hit zones for proper detection
                        this.fixHitZonesForQuickDraw();
                        
                        break;
                        
                    case 'quickDrawKill':
                        this.handleKill(message);
                        break;
                        
                    case 'quickDrawDeath':
                        this.handleDeath(message);
                        break;
                        
                    case 'quickDrawResult':
                    case 'quickDrawEnd':  // Handle both formats for compatibility
                        this.handleResult(message);
                        break;
                        
                    case 'respawn':
                        // Handle server-initiated respawn after quickdraw match
                        console.log('[QuickDraw] Received respawn message from server');
                        
                        if (this.localPlayer) {
                            // Set player position from server
                            if (message.position) {
                                this.localPlayer.group.position.set(
                                    message.position.x,
                                    message.position.y,
                                    message.position.z
                                );
                                console.log(`[QuickDraw] Player respawned at server position: (${message.position.x.toFixed(2)}, ${message.position.y.toFixed(2)}, ${message.position.z.toFixed(2)})`);
                            }
                            
                            // Set active weapon if provided by server
                            if (message.activeWeapon && (message.activeWeapon === 'revolver' || message.activeWeapon === 'shotgun')) {
                                // Only switch if different from current
                                if (this.localPlayer.activeWeapon !== message.activeWeapon) {
                                    this.localPlayer.switchWeapon(message.activeWeapon);
                                }
                            }
                            
                            // Reset all weapon ammo to maximum
                            this.localPlayer.weaponAmmo = {
                                revolver: this.localPlayer.weaponStats.revolver.maxBullets,
                                shotgun: this.localPlayer.weaponStats.shotgun.maxBullets
                            };
                            
                            // Set the active weapon's bullet count
                            this.localPlayer.bullets = this.localPlayer.weaponAmmo[this.localPlayer.activeWeapon];
                            this.localPlayer.maxBullets = this.localPlayer.weaponStats[this.localPlayer.activeWeapon].maxBullets;
                            
                            // Cancel any ongoing reloading
                            if (this.localPlayer.isReloading) {
                                // Cancel reload animation
                                if (this.localPlayer.viewmodel) {
                                    this.localPlayer.viewmodel.cancelReload();
                                }
                                
                                // Hide reload UI elements
                                const reloadProgressContainer = document.getElementById('reload-progress-container');
                                if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
                            }
                            
                            // Reset health
                            this.localPlayer.health = message.health || 100;
                            
                            // Reset states
                            this.localPlayer.isReloading = false;
                            this.localPlayer.isAiming = false;
                            this.localPlayer.velocity.y = 0;
                            this.localPlayer.canAim = true;
                            this.localPlayer.canMove = true;
                            this.localPlayer.canShoot = true;
                            
                            // Update UI
                            if (typeof updateHealthUI === 'function') {
                                updateHealthUI(this.localPlayer);
                            }
                            
                            if (typeof updateAmmoUI === 'function') {
                                updateAmmoUI(this.localPlayer);
                            }
                            
                            console.log(`[QuickDraw] Respawn complete - Current weapon: ${this.localPlayer.activeWeapon}, Ammo: ${this.localPlayer.bullets}/${this.localPlayer.maxBullets}`);
                        }
                        
                        // Ensure we're not in a duel state
                        this.inDuel = false;
                        this.inLobby = false;
                        this.duelState = 'none';
                        this.duelActive = false;
                        break;
                        
                    case 'fullStateReset':
                        // New comprehensive server-directed reset 
                        console.log('[QuickDraw] Received full state reset command from server');
                        this.resetPlayerAndRespawn(message);
                        break;
                        
                    case 'quickDrawChallengeReceived':
                        this.handleChallengeReceived(message);
                        break;
                        
                    case 'quickDrawChallengeAccepted':
                        this.handleChallengeAccepted(message);
                        break;
                        
                    case 'quickDrawChallengeDeclined':
                        this.handleChallengeDeclined(message);
                        break;
                    
                    case 'quickDrawAccepted':
                    case 'quickDrawAccept':
                        // Handle server confirmation of challenge acceptance
                        console.log('[QuickDraw] Challenge acceptance confirmed by server');
                        // The match will be set up by the server and we'll receive a matchFound message
                        break;
                        
                    case 'debug':
                        // Display debug messages from server
                        console.log(`[DEBUG] Server message: ${message.message}`);
                        // Show on-screen for easier debugging
                        if (message.message.includes('hit detection')) {
                            this.showMessage(`DEBUG: ${message.message}`, 3000, '#ff9900');
                        }
                        break;
                        
                    case 'quickDrawMiss':
                        // Handle explicit miss notifications
                        console.log(`[QuickDraw] Player ${message.playerId} missed shot at player ${message.targetId}`);
                        // No visual feedback for misses per user request
                        break;
                        
                    case 'playerHealthUpdate':
                        // Only handle playerHealthUpdate if we're in a duel and it's related to us
                        if (this.inDuel && 
                            (message.playerId === this.localPlayer.id || message.playerId === this.duelOpponentId)) {
                            
                            // Initialize health update tracking if it doesn't exist
                            if (!this.healthUpdateTracking) {
                                this.healthUpdateTracking = new Map();
                            }
                            
                            // Create a unique ID for this health update to prevent duplicates
                            const updateId = `${message.playerId}_${message.health}_${Date.now()}`;
                            
                            // Update own health if it's us
                            if (message.playerId === this.localPlayer.id) {
                                // Update both the local player's health and the health bar
                                this.localPlayer.health = message.health;
                                this.updateHealthBar(message.health);
                                
                                // Show hit feedback if damaged
                                if (message.damage > 0) {
                                    this.showHitFeedback(message.damage);
                                }
                                
                                // Also update the main UI health display
                                if (typeof updateHealthUI === 'function') {
                                    updateHealthUI(this.localPlayer);
                                }
                                
                                console.log(`[QuickDraw] Health updated: ${message.health}`);
                                
                                // If player health is 0, play death animation for local player
                                if (message.health <= 0) {
                                    // Make sure we have a local player model for death animation
                                    if (!this.localPlayerModel) {
                                        this.createLocalPlayerModel();
                                    }
                                    
                                    // Ensure local player model is visible in aerial view
                                    if (this.localPlayerModel) {
                                        this.setupAndEnableAerialCamera();
                                        this.localPlayerModel.group.visible = true;
                                        
                                        // Play the death animation
                                        if (this.localPlayerModel.playDeathAnimation) {
                                            console.log('[QuickDraw] Playing death animation for local player');
                                            const deathResult = this.localPlayerModel.playDeathAnimation();
                                            
                                            // Disable player controls during death animation
                                            if (this.localPlayer) {
                                                this.localPlayer.canMove = false;
                                                this.localPlayer.canAim = false;
                                                this.localPlayer.forceLockMovement = true;
                                            }
                                        }
                                    }
                                }
                            }
                            // Update opponent's health if needed (could be extended for UI)
                            else if (message.playerId === this.duelOpponentId) {
                                // Could update opponent health bar if we had one
                                console.log(`[QuickDraw] Opponent health updated: ${message.health}`);
                                
                                // If opponent health is 0, mark them as dying to trigger death animation
                                if (message.health <= 0) {
                                    // Find opponent in the otherPlayers map
                                    const opponentPlayer = this.networkManager.otherPlayers.get(this.duelOpponentId);
                                    if (opponentPlayer) {
                                        // Set the dying flag to trigger death animation
                                        opponentPlayer.isDying = true;
                                        
                                        // Find the remote player model if it exists
                                        if (this.scene.remotePlayerModels) {
                                            const opponentModel = this.scene.remotePlayerModels.get(this.duelOpponentId);
                                            if (opponentModel && opponentModel.playDeathAnimation) {
                                                console.log(`[QuickDraw] Playing death animation for remote player ${this.duelOpponentId}`);
                                                opponentModel.playDeathAnimation();
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Track this update to prevent duplicates
                            this.healthUpdateTracking.set(updateId, Date.now());
                            
                            // Clean up old health updates (older than 1 second)
                            const now = Date.now();
                            for (const [id, timestamp] of this.healthUpdateTracking.entries()) {
                                if (now - timestamp > 1000) {
                                    this.healthUpdateTracking.delete(id);
                                }
                            }
                        }
                        break;
                }
            } catch (err) {
                console.error('[QuickDraw] Error parsing message:', err);
            }
        };
    }

    /**
     * Updates the list of nearby players for challenge feature
     */
    updateNearbyPlayers() {
        // Skip if in duel or lobby already
        if (this.inDuel || this.inLobby || this.pendingChallenge) return;
        
        const playerPos = this.localPlayer.group.position.clone();
        this.nearbyPlayers.clear();
        this.challengePromptActive = false;
        
        // Check if any other players are within the challenge radius
        if (this.networkManager && this.networkManager.otherPlayers) {
            for (const [playerId, playerData] of this.networkManager.otherPlayers) {
                // Skip NPCs - don't allow dueling with them
                // First make sure playerId is a string before using string methods
                if (playerData.isNpc === true || 
                    (typeof playerId === 'string' && playerId.startsWith('npc_'))) {
                    continue;
                }
                
                // Skip players who are in a quick draw already or don't have position
                if (!playerData.position || playerData.quickDrawLobbyIndex >= 0 || 
                    playerData.inQuickDrawDuel) continue;
                
                // Calculate distance to player
                const otherPos = new THREE.Vector3(
                    playerData.position.x,
                    playerData.position.y,
                    playerData.position.z
                );
                
                const distance = playerPos.distanceTo(otherPos);
                
                // If within challenge radius, add to nearby players
                if (distance <= this.playerProximityRadius) {
                    this.nearbyPlayers.set(playerId, {
                        id: playerId,
                        distance: distance,
                        position: otherPos
                    });
                    
                    this.challengePromptActive = true;
                }
            }
        }
        
        // Update UI based on nearby players
        this.updateChallengeUI();
    }

    /**
     * Updates the UI based on nearby players
     */
    updateChallengeUI() {
        // Skip if in duel, lobby, or if there's a pending challenge
        if (this.inDuel || this.inLobby || this.pendingChallenge) {
            // Hide challenge prompt
            this.challengePrompt.style.display = 'none';
            this.challengeUIVisible = false;
            
            // Also hide invite button on mobile
            if (window.mobileControls && typeof window.mobileControls.checkForNearbyPlayers === 'function') {
                window.mobileControls.checkForNearbyPlayers(false);
            }
            return;
        }
        
        // Update UI based on whether there are nearby players
        if (this.challengePromptActive && !this.challengeUIVisible) {
            this.challengePrompt.style.display = 'flex'; // Use flex instead of block
            this.challengeUIVisible = true;
            
            // Also show invite button on mobile
            if (window.mobileControls && typeof window.mobileControls.checkForNearbyPlayers === 'function') {
                window.mobileControls.checkForNearbyPlayers(true);
            }
        } else if (!this.challengePromptActive && this.challengeUIVisible) {
            this.challengePrompt.style.display = 'none';
            this.challengeUIVisible = false;
            
            // Also hide invite button on mobile
            if (window.mobileControls && typeof window.mobileControls.checkForNearbyPlayers === 'function') {
                window.mobileControls.checkForNearbyPlayers(false);
            }
        }
    }

    /**
     * Send a challenge to the nearest player
     */
    sendChallenge() {
        if (this.nearbyPlayers.size === 0) return;
        
        // Find the nearest player
        let nearestPlayerId = null;
        let nearestDistance = Infinity;
        
        for (const [playerId, data] of this.nearbyPlayers) {
            if (data.distance < nearestDistance) {
                nearestDistance = data.distance;
                nearestPlayerId = playerId;
            }
        }
        
        if (nearestPlayerId) {
            // Check if there's an active outgoing invite to this player
            if (this.outgoingChallenges.has(nearestPlayerId)) {
                console.log(`[QuickDraw] Already sent challenge to player ${nearestPlayerId}, waiting for response`);
                return;
            }
            
            // Check if this player is on cooldown from a previous invite
            if (this.inviteCooldowns.has(nearestPlayerId)) {
                const cooldownEndTime = this.inviteCooldowns.get(nearestPlayerId);
                if (Date.now() < cooldownEndTime) {
                    console.log(`[QuickDraw] This player is on cooldown for ${Math.ceil((cooldownEndTime - Date.now()) / 1000)}s`);
                    return;
                } else {
                    // Cooldown is over, remove it
                    this.inviteCooldowns.delete(nearestPlayerId);
                }
            }
            
            // Hide the challenge prompt
            this.challengePrompt.style.display = 'none';
            this.challengeUIVisible = false;
            
            // Track this outgoing challenge
            this.outgoingChallenges.set(nearestPlayerId, Date.now());
            
            // Send challenge to server
            this.networkManager.sendQuickDrawChallenge(nearestPlayerId);
            
            console.log(`Quick Draw challenge sent to player ${nearestPlayerId}`);
        }
    }

    /**
     * Handle receiving a challenge from another player
     * @param {Object} message - The challenge message
     */
    handleChallengeReceived(message) {
        console.log('[QuickDraw] Challenge received from player', message.challengerId);
        
        if (this.inDuel || this.inLobby) {
            console.log('[QuickDraw] Already in duel or lobby, automatically declining');
            // Automatically decline if already in a duel or lobby
            this.networkManager.sendQuickDrawDecline(message.challengerId);
            return;
        }
        
        // Store the pending challenge
        this.pendingChallenge = {
            challengerId: message.challengerId,
            challengerPosition: message.challengerPosition
        };
        
        // Explicitly hide the "Press E to Duel" challenge prompt
        this.challengePrompt.style.display = 'none';
        this.challengeUIVisible = false;
        
        // Show mobile quick draw invite UI if on mobile
        if (window.mobileControls && typeof window.mobileControls.showQuickdrawInvite === 'function') {
            window.mobileControls.showQuickdrawInvite();
        } else {
            // Show the challenge invitation for desktop
            this.challengeInvitation.style.display = 'block';
        }
        
        // Play notification sound
        if (this.soundManager) {
            this.soundManager.playSound("bellstart");
        }
        
        console.log(`Received Quick Draw challenge from player ${message.challengerId}`);
    }

    /**
     * Accept a pending challenge
     */
    acceptChallenge() {
        if (!this.pendingChallenge) return;
        
        // Hide the invitation
        this.challengeInvitation.style.display = 'none';
        
        // Hide mobile invite buttons if on mobile
        if (window.mobileControls && typeof window.mobileControls.hideQuickdrawInvite === 'function') {
            window.mobileControls.hideQuickdrawInvite();
        }
        
        // Hide the challenge prompt if visible
        this.challengePrompt.style.display = 'none';
        this.challengeUIVisible = false;
        this.challengePromptActive = false;
        
        // Store challenger id before clearing
        const challengerId = this.pendingChallenge.challengerId;
        
        // Send acceptance to server
        this.networkManager.sendQuickDrawAccept(challengerId);
        
        console.log(`Accepted Quick Draw challenge from player ${challengerId}`);
        
        // Log that we're waiting for match details
        console.log('Waiting for server to set up the duel...');
    }

    /**
     * Decline a pending challenge
     */
    declineChallenge() {
        if (!this.pendingChallenge) return;
        
        // Hide the invitation
        this.challengeInvitation.style.display = 'none';
        
        // Hide mobile invite buttons if on mobile
        if (window.mobileControls && typeof window.mobileControls.hideQuickdrawInvite === 'function') {
            window.mobileControls.hideQuickdrawInvite();
        }
        
        // Send decline to server
        this.networkManager.sendQuickDrawDecline(this.pendingChallenge.challengerId);
        
        // Clear the pending challenge
        this.pendingChallenge = null;
    }

    /**
     * Handle challenge accepted by other player
     * @param {Object} message - The acceptance message
     */
    handleChallengeAccepted(message) {
        console.log(`Player ${message.targetId} accepted your Quick Draw challenge`);
        
        // Remove from outgoing challenges
        this.outgoingChallenges.delete(message.targetId);
        
        // Add a cooldown of 3 seconds after accepting
        this.inviteCooldowns.set(message.targetId, Date.now() + 3000);
        
        // Wait for server to respond with match details
    }

    /**
     * Handle challenge declined by other player
     * @param {Object} message - The decline message
     */
    handleChallengeDeclined(message) {
        console.log(`Player ${message.targetId} declined your Quick Draw challenge`);
        
        // Remove from outgoing challenges
        this.outgoingChallenges.delete(message.targetId);
    }

    /**
     * Show the "READY?" message with enhanced typography.
     */
    showReadyMessage() {
        this.duelState = 'ready';
        this.updateStatusIndicator();
        
        // Set a timer to play sound only
        if (this.soundManager) {
            this.soundManager.playSound("bellcountdown", 0.7);
        }
    }

    /**
     * Start the countdown phase of the duel.
     */
    startDuelCountdown() {
        this.duelState = 'countdown';
        this.updateStatusIndicator();
        this.hideMessage();
        
        // Explicitly disable aiming during countdown
        this.localPlayer.canAim = false;
        
        // Hide all player nametags during the duel
        this.hidePlayerNametags();
        
        // Only set up aerial camera if it's not already active
        // This prevents the camera path from changing after the match starts
        if (!this.aerialCameraActive) {
            // Create and switch to aerial camera 
            this.setupAndEnableAerialCamera();
        }
        
        console.log('Duel countdown started - waiting for draw signal');
    }

    /**
     * Setup and immediately enable the aerial camera
     */
    setupAndEnableAerialCamera() {
        // Create aerial camera if it doesn't exist
        if (!this.aerialCamera) {
            this.aerialCamera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            this.scene.add(this.aerialCamera);
        }
        
        // Create local player model if it doesn't exist
        this.setupLocalPlayerModel();
        
        // Save the current camera for later restoration
        if (this.localPlayer && this.localPlayer.camera) {
            this.originalCamera = this.localPlayer.camera;
            
            // Clear any direct override flags
            this._directCameraOverride = false;
        } else {
            console.warn('Cannot save original camera - local player camera not available');
        }
        
        // Set up the flight path for the quickdraw match
        if (window.flyingEagle) {
            // Wait until both players have properly spawned
            // This ensures we get the correct positions after the quickdraw spawn
            setTimeout(() => {
                // Get player positions to determine the center of the duel
                const player1Pos = this.localPlayer.group.position.clone();
                const player2Pos = this.getOpponentPosition();
                let duelCenter;
                
                if (player2Pos) {
                    // Calculate midpoint between players for eagle's circular path center
                    duelCenter = new THREE.Vector3(
                        (player1Pos.x + player2Pos.x) / 2,
                        (player1Pos.y + player2Pos.y) / 2,
                        (player1Pos.z + player2Pos.z) / 2
                    );
                    
                    // Calculate distance between players for flight radius
                    const distanceBetweenPlayers = player1Pos.distanceTo(player2Pos);
                    
                    // Use the new method to set a closer flight path for quickdraw
                    window.flyingEagle.setQuickdrawFlightPath(duelCenter, distanceBetweenPlayers);
                    
                    console.log('Eagle quickdraw flight path set - closer to players for cinematic view');
                    console.log(`Duel center: (${duelCenter.x.toFixed(2)}, ${duelCenter.y.toFixed(2)}, ${duelCenter.z.toFixed(2)})`);
                    console.log(`Player1: (${player1Pos.x.toFixed(2)}, ${player1Pos.y.toFixed(2)}, ${player1Pos.z.toFixed(2)})`);
                    console.log(`Player2: (${player2Pos.x.toFixed(2)}, ${player2Pos.y.toFixed(2)}, ${player2Pos.z.toFixed(2)})`);
                    console.log(`Distance between players: ${distanceBetweenPlayers.toFixed(2)}`);
                    
                    this.aerialCameraPathSet = true;
                } else {
                    console.warn('Cannot find opponent position - using fallback camera position');
                    
                    // Fallback - position camera around local player only
                    duelCenter = player1Pos.clone();
                    
                    // Setup the eagle's circular flight path around the player
                    window.flyingEagle.setQuickdrawFlightPath(duelCenter, 10); // Default small distance for single player
                    
                    console.log('Eagle quickdraw flight path set to fallback position');
                    this.aerialCameraPathSet = true;
                }
            }, 250); // Small delay to ensure players are in position
            
            // Use the aerial camera as the eagle's POV camera
            window.flyingEagle.camera = this.aerialCamera;
            window.flyingEagle.activateAerialCamera();
        }
        
        // DIRECT SWITCH: Set the renderer's camera directly to aerial
        if (window.renderer) {
            window.renderer.camera = this.aerialCamera;
            
            // Also set the instance camera if available
            if (window.renderer.instance) {
                window.renderer.instance.camera = this.aerialCamera;
                
                // Force a render
                window.renderer.instance.render(this.scene, this.aerialCamera);
            }
        }
        
        // Show local player model
        if (this.localPlayerModel && !this.localPlayerModel.loading) {
            this.localPlayerModel.group.visible = true;
        }
        
        this.aerialCameraActive = true;
        
        console.log('Eagle POV aerial camera enabled for duel countdown');
    }

    /**
     * Position the aerial camera to focus on both players
     */
    positionAerialCamera() {
        if (!this.aerialCamera) return;
        
        // Get player positions
        const player1Pos = this.localPlayer.group.position.clone();
        const player2Pos = this.getOpponentPosition();
        
        if (!player2Pos) {
            console.warn('Cannot find opponent position - using fallback camera position');
            
            // Fallback - position camera around local player only
            const cameraX = player1Pos.x + Math.cos(this.aerialCameraAngle) * 10;
            const cameraZ = player1Pos.z + Math.sin(this.aerialCameraAngle) * 10;
            
            this.aerialCamera.position.set(
                cameraX,
                player1Pos.y + 7, // Higher position to see more of the scene
                cameraZ
            );
            
            // Look at the player
            this.aerialCamera.lookAt(player1Pos);
            return;
        }
        
        // Calculate midpoint between players
        const midpoint = new THREE.Vector3(
            (player1Pos.x + player2Pos.x) / 2,
            (player1Pos.y + player2Pos.y) / 2,
            (player1Pos.z + player2Pos.z) / 2
        );
        
        // Calculate distance between players to scale camera positioning
        const distanceBetweenPlayers = player1Pos.distanceTo(player2Pos);
        
        // Set camera height based on distance (more distance = higher camera)
        const cameraHeight = Math.max(5, distanceBetweenPlayers * 0.5);
        
        // Set camera distance from midpoint based on player distance
        const cameraDistance = Math.max(10, distanceBetweenPlayers * 1.2);
        
        // Camera position along the circle
        const cameraX = midpoint.x + Math.cos(this.aerialCameraAngle) * cameraDistance;
        const cameraZ = midpoint.z + Math.sin(this.aerialCameraAngle) * cameraDistance;
        
        // Position camera
        this.aerialCamera.position.set(
            cameraX,
            midpoint.y + cameraHeight,
            cameraZ
        );
        
        // Look at midpoint
        this.aerialCamera.lookAt(midpoint);
        
        // Log camera positioning for debugging
        if (this.aerialCameraActive && Math.random() < 0.01) { // Only log occasionally to avoid spam
            console.log(`Aerial camera: pos(${cameraX.toFixed(1)}, ${(midpoint.y + cameraHeight).toFixed(1)}, ${cameraZ.toFixed(1)}) looking at (${midpoint.x.toFixed(1)}, ${midpoint.y.toFixed(1)}, ${midpoint.z.toFixed(1)})`);
        }
    }

    /**
     * Update aerial camera rotation and positioning
     * @param {number} deltaTime - Time elapsed since last frame
     */
    updateAerialCamera(deltaTime) {
        if (!this.aerialCameraActive || !this.aerialCamera) return;
        
        // We no longer need to position the camera manually
        // since the eagle controls its own path and the camera follows it
        
        // Update local player model if it exists
        if (this.localPlayerModel) {
            this.updateLocalPlayerModel();
            
            // Ensure animations are running on the model
            if (this.localPlayerModel.animationMixer) {
                this.localPlayerModel.animationMixer.update(deltaTime);
            }
        }
    }

    /**
     * Setup the local player model for third-person view
     */
    setupLocalPlayerModel() {
        // If model already exists, make it visible and update it
        if (this.localPlayerModel && !this.localPlayerModel.loading) {
            // Only set visibility if group exists
            if (this.localPlayerModel.group) {
                this.localPlayerModel.group.visible = true;
            } else {
                console.warn('Local player model exists but group is undefined');
            }
            this.updateLocalPlayerModel();
            return;
        }
        
        // Load ThirdPersonModel if not available
        if (!window.ThirdPersonModel) {
            console.log('Loading ThirdPersonModel module...');
            // First set a placeholder to prevent duplicated loading
            this.localPlayerModel = { loading: true };
            
            import('./playerModel.js').then(module => {
                window.ThirdPersonModel = module.ThirdPersonModel;
                this.createLocalPlayerModel();
            }).catch(error => {
                console.error('Failed to load ThirdPersonModel:', error);
                this.localPlayerModel = null;
            });
        } else {
            // Create model immediately if ThirdPersonModel is available
            this.createLocalPlayerModel();
        }
    }

    /**
     * Create the local player model
     */
    createLocalPlayerModel() {
        // Skip if already created or currently loading
        if (this.localPlayerModel && !this.localPlayerModel.loading) return;
        
        if (!window.ThirdPersonModel) {
            console.error('Cannot create player model: ThirdPersonModel not available');
            return;
        }
        
        try {
            console.log('Creating local player model for aerial view');
            
            // Create the model
            this.localPlayerModel = new window.ThirdPersonModel(this.scene, this.localPlayer.id);
            
            // Check if model was created correctly
            if (!this.localPlayerModel || !this.localPlayerModel.group) {
                console.error('Failed to create player model - group not available');
                this.localPlayerModel = null;
                return;
            }
            
            // Enable debug logging for this model
            this.localPlayerModel.debug = true;
            
            // Apply player appearance if available
            if (window.playerIdentity && window.playerIdentity.appearance) {
                const appearance = window.playerIdentity.appearance;
                if (this.localPlayerModel.setSkinTone) {
                    this.localPlayerModel.setSkinTone(appearance.skinTone || '#C68642');
                }
                if (this.localPlayerModel.setClothingColor) {
                    this.localPlayerModel.setClothingColor(appearance.clothingColor || '#8B4513');
                }
            }
            
            // Add missing updateHitZones method if it doesn't exist
            if (!this.localPlayerModel.updateHitZones) {
                console.log('Adding missing updateHitZones method to localPlayerModel');
                this.localPlayerModel.updateHitZones = function() {
                    // If the model has the updateCollisionBox method, use that to update hitboxes
                    if (typeof this.updateCollisionBox === 'function') {
                        this.updateCollisionBox();
                        
                        // Ensure hitZones mapping exists and is properly updated
                        if (!this.hitZones && (this.headHitbox || this.bodyHitbox || this.limbsHitbox)) {
                            this.hitZones = {
                                head: this.headHitbox,
                                body: this.bodyHitbox,
                                legs: this.limbsHitbox
                            };
                            console.log('Created hit zones mapping from hitboxes');
                        }
                    } else if (this.hitZones) {
                        console.log('Model has hit zones - already properly setup');
                    } else {
                        console.log('Model does not have hit zones defined');
                        
                        // Create basic hitboxes if they don't exist
                        if (this.group && !this.hitZones) {
                            // Calculate bounding box from the model
                            const boundingBox = new THREE.Box3().setFromObject(this.group);
                            const size = boundingBox.getSize(new THREE.Vector3());
                            const center = boundingBox.getCenter(new THREE.Vector3());
                            
                            // Create basic hitboxes
                            this.headHitbox = new THREE.Box3(
                                new THREE.Vector3(center.x - size.x/4, center.y + size.y/4, center.z - size.x/4),
                                new THREE.Vector3(center.x + size.x/4, center.y + size.y/2, center.z + size.x/4)
                            );
                            
                            this.bodyHitbox = new THREE.Box3(
                                new THREE.Vector3(center.x - size.x/3, center.y - size.y/4, center.z - size.x/3),
                                new THREE.Vector3(center.x + size.x/3, center.y + size.y/4, center.z + size.x/3)
                            );
                            
                            this.limbsHitbox = new THREE.Box3(
                                new THREE.Vector3(center.x - size.x/3, center.y - size.y/2, center.z - size.x/3),
                                new THREE.Vector3(center.x + size.x/3, center.y - size.y/4, center.z + size.x/3)
                            );
                            
                            // Create hitZones mapping
                            this.hitZones = {
                                head: this.headHitbox,
                                body: this.bodyHitbox,
                                legs: this.limbsHitbox
                            };
                            
                            console.log('Created emergency hit zones for model without proper hitboxes');
                        }
                    }
                };
            }
            
            // Update position and play idle animation
            this.updateLocalPlayerModel(true);
            
            // Force idle animation - We need to initialize the animation properly
            if (this.localPlayerModel.playAnimation) {
                try {
                    // First make sure animations are properly initialized
                    if (this.localPlayerModel.setupAnimations && 
                        (!this.localPlayerModel.animations || Object.keys(this.localPlayerModel.animations).length === 0)) {
                        // Try to force animation setup if animations aren't loaded
                        if (window.preloadedModels && window.preloadedModels.playermodel && 
                            window.preloadedModels.playermodel.animations) {
                            this.localPlayerModel.setupAnimations(window.preloadedModels.playermodel.animations);
                        }
                    }
                    
                    // Play idle animation with immediate transition
                    this.localPlayerModel.playAnimation('idle', 0);
                    
                    // Explicitly set walking/running flags to ensure proper state
                    this.localPlayerModel.isWalking = false;
                    this.localPlayerModel.isRunning = false;
                    
                    console.log('Playing idle animation on local player model');
                } catch (animError) {
                    console.error('Error playing idle animation:', animError);
                }
            } else {
                console.warn('No playAnimation method available on player model');
            }
            
            // Make sure the model is added to the scene
            if (!this.scene.children.includes(this.localPlayerModel.group)) {
                console.log('Adding player model to scene');
                this.scene.add(this.localPlayerModel.group);
            }
            
            // Show immediately if aerial camera is active
            this.localPlayerModel.group.visible = this.aerialCameraActive;
            
            console.log('Local player model created successfully');
        } catch (error) {
            console.error('Error creating local player model:', error);
            
            // Create a minimal placeholder model to prevent further errors
            this.localPlayerModel = { 
                loading: false,
                group: new THREE.Group(),
                updateHitZones: function() {},
                playAnimation: function() {},
                hitZones: {}
            };
            
            // Add the minimal group to the scene
            this.scene.add(this.localPlayerModel.group);
            
            console.log('Created minimal placeholder model to prevent further errors');
        }
    }

    /**
     * Update local player model position to match the player's camera position.
     * @param {boolean} forceLog - Whether to force logging regardless of state changes.
     */
    updateLocalPlayerModel(forceLog = false) {
        if (!this.localPlayerModel || this.localPlayerModel.loading) return;
        
        // Get the player's current camera position
        const cameraPosition = this.localPlayer.group.position;
        
        // Position calculations
        const lastPosition = this.localPlayerModel.group ? 
            this.localPlayerModel.group.position.clone() : new THREE.Vector3();
        
        // Create position with the Y-offset correction to ensure feet touch ground
        const correctedPosition = cameraPosition.clone();
        
        // Always use consistent offset of 2.72 for proper ground alignment
        correctedPosition.y -= 2.72;
        
        if (this.debug && this.inDuel) {
            console.log(`[QuickDraw DEBUG] Positioning player model: camera at ${cameraPosition.y.toFixed(2)}, feet at ${correctedPosition.y.toFixed(2)}`);
        }
        
        if (this.localPlayerModel.group) {
            this.localPlayerModel.group.position.copy(correctedPosition);
            
            // Copy the player's rotation to the model
            this.localPlayerModel.group.rotation.y = this.localPlayer.group.rotation.y;
            
            // Determine if position has changed significantly to log
            const positionChanged = lastPosition.distanceTo(this.localPlayerModel.group.position) > 0.01;
            
            // Log player model position updates when debugging or forced
            if ((positionChanged || forceLog) && this.debug) {
                console.log(`[QuickDraw] Updated local player model position: 
                    Camera: (${cameraPosition.x.toFixed(2)}, ${cameraPosition.y.toFixed(2)}, ${cameraPosition.z.toFixed(2)})
                    Model: (${this.localPlayerModel.group.position.x.toFixed(2)}, ${this.localPlayerModel.group.position.y.toFixed(2)}, ${this.localPlayerModel.group.position.z.toFixed(2)})
                    On Ground: y=${correctedPosition.y.toFixed(2)}`);
            }
            
            // Only update hit zones if position changed or explicitly forced
            // This avoids unnecessary updates during quickdraw when player can't move
            if ((positionChanged || forceLog) && typeof this.localPlayerModel.updateHitZones === 'function') {
                this.localPlayerModel.updateHitZones();
            }
        } else {
            console.warn('Cannot update local player model - group not initialized');
        }
    }

    /**
     * Get the position of the opponent in the duel
     * @returns {THREE.Vector3|null} - The opponent's position or null if not found
     */
    getOpponentPosition() {
        if (!this.duelOpponentId) return null;
        
        // First try window.otherPlayers (from main.js)
        if (window.otherPlayers && window.otherPlayers.has(this.duelOpponentId)) {
            const opponent = window.otherPlayers.get(this.duelOpponentId);
            if (opponent && opponent.group) {
                return opponent.group.position.clone();
            }
        }
        
        // Fallback to networkManager.otherPlayers
        if (this.networkManager && this.networkManager.otherPlayers) {
            const opponentData = this.networkManager.otherPlayers.get(this.duelOpponentId);
            if (opponentData && opponentData.position) {
                return new THREE.Vector3(
                    opponentData.position.x,
                    opponentData.position.y,
                    opponentData.position.z
                );
            }
        }
        
        return null;
    }

    /**
     * Handle the Draw signal from server
     */
    triggerDraw() {
        this.duelState = 'draw';
        
        // Hide all nametags again to ensure they're hidden during the crucial draw moment
        this.hidePlayerNametags();
        
        // Show the special DRAW message
        this.showMessage("DRAW!", 1000, '#FF0000');
        
        // Show visual draw indicator
        this.drawCircle.style.display = 'block';
        this.drawCircle.style.opacity = '1';
        this.drawCircle.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // Add slow-mo effect if enabled
        if (window.renderer && window.renderer.setTimeScale) {
            window.renderer.setTimeScale(0.5); // Slow to half-speed
            
            // Reset time scale after 1s
            setTimeout(() => {
                if (window.renderer && window.renderer.setTimeScale) {
                    window.renderer.setTimeScale(1.0);
                }
            }, 1000);
        }
        
        // Enable aiming immediately on DRAW
        this.localPlayer.canAim = true;
        
        // Visual feedback 
        setTimeout(() => {
            if (this.drawCircle.style.display !== 'none') {
                this.drawCircle.style.opacity = '0';
                this.drawCircle.style.transform = 'translate(-50%, -50%) scale(1.5)';
                
                // Hide the circle after animation completes
                setTimeout(() => {
                    this.drawCircle.style.display = 'none';
                }, 500);
            }
        }, 500);
        
        // Play draw sound with intensity
        if (this.soundManager) {
            this.soundManager.playSound("draw", 0.8);
        }
        
        // Update UI
        this.updateStatusIndicator();
    }

    /**
     * Handle the countdown message from server - preparation phase  
     * @param {Object} message - Countdown message data
     */
    handleCountdown(message) {
        console.log('[QuickDraw] Received countdown message');
        this.startDuelCountdown();
        
        // Ensure nametags are hidden
        this.hidePlayerNametags();
    }
    
    /**
     * Handle match found message for a queue match
     * @param {Object} message - Match data
     */
    handleMatchFound(message) {
        if (!this.localPlayer) return;
        
        console.log('[QuickDraw] Match found:', message);
        
        // Extract match details
        this.inDuel = true;
        this.duelOpponentId = message.opponentId;
        this.duelActive = true;
        
        // Update aerial camera state
        this.aerialCameraActive = false;
        this.aerialCameraPathSet = false;
        
        // Set internal state to override camera
        this._directCameraOverride = false;
        
        // Update lobby status
        this.inLobby = false;
        
        // Show the message
        this.showReadyMessage();
        
        // Disable player movement and aiming during the duel
        this.localPlayer.canAim = false;
        this.localPlayer.canMove = false;
        
        // Hide nametags for dueling players
        this.hidePlayerNametags();
        
        // Force-lock player movement to prevent any accidental movement
        if (message.movementLocked === true) {
            // Completely block any movement input
            this.localPlayer.forceLockMovement = true;
            
            // Backup original move method and replace with empty function
            if (!this.localPlayer._origMove) {
                this.localPlayer._origMove = this.localPlayer.move;
                this.localPlayer.move = () => {}; // No-op function
            }
        }
        
        // FIXED ISSUE: Teleport player to the spawn position if provided by server
        if (message.startPosition) {
            // Teleport player to the provided position
            console.log(`[QuickDraw] Teleporting player to spawn position:`, message.startPosition);
            this.localPlayer.group.position.set(
                message.startPosition.x,
                message.startPosition.y,
                message.startPosition.z
            );
            
            // Reset velocity to zero
            this.localPlayer.velocity = new THREE.Vector3(0, 0, 0);
            
            // Also set rotation if provided
            if (message.startRotation !== undefined) {
                console.log(`[QuickDraw] Setting player rotation to: ${message.startRotation}`);
                this.localPlayer.group.rotation.y = message.startRotation;
                
                // Debug visualization of player direction
                if (this.debug) {
                    this.showFacingDirection(this.localPlayer.group.position.clone(), message.startRotation);
                }
            }
        } else {
            console.warn('[QuickDraw] No spawn position provided by server');
        }
        
        // Update the main UI health display too
        if (typeof updateHealthUI === 'function') {
            updateHealthUI(this.localPlayer);
        }
        
        // Update status indicator
        this.updateStatusIndicator();
        
        // Mark as ready after showing message
        this.createDuelTimeout(() => {
            console.log('[QuickDraw] Sending ready signal to server');
            this.networkManager.sendQuickDrawReady();
        }, 2000);
    }
    
    /**
     * Reset player state and respawn after a duel
     * @param {Object} message - Reset data
     */
    resetPlayerAndRespawn(message) {
        console.log('[QuickDraw] Received reset and respawn request');
        
        // Restore nametags before resetting state
        this.restorePlayerNametags();
        
        // Reset player state completely
        this.resetPlayerState();
        
        // Apply any health update from message
        if (message && message.health !== undefined) {
            this.localPlayer.health = message.health;
            
            // Update health UI
            if (typeof updateHealthUI === 'function') {
                updateHealthUI(this.localPlayer);
            }
        }
        
        // Reset camera (important even if no aerial view was used)
        this.disableAerialCamera();
        
        // Respawn player at a random town position 
        this.respawnPlayerInTown();
        
        // Send a state reset message to other clients
        this.sendPlayerStateReset();
        
        // Clear all duel timers
        this.clearAllDuelTimers();
    }

    /**
     * Handle the result of the duel (win/loss)
     * @param {Object} message - Result data
     */
    handleResult(message) {
        console.log('[QuickDraw] Received duel result:', message);
        
        // Show appropriate victory/defeat animation
        this.endDuel(message.winnerId);
        
        // Update internal state
        this.inDuel = false;
        this.duelState = 'none';
        
        // Restore nametags but after a delay to match the victory/defeat animation timing
        setTimeout(() => {
            this.restorePlayerNametags();
        }, 1000);
    }

    /**
     * Handle player death in duel
     * @param {Object} message - Death data
     */
    handleDeath(message) {
        console.log(`You were killed by player ${message.killerId}`);
        
        // Set death/kill animation flag to prevent camera switching
        this.inDeathOrKillAnimation = true;
        
        // Skip showing "YOU DIED" message if this is a duel death (we'll show DEFEAT instead)
        if (!this.inDuel) {
            // Show death message only for non-duel deaths
            this.showMessage('YOU DIED', 1500, '#FF0000');
        }
        
        // Play death sound
        if (this.soundManager) {
            this.soundManager.playSound("death", 0.7);
        }
        
        // Create death effect
        this.createDeathEffect();
        
        // Store original mouse handler for later restoration
        const origMouseMove = document.onmousemove;
        
        // Make sure we have a local player model for the death animation
        if (!this.localPlayerModel) {
            this.createLocalPlayerModel();
        }
        
        // Apply death camera effect ALWAYS, regardless of duel status
        if (this.localPlayer && this.localPlayer.camera) {
            // Save original camera rotation
            const originalRotation = this.localPlayer.camera.rotation.clone();
            
            // Apply death camera rotation - rotate camera to look down at the ground
            // Start a smooth rotation animation from current position to looking down
            const deathCameraDuration = 1000; // 1 second for the rotation animation
            const startTime = Date.now();
            const targetRotationX = Math.PI / 2; // Looking down at the ground (90 degrees)
            
            // Create an animation function that rotates the camera over time
            const rotateCameraUp = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / deathCameraDuration, 1);
                
                // Use an easing function (ease-out) for smoother animation
                const easeOut = 1 - Math.pow(1 - progress, 2);
                
                // Interpolate between original and target rotation
                this.localPlayer.camera.rotation.x = originalRotation.x * (1 - easeOut) + targetRotationX * easeOut;
                
                // Continue the animation until complete
                if (progress < 1) {
                    requestAnimationFrame(rotateCameraUp);
                }
            };
            
            // Start the camera rotation animation
            rotateCameraUp();
            
            // Disable mouse look temporarily
            document.onmousemove = (e) => {
                // Block mouse movement during death animation
                e.stopPropagation();
                return false;
            };
        }
        
        // Keep the player's POV camera active during death
        if (this.localPlayerModel) {
            // Force the local player's camera to be active
            if (window.renderer) {
                window.renderer.camera = this.localPlayer.camera;
                
                // Also set the instance camera if available
                if (window.renderer.instance) {
                    window.renderer.instance.camera = this.localPlayer.camera;
                }
            }
            
            // Make the model visible for other players but not in our own view
            this.localPlayerModel.group.visible = true;
            
            // Play the death animation
            if (this.localPlayerModel.playDeathAnimation) {
                console.log('[QuickDraw] Playing death animation');
                const deathResult = this.localPlayerModel.playDeathAnimation();
                
                // Play the player fall sound when death animation starts
                if (this.soundManager) {
                    this.soundManager.playSound("playerfall", 0, 0.8);
                }
                
                // Allow the death animation to complete before reset/respawn
                const deathAnimDuration = deathResult.duration || 1500;
                
                // Disable player controls during death animation
                if (this.localPlayer) {
                    this.localPlayer.canMove = false;
                    this.localPlayer.canAim = false;
                    this.localPlayer.forceLockMovement = true;
                }
                
                // Wait for animation to complete before server sends respawn
                console.log(`[QuickDraw] Death animation playing, duration: ${deathAnimDuration}ms`);
                
                // Clear animation flag after animation completes
                setTimeout(() => {
                    this.inDeathOrKillAnimation = false;
                    
                    // Restore original mouse movement
                    document.onmousemove = origMouseMove;
                }, deathAnimDuration + 500); // Add a bit of buffer
                
                // The server will send fullStateReset message after the animation duration
                // We're ensuring the animation has time to play fully
                
                // Broadcast our death animation state to other players
                if (this.networkManager && this.networkManager.socket) {
                    this.networkManager.socket.send(JSON.stringify({
                        type: 'playerUpdate',
                        isDying: true,  // Special flag to trigger death animation on other clients
                        health: 0,
                        position: this.localPlayer.group.position,
                        rotation: { y: this.localPlayer.group.rotation.y }
                    }));
                    console.log('[QuickDraw] Broadcast death animation state to other players');
                }
            } else {
                console.warn('[QuickDraw] Death animation not available on player model');
                
                // Clear animation flag after a default delay if no animation
                setTimeout(() => {
                    this.inDeathOrKillAnimation = false;
                    
                    // Restore original mouse movement
                    document.onmousemove = origMouseMove;
                }, 3000);
            }
        } else {
            console.warn('[QuickDraw] Could not create local player model for death animation');
            
            // Clear animation flag after a default delay if no model
            setTimeout(() => {
                this.inDeathOrKillAnimation = false;
                
                // Restore original mouse movement
                document.onmousemove = origMouseMove;
            }, 3000);
        }
    }
    
    /**
     * Handle player kill in duel
     * @param {Object} message - Kill data
     */
    handleKill(message) {
        console.log('[QuickDraw] Player got a kill in duel', message);
        
        // Create kill effect 
        this.createKillEffect();
        
        // Add a hit marker
        this.showHitMarker(message.hitZone || 'body');
        
        // Restore nametags
        this.restorePlayerNametags();
        
        // The result screen will appear shortly
    }

    /**
     * Checks the Quick Draw state and updates game elements accordingly
     * @param {number} deltaTime - Time elapsed since last frame
     */
    update(deltaTime) {
        // Skip if player not initialized
        if (!this.localPlayer || !this.localPlayer.group) return;
        
        // CRITICAL: Emergency camera switch enforcement
        if (this.duelState === 'draw') {
            // If we're in draw phase, FORCE the local camera always
            if (window.renderer && window.renderer.instance) {
                if (this.localPlayer && this.localPlayer.camera) {
                    // Direct override if not already applied
                    if (!this._directCameraOverride) {
                        console.log('EMERGENCY CAMERA RESET in update loop - forcing player camera');
                        window.renderer.instance.camera = this.localPlayer.camera;
                        window.renderer.camera = this.localPlayer.camera;
                        this._directCameraOverride = true;
                    }
                    
                    // Double-check that camera is still correctly set
                    if (window.renderer.instance.camera !== this.localPlayer.camera) {
                        console.warn('CRITICAL: Camera was changed outside our control - RE-FORCING player camera');
                        window.renderer.instance.camera = this.localPlayer.camera;
                        window.renderer.camera = this.localPlayer.camera;
                    }
                }
            }
            
            // Make sure aerial camera is disabled
            this.aerialCameraActive = false;
            
            // Ensure local player model is hidden
            if (this.localPlayerModel && !this.localPlayerModel.loading && this.localPlayerModel.group) {
                this.localPlayerModel.group.visible = false;
            }
            
            // If we're in duel mode, periodically check and fix hit zones
            if (this.inDuel && Math.random() < 0.01) { // Check occasionally 
                this.fixHitZonesForQuickDraw();
            }
        } 
        else if ((this.duelState === 'ready' || this.duelState === 'countdown' || this.duelState === 'none') && 
                 this.inDuel && !this.aerialCameraActive && !this.inDeathOrKillAnimation) {
            // Only enable aerial camera if we're not in death/kill animation
            console.log('Aerial camera not active during pre-draw phase - enabling');
            this.setupAndEnableAerialCamera();
        }
        
        // Update flying eagle if it exists
        if (window.flyingEagle && (this.aerialCameraActive || this.duelState === 'draw')) {
            window.flyingEagle.update(deltaTime);
        }
        
        // Update aerial camera if active and not in death/kill animation
        if (this.aerialCameraActive && !this.inDeathOrKillAnimation) {
            this.updateAerialCamera(deltaTime);
        }
        
        // If in death/kill animation, ensure player camera is active
        if (this.inDeathOrKillAnimation && this.localPlayer && this.localPlayer.camera) {
            if (window.renderer) {
                if (window.renderer.camera !== this.localPlayer.camera) {
                    console.log('Forcing player camera during death/kill animation');
                    window.renderer.camera = this.localPlayer.camera;
                    
                    // Also set the instance camera if available
                    if (window.renderer.instance && window.renderer.instance.camera !== this.localPlayer.camera) {
                        window.renderer.instance.camera = this.localPlayer.camera;
                    }
                }
            }
        }
        
        // Update nearby players for challenges
        this.updateNearbyPlayers();
        
        // Update status indicator
        this.updateStatusIndicator();
        
        // If penalized, keep gun locked until penalty expires
        if (this.penaltyEndTime > 0) {
            if (Date.now() < this.penaltyEndTime) {
                // Keep gun locked
                this.localPlayer.canAim = false;
            } else {
                // Penalty expired, unlock gun if in draw phase
                if (this.duelState === 'draw') {
                    this.localPlayer.canAim = true;
                }
                
                // Clear penalty
                this.penaltyEndTime = 0;
            }
        }
        
        // Check for early draw (using mouse down) during countdown
        if (this.duelState === 'countdown' && !this.penaltyEndTime) {
            if ((window.mouseDown && (window.mouseDown.left || window.mouseDown.right)) || this.localPlayer.isAiming) {
                this.penalizeEarlyDraw();
            }
        }
    }

    /**
     * Updates the Quick Draw status indicator.
     */
    updateStatusIndicator() {
        if (!this.statusIndicator) return;
        
        // Show/hide based on duel state
        if (this.inDuel || this.inLobby) {
            this.statusIndicator.style.display = 'block';
            let statusText = '';
            
            if (this.inLobby) {
                statusText = 'Quick Draw: Waiting for players...';
            } else if (this.inDuel) {
                switch (this.duelState) {
                    case 'ready':
                        statusText = 'Quick Draw: Get ready!';
                        break;
                    case 'countdown':
                        statusText = 'Quick Draw: Wait for the signal!';
                        break;
                    case 'draw':
                        statusText = 'Quick Draw: DRAW!';
                        break;
                    default:
                        statusText = 'Quick Draw: Duel in progress';
                }
            }
            
            this.statusIndicator.textContent = statusText;
        } else {
            this.statusIndicator.style.display = 'none';
        }
    }

    /**
     * Handle match found notification from server.
     */
    handleMatchFound(message) {
        console.log('[QuickDraw] Match found handler executed', message);
        
        // Validate required fields
        if (!message.opponentId) {
            console.error('[QuickDraw] Missing opponent ID in match found message:', message);
            return;
        }
        
        // First, make sure any previous aerial camera is disabled
        this.disableAerialCamera();
        
        // Clear any existing timers from previous matches
        this.clearAllDuelTimers();
        
        this.inDuel = true;
        this.inLobby = false;
        this.duelOpponentId = message.opponentId;
        this.duelState = 'none';
        this.pendingChallenge = null;
        
        console.log(`[QuickDraw] Starting duel with opponent ${this.duelOpponentId}`);
        
        // Play dramatic music for the duel start
        if (this.soundManager) {
            this.soundManager.playSound("dramatic", 0, 0.7); // Play at 70% volume
        }
        
        // Store original player movement and aiming states
        this.originalCanAim = this.localPlayer.canAim;
        this.originalCanMove = this.localPlayer.canMove;
        
        // Store original position to return after the duel
        this.originalPosition = {
            x: this.localPlayer.group.position.x,
            y: this.localPlayer.group.position.y,
            z: this.localPlayer.group.position.z
        };
        this.originalRotation = this.localPlayer.group.rotation.y;
        
        // Disable player movement and aiming during the duel
        this.localPlayer.canAim = false;
        this.localPlayer.canMove = false;
        
        // Hide nametags for dueling players
        this.hidePlayerNametags();
        
        // Force-lock player movement to prevent any accidental movement
        if (message.movementLocked === true) {
            // Completely block any movement input
            this.localPlayer.forceLockMovement = true;
            
            // Backup original move method and replace with empty function
            if (!this.localPlayer._origMove) {
                this.localPlayer._origMove = this.localPlayer.move;
                this.localPlayer.move = () => {}; // No-op function
            }
        }
        
        // FIXED ISSUE: Teleport player to the spawn position if provided by server
        if (message.startPosition) {
            // Teleport player to the provided position
            console.log(`[QuickDraw] Teleporting player to spawn position:`, message.startPosition);
            this.localPlayer.group.position.set(
                message.startPosition.x,
                message.startPosition.y,
                message.startPosition.z
            );
            
            // Reset velocity to zero
            this.localPlayer.velocity = new THREE.Vector3(0, 0, 0);
            
            // Also set rotation if provided
            if (message.startRotation !== undefined) {
                console.log(`[QuickDraw] Setting player rotation to: ${message.startRotation}`);
                this.localPlayer.group.rotation.y = message.startRotation;
                
                // Debug visualization of player direction
                if (this.debug) {
                    this.showFacingDirection(this.localPlayer.group.position.clone(), message.startRotation);
                }
            }
        } else {
            console.warn('[QuickDraw] No spawn position provided by server');
        }
        
        // Update the main UI health display too
        if (typeof updateHealthUI === 'function') {
            updateHealthUI(this.localPlayer);
        }
        
        // Update status indicator
        this.updateStatusIndicator();
        
        // Mark as ready after showing message
        this.createDuelTimeout(() => {
            console.log('[QuickDraw] Sending ready signal to server');
            this.networkManager.sendQuickDrawReady();
        }, 2000);
    }
    
    /**
     * Hide all player nametags during a duel, not just the participants
     * @param {number} player1Id - First player's ID (local player)
     * @param {number} player2Id - Second player's ID (opponent)
     */
    hidePlayerNametags() {
        // Check if we have access to the multiplayerManager
        if (!window.multiplayerManager) {
            console.warn('[QuickDraw] Cannot hide nametags - multiplayerManager not available');
            return;
        }
        
        console.log(`[QuickDraw] Hiding all nametags during quickdraw duel`);
        
        // Store original display state for all player labels
        this.originalLabelDisplays = new Map();
        
        // Hide all player labels
        window.multiplayerManager.playerLabels.forEach((labelData, playerId) => {
            if (labelData && labelData.div) {
                this.originalLabelDisplays.set(playerId, labelData.div.style.display);
                labelData.div.style.display = 'none';
            }
        });
    }
    
    /**
     * Restore all hidden nametags after duel
     */
    restorePlayerNametags() {
        // Check if we have access to the multiplayerManager
        if (!window.multiplayerManager) return;
        
        console.log('[QuickDraw] Restoring all player nametags after duel');
        
        // Restore all player labels to their original display state
        if (this.originalLabelDisplays && this.originalLabelDisplays.size > 0) {
            window.multiplayerManager.playerLabels.forEach((labelData, playerId) => {
                if (labelData && labelData.div) {
                    const originalDisplay = this.originalLabelDisplays.get(playerId) || 'block';
                    labelData.div.style.display = originalDisplay;
                }
            });
            
            // Clear stored display states
            this.originalLabelDisplays.clear();
        } else {
            // Fallback - make all labels visible
            window.multiplayerManager.playerLabels.forEach((labelData, playerId) => {
                if (labelData && labelData.div) {
                    labelData.div.style.display = 'block';
                }
            });
        }
    }
    
    /**
     * Show a temporary arrow indicating which way the player is facing
     * @param {Object} position - The player position
     * @param {number} rotation - The player rotation in radians
     */
    showFacingDirection(position, rotation) {
        // Create a group to hold all debug objects
        const debugGroup = new THREE.Group();
        
        // Create direction arrow with more visibility
        const arrowLength = 8; // Longer arrow
        const arrowGeometry = new THREE.ConeGeometry(0.5, arrowLength, 8);
        const arrowMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00FF00,
            transparent: true,
            opacity: 0.8
        });
        const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
        
        // Position the arrow at player position, slightly above ground
        arrow.position.set(0, 2, 0); // Local position within group
        
        // Rotate arrow to match player rotation
        // By default, the cone points up along Y axis, so we need to rotate it to point along Z axis first
        arrow.rotation.x = Math.PI / 2;
        
        // Add line showing forward direction
        const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xFFFF00,
            linewidth: 3
        });
        const linePoints = [];
        linePoints.push(new THREE.Vector3(0, 0.5, 0));
        linePoints.push(new THREE.Vector3(0, 0.5, arrowLength * 1.2)); // Slightly longer than arrow
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        
        // Create text label showing rotation angle
        const textCanvas = document.createElement('canvas');
        textCanvas.width = 256;
        textCanvas.height = 128;
        const context = textCanvas.getContext('2d');
        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
        context.fillRect(0, 0, textCanvas.width, textCanvas.height);
        context.font = 'bold 24px Arial';
        context.fillStyle = 'white';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        
        // Calculate angle in degrees for display
        const angleDegrees = (rotation * 180 / Math.PI).toFixed(1);
        context.fillText(`Rotation: ${angleDegrees}°`, textCanvas.width / 2, textCanvas.height / 2);
        
        const texture = new THREE.CanvasTexture(textCanvas);
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
        });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(5, 2.5, 1);
        sprite.position.set(0, 4, 0); // Position above arrow
        
        // Add all elements to the debug group
        debugGroup.add(arrow);
        debugGroup.add(line);
        debugGroup.add(sprite);
        
        // Position and rotate the entire group
        debugGroup.position.copy(position);
        debugGroup.rotation.y = rotation;
        
        // Add to scene
        this.scene.add(debugGroup);
        
        // Add temporary sphere at player position as reference
        const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const sphereMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xFF0000,
            transparent: true,
            opacity: 0.6
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphere.position.set(position.x, position.y + 0.5, position.z);
        this.scene.add(sphere);
        
        // Create a label for "Player Position"
        const posCanvas = document.createElement('canvas');
        posCanvas.width = 256;
        posCanvas.height = 64;
        const posContext = posCanvas.getContext('2d');
        posContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
        posContext.fillRect(0, 0, posCanvas.width, posCanvas.height);
        posContext.font = 'bold 20px Arial';
        posContext.fillStyle = 'white';
        posContext.textAlign = 'center';
        posContext.textBaseline = 'middle';
        posContext.fillText('Player Position', posCanvas.width / 2, posCanvas.height / 2);
        
        const posTexture = new THREE.CanvasTexture(posCanvas);
        const posMaterial = new THREE.SpriteMaterial({
            map: posTexture,
            transparent: true
        });
        const posSprite = new THREE.Sprite(posMaterial);
        posSprite.scale.set(4, 1, 1);
        posSprite.position.set(position.x, position.y + 1.5, position.z);
        this.scene.add(posSprite);
        
        console.log(`Debug direction arrow created at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}) with rotation ${rotation.toFixed(4)} rad (${angleDegrees}°)`);
        
        // Remove after 5 seconds
        setTimeout(() => {
            this.scene.remove(debugGroup);
            this.scene.remove(sphere);
            this.scene.remove(posSprite);
        }, 5000);
    }
    
    /**
     * Updates the health bar with the current health value
     * @param {number} health - Health value (0-100)
     */
    updateHealthBar(health) {
        // Ensure health is within valid range
        health = Math.max(0, Math.min(100, health));
        
        // Update health bar width
        this.healthBar.style.width = `${health}%`;
        
        // Update color based on health amount
        if (health > 60) {
            this.healthBar.style.backgroundColor = '#00FF00'; // Green
        } else if (health > 30) {
            this.healthBar.style.backgroundColor = '#FFA500'; // Orange
        } else {
            this.healthBar.style.backgroundColor = '#FF0000'; // Red
        }
        
        // Update text
        this.healthText.textContent = `${health} HP`;
    }

    /**
     * Apply a penalty with dramatic red flashing warning.
     * Once triggered, records a penalty end time so that gun drawing remains locked
     * for a full 3 seconds even if the "DRAW!" signal comes.
     */
    penalizeEarlyDraw() {
        // Lock gun for 3 seconds
        this.penaltyEndTime = Date.now() + 3000;
        this.localPlayer.canAim = false;
        
        // Force holster any weapon that might be drawn
        if (this.localPlayer.isAiming) {
            this.localPlayer.isAiming = false;
            
            // Play the holstering animation
            if (this.localPlayer.viewmodel) {
                this.localPlayer.viewmodel.playHolsterAnim();
                
                // Hide viewmodel after holster animation completes
                setTimeout(() => {
                    if (this.localPlayer.viewmodel) {
                        this.localPlayer.viewmodel.group.visible = false;
                    }
                }, 500);
            }
        }
        
        // Show the penalty message
        this.showMessage('TOO EARLY! Penalty!', 2000);
        
        // Create a flashing red overlay for penalty
        const penaltyOverlay = document.createElement('div');
        penaltyOverlay.style.position = 'absolute';
        penaltyOverlay.style.top = '0';
        penaltyOverlay.style.left = '0';
        penaltyOverlay.style.width = '100%';
        penaltyOverlay.style.height = '100%';
        penaltyOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        penaltyOverlay.style.zIndex = '999';
        penaltyOverlay.style.animation = 'penalty-flash 0.5s 3';
        
        // Add animation style
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes penalty-flash {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Add to game container and remove after penalty
        document.getElementById('game-container').appendChild(penaltyOverlay);
        
        // Play penalty sound
        if (this.soundManager) {
            this.soundManager.playSound("wrong", 0.7);
        }
        
        // Remove overlay after penalty animation
        setTimeout(() => {
            if (penaltyOverlay.parentNode) {
                penaltyOverlay.parentNode.removeChild(penaltyOverlay);
            }
        }, 1500);
        
        // Send penalty to server for validation
        if (this.networkManager && typeof this.networkManager.sendQuickDrawPenalty === 'function') {
            this.networkManager.sendQuickDrawPenalty();
        }
    }

    /**
     * End the duel with enhanced win/lose UI effects.
     */
    endDuel(winnerId) {
        console.log('[QuickDraw] Ending duel, winner:', winnerId);
        
        // Update state first to prevent any update logic from running
        this.duelState = 'none';
        
        // Set flag to prevent switching back to aerial view
        this.inDeathOrKillAnimation = true;
        
        // IMPORTANT: We no longer show aerial camera after death
        // Instead, we keep the player's camera viewpoint
        console.log('[QuickDraw] Keeping player viewpoint for death scene');
        
        // Force player camera to be active
        if (this.localPlayer && this.localPlayer.camera) {
            if (window.renderer) {
                window.renderer.camera = this.localPlayer.camera;
                
                // Also set the instance camera if available
                if (window.renderer.instance) {
                    window.renderer.instance.camera = this.localPlayer.camera;
                }
            }
            
            // Only apply death camera rotation if player lost
            const playerLost = winnerId !== this.localPlayer.id;
            if (playerLost) {
                // Store original mouse handler for later restoration
                const origMouseMove = document.onmousemove;
                
                // Save original camera rotation
                const originalRotation = this.localPlayer.camera.rotation.clone();
                
                // Apply death camera rotation - rotate camera to look down at the ground
                // Start a smooth rotation animation from current position to looking down
                const deathCameraDuration = 1000; // 1 second for the rotation animation
                const startTime = Date.now();
                const targetRotationX = Math.PI / 2; // Looking down at the ground (90 degrees)
                
                // Create an animation function that rotates the camera over time
                const rotateCameraUp = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / deathCameraDuration, 1);
                    
                    // Use an easing function (ease-out) for smoother animation
                    const easeOut = 1 - Math.pow(1 - progress, 2);
                    
                    // Interpolate between original and target rotation
                    this.localPlayer.camera.rotation.x = originalRotation.x * (1 - easeOut) + targetRotationX * easeOut;
                    
                    // Continue the animation until complete
                    if (progress < 1) {
                        requestAnimationFrame(rotateCameraUp);
                    }
                };
                
                // Start the camera rotation animation
                rotateCameraUp();
                
                // Disable mouse look temporarily
                document.onmousemove = (e) => {
                    // Block mouse movement during death animation
                    e.stopPropagation();
                    return false;
                };
                
                // Restore mouse movement after animation completes
                setTimeout(() => {
                    document.onmousemove = origMouseMove;
                }, 3000);
            }
        }
        
        // Ensure letterbox effect is removed immediately
        document.body.classList.remove('letterbox-active');
        
        // Determine if player won or lost
        const playerWon = winnerId === this.localPlayer.id;
        
        // Tell the renderer not to show kill markers for quickdraw
        if (window.renderer) {
            window.renderer.skipNextKillMarker = true;
        }
        
        // Create overlay and play sounds
        this.showVictoryDefeatOverlay(playerWon);
        
        // Unlock player's original movement methods right away
        // This is crucial - ensure the player isn't locked even if later code fails
        if (this.localPlayer) {
            // Restore original movement methods right away
            if (this.localPlayer._origMove) {
                console.log('[QuickDraw] Restoring original move method immediately');
                this.localPlayer.move = this.localPlayer._origMove;
                this.localPlayer._origMove = null;
            }
            
            // Reset force lock immediately
            this.localPlayer.forceLockMovement = false;
        }
        
        // Clear animation flag after the victory/defeat screen has been shown
        setTimeout(() => {
            this.inDeathOrKillAnimation = false;
            
            // Restore nametags after death animation
            this.restorePlayerNametags();
            
            // Double-check that letterbox effect is removed after animation
            document.body.classList.remove('letterbox-active');
        }, 3000);
        
        // Server will send fullStateReset message after a delay
    }

    /**
     * Show victory/defeat overlay with appropriate effects
     */
    showVictoryDefeatOverlay(playerWon) {
        // Create an auto-fading overlay
        const resultOverlay = document.createElement('div');
        resultOverlay.id = 'quickdraw-result-overlay';
        resultOverlay.className = 'quickdraw-result';
        resultOverlay.style.position = 'fixed';
        resultOverlay.style.top = '0';
        resultOverlay.style.left = '0';
        resultOverlay.style.width = '100%';
        resultOverlay.style.height = '100%';
        resultOverlay.style.display = 'flex';
        resultOverlay.style.flexDirection = 'column';
        resultOverlay.style.alignItems = 'center';
        resultOverlay.style.justifyContent = 'center';
        resultOverlay.style.backgroundColor = playerWon ? 'rgba(0, 0, 0, 0.4)' : 'rgba(0, 0, 0, 0.4)';
        resultOverlay.style.zIndex = '9999';
        resultOverlay.style.opacity = '0';
        resultOverlay.style.transition = 'opacity 0.5s ease-in, opacity 1s ease-out 2.5s';
        
        // Create western-style wooden sign background
        const woodenSign = document.createElement('div');
        woodenSign.style.width = '600px';
        woodenSign.style.height = '300px';
        woodenSign.style.background = 'url("/textures/wooden_sign.png") no-repeat center center';
        woodenSign.style.backgroundSize = 'contain';
        woodenSign.style.display = 'flex';
        woodenSign.style.alignItems = 'center';
        woodenSign.style.justifyContent = 'center';
        woodenSign.style.position = 'relative';
        woodenSign.style.transform = 'rotate(-3deg)';
        
        // Create text element inside the wooden sign
        const resultText = document.createElement('div');
        resultText.textContent = playerWon ? 'VICTORY!' : 'DEFEAT';
        resultText.style.fontSize = '80px';
        resultText.style.fontWeight = 'bold';
        resultText.style.fontFamily = 'Western, "Wanted M54", serif';
        resultText.style.color = playerWon ? '#FFD700' : '#FF3333';
        resultText.style.textShadow = playerWon 
            ? '0 0 10px #FF9900, 0 0 20px #FF9900, 2px 2px 2px rgba(0,0,0,0.7)' 
            : '0 0 10px #AA0000, 0 0 20px #AA0000, 2px 2px 2px rgba(0,0,0,0.7)';
        resultText.style.transform = 'translateY(-10px)';
        
        // Create subtitle message
        const subtitleText = document.createElement('div');
        subtitleText.textContent = playerWon ? 'You Won The Duel!' : 'You Lost The Duel!';
        subtitleText.style.fontSize = '24px';
        subtitleText.style.fontFamily = 'Western, "Rye", serif';
        subtitleText.style.color = '#FFF8DC';
        subtitleText.style.marginTop = '10px';
        subtitleText.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)';
        
        // Add decorative bullet holes to the sign if defeated
        if (!playerWon) {
            for (let i = 0; i < 3; i++) {
                const bulletHole = document.createElement('div');
                bulletHole.style.position = 'absolute';
                bulletHole.style.width = '30px';
                bulletHole.style.height = '30px';
                bulletHole.style.borderRadius = '50%';
                bulletHole.style.backgroundColor = '#000';
                bulletHole.style.boxShadow = 'inset 0 0 10px 5px rgba(30, 30, 30, 0.8)';
                
                // Random positions for bullet holes
                bulletHole.style.top = `${Math.random() * 70 + 15}%`;
                bulletHole.style.left = `${Math.random() * 70 + 15}%`;
                bulletHole.style.transform = 'translate(-50%, -50%)';
                
                woodenSign.appendChild(bulletHole);
            }
        } else {
            // Add decorative sheriff star for victory
            const star = document.createElement('div');
            star.style.position = 'absolute';
            star.style.top = '10%';
            star.style.right = '15%';
            star.style.width = '60px';
            star.style.height = '60px';
            star.style.backgroundImage = 'url("/textures/sheriff_badge.png")';
            star.style.backgroundSize = 'contain';
            star.style.backgroundRepeat = 'no-repeat';
            star.style.filter = 'drop-shadow(0 0 5px gold)';
            
            woodenSign.appendChild(star);
        }
        
        // Add decoration rope to sign
        const rope = document.createElement('div');
        rope.style.position = 'absolute';
        rope.style.top = '-20px';
        rope.style.left = '50%';
        rope.style.width = '8px';
        rope.style.height = '30px';
        rope.style.backgroundColor = '#8B4513';
        rope.style.transform = 'translateX(-50%)';
        
        woodenSign.appendChild(resultText);
        woodenSign.appendChild(subtitleText);
        woodenSign.appendChild(rope);
        resultOverlay.appendChild(woodenSign);
        document.body.appendChild(resultOverlay);
        
        // Fade in and animate
        setTimeout(() => {
            resultOverlay.style.opacity = '1';
            woodenSign.style.transition = 'transform 0.3s ease-in-out';
            woodenSign.style.transform = 'rotate(-3deg) scale(1.1)';
            
            setTimeout(() => {
                woodenSign.style.transform = 'rotate(-3deg) scale(1)';
                // Start subtle swinging animation
                woodenSign.style.animation = 'gentle-swing 2s ease-in-out infinite';
                
                // Add swing animation
                const styleSheet = document.createElement('style');
                styleSheet.id = 'quickdraw-animations';
                styleSheet.textContent = `
                    @keyframes gentle-swing {
                        0% { transform: rotate(-3deg); }
                        50% { transform: rotate(-1deg); }
                        100% { transform: rotate(-3deg); }
                    }
                `;
                document.head.appendChild(styleSheet);
            }, 300);
        }, 100);
        
        // Standard message overlay as backup
        this.messageOverlay.textContent = playerWon ? 'VICTORY!' : 'DEFEAT';
        this.messageOverlay.className = 'quickdraw-result';
        this.messageOverlay.style.display = 'block';
        this.messageOverlay.style.fontSize = '72px';
        this.messageOverlay.style.color = playerWon ? '#FFD700' : '#FF3333';
        this.messageOverlay.style.textShadow = playerWon 
            ? '0 0 20px #FF9900' 
            : '0 0 20px #AA0000';
        
        // Play victory/defeat sound
        if (this.soundManager) {
            this.soundManager.playSound("quickdrawending", 0, 0.8);
        }
        
        // Auto-fade out the overlay faster (after 2 seconds instead of 2.5)
        setTimeout(() => {
            // Apply smoother fade out transition
            resultOverlay.style.transition = 'opacity 0.8s ease-out';
            resultOverlay.style.opacity = '0';
            
            // Remove from DOM after fade out
            setTimeout(() => {
                if (resultOverlay.parentNode) {
                    resultOverlay.parentNode.removeChild(resultOverlay);
                }
                
                // Clean up animation style
                const animStyle = document.getElementById('quickdraw-animations');
                if (animStyle && animStyle.parentNode) {
                    animStyle.parentNode.removeChild(animStyle);
                }
                
                // Hide message overlay too
                this.hideMessage();
            }, 1000);
        }, 2000);
    }
    
    /**
     * Checks if a point is within the active arena.
     * This is a compatibility method for player.js boundary checks.
     * Now that we're using direct challenges on the map, this always returns true.
     * @param {THREE.Vector3} position - The position to check
     * @param {number} arenaIndex - The arena index
     * @returns {boolean} - True, since there are no arena boundaries to enforce
     */
    isPointInArena(position, arenaIndex) {
        // Since we're not using arenas anymore, always return true
        // to prevent boundary collision detection from restricting movement
        return true;
    }

    /**
     * Show feedback when player is hit during a duel
     * @param {number} damage - The amount of damage taken
     */
    showHitFeedback(damage) {
        // Create flash effect for hit feedback
        const hitOverlay = document.createElement('div');
        hitOverlay.style.position = 'absolute';
        hitOverlay.style.top = '0';
        hitOverlay.style.left = '0';
        hitOverlay.style.width = '100%';
        hitOverlay.style.height = '100%';
        hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        hitOverlay.style.pointerEvents = 'none';
        hitOverlay.style.zIndex = '999';
        hitOverlay.style.animation = 'hit-flash 0.2s ease-out';
        
        // Add animation style
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes hit-flash {
                0% { opacity: 0.7; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Add to game container
        document.getElementById('game-container').appendChild(hitOverlay);
        
        // Remove overlay after animation
        setTimeout(() => {
            if (hitOverlay.parentNode) {
                hitOverlay.parentNode.removeChild(hitOverlay);
            }
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        }, 200);
        
        // Show damage number
        if (damage > 0) {
            const damageText = document.createElement('div');
            damageText.textContent = `-${damage}`;
            damageText.style.position = 'absolute';
            damageText.style.top = '30%';
            damageText.style.left = '50%';
            damageText.style.transform = 'translate(-50%, -50%)';
            damageText.style.color = '#FF4444';
            damageText.style.fontSize = '32px';
            damageText.style.fontWeight = 'bold';
            damageText.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.7)';
            damageText.style.pointerEvents = 'none';
            damageText.style.zIndex = '1100';
            damageText.style.opacity = '1';
            damageText.style.transition = 'opacity 1s, transform 1s';
            
            document.getElementById('game-container').appendChild(damageText);
            
            // Animate and remove after animation
            setTimeout(() => {
                damageText.style.opacity = '0';
                damageText.style.transform = 'translate(-50%, -100%)';
                
                setTimeout(() => {
                    if (damageText.parentNode) {
                        damageText.parentNode.removeChild(damageText);
                    }
                }, 1000);
            }, 50);
        }
        
        // Play hit sound
        if (this.soundManager) {
            this.soundManager.playSound("hurt", 0.7);
        }
    }

    /**
     * Fix hit zones for players in QuickDraw mode
     */
    fixHitZonesForQuickDraw() {
        // First, try to fix local player's hit zones
        if (window.playersMap && this.localPlayer && this.localPlayer.id) {
            console.log('Fixing hit zones for QuickDraw mode');
            
            // Add local player to playersMap for bullet collision detection
            const localPlayerId = this.localPlayer.id.toString();
            if (!window.playersMap.has(localPlayerId) && this.localPlayerModel) {
                window.playersMap.set(localPlayerId, this.localPlayerModel);
                console.log(`Added local player ${localPlayerId} to players map for hit detection`);
            }
            
            // Make sure opponent is in the playersMap
            if (this.duelOpponentId && !window.playersMap.has(this.duelOpponentId.toString())) {
                // Try to find the opponent in remotePlayers
                if (window.remotePlayers && window.remotePlayers.has(this.duelOpponentId.toString())) {
                    const opponentModel = window.remotePlayers.get(this.duelOpponentId.toString());
                    if (opponentModel) {
                        window.playersMap.set(this.duelOpponentId.toString(), opponentModel);
                        console.log(`Added opponent ${this.duelOpponentId} to players map for hit detection`);
                    }
                }
            }
            
            // Setup hit zones mapping for all players in the map
            for (const [playerId, playerModel] of window.playersMap.entries()) {
                if (playerModel) {
                    // Check if the model has hitboxes but no hitZones mapping
                    if ((playerModel.headHitbox || playerModel.bodyHitbox || playerModel.limbsHitbox) && 
                        !playerModel.hitZones) {
                        
                        console.log(`Creating hitZones mapping for player ${playerId}`);
                        
                        // Create the mapping of hitboxes to hitZones
                        playerModel.hitZones = {
                            head: playerModel.headHitbox,
                            body: playerModel.bodyHitbox,
                            legs: playerModel.limbsHitbox
                        };
                        
                        // Make sure updateHitZones properly updates the hitZones mapping
                        const originalUpdateMethod = playerModel.updateCollisionBox;
                        if (originalUpdateMethod && !playerModel._hitZonesMappingAdded) {
                            playerModel._hitZonesMappingAdded = true;
                            playerModel.updateCollisionBox = function() {
                                // Call the original method first
                                originalUpdateMethod.call(this);
                                
                                // Update the hitZones mapping
                                if (this.hitZones) {
                                    this.hitZones.head = this.headHitbox;
                                    this.hitZones.body = this.bodyHitbox;
                                    this.hitZones.legs = this.limbsHitbox;
                                }
                            };
                            
                            // Force an update
                            playerModel.updateCollisionBox();
                            console.log(`Enhanced updateCollisionBox for player ${playerId} to maintain hitZones mapping`);
                        }
                    }
                }
            }
            
            // Fix visible hit zones for debugging
            if (window.showHitZoneDebug) {
                if (window.physics && typeof window.physics.refreshHitZoneDebug === 'function') {
                    window.physics.refreshHitZoneDebug();
                    console.log('Refreshed hit zone debug visualization');
                }
            }
        }
    }

    /**
     * Handle shooting in Quick Draw mode.
     * This is called when the player fires during a Quick Draw duel.
     */
    handleShoot() {
        // Do not allow shooting if not in the draw phase
        if (this.duelState !== 'draw') {
            console.log('Cannot shoot yet - waiting for draw signal');
            return false;
        }
        
        console.log('Player fired in Quick Draw mode!');
        
        // Check if opponent is visible in the scene
        const opponentId = this.duelOpponentId?.toString();
        if (!opponentId) {
            console.error('No opponent ID found for shooting');
            return false;
        }
        
        // Try to find opponent in players map
        let opponentModel = null;
        let opponentHitZones = null;
        let opponentFound = false;
        
        // First try ALL possible player maps
        const playerMaps = [
            { name: 'playersMap', map: window.playersMap },
            { name: 'remotePlayers', map: window.remotePlayers },
            { name: 'otherPlayers', map: window.otherPlayers }
        ];
        
        // Debug - list all player IDs in all maps
        console.log('DEBUGGING ALL PLAYER MAPS:');
        for (const mapInfo of playerMaps) {
            if (mapInfo.map) {
                console.log(`${mapInfo.name} contents:`);
                for (const [pid, model] of mapInfo.map.entries()) {
                    console.log(`- Player ${pid}: ${model ? 'found' : 'missing'}`);
                    
                    // If this is our opponent, store the model
                    if (pid === opponentId && model && !opponentModel) {
                        console.log(`Found opponent ${opponentId} in ${mapInfo.name}`);
                        opponentModel = model;
                        opponentFound = true;
                        
                        // Add to playersMap for future reference
                        if (window.playersMap && mapInfo.name !== 'playersMap') {
                            window.playersMap.set(opponentId, model);
                        }
                    }
                }
            } else {
                console.log(`${mapInfo.name} not available`);
            }
        }
        
        // Special case: Try to use opponent position data if available
        if (!opponentModel && this.networkManager && this.networkManager.otherPlayers) {
            const opponentData = this.networkManager.otherPlayers.get(opponentId);
            if (opponentData) {
                console.log(`Found opponent ${opponentId} position data in networkManager`);
                opponentFound = true;
                
                // Create emergency model with position
                opponentModel = {
                    id: opponentId,
                    position: new THREE.Vector3(
                        opponentData.position.x,
                        opponentData.position.y,
                        opponentData.position.z
                    ),
                    group: new THREE.Group()
                };
                
                // Position the group
                if (opponentModel.position) {
                    opponentModel.group.position.copy(opponentModel.position);
                }
                
                // Add to scene temporarily
                if (this.scene) {
                    this.scene.add(opponentModel.group);
                    
                    // Schedule removal
                    setTimeout(() => {
                        if (this.scene && opponentModel.group) {
                            this.scene.remove(opponentModel.group);
                        }
                    }, 100);
                }
            }
        }
        
        // If we found an opponent model, check for hit zones
        if (opponentModel) {
            if (opponentModel.hitZones) {
                opponentHitZones = opponentModel.hitZones;
            }
            else if (opponentModel.headHitbox || opponentModel.bodyHitbox || opponentModel.limbsHitbox) {
                // Create hitZones mapping from individual hitboxes
                opponentHitZones = {
                    head: opponentModel.headHitbox,
                    body: opponentModel.bodyHitbox,
                    legs: opponentModel.limbsHitbox
                };
                
                // Store on the model
                opponentModel.hitZones = opponentHitZones;
                console.log('Created hitZones mapping from individual hitboxes');
            }
        }
        
        // If still no model found, log error
        if (!opponentFound) {
            console.error(`Cannot find opponent model for player ${opponentId}`);
            
            // List available players for debug
            console.log('Available players in playersMap:');
            if (window.playersMap) {
                for (const [pid, model] of window.playersMap.entries()) {
                    console.log(`- Player ${pid}: ${model ? 'found' : 'missing'}`);
                }
            }
            
            console.log('Available players in remotePlayers:');
            if (window.remotePlayers) {
                for (const [pid, model] of window.remotePlayers.entries()) {
                    console.log(`- Player ${pid}: ${model ? 'found' : 'missing'}`);
                }
            }
        }
        
        // Check if we have valid hit zones
        if (!opponentHitZones) {
            console.warn(`No hit zones found for opponent ${opponentId}`);
            
            // Emergency fallback - create temporary hit zone for opponent if we have a position
            if (opponentModel && opponentModel.group) {
                console.log('Creating emergency hit zones for opponent');
                
                // Create a simple box hit zone around the opponent
                const boundingBox = new THREE.Box3().setFromObject(opponentModel.group);
                const size = boundingBox.getSize(new THREE.Vector3());
                const center = boundingBox.getCenter(new THREE.Vector3());
                
                // Create a simple hit zone object
                opponentHitZones = {
                    head: new THREE.Box3(
                        new THREE.Vector3(center.x - size.x/4, center.y + size.y/4, center.z - size.x/4),
                        new THREE.Vector3(center.x + size.x/4, center.y + size.y/2, center.z + size.x/4)
                    ),
                    body: new THREE.Box3(
                        new THREE.Vector3(center.x - size.x/3, center.y - size.y/4, center.z - size.x/3),
                        new THREE.Vector3(center.x + size.x/3, center.y + size.y/4, center.z + size.x/3)
                    ),
                    legs: new THREE.Box3(
                        new THREE.Vector3(center.x - size.x/3, center.y - size.y/2, center.z - size.x/3),
                        new THREE.Vector3(center.x + size.x/3, center.y - size.y/4, center.z + size.x/3)
                    )
                };
                
                // Store the hit zones on the model
                opponentModel.hitZones = opponentHitZones;
                console.log('Emergency hit zones created based on model position');
            } 
            else if (opponentFound) {
                // If we have opponent data but no model/group, create basic hit zones based on fixed dimensions
                const opponentPos = opponentModel.position || this.getOpponentPosition() || new THREE.Vector3(0, 2, -10);
                
                if (opponentPos) {
                    const playerHeight = 3.0;
                    const playerWidth = 1.0;
                    
                    // Create basic hit zones at opponent position
                    opponentHitZones = {
                        head: new THREE.Box3(
                            new THREE.Vector3(opponentPos.x - playerWidth/4, opponentPos.y + playerHeight*0.6, opponentPos.z - playerWidth/4),
                            new THREE.Vector3(opponentPos.x + playerWidth/4, opponentPos.y + playerHeight*0.9, opponentPos.z + playerWidth/4)
                        ),
                        body: new THREE.Box3(
                            new THREE.Vector3(opponentPos.x - playerWidth/2, opponentPos.y + playerHeight*0.2, opponentPos.z - playerWidth/2),
                            new THREE.Vector3(opponentPos.x + playerWidth/2, opponentPos.y + playerHeight*0.6, opponentPos.z + playerWidth/2)
                        ),
                        legs: new THREE.Box3(
                            new THREE.Vector3(opponentPos.x - playerWidth/2, opponentPos.y, opponentPos.z - playerWidth/2),
                            new THREE.Vector3(opponentPos.x + playerWidth/2, opponentPos.y + playerHeight*0.2, opponentPos.z + playerWidth/2)
                        )
                    };
                    
                    console.log('Created emergency hit zones based on position data');
                    
                    // Store on the model if we have one
                    if (opponentModel) {
                        opponentModel.hitZones = opponentHitZones;
                    }
                }
            }
        }
        
        // Get bullet direction from player camera
        const camera = this.localPlayer.camera;
        const bulletDirection = new THREE.Vector3(0, 0, -1);
        bulletDirection.applyQuaternion(camera.quaternion);
        
        // Create ray for bullet path (removed mobile-specific offset)
        const bulletOrigin = new THREE.Vector3();
        camera.getWorldPosition(bulletOrigin);
        
        // Offset slightly to account for gun position
        bulletOrigin.add(new THREE.Vector3(
            bulletDirection.x * 0.2,
            bulletDirection.y * 0.2,
            bulletDirection.z * 0.2
        ));
        
        const bulletRay = new THREE.Raycaster(bulletOrigin, bulletDirection, 0, 100);
        
        // Visualize bullet path for debugging
        if (this.debug) {
            const debugEndPoint = bulletOrigin.clone().add(bulletDirection.clone().multiplyScalar(100));
            this.drawBulletPath(bulletOrigin.clone(), debugEndPoint);
        }
        
        // Check for a hit
        let hitZone = null;
        let hitDistance = Infinity;
        let hitDetected = false;
        
        // Check intersection with each hit zone
        if (opponentHitZones) {
            // Check head hit
            if (opponentHitZones.head) {
                const headIntersection = bulletRay.ray.intersectBox(opponentHitZones.head, new THREE.Vector3());
                if (headIntersection) {
                    const distance = headIntersection.distanceTo(bulletOrigin);
                    if (distance < hitDistance) {
                        hitZone = 'head';
                        hitDistance = distance;
                        hitDetected = true;
                        console.log(`HEAD HIT at distance ${distance.toFixed(2)}`);
                    }
                }
            }
            
            // Check body hit
            if (opponentHitZones.body) {
                const bodyIntersection = bulletRay.ray.intersectBox(opponentHitZones.body, new THREE.Vector3());
                if (bodyIntersection) {
                    const distance = bodyIntersection.distanceTo(bulletOrigin);
                    if (distance < hitDistance) {
                        hitZone = 'body';
                        hitDistance = distance;
                        hitDetected = true;
                        console.log(`BODY HIT at distance ${distance.toFixed(2)}`);
                    }
                }
            }
            
            // Check legs hit
            if (opponentHitZones.legs) {
                const legsIntersection = bulletRay.ray.intersectBox(opponentHitZones.legs, new THREE.Vector3());
                if (legsIntersection) {
                    const distance = legsIntersection.distanceTo(bulletOrigin);
                    if (distance < hitDistance) {
                        hitZone = 'legs';
                        hitDistance = distance;
                        hitDetected = true;
                        console.log(`LEGS HIT at distance ${distance.toFixed(2)}`);
                    }
                }
            }
        }
        
        // If we have a hit, send it to the server
        if (hitDetected && hitZone) {
            console.log(`Hit opponent ${opponentId} in the ${hitZone}!`);
            
            // Calculate damage based on hit zone
            let damage = 40; // Default body damage
            if (hitZone === 'head') {
                damage = 100; // One-shot kill for headshot
            } else if (hitZone === 'legs') {
                damage = 25; // Less damage for leg hit
            }
            
            // Send hit to server with hit detection flag
            this.networkManager.sendQuickDrawShoot(opponentId, 0, hitZone, damage, true);
            
            // Show hit marker
            this.showHitMarker(hitZone);
            
            return true;
        } else {
            console.log('Missed the opponent');
            
            // Send miss to server with hit detection flag
            this.networkManager.sendQuickDrawShoot(opponentId, 0, 'miss', 0, true);
            
            return false;
        }
    }

    /**
     * Draw a line representing the bullet path (for debugging)
     */
    drawBulletPath(start, end) {
        // Remove any existing debug line
        if (this.bulletPathLine) {
            this.scene.remove(this.bulletPathLine);
            this.bulletPathLine = null;
        }
        
        // Create line geometry
        const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
        
        // Create line material
        const material = new THREE.LineBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7
        });
        
        // Create line and add to scene
        this.bulletPathLine = new THREE.Line(geometry, material);
        this.scene.add(this.bulletPathLine);
        
        // Auto-remove after 2 seconds
        setTimeout(() => {
            if (this.bulletPathLine) {
                this.scene.remove(this.bulletPathLine);
                this.bulletPathLine = null;
            }
        }, 2000);
    }

    /**
     * Show a hit marker on the screen
     */
    showHitMarker(hitZone) {
        // Create hit marker element if it doesn't exist
        if (!this.hitMarker) {
            this.hitMarker = document.createElement('div');
            this.hitMarker.style.position = 'absolute';
            this.hitMarker.style.top = '50%';
            this.hitMarker.style.left = '50%';
            this.hitMarker.style.transform = 'translate(-50%, -50%)';
            this.hitMarker.style.width = '40px';
            this.hitMarker.style.height = '40px';
            this.hitMarker.style.backgroundImage = 'url("/assets/hitmarker.png")';
            this.hitMarker.style.backgroundSize = 'contain';
            this.hitMarker.style.backgroundRepeat = 'no-repeat';
            this.hitMarker.style.pointerEvents = 'none';
            this.hitMarker.style.zIndex = '1000';
            this.hitMarker.style.opacity = '0';
            this.hitMarker.style.transition = 'opacity 0.1s ease-in-out';
            
            document.body.appendChild(this.hitMarker);
        }
        
        // Set color based on hit zone
        let color = '#ffffff';
        if (hitZone === 'head') {
            color = '#ff0000'; // Red for headshot
            
            // Play headshot sound
            if (window.audioManager) {
                window.audioManager.playSound('headshot', 0.7);
            }
        }
        
        // Set color and show hit marker
        this.hitMarker.style.filter = `brightness(1.5) drop-shadow(0 0 2px ${color})`;
        this.hitMarker.style.opacity = '1';
        
        // Play hit sound
        if (window.audioManager) {
            window.audioManager.playSound('hit_marker', 0.5);
        }
        
        // Hide after a short delay
        setTimeout(() => {
            if (this.hitMarker) {
                this.hitMarker.style.opacity = '0';
            }
        }, 300);
    }

    /**
     * Initialize Quick Draw mode
     */
    init() {
        console.log('Initializing Quick Draw mode');
        this.debug = false;  // Set to true to enable debug logging
        
        // Initialize network handlers
        this.initNetworkHandlers();
        
        // Hook into player shooting actions
        this.hookPlayerShooting();
        
        // Initialize UI elements
        this.initUI();
        
        // Initialize the aerial camera
        this.initAerialCamera();
        
        // Initialize hit zone debugging if needed
        if (this.debug) {
            this.initHitZoneDebugging();
        }
    }

    /**
     * Hook into player shooting actions to handle Quick Draw specific logic
     */
    hookPlayerShooting() {
        // Store original shoot method
        if (this.localPlayer && !this.localPlayer._originalShoot) {
            // Store original shoot method if it exists
            this.localPlayer._originalShoot = this.localPlayer.shoot;
            
            // Override shoot method
            this.localPlayer.shoot = (...args) => {
                // If we're in a duel, handle QuickDraw specific shooting
                if (this.inDuel && this.duelState === 'draw') {
                    console.log('QuickDraw shooting detected');
                    
                    // First check if player is allowed to shoot
                    if (!this.localPlayer.canAim) {
                        console.log('Cannot shoot - player aiming is disabled');
                        return false;
                    }
                    
                    // Check if the opponent should be hit
                    const hitResult = this.handleShoot();
                    
                    // Call original shoot method to handle animations and effects
                    // but with a flag to prevent double processing
                    if (this.localPlayer._originalShoot) {
                        // Create a context object to pass to the original method
                        const shootContext = {
                            _quickDrawProcessed: true,
                            hitResult: hitResult
                        };
                        
                        // Call original with our quickdraw context
                        return this.localPlayer._originalShoot.apply(this.localPlayer, [...args, shootContext]);
                    }
                    
                    return hitResult;
                } else {
                    // Not in QuickDraw - use original shoot method
                    if (this.localPlayer._originalShoot) {
                        return this.localPlayer._originalShoot.apply(this.localPlayer, args);
                    }
                }
                
                return false;
            };
            
            console.log('Hooked player shooting for QuickDraw mode');
        }
        
        // Also hook into the input manager to detect mouse clicks during Quick Draw
        if (window.inputManager && !window.inputManager._quickDrawHooked) {
            // Store original mouse down handler
            const originalMouseDown = window.inputManager.handleMouseDown;
            
            // Override mouse down handler
            window.inputManager.handleMouseDown = (event) => {
                // Call original handler first
                if (originalMouseDown) {
                    originalMouseDown.call(window.inputManager, event);
                }
                
                // Additional QuickDraw specific logic
                if (this.inDuel && this.duelState === 'draw') {
                    // Left mouse button
                    if (event.button === 0) {
                        // Check if player tried to shoot before allowed
                        if (!this.localPlayer.canAim) {
                            console.log('Player tried to shoot too early!');
                            
                            // Apply penalty for shooting too early
                            this.applyEarlyShootPenalty();
                        }
                    }
                }
            };
            
            // Mark as hooked
            window.inputManager._quickDrawHooked = true;
            console.log('Hooked input manager for QuickDraw mode');
        }
    }

    /**
     * Apply penalty for shooting too early
     */
    applyEarlyShootPenalty() {
        console.log('Applying penalty for shooting too early');
        
        // Notify server about penalty
        this.networkManager.sendQuickDrawPenalty();
        
        // Disable aiming for 3 seconds as penalty
        this.localPlayer.canAim = false;
        this.penaltyEndTime = Date.now() + 3000;
        
        // Show penalty message
        this.showMessage('Too Early! Penalty: 3s', 2000, '#ff0000');
        
        // Schedule re-enabling of aiming after penalty time
        setTimeout(() => {
            if (this.inDuel && this.duelState === 'draw') {
                this.localPlayer.canAim = true;
                console.log('Penalty ended, player can now aim');
            }
        }, 3000);
    }

    /**
     * Initialize hit zone debugging if needed
     */
    initHitZoneDebugging() {
        console.log('Initializing hit zone debugging');
        
        // Create toggle button
        const debugButton = document.createElement('button');
        debugButton.innerText = 'Toggle Hit Zones';
        debugButton.style.position = 'absolute';
        debugButton.style.bottom = '10px';
        debugButton.style.right = '10px';
        debugButton.style.zIndex = '1000';
        debugButton.style.padding = '5px 10px';
        debugButton.style.background = 'rgba(0,0,0,0.7)';
        debugButton.style.color = 'white';
        debugButton.style.border = '1px solid #666';
        debugButton.style.borderRadius = '4px';
        
        // Add to DOM
        document.body.appendChild(debugButton);
        
        // Toggle hit zone visualization
        let hitZonesVisible = false;
        debugButton.addEventListener('click', () => {
            hitZonesVisible = !hitZonesVisible;
            debugButton.innerText = hitZonesVisible ? 'Hide Hit Zones' : 'Show Hit Zones';
            
            // Set global flag
            window.showHitZoneDebug = hitZonesVisible;
            
            // Update visualization
            this.visualizeHitZones(hitZonesVisible);
        });
    }

    /**
     * Visualize hit zones for debugging
     */
    visualizeHitZones(show) {
        // Clean up existing visualizations
        if (this.hitZoneHelpers) {
            for (const helper of this.hitZoneHelpers) {
                this.scene.remove(helper);
            }
        }
        
        // Initialize array
        this.hitZoneHelpers = [];
        
        // Exit if not showing
        if (!show) return;
        
        // First, ensure hit zone mappings are created for all players
        this.fixHitZonesForQuickDraw();
        
        // Create helpers for local player model too, if available
        if (this.localPlayerModel) {
            console.log('Visualizing local player hit zones');
            
            // Try hitZones mapping first
            if (this.localPlayerModel.hitZones) {
                for (const [zone, box] of Object.entries(this.localPlayerModel.hitZones)) {
                    const color = zone === 'head' ? 0xff0000 : (zone === 'body' ? 0x00ff00 : 0x0000ff);
                    const helper = new THREE.Box3Helper(box, color);
                    this.scene.add(helper);
                    this.hitZoneHelpers.push(helper);
                }
            } 
            // Fall back to individual hitboxes if available
            else if (this.localPlayerModel.headHitbox || this.localPlayerModel.bodyHitbox || this.localPlayerModel.limbsHitbox) {
                if (this.localPlayerModel.headHitbox) {
                    const helper = new THREE.Box3Helper(this.localPlayerModel.headHitbox, 0xff0000);
                    this.scene.add(helper);
                    this.hitZoneHelpers.push(helper);
                }
                
                if (this.localPlayerModel.bodyHitbox) {
                    const helper = new THREE.Box3Helper(this.localPlayerModel.bodyHitbox, 0x00ff00);
                    this.scene.add(helper);
                    this.hitZoneHelpers.push(helper);
                }
                
                if (this.localPlayerModel.limbsHitbox) {
                    const helper = new THREE.Box3Helper(this.localPlayerModel.limbsHitbox, 0x0000ff);
                    this.scene.add(helper);
                    this.hitZoneHelpers.push(helper);
                }
            }
        }
        
        // Create helpers for our opponent
        const opponentId = this.duelOpponentId?.toString();
        if (opponentId) {
            let opponentModel = null;
            
            // Try different sources for opponent model
            if (window.playersMap && window.playersMap.has(opponentId)) {
                opponentModel = window.playersMap.get(opponentId);
            } else if (window.remotePlayers && window.remotePlayers.has(opponentId)) {
                opponentModel = window.remotePlayers.get(opponentId);
            } else if (window.otherPlayers && window.otherPlayers.has(opponentId)) {
                opponentModel = window.otherPlayers.get(opponentId);
            }
            
            if (opponentModel) {
                console.log('Visualizing opponent hit zones');
                
                // Try hitZones mapping first
                if (opponentModel.hitZones) {
                    for (const [zone, box] of Object.entries(opponentModel.hitZones)) {
                        const color = zone === 'head' ? 0xff0000 : (zone === 'body' ? 0x00ff00 : 0x0000ff);
                        const helper = new THREE.Box3Helper(box, color);
                        this.scene.add(helper);
                        this.hitZoneHelpers.push(helper);
                    }
                } 
                // Fall back to individual hitboxes if available
                else if (opponentModel.headHitbox || opponentModel.bodyHitbox || opponentModel.limbsHitbox) {
                    if (opponentModel.headHitbox) {
                        const helper = new THREE.Box3Helper(opponentModel.headHitbox, 0xff0000);
                        this.scene.add(helper);
                        this.hitZoneHelpers.push(helper);
                    }
                    
                    if (opponentModel.bodyHitbox) {
                        const helper = new THREE.Box3Helper(opponentModel.bodyHitbox, 0x00ff00);
                        this.scene.add(helper);
                        this.hitZoneHelpers.push(helper);
                    }
                    
                    if (opponentModel.limbsHitbox) {
                        const helper = new THREE.Box3Helper(opponentModel.limbsHitbox, 0x0000ff);
                        this.scene.add(helper);
                        this.hitZoneHelpers.push(helper);
                    }
                }
                // If no hit zones, try to create them
                else if (opponentModel.group) {
                    console.log('Creating on-the-fly hit zones for visualization');
                    
                    // Calculate bounding box from the model
                    const boundingBox = new THREE.Box3().setFromObject(opponentModel.group);
                    const size = boundingBox.getSize(new THREE.Vector3());
                    const center = boundingBox.getCenter(new THREE.Vector3());
                    
                    // Create basic hitboxes for visualization
                    const headBox = new THREE.Box3(
                        new THREE.Vector3(center.x - size.x/4, center.y + size.y/4, center.z - size.x/4),
                        new THREE.Vector3(center.x + size.x/4, center.y + size.y/2, center.z + size.x/4)
                    );
                    
                    const bodyBox = new THREE.Box3(
                        new THREE.Vector3(center.x - size.x/3, center.y - size.y/4, center.z - size.x/3),
                        new THREE.Vector3(center.x + size.x/3, center.y + size.y/4, center.z + size.x/3)
                    );
                    
                    const legsBox = new THREE.Box3(
                        new THREE.Vector3(center.x - size.x/3, center.y - size.y/2, center.z - size.x/3),
                        new THREE.Vector3(center.x + size.x/3, center.y - size.y/4, center.z + size.x/3)
                    );
                    
                    // Create helpers
                    const headHelper = new THREE.Box3Helper(headBox, 0xff0000);
                    const bodyHelper = new THREE.Box3Helper(bodyBox, 0x00ff00);
                    const legsHelper = new THREE.Box3Helper(legsBox, 0x0000ff);
                    
                    // Add to scene
                    this.scene.add(headHelper);
                    this.scene.add(bodyHelper);
                    this.scene.add(legsHelper);
                    
                    // Track helpers
                    this.hitZoneHelpers.push(headHelper, bodyHelper, legsHelper);
                }
            }
        }
    }

    /**
     * Handle countdown notification from server.
     * @param {Object} message - The countdown message
     */
    handleCountdown(message) {
        console.log('Received countdown notification from server');
        this.startDuelCountdown();
    }

    /**
     * Handle kill notification from server.
     * @param {Object} message - The kill message
     */
    handleKill(message) {
        console.log(`You killed player ${message.targetId}`);
        
        // Set death/kill animation flag
        this.inDeathOrKillAnimation = true;
        
        // Show kill message
        this.showMessage('KILL!', 1500, '#00FF00');
        
        // Play kill sound
        if (this.soundManager) {
            this.soundManager.playSound("kill", 0.7);
        }
        
        // Create kill effect
        this.createKillEffect();
        
        // Ensure the local player's camera remains active
        if (window.renderer && this.localPlayer) {
            window.renderer.camera = this.localPlayer.camera;
            
            // Also set the instance camera if available
            if (window.renderer.instance) {
                window.renderer.instance.camera = this.localPlayer.camera;
            }
        }
        
        // Clear animation flag after a delay
        setTimeout(() => {
            this.inDeathOrKillAnimation = false;
        }, 3000); // Enough time for death animation to complete
    }

    /**
     * Handle death notification from server.
     * @param {Object} message - The death message
     */
    handleDeath(message) {
        console.log(`You were killed by player ${message.killerId}`);
        
        // Set death/kill animation flag to prevent camera switching
        this.inDeathOrKillAnimation = true;
        
        // Skip showing "YOU DIED" message if this is a duel death (we'll show DEFEAT instead)
        if (!this.inDuel) {
            // Show death message only for non-duel deaths
            this.showMessage('YOU DIED', 1500, '#FF0000');
        }
        
        // Play death sound
        if (this.soundManager) {
            this.soundManager.playSound("death", 0.7);
        }
        
        // Create death effect
        this.createDeathEffect();
        
        // Make sure we have a local player model for the death animation
        if (!this.localPlayerModel) {
            this.createLocalPlayerModel();
        }
        
        // Store original mouse handler for later restoration
        const origMouseMove = document.onmousemove;
        
        // Keep the player's POV camera active during death
        if (this.localPlayerModel) {
            // Force the local player's camera to be active
            if (window.renderer) {
                window.renderer.camera = this.localPlayer.camera;
                
                // Also set the instance camera if available
                if (window.renderer.instance) {
                    window.renderer.instance.camera = this.localPlayer.camera;
                }
            }
            
            // Save original camera rotation
            const originalRotation = this.localPlayer.camera.rotation.clone();
            
            // Apply death camera rotation - rotate camera to look down at the ground
            // Start a smooth rotation animation from current position to looking down
            const deathCameraDuration = 1000; // 1 second for the rotation animation
            const startTime = Date.now();
            const targetRotationX = Math.PI / 2; // Looking down at the ground (90 degrees) instead of up
            
            // Create an animation function that rotates the camera over time
            const rotateCameraUp = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / deathCameraDuration, 1);
                
                // Use an easing function (ease-out) for smoother animation
                const easeOut = 1 - Math.pow(1 - progress, 2);
                
                // Interpolate between original and target rotation
                this.localPlayer.camera.rotation.x = originalRotation.x * (1 - easeOut) + targetRotationX * easeOut;
                
                // Continue the animation until complete
                if (progress < 1) {
                    requestAnimationFrame(rotateCameraUp);
                }
            };
            
            // Start the camera rotation animation
            rotateCameraUp();
            
            // Make the model visible for other players but not in our own view
            this.localPlayerModel.group.visible = true;
            
            // Play the death animation
            if (this.localPlayerModel.playDeathAnimation) {
                console.log('[QuickDraw] Playing death animation');
                const deathResult = this.localPlayerModel.playDeathAnimation();
                
                // Play the player fall sound when death animation starts
                if (this.soundManager) {
                    this.soundManager.playSound("playerfall", 0, 0.8);
                }
                
                // Allow the death animation to complete before reset/respawn
                const deathAnimDuration = deathResult.duration || 1500;
                
                // Disable player controls during death animation
                if (this.localPlayer) {
                    this.localPlayer.canMove = false;
                    this.localPlayer.canAim = false;
                    this.localPlayer.forceLockMovement = true;
                    
                    // Disable mouse look temporarily to prevent camera movement
                    document.onmousemove = (e) => {
                        // Block mouse movement during death animation
                        e.stopPropagation();
                        return false;
                    };
                }
                
                // Wait for animation to complete before server sends respawn
                console.log(`[QuickDraw] Death animation playing, duration: ${deathAnimDuration}ms`);
                
                // Clear animation flag after animation completes
                setTimeout(() => {
                    this.inDeathOrKillAnimation = false;
                }, deathAnimDuration + 500); // Add a bit of buffer
                
                // The server will send fullStateReset message after the animation duration
                // We're ensuring the animation has time to play fully
                
                // Broadcast our death animation state to other players
                if (this.networkManager && this.networkManager.socket) {
                    this.networkManager.socket.send(JSON.stringify({
                        type: 'playerUpdate',
                        isDying: true,  // Special flag to trigger death animation on other clients
                        health: 0,
                        position: this.localPlayer.group.position,
                        rotation: { y: this.localPlayer.group.rotation.y }
                    }));
                    console.log('[QuickDraw] Broadcast death animation state to other players');
                }
            } else {
                console.warn('[QuickDraw] Death animation not available on player model');
                
                // Clear animation flag after a default delay if no animation
                setTimeout(() => {
                    this.inDeathOrKillAnimation = false;
                }, 3000);
            }
        } else {
            console.warn('[QuickDraw] Could not create local player model for death animation');
            
            // Clear animation flag after a default delay if no model
            setTimeout(() => {
                this.inDeathOrKillAnimation = false;
            }, 3000);
        }
    }

    /**
     * Handle duel result notification from server.
     * @param {Object} message - The result message
     */
    handleResult(message) {
        console.log(`[QuickDraw] Duel ended. Winner: ${message.winnerId}`);
        
        // Show the victory/defeat screen and visual effects
        this.endDuel(message.winnerId);
        
        // We no longer need to manually manage death animations here
        // because the server will send playerDeath, death, and kill messages
        // which will be handled by the existing handlers
        console.log('[QuickDraw] Death animation will be handled by standard death/kill handlers');
        
        // The server will send a respawn message after the death animation completes
    }
    
    /**
     * Reset all player state variables
     */
    resetPlayerState() {
        if (!this.localPlayer) return;
        
        console.log('[QuickDraw] Resetting player state completely');
        
        // Reset movement flags
        this.localPlayer.canMove = true;
        this.localPlayer.canAim = true;
        this.localPlayer.forceLockMovement = false;
        this.localPlayer.forceLockRotation = false;
        
        // Reset weapon state
        this.localPlayer.isAiming = false;
        this.localPlayer.isReloading = false;
        this.localPlayer.isShooting = false;
        this.localPlayer.bullets = this.localPlayer.maxBullets || 6;
        
        // Reset health
        this.localPlayer.health = 100;
        
        // Reset animation state if there's a viewmodel
        if (this.localPlayer.viewmodel) {
            this.localPlayer.viewmodel.visible = true;
            
            // Reset gun position to holster
            if (this.localPlayer.currentGunOffset && this.localPlayer.holsterOffset) {
                this.localPlayer.currentGunOffset.copy(this.localPlayer.holsterOffset);
            }
            
            // Clear any ongoing gun animation
            if (this.localPlayer.gunAnimation) {
                this.localPlayer.gunAnimation.reset();
                this.localPlayer.gunAnimation = null;
            }
        }
        
        // Reset any original movement methods that might have been backed up
        if (this.localPlayer._origMove) {
            this.localPlayer.move = this.localPlayer._origMove;
            this.localPlayer._origMove = null;
        }
        
        // Ensure player nametags are restored
        this.restorePlayerNametags();
        
        // Ensure letterbox effect is removed
        document.body.classList.remove('letterbox-active');
        
        // Reset quickdraw specific state
        this.inDuel = false;
        this.inLobby = false;
        this.duelState = 'none';
        this.duelOpponentId = null;
        this.duelActive = false;
        
        // Update UI
        if (typeof updateHealthUI === 'function') {
            updateHealthUI(this.localPlayer);
        }
        
        console.log('[QuickDraw] Player state reset complete');
    }
    
    /**
     * Respawn player at a random town position
     */
    respawnPlayerInTown() {
        if (!this.localPlayer) return;
        
        console.log('[QuickDraw] Respawning player in town');
        
        // Use the scene's spawn function if available
        if (this.scene && this.scene.spawnPlayer) {
            this.scene.spawnPlayer(this.localPlayer, true);
            console.log('[QuickDraw] Player respawned using scene spawnPlayer');
        } else {
            // Fallback: manual respawn at a random town position
            const townWidth = 60;  // Taken from GAME_CONSTANTS on server
            const townLength = 100; // Taken from GAME_CONSTANTS on server
            
            // Generate random position within town bounds
            const spawnX = (Math.random() - 0.5) * townWidth * 0.8;
            const spawnY = 1.6; // Standard player height
            const spawnZ = (Math.random() - 0.5) * townLength * 0.8;
            
            // Set player position
            this.localPlayer.group.position.set(spawnX, spawnY, spawnZ);
            console.log(`[QuickDraw] Player respawned at random town position: (${spawnX.toFixed(2)}, ${spawnY.toFixed(2)}, ${spawnZ.toFixed(2)})`);
        }
        
        // Reset velocity (especially important for y velocity)
        this.localPlayer.velocity = new THREE.Vector3(0, 0, 0);
        
        // Ensure the local player's camera is active
        if (this.scene && this.scene.renderer) {
            this.scene.renderer.camera = this.localPlayer.camera;
            this.scene.renderer.overrideCamera = null;
        }
        
        // Remove any third-person model of the local player
        this.removeLocalPlayerModel();
    }
    
    /**
     * Remove the local player's third-person model if it exists
     */
    removeLocalPlayerModel() {
        if (this.localPlayerModel) {
            console.log('[QuickDraw] Removing local player model');
            
            // Reset animation states to ensure clean state for next use
            this.localPlayerModel.isDying = false;
            this.localPlayerModel.isAiming = false;
            this.localPlayerModel.isShooting = false;
            this.localPlayerModel.isWalking = false;
            this.localPlayerModel.isRunning = false;
            
            // Clean up any active animations
            if (this.localPlayerModel.mixer) {
                this.localPlayerModel.mixer.stopAllAction();
            }
            
            if (this.localPlayerModel.animations) {
                for (const actionName in this.localPlayerModel.animations) {
                    const action = this.localPlayerModel.animations[actionName];
                    if (action && action.stop) {
                        action.stop();
                    }
                }
            }
            
            if (this.localPlayerModel.group) {
                // Remove from scene if it's part of the scene
                if (this.localPlayerModel.group.parent) {
                    this.localPlayerModel.group.parent.remove(this.localPlayerModel.group);
                }
                
                // Or try removing directly from scene
                if (this.scene && this.scene.children) {
                    this.scene.remove(this.localPlayerModel.group);
                }
            }
            
            // Dispose of all resources
            if (typeof this.localPlayerModel.dispose === 'function') {
                this.localPlayerModel.dispose();
            }
            
            // Clear the reference
            this.localPlayerModel = null;
        }
    }
    
    /**
     * Send a message to all clients to reset this player's state
     */
    sendPlayerStateReset() {
        if (!this.networkManager || !this.localPlayer) return;
        
        console.log('[QuickDraw] Broadcasting player state reset to all clients');
        
        try {
            // Send a full player state update with reset values
            this.networkManager.socket.send(JSON.stringify({
                type: 'playerUpdate',
                position: this.localPlayer.group.position,
                rotation: { y: this.localPlayer.group.rotation.y },
                isAiming: false,
                isReloading: false,
                health: 100,
                quickDrawLobbyIndex: -1,  // Not in any quickdraw lobby
                fullReset: true  // Special flag to indicate a full state reset
            }));
            
            console.log('[QuickDraw] Player state reset broadcast complete');
        } catch (error) {
            console.error('[QuickDraw] Error sending player state reset:', error);
        }
    }

    /**
     * Create a visual effect when player gets a kill
     */
    createKillEffect() {
        // Create a green flash to indicate kill
        const killFlash = document.createElement('div');
        killFlash.style.position = 'absolute';
        killFlash.style.top = '0';
        killFlash.style.left = '0';
        killFlash.style.width = '100%';
        killFlash.style.height = '100%';
        killFlash.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
        killFlash.style.pointerEvents = 'none';
        killFlash.style.zIndex = '999';
        killFlash.style.animation = 'kill-flash 0.5s ease-out';
        
        // Add animation style
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes kill-flash {
                0% { opacity: 0.5; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
        
        // Add to game container
        document.getElementById('game-container').appendChild(killFlash);
        
        // Remove after animation
        setTimeout(() => {
            if (killFlash.parentNode) {
                killFlash.parentNode.removeChild(killFlash);
            }
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        }, 500);
    }

    /**
     * Create a visual effect when player dies
     */
    createDeathEffect() {
        // Create a red vignette effect for death
        const deathOverlay = document.createElement('div');
        deathOverlay.style.position = 'absolute';
        deathOverlay.style.top = '0';
        deathOverlay.style.left = '0';
        deathOverlay.style.width = '100%';
        deathOverlay.style.height = '100%';
        deathOverlay.style.background = 'radial-gradient(ellipse at center, rgba(0,0,0,0) 0%,rgba(255,0,0,0.5) 100%)';
        deathOverlay.style.pointerEvents = 'none';
        deathOverlay.style.zIndex = '999';
        deathOverlay.style.opacity = '0';
        deathOverlay.style.animation = 'death-fade 1s ease-in forwards';
        
        // Add animation style
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes death-fade {
                0% { opacity: 0; }
                100% { opacity: 1; }
            }
        `;
        document.head.appendChild(style);
        
        // Add to game container
        document.getElementById('game-container').appendChild(deathOverlay);
        
        // Remove after animation (longer for death effect)
        setTimeout(() => {
            if (deathOverlay.parentNode) {
                deathOverlay.parentNode.removeChild(deathOverlay);
            }
            if (style.parentNode) {
                style.parentNode.removeChild(style);
            }
        }, 1500);
    }

    /**
     * Disable and remove the aerial camera.
     */
    disableAerialCamera() {
        console.log('[QuickDraw] Disabling aerial camera');
        
        // Set active flag to false first
        this.aerialCameraActive = false;
        
        // Deactivate eagle POV camera if active
        if (window.flyingEagle) {
            window.flyingEagle.deactivateAerialCamera();
            
            // Return the eagle to its default path around the town
            window.flyingEagle.returnToDefaultPath();
        }
        
        // Remove camera from scene
        if (this.aerialCamera) {
            console.log('[QuickDraw] Removing aerial camera from scene');
            
            // Remove from parent if attached
            if (this.aerialCamera.parent) {
                this.aerialCamera.parent.remove(this.aerialCamera);
            }
            // Or try removing directly from scene
            else if (this.scene && this.scene.scene) {
                this.scene.scene.remove(this.aerialCamera);
            }
            
            // Clear reference to camera
            this.aerialCamera = null;
        }
        
        // If we're not in death animation, restore original camera
        if (!this.inDeathOrKillAnimation && this.localPlayer && this.localPlayer.camera) {
            // Force switch back to player camera if not in death animation
            if (window.renderer) {
                window.renderer.camera = this.localPlayer.camera;
                
                if (window.renderer.instance) {
                    window.renderer.instance.camera = this.localPlayer.camera;
                }
            }
        }
        
        // Reset path set flag so it will be re-initialized for the next match
        this.aerialCameraPathSet = false;
    }

    /**
     * Initialize UI elements for QuickDraw mode
     */
    initUI() {
        // Skip if UI was already created
        if (this.messageOverlay) return;
        
        console.log('Initializing QuickDraw UI');
        
        // Create main UI elements
        this.createUI();
        
        // Create challenge UI elements
        this.createChallengeUI();
    }

    /**
     * Initialize aerial camera for duel mode
     */
    initAerialCamera() {
        // Create aerial camera if it doesn't exist
        if (!this.aerialCamera) {
            console.log('Creating aerial camera for QuickDraw duels');
            
            this.aerialCamera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            
            if (this.scene) {
                this.scene.add(this.aerialCamera);
            } else {
                console.error('Cannot add aerial camera - scene not available');
            }
        }
        
        // Initialize flying eagle for aerial camera if it doesn't exist
        if (!window.flyingEagle) {
            console.log('Initializing flying eagle for QuickDraw aerial view');
            window.flyingEagle = new FlyingEagle({
                scene: this.scene,
                camera: this.aerialCamera
            });
            
            // Set default town center
            const townCenter = new THREE.Vector3(0, 0, 0);
            window.flyingEagle.townCenter = townCenter;
            window.flyingEagle.setDefaultFlightPath();
        }
    }

    /**
     * Create a timeout that will be automatically cleared on cleanup
     * to prevent lingering effects when a duel ends prematurely.
     */
    createDuelTimeout(callback, delay) {
        // Initialize the array if it doesn't exist
        if (!this._duelTimers) {
            this._duelTimers = [];
        }
        
        // Create the timeout and store its ID
        const timerId = setTimeout(() => {
            // Remove this timer from the tracking array once it completes
            if (this._duelTimers) {
                const index = this._duelTimers.indexOf(timerId);
                if (index !== -1) {
                    this._duelTimers.splice(index, 1);
                }
            }
            
            // Execute the callback safely
            try {
                callback();
            } catch (error) {
                console.error('[QuickDraw] Error in timeout callback:', error);
            }
        }, delay);
        
        // Add this timer to our tracking array
        this._duelTimers.push(timerId);
        console.log(`[QuickDraw] Created duel timeout #${timerId}, total active: ${this._duelTimers.length}`);
        
        return timerId;
    }

    /**
     * Clear all duel-related timers to prevent lingering effects
     */
    clearAllDuelTimers() {
        if (!this._duelTimers) {
            return;
        }
        
        console.log(`[QuickDraw] Clearing all ${this._duelTimers.length} duel timers`);
        
        // Clear each timer and track how many we actually cleared
        let clearedCount = 0;
        const timersCopy = [...this._duelTimers]; // Create a copy to avoid modification issues
        
        for (const timerId of timersCopy) {
            clearTimeout(timerId);
            clearedCount++;
        }
        
        // Reset the array
        this._duelTimers = [];
        
        console.log(`[QuickDraw] Cleared ${clearedCount} duel timers`);
    }

    /**
     * Helper to show a message in the center of the screen.
     * @param {string} message - The message to display
     * @param {number} duration - How long to show the message (in ms)
     * @param {string} color - Optional color for the message text
     */
    showMessage(message, duration = 0, color = '') {
        // Check if messageOverlay exists
        if (!this.messageOverlay) {
            console.log('[QuickDraw] Creating missing messageOverlay for showMessage');
            // Text overlay for messages
            this.messageOverlay = document.createElement('div');
            this.messageOverlay.id = 'quick-draw-message';
            this.messageOverlay.style.position = 'absolute';
            this.messageOverlay.style.top = '50%';
            this.messageOverlay.style.left = '50%';
            this.messageOverlay.style.transform = 'translate(-50%, -50%)';
            this.messageOverlay.style.color = 'white';
            this.messageOverlay.style.fontSize = '48px';
            this.messageOverlay.style.fontWeight = 'bold';
            this.messageOverlay.style.textAlign = 'center';
            this.messageOverlay.style.display = 'none';
            this.messageOverlay.style.fontFamily = 'Western, Arial, sans-serif';
            this.messageOverlay.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
            this.messageOverlay.style.zIndex = '1000';
            document.getElementById('game-container').appendChild(this.messageOverlay);
        }
        
        // Set message text
        this.messageOverlay.textContent = message;
        
        // Set color if provided
        if (color) {
            this.messageOverlay.style.color = color;
        } else {
            this.messageOverlay.style.color = '#FFFFFF'; // Default to white
        }
        
        // Show the message
        this.messageOverlay.style.display = 'block';
        
        // Hide after specified duration
        if (duration > 0) {
            this.createDuelTimeout(() => {
                this.hideMessage();
            }, duration);
        }
    }

    /**
     * Hide the message overlay.
     */
    hideMessage() {
        if (this.messageOverlay) {
            this.messageOverlay.style.display = 'none';
        }
    }

    /**
     * Use raycast to find the proper ground level at the given position
     * @param {Object} position - The position to check (x, z coordinates)
     * @returns {number} - The ground height at that position
     */
    findGroundHeight(position) {
        // Default ground level is 0 (flat town area)
        let groundHeight = 0;
        
        // Check if we have physics and terrain systems available
        if (window.physics) {
            // First check for terrain height (desert dunes, etc.)
            const terrainHeight = window.physics.getTerrainHeightAt(position.x, position.z);
            groundHeight = Math.max(groundHeight, terrainHeight);
            
            // Check the physics bodies to find any platform/structure at this position
            if (window.physics.bodies) {
                // Create ray start position high above the potential ground
                const rayStart = new THREE.Vector3(position.x, 50, position.z);
                
                // Check each physics body
                for (const body of window.physics.bodies) {
                    // Skip irrelevant bodies
                    if (body.arenaBoundary || body.mass > 0) continue;
                    
                    // Currently we only handle box shapes
                    for (let i = 0; i < body.shapes.length; i++) {
                        const shape = body.shapes[i];
                        if (shape.type !== CANNON.Shape.types.BOX) continue;
                        
                        // Get shape properties
                        const shapePos = new CANNON.Vec3();
                        body.pointToWorldFrame(body.shapeOffsets[i], shapePos);
                        
                        // Convert to THREE.js
                        const boxPos = new THREE.Vector3(shapePos.x, shapePos.y, shapePos.z);
                        const boxSize = new THREE.Vector3(
                            shape.halfExtents.x * 2,
                            shape.halfExtents.y * 2,
                            shape.halfExtents.z * 2
                        );
                        
                        // Check if the ray passes through this box horizontally
                        const margin = 0.5; // Small margin for precision
                        if (Math.abs(position.x - boxPos.x) <= boxSize.x/2 + margin && 
                            Math.abs(position.z - boxPos.z) <= boxSize.z/2 + margin) {
                            
                            // Get top of box
                            const topOfBox = boxPos.y + boxSize.y/2;
                            
                            // If this box is higher than current ground level, update it
                            // But only if the ray from above would hit it first
                            if (topOfBox > groundHeight && topOfBox < rayStart.y) {
                                groundHeight = topOfBox;
                                console.log(`[QuickDraw] Found elevated ground at ${groundHeight.toFixed(2)} (box: ${boxPos.x.toFixed(2)}, ${boxPos.y.toFixed(2)}, ${boxPos.z.toFixed(2)})`);
                            }
                        }
                    }
                }
            }
        }
        
        console.log(`[QuickDraw] Ground height at (${position.x.toFixed(2)}, ${position.z.toFixed(2)}) is ${groundHeight.toFixed(2)}`);
        return groundHeight;
    }

    /**
     * Properly ground a player at the specified position
     * @param {Object} position - The position to start with (will be modified)
     * @returns {Object} - The corrected position with proper eye height above ground
     */
    groundPlayerPosition(position) {
        if (!position) return position;
        
        // First find the actual ground height at this position
        const groundHeight = this.findGroundHeight(position);
        
        // Set the player's eye level to be exactly 2.72 units above ground
        const groundedPosition = {
            x: position.x,
            y: groundHeight + 2.72, // Standard eye level above ground
            z: position.z
        };
        
        console.log(`[QuickDraw] Grounded player position:`, 
            `Original: (${position.x.toFixed(2)}, ${position.y ? position.y.toFixed(2) : 'N/A'}, ${position.z.toFixed(2)})`,
            `Grounded: (${groundedPosition.x.toFixed(2)}, ${groundedPosition.y.toFixed(2)}, ${groundedPosition.z.toFixed(2)})`);
        
        return groundedPosition;
    }

    /**
     * Reset player state and respawn them at a random town position
     * @param {Object} message - The reset message from the server
     */
    resetPlayerAndRespawn(message) {
        console.log('[QuickDraw] Executing comprehensive player reset and respawn');
        
        if (!this.localPlayer) return;
        
        // First, clear all match UI elements
        this.clearMatchUI();
        
        // Clear any active timers
        this.clearAllDuelTimers();
        
        // Reset all player movement control flags
        this.localPlayer.canMove = true;
        this.localPlayer.canAim = true;
        this.localPlayer.forceLockMovement = false;
        this.localPlayer.forceLockRotation = false;
        
        // Reset weapon state
        this.localPlayer.isAiming = false;
        this.localPlayer.isReloading = false;
        this.localPlayer.isShooting = false;
        
        // Set bullets and health from server message
        this.localPlayer.health = message.health || 100;
        this.localPlayer.bullets = message.bullets || this.localPlayer.maxBullets || 6;
        
        // Reset any original movement methods that might have been backed up
        if (this.localPlayer._origMove) {
            console.log('[QuickDraw] Restoring original move method');
            this.localPlayer.move = this.localPlayer._origMove;
            this.localPlayer._origMove = null;
        }
        
        // Disable aerial camera completely
        this.disableAerialCamera();
        
        // Ensure the player camera is the active camera
        if (this.scene && this.scene.renderer) {
            this.scene.renderer.overrideCamera = null;
            this.scene.renderer.camera = this.localPlayer.camera;
        }
        
        // Reset all quickdraw state flags
        this.inDuel = false;
        this.inLobby = false;
        this.duelState = 'none';
        this.duelOpponentId = null;
        this.duelActive = false;
        this.aerialCameraPathSet = false;
        
        // Remove local player model
        this.removeLocalPlayerModel();
        
        // Reset gun and animation state
        if (this.localPlayer.viewmodel) {
            console.log('[QuickDraw] Resetting gun state');
            this.localPlayer.viewmodel.visible = true;
            
            // Reset gun position to holster
            if (this.localPlayer.currentGunOffset && this.localPlayer.holsterOffset) {
                this.localPlayer.currentGunOffset.copy(this.localPlayer.holsterOffset);
            }
            
            // Clear any ongoing gun animation
            if (this.localPlayer.gunAnimation) {
                this.localPlayer.gunAnimation.reset();
                this.localPlayer.gunAnimation = null;
            }
        }
        
        // Set player position from server message
        if (message.position) {
            // Apply the position
            this.localPlayer.group.position.set(
                message.position.x,
                message.position.y,
                message.position.z
            );
            console.log(`[QuickDraw] Player respawned at position: (${message.position.x.toFixed(2)}, ${message.position.y.toFixed(2)}, ${message.position.z.toFixed(2)})`);
            
            // Reset velocity (especially important for y velocity)
            this.localPlayer.velocity = new THREE.Vector3(0, 0, 0);
        }
        
        // Update UI
        if (typeof updateHealthUI === 'function') {
            updateHealthUI(this.localPlayer);
        }
        
        // Broadcast our full reset to other clients to ensure our model is refreshed on their end
        this.sendPlayerStateReset();
        
        console.log('[QuickDraw] Player reset and respawn complete');
    }

    /**
     * Clear all match UI elements
     */
    clearMatchUI() {
        console.log('[QuickDraw] Clearing match UI elements');
        
        // Hide message overlay
        this.hideMessage();
        
        // Hide draw circle
        if (this.drawCircle) {
            this.drawCircle.style.display = 'none';
        }
        
        // Hide status indicator
        if (this.statusIndicator) {
            this.statusIndicator.style.display = 'none';
        }
        
        // Hide health bar
        if (this.healthBarContainer) {
            this.healthBarContainer.style.display = 'none';
        }
        
        // Restore player nametags
        this.restorePlayerNametags();
    }

    /**
     * Cleanup method for use before unloading the page or resetting the game.
     * This ensures all UI elements, timers, and state are properly cleaned up.
     */
    cleanup() {
        console.log('[QuickDraw] Cleaning up QuickDraw instance');
        
        // Always restore nametags when cleaning up
        this.restorePlayerNametags();
        
        // Ensure letterbox effect is removed
        document.body.classList.remove('letterbox-active');
        
        // Clear all duel-related timers
        this.clearAllDuelTimers();
        
        // Reset player state if we have a local player
        if (this.localPlayer) {
            this.resetPlayerState();
        }
        
        // Ensure aerial camera is disabled
        this.disableAerialCamera();
        
        // Reset all state variables
        this.inDuel = false;
        this.inLobby = false;
        this.duelState = 'none';
        this.duelOpponentId = null;
        this.pendingChallenge = null;
        this.duelActive = false;
        
        // Hide UI elements
        this.hideMessage();
        if (this.statusIndicator) this.statusIndicator.style.display = 'none';
        if (this.drawCircle) this.drawCircle.style.display = 'none';
        if (this.healthBarContainer) this.healthBarContainer.style.display = 'none';
        if (this.challengePrompt) this.challengePrompt.style.display = 'none';
        
        console.log('[QuickDraw] Cleanup complete');
    }

    /**
     * Hide all player nametags during a duel
     */
    hidePlayerNametags() {
        // Check if we have access to the multiplayerManager
        if (!window.multiplayerManager) {
            console.warn('[QuickDraw] Cannot hide nametags - multiplayerManager not available');
            return;
        }
        
        console.log(`[QuickDraw] Hiding ALL nametags during quickdraw duel using global control`);
        
        // Use the new global method to disable all nametags
        window.multiplayerManager.setAllNametagsVisible(false);
    }
    
    /**
     * Restore all hidden nametags after duel
     */
    restorePlayerNametags() {
        // Check if we have access to the multiplayerManager
        if (!window.multiplayerManager) return;
        
        console.log('[QuickDraw] Restoring ALL nametags after duel using global control');
        
        // Use the new global method to enable all nametags
        window.multiplayerManager.setAllNametagsVisible(true);
    }

    /**
     * Ensures we have access to the MultiplayerManager for nametag control
     */
    ensureMultiplayerManagerAccess() {
        // Check if window.multiplayerManager is already set
        if (!window.multiplayerManager) {
            console.warn('[QuickDraw] MultiplayerManager not available yet - will retry later');
            
            // Set up a retry check after a short delay
            setTimeout(() => {
                if (!window.multiplayerManager) {
                    console.warn('[QuickDraw] MultiplayerManager still not available - nametag control will be limited');
                } else {
                    console.log('[QuickDraw] MultiplayerManager now available - nametag control enabled');
                }
            }, 2000);
        } else {
            console.log('[QuickDraw] MultiplayerManager available - nametag control enabled');
        }
    }
}

================================================
File: /public/js/scene.js
================================================
// /public/js/scene.js
export let scene;
import { DesertTerrain } from './desertTerrain.js';
import { TumbleweedManager } from './tumbleweed.js';

// Adding skybox references for animation
let skyMesh;
let groundMesh;
const SKYBOX_ROTATION_SPEED = 0.00001; // Much slower rotation speed

// Add tumbleweed manager
let tumbleweedManager;

// Add train animation components
let train;
let trainPath;
let trainProgress = 0;
// Time-based train tracking
let trainStartTime = 0; // Global reference time when train started
let trainCycleTime = 0; // Time in ms for a full one-way trip
let trainSpeed = 0.0003; // Speed received from server
let trainTrackLength = 2000; // Track length (matching server)
let trainDirection = 1; // Current direction

// Position the track along Z axis
const TRAIN_TRACK_START = new THREE.Vector3(0, 0, -1000);
const TRAIN_TRACK_END = new THREE.Vector3(0, 0, 1000);

// Flag to control if train has been initialized from server
let trainInitialized = false;
let trainLogMessages = true; // Control train update logs

// Make train track endpoints globally available for terrain system
window.TRAIN_TRACK_START = TRAIN_TRACK_START;
window.TRAIN_TRACK_END = TRAIN_TRACK_END;

// Add texture state tracking
const texturesLoaded = {
  skyLoaded: false,
  groundLoaded: false,
  skyAttempts: 0,
  groundAttempts: 0
};

// Track FPS updates
let fpsUpdateCounter = 0;

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {Object} - Contains the camera and renderer.
 */
export function initScene() {
  scene = new THREE.Scene();
  
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // Set output encoding for consistent lighting and color reproduction.
  renderer.outputEncoding = THREE.sRGBEncoding;

  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) {
    throw new Error("Game container not found in HTML.");
  }
  gameContainer.appendChild(renderer.domElement);

  // Initialize with a desert sand color instead of blue
  scene.background = new THREE.Color(0xec9e5c);
  
  // Preload textures before creating skybox
  THREE.Cache.enabled = true;
  // Start loading skybox immediately
  preloadSkyboxTextures(() => {
    // Load the two skybox parts after preloading
    loadTwoPartSkybox();
  });
  
  // Change fog color to match desert colors instead of blue
  const desertFogColor = new THREE.Color(0xec9e5c); // Desert sand color
  scene.fog = new THREE.Fog(desertFogColor, 250, 900); // Increased fog distances

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  // Increase ambient light intensity and warm it up to match desert environment
  const ambientLight = new THREE.AmbientLight(0xffebc8, 0.6);
  scene.add(ambientLight);

  // Adjust directional light to be softer and more diffused for desert environment
  const directionalLight = new THREE.DirectionalLight(0xffffb3, 1.0);
  directionalLight.position.set(1, 1.2, 0.5).normalize();
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  directionalLight.shadow.radius = 3; // Add shadow blur for softer shadows
  scene.add(directionalLight);

  // Create the western town instead of just a ground plane
  createWesternTown();
  
  // Create the desert terrain
  createDesertTerrain();
  
  // Create circular train track and load train
  createTrainSystem();

  return { camera, renderer };
}

/**
 * Preloads skybox textures to ensure they're in memory
 * @param {Function} callback - Function to call when preloading is complete
 */
function preloadSkyboxTextures(callback) {
  const textureLoader = new THREE.TextureLoader();
  let loadedCount = 0;
  const totalTextures = 2;
  
  // Add cache-busting query parameter
  const timestamp = Date.now();
  const skyUrl = `models/skypart.png?t=${timestamp}`;
  const groundUrl = `models/groundpart.png?t=${timestamp}`;
  
  function checkAllLoaded() {
    loadedCount++;
    if (loadedCount >= totalTextures) {
      callback();
    }
  }

  // Preload the sky texture
  textureLoader.load(
    skyUrl,
    () => {
      console.log("Sky texture preloaded successfully");
      checkAllLoaded();
    },
    undefined,
    () => {
      console.warn("Sky texture preload failed, continuing anyway");
      checkAllLoaded();
    }
  );
  
  // Preload the ground texture
  textureLoader.load(
    groundUrl,
    () => {
      console.log("Ground texture preloaded successfully");
      checkAllLoaded();
    },
    undefined,
    () => {
      console.warn("Ground texture preload failed, continuing anyway");
      checkAllLoaded();
    }
  );
}

/**
 * Loads the two-part skybox with separate ground and animated sky
 */
function loadTwoPartSkybox() {
  const textureLoader = new THREE.TextureLoader();
  const skyboxRadius = 900;
  
  // Function to create sky part with a texture
  function createSkyPart(skyTexture) {
    console.log("Creating sky part with texture");
    
    // Verify if texture is valid before proceeding
    if (!skyTexture.image || !skyTexture.image.width || !skyTexture.image.height) {
      console.error("Sky texture is invalid, using fallback instead");
      createFallbackSkyPart();
      return;
    }
    
    // Create sky mesh with LARGER radius (1.01x)
    const skyGeometry = new THREE.SphereGeometry(skyboxRadius * 1.01, 64, 32);
    skyGeometry.scale(-1, 1, 1);
    
    const skyMaterial = new THREE.MeshBasicMaterial({
      map: skyTexture,
      transparent: true,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (skyMesh) {
      scene.remove(skyMesh);
      skyMesh.geometry.dispose();
      skyMesh.material.dispose();
    }
    
    skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(skyMesh);
    texturesLoaded.skyLoaded = true;
    console.log("Sky part added to scene");
  }
  
  // Function to create fallback sky part
  function createFallbackSkyPart() {
    console.log("Creating fallback sky part");
    
    // Create fallback sky with solid color
    const skyGeometry = new THREE.SphereGeometry(skyboxRadius * 1.01, 64, 32);
    skyGeometry.scale(-1, 1, 1);
    
    const skyMaterial = new THREE.MeshBasicMaterial({
      color: 0x87CEEB, // Sky blue
      side: THREE.BackSide,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (skyMesh) {
      scene.remove(skyMesh);
      skyMesh.geometry.dispose();
      skyMesh.material.dispose();
    }
    
    skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(skyMesh);
    texturesLoaded.skyLoaded = true;
    console.log("Fallback sky part added to scene");
  }
  
  // Function to create ground part with a texture
  function createGroundPart(groundTexture) {
    console.log("Creating ground part with texture");
    
    // Verify if texture is valid before proceeding
    if (!groundTexture.image || !groundTexture.image.width || !groundTexture.image.height) {
      console.error("Ground texture is invalid, using fallback instead");
      createFallbackGroundPart();
      return;
    }
    
    // Create ground mesh with normal radius
    const groundGeometry = new THREE.SphereGeometry(skyboxRadius, 64, 32);
    groundGeometry.scale(-1, 1, 1);
    
    const groundMaterial = new THREE.MeshBasicMaterial({
      map: groundTexture,
      transparent: true,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (groundMesh) {
      scene.remove(groundMesh);
      groundMesh.geometry.dispose();
      groundMesh.material.dispose();
    }
    
    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
    scene.add(groundMesh);
    texturesLoaded.groundLoaded = true;
    console.log("Ground part added to scene");
  }
  
  // Function to create fallback ground part
  function createFallbackGroundPart() {
    console.log("Creating fallback ground part");
    
    // Create fallback ground with solid color
    const groundGeometry = new THREE.SphereGeometry(skyboxRadius, 64, 32);
    groundGeometry.scale(-1, 1, 1);
    
    const groundMaterial = new THREE.MeshBasicMaterial({
      color: 0xAA7755, // Desert sand color
      side: THREE.BackSide,
      fog: false
    });
    
    // Cleanup previous mesh if exists
    if (groundMesh) {
      scene.remove(groundMesh);
      groundMesh.geometry.dispose();
      groundMesh.material.dispose();
    }
    
    groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
    scene.add(groundMesh);
    texturesLoaded.groundLoaded = true;
    console.log("Fallback ground part added to scene");
  }
  
  // Function to load sky texture with retry capability and cache-busting
  function loadSkyTexture(retryCount = 0) {
    const maxRetries = 3;
    texturesLoaded.skyAttempts++;
    
    // Add cache-busting query param
    const timestamp = Date.now();
    const url = `models/skypart.png?t=${timestamp}`;
    
    textureLoader.load(
      url,
      function(skyTexture) {
        console.log("Sky texture loaded successfully");
        skyTexture.needsUpdate = true; // Ensure texture is updated
        createSkyPart(skyTexture);
      },
      // Progress callback
      function(xhr) {
        if (xhr.lengthComputable) {
          const percentage = Math.round((xhr.loaded / xhr.total) * 100);
          if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
            console.log(`Loading sky texture: ${percentage}%`);
          }
        }
      },
      // Error callback
      function(error) {
        console.error('Error loading sky texture:', error);
        
        // Retry logic with increasing delay
        if (retryCount < maxRetries) {
          const delay = 500 * Math.pow(2, retryCount); // Exponential backoff: 500ms, 1000ms, 2000ms
          console.log(`Retrying sky texture load (attempt ${retryCount + 1}/${maxRetries}) in ${delay}ms...`);
          setTimeout(() => {
            loadSkyTexture(retryCount + 1);
          }, delay);
        } else {
          console.error('Failed to load sky texture after multiple attempts');
          createFallbackSkyPart();
        }
      }
    );
  }
  
  // Function to load ground texture with retry capability and cache-busting
  function loadGroundTexture(retryCount = 0) {
    const maxRetries = 3;
    texturesLoaded.groundAttempts++;
    
    // Add cache-busting query param
    const timestamp = Date.now();
    const url = `models/groundpart.png?t=${timestamp}`;
    
    textureLoader.load(
      url,
      function(groundTexture) {
        console.log("Ground texture loaded successfully");
        groundTexture.needsUpdate = true; // Ensure texture is updated
        createGroundPart(groundTexture);
      },
      // Progress callback
      function(xhr) {
        if (xhr.lengthComputable) {
          const percentage = Math.round((xhr.loaded / xhr.total) * 100);
          if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
            console.log(`Loading ground texture: ${percentage}%`);
          }
        }
      },
      // Error callback
      function(error) {
        console.error('Error loading ground texture:', error);
        
        // Retry logic with increasing delay
        if (retryCount < maxRetries) {
          const delay = 500 * Math.pow(2, retryCount); // Exponential backoff: 500ms, 1000ms, 2000ms
          console.log(`Retrying ground texture load (attempt ${retryCount + 1}/${maxRetries}) in ${delay}ms...`);
          setTimeout(() => {
            loadGroundTexture(retryCount + 1);
          }, delay);
        } else {
          console.error('Failed to load ground texture after multiple attempts');
          createFallbackGroundPart();
        }
      }
    );
  }
  
  // Start the texture loading with retry capability
  loadSkyTexture();
  loadGroundTexture();
  
  // Safety check - if textures aren't loaded after 10 seconds, use fallbacks
  setTimeout(() => {
    if (!texturesLoaded.skyLoaded && texturesLoaded.skyAttempts < 4) {
      console.warn("Sky texture not loaded after timeout, using fallback");
      createFallbackSkyPart();
    }
    if (!texturesLoaded.groundLoaded && texturesLoaded.groundAttempts < 4) {
      console.warn("Ground texture not loaded after timeout, using fallback");
      createFallbackGroundPart();
    }
  }, 10000);
}

/**
 * Creates a western town by loading the town.glb model
 */
function createWesternTown() {
  // Town dimensions (kept the same for compatibility)
  const TOWN_WIDTH = 60;  // Width of the town (X-axis)
  const TOWN_LENGTH = 100; // Length of the town (Z-axis)
  const STREET_WIDTH = 15; // Width of the main street

  // Make town dimensions globally accessible
  window.townDimensions = {
    width: TOWN_WIDTH,
    length: TOWN_LENGTH,
    streetWidth: STREET_WIDTH
  };

  // Function to process the town model
  function processTownModel(gltf) {
    // Add the entire model to the scene
    scene.add(gltf.scene);
    console.log("Town model added to scene");
    
    // Log all objects in the model
    let objectCount = 0;
    let colliderCount = 0;
    
    // Create colliders for objects prefixed with "collider"
    const colliders = [];
    
    gltf.scene.traverse((node) => {
      if (node.isMesh) {
        objectCount++;
        
        // Make sure all meshes cast and receive shadows
        node.castShadow = true;
        node.receiveShadow = true;
        
        // Add collision boxes for objects with "collider" prefix
        if (node.name.toLowerCase().startsWith('collider')) {
          colliderCount++;
          
          // Make the collider semi-transparent for easier identification in debug mode
          if (node.material) {
            // Clone the material to avoid affecting other objects with the same material
            node.material = node.material.clone();
            node.material.transparent = true;
            node.material.opacity = 0.0;
            node.material.color.set(0xff0000); // Make colliders red
          }
          
          // Get world geometry
          const bbox = new THREE.Box3().setFromObject(node);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          
          // Create a physics body for this collider
          if (window.physics) {
            const position = new THREE.Vector3();
            bbox.getCenter(position);
            
            const halfExtents = new CANNON.Vec3(size.x/2, size.y/2, size.z/2);
            const shape = new CANNON.Box(halfExtents);
            
            const body = new CANNON.Body({
              mass: 0, // Static body
              position: new CANNON.Vec3(position.x, position.y, position.z),
              shape: shape
            });
            
            // Add to physics world
            window.physics.world.addBody(body);
            window.physics.bodies.push(body);
            
            // Store the node and body together for debugging
            colliders.push({ node, body });
            
            // Hide collider mesh by default (will be toggled by debug mode)
            node.visible = false;
          }
        }
      }
    });
    
    // Store colliders for potential later use
    window.townColliders = colliders;
    
    console.log(`Town model loaded with ${objectCount} objects, including ${colliderCount} colliders`);
  }
  
  // Load the town model
  const loader = new THREE.GLTFLoader();
  console.log("Loading town.glb model...");
  loader.load('models/town.glb', 
    (gltf) => processTownModel(gltf), 
    // Progress callback
    (progress) => {
      if (progress.lengthComputable) {
        const percentage = Math.round((progress.loaded / progress.total) * 100);
        // Only log at 25%, 50%, 75%, and 100% to reduce spam
        if (percentage === 25 || percentage === 50 || percentage === 75 || percentage === 100) {
          console.log(`Loading town model: ${percentage}%`);
        }
      }
    },
    (error) => {
      console.error('Error loading town model:', error);
    }
  );
}

/**
 * Creates a simple western-style building
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} z - Z position
 */
function createWesternBuilding(x, y, z) {
  // Randomize building dimensions
  const width = 8 + Math.random() * 4;
  const height = 5 + Math.random() * 3;
  const depth = 6 + Math.random() * 4;
  
  const buildingGroup = new THREE.Group();
  
  // Building body
  const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
  const buildingMaterial = new THREE.MeshStandardMaterial({
    color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, // Brown variations
    roughness: 0.8,
    metalness: 0.2
  });
  const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
  building.position.set(0, height / 2, 0);
  building.castShadow = true;
  building.receiveShadow = true;
  buildingGroup.add(building);
  
  // Roof (simple triangular prism)
  const roofHeight = 2;
  const roofGeometry = new THREE.BufferGeometry();
  
  const vertices = new Float32Array([
    // Front triangle
    -width/2, height, -depth/2,
    width/2, height, -depth/2,
    0, height + roofHeight, -depth/2,
    
    // Back triangle
    -width/2, height, depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, depth/2,
    
    // Left side
    -width/2, height, -depth/2,
    -width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2,
    
    // Right side
    width/2, height, -depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2
  ]);
  
  const indices = [
    // Front triangle
    0, 1, 2,
    
    // Back triangle
    3, 5, 4,
    
    // Left side
    6, 8, 7,
    7, 8, 9,
    
    // Right side
    10, 11, 12,
    11, 13, 12
  ];
  
  roofGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  roofGeometry.setIndex(indices);
  roofGeometry.computeVertexNormals();
  
  const roofMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Dark brown
    roughness: 0.9,
    metalness: 0.1
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.castShadow = true;
  buildingGroup.add(roof);
  
  // Door
  const doorWidth = 1.5;
  const doorHeight = 3;
  const doorGeometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
  const doorMaterial = new THREE.MeshStandardMaterial({
    color: 0x4d2600, // Dark brown
    roughness: 0.8,
    metalness: 0.2
  });
  const door = new THREE.Mesh(doorGeometry, doorMaterial);
  door.position.set(0, doorHeight / 2, depth / 2 + 0.01);
  buildingGroup.add(door);
  
  // Windows (1-3 random windows)
  const windowCount = 1 + Math.floor(Math.random() * 3);
  for (let i = 0; i < windowCount; i++) {
    const windowWidth = 1;
    const windowHeight = 1;
    const windowGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
    const windowMaterial = new THREE.MeshStandardMaterial({
      color: 0xECF0F1, // White-ish
      roughness: 0.4,
      metalness: 0.6
    });
    const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
    
    // Position windows randomly on the front face
    let wxPos = -width / 3 + i * width / 3;
    if (windowCount === 1) wxPos = 0;
    
    windowMesh.position.set(
      wxPos,
      height / 2 + 0.5,
      depth / 2 + 0.01
    );
    buildingGroup.add(windowMesh);
  }
  
  // Position the whole building
  buildingGroup.position.set(x, y, z);
  
  // Rotate the building to face the street
  if (x < 0) {
    buildingGroup.rotation.y = Math.PI / 2;
  } else {
    buildingGroup.rotation.y = -Math.PI / 2;
  }
  
  scene.add(buildingGroup);
}

/**
 * Creates a straight train track and loads the train model
 */
function createTrainSystem() {
  // Create a straight path for the train
  const numPoints = 2; // Just need two points for a straight line
  const points = [];
  const trackElevation = 0.5; // Slightly elevated above ground

  // Add track endpoints
  points.push(new THREE.Vector3(TRAIN_TRACK_START.x, TRAIN_TRACK_START.y + trackElevation, TRAIN_TRACK_START.z));
  points.push(new THREE.Vector3(TRAIN_TRACK_END.x, TRAIN_TRACK_END.y + trackElevation, TRAIN_TRACK_END.z));

  // Create spline from points
  trainPath = new THREE.CatmullRomCurve3(points);
  trainPath.closed = false; // Open path, not a loop

  // Visualize the path with a line - helps with debugging, can be removed later
  const pathGeometry = new THREE.BufferGeometry().setFromPoints(trainPath.getPoints(200));
  const pathMaterial = new THREE.LineBasicMaterial({ color: 0x888888 });
  const pathLine = new THREE.Line(pathGeometry, pathMaterial);
  scene.add(pathLine);
  
  // Load train model
  const loader = new THREE.GLTFLoader();
  loader.load(
    'models/train.glb',
    (gltf) => {
      train = gltf.scene;
      train.traverse((node) => {
        if (node.isMesh) {
          node.castShadow = true;
          node.receiveShadow = true;
        }
      });
      
      // Scale and position the train
      train.scale.set(2, 2, 2);
      
      // Initialize userData for direction tracking
      train.userData = { lastDirection: trainDirection };
      
      // Position based on current progress (either from server sync or default)
      if (trainInitialized) {
        // Calculate position using time-based approach if already initialized
        trainProgress = calculateTrainProgress();
        trainDirection = getCurrentTrainDirection();
        train.userData.lastDirection = trainDirection;
        
        console.log(`Train model loaded - positioning using time-based sync: progress=${trainProgress.toFixed(4)}, direction=${trainDirection}`);
      } else {
        // Initial position at the start of track as default
        trainProgress = 0;
        trainDirection = 1;
        console.log("Train model loaded - using default starting position");
      }
      
      // Position the train
      const position = trainPath.getPointAt(trainProgress);
      train.position.copy(position);
      
      // Set rotation based on direction
      if (trainDirection < 0) {
        // Should be facing TRAIN_TRACK_START from TRAIN_TRACK_END
        const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_START, TRAIN_TRACK_END).normalize();
        const target = new THREE.Vector3().copy(train.position).add(dirVector);
        train.lookAt(target);
      } else {
        // Should be facing TRAIN_TRACK_END from TRAIN_TRACK_START
        const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_END, TRAIN_TRACK_START).normalize();
        const target = new THREE.Vector3().copy(train.position).add(dirVector);
        train.lookAt(target);
      }
      
      // Add to scene
      scene.add(train);
      
      console.log('Train model loaded successfully');
    },
    (xhr) => {
      console.log(`Loading train: ${(xhr.loaded / xhr.total) * 100}% loaded`);
    },
    (error) => {
      console.error('Error loading train model:', error);
      
      // Fallback: create a simple train placeholder if model fails to load
      createSimpleTrainPlaceholder();
    }
  );
}

/**
 * Creates a simple placeholder train if the model fails to load
 */
function createSimpleTrainPlaceholder() {
  // Create a simple train placeholder using basic shapes
  const trainGroup = new THREE.Group();
  
  // Create main body
  const trainBody = new THREE.Mesh(
    new THREE.BoxGeometry(5, 2, 2),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  trainGroup.add(trainBody);
  
  // Create locomotive top
  const trainTop = new THREE.Mesh(
    new THREE.BoxGeometry(2, 1, 1.8),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  trainTop.position.set(-1.5, 1.5, 0);
  trainGroup.add(trainTop);
  
  // Create wheels
  const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 16);
  const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
  
  // Front wheels
  const frontWheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  frontWheel1.rotation.z = Math.PI / 2;
  frontWheel1.position.set(-1.5, -1, -1);
  trainGroup.add(frontWheel1);
  
  const frontWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  frontWheel2.rotation.z = Math.PI / 2;
  frontWheel2.position.set(-1.5, -1, 1);
  trainGroup.add(frontWheel2);
  
  // Back wheels
  const backWheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  backWheel1.rotation.z = Math.PI / 2;
  backWheel1.position.set(1.5, -1, -1);
  trainGroup.add(backWheel1);
  
  const backWheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
  backWheel2.rotation.z = Math.PI / 2;
  backWheel2.position.set(1.5, -1, 1);
  trainGroup.add(backWheel2);
  
  // Add chimney
  const chimney = new THREE.Mesh(
    new THREE.CylinderGeometry(0.3, 0.3, 1, 8),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  chimney.position.set(-2, 2, 0);
  trainGroup.add(chimney);
  
  // Set up train as the placeholder
  train = trainGroup;
  train.castShadow = true;
  
  // Initialize userData for direction tracking
  train.userData = { lastDirection: trainDirection };
  
  // Position based on current progress (either from server sync or default)
  if (trainInitialized) {
    // Calculate position using time-based approach if already initialized
    trainProgress = calculateTrainProgress();
    trainDirection = getCurrentTrainDirection();
    train.userData.lastDirection = trainDirection;
    
    console.log(`Train placeholder - positioning using time-based sync: progress=${trainProgress.toFixed(4)}, direction=${trainDirection}`);
  } else {
    // Initial position at the start of track as default
    trainProgress = 0;
    trainDirection = 1;
    console.log("Train placeholder - using default starting position");
  }
  
  // Position the train
  const position = trainPath.getPointAt(trainProgress);
  train.position.copy(position);
  
  // Set rotation based on direction
  if (trainDirection < 0) {
    // Should be facing TRAIN_TRACK_START from TRAIN_TRACK_END
    const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_START, TRAIN_TRACK_END).normalize();
    const target = new THREE.Vector3().copy(train.position).add(dirVector);
    train.lookAt(target);
  } else {
    // Should be facing TRAIN_TRACK_END from TRAIN_TRACK_START
    const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_END, TRAIN_TRACK_START).normalize();
    const target = new THREE.Vector3().copy(train.position).add(dirVector);
    train.lookAt(target);
  }
  
  scene.add(train);
  
  console.log('Using simple train placeholder');
}

/**
 * Calculate train progress (0-1) based on elapsed time since train system started
 * @returns {number} Progress value between 0-1
 */
function calculateTrainProgress() {
  if (!trainInitialized || !trainStartTime || !trainCycleTime) {
    // Fall back to default
    return trainProgress;
  }
  
  const elapsedTime = Date.now() - trainStartTime;
  const cycleCount = Math.floor(elapsedTime / trainCycleTime);
  const timeInCurrentCycle = elapsedTime % trainCycleTime;
  
  // Calculate progress within current cycle (0-1)
  const cycleProgress = timeInCurrentCycle / trainCycleTime;
  
  // If even cycle, progress from 0 to 1 (forward)
  // If odd cycle, progress from 1 to 0 (backward)
  return cycleCount % 2 === 0 ? cycleProgress : 1 - cycleProgress;
}

/**
 * Get current train direction based on elapsed time
 * @returns {number} 1 for forward, -1 for backward
 */
function getCurrentTrainDirection() {
  if (!trainInitialized || !trainStartTime || !trainCycleTime) {
    // Fall back to default
    return trainDirection;
  }
  
  const elapsedTime = Date.now() - trainStartTime;
  const cycleCount = Math.floor(elapsedTime / trainCycleTime);
  // Direction changes every cycle
  return cycleCount % 2 === 0 ? 1 : -1;
}

/**
 * Updates the train position along the straight track
 * @param {number} deltaTime - Time since last frame in seconds
 */
export function updateTrain(deltaTime) {
  if (!train) return;
  
  if (trainInitialized) {
    // Time-based train movement - calculate position based on global timer
    trainProgress = calculateTrainProgress();
    trainDirection = getCurrentTrainDirection();
    
    // Get position on the path
    const position = trainPath.getPointAt(trainProgress);
    train.position.copy(position);
    
    // Check if we need to update train rotation when changing direction
    const expectedDirection = getCurrentTrainDirection();
    if (train.userData.lastDirection !== expectedDirection) {
      // Direction changed, rotate 180 degrees
      const currentRotation = train.rotation.y;
      train.rotation.y = currentRotation + Math.PI;
      train.userData.lastDirection = expectedDirection;
      
      if (trainLogMessages) {
        console.log(`Train changed direction to ${expectedDirection > 0 ? 'forwards' : 'backwards'}`);
      }
    }
  } else {
    // Original client-side train movement (fallback before server sync)
    trainProgress += 0.0003 * trainDirection * deltaTime * 60;
    
    // Change direction when reaching either end
    if (trainProgress >= 1) {
      // Reached the end, turn around
      trainDirection = -1;
      trainProgress = 1;
      
      // Rotate 180 degrees
      const currentRotation = train.rotation.y;
      train.rotation.y = currentRotation + Math.PI;
      
    } else if (trainProgress <= 0) {
      // Reached the start, turn around
      trainDirection = 1;
      trainProgress = 0;
      
      // Rotate 180 degrees
      const currentRotation = train.rotation.y;
      train.rotation.y = currentRotation + Math.PI;
    }
    
    // Get position on the path
    const position = trainPath.getPointAt(trainProgress);
    train.position.copy(position);
  }
}

/**
 * Sets train state from server's initial data
 * @param {Object} data - Train initialization data from server
 */
export function setTrainInitialState(data) {
  console.log('Received initial train state:', data);
  
  if (!data || typeof data.startTime !== 'number' || typeof data.cycleTime !== 'number') {
    console.error("Invalid train initialization data:", data);
    return;
  }
  
  // Store time-based tracking values
  trainStartTime = data.startTime;
  trainCycleTime = data.cycleTime;
  trainSpeed = data.speed || 0.0003;
  trainTrackLength = data.trackLength || 2000;
  
  // Calculate current position
  trainProgress = calculateTrainProgress();
  trainDirection = getCurrentTrainDirection();
  
  console.log(`Train synchronized: startTime=${trainStartTime}, progress=${trainProgress.toFixed(4)}, direction=${trainDirection}`);
  
  // Update train position if it exists
  if (train) {
    // Store the direction in the train object for rotation tracking
    if (!train.userData) train.userData = {};
    train.userData.lastDirection = trainDirection;
    
    // Update train position
    const position = trainPath.getPointAt(trainProgress);
    train.position.copy(position);
    
    // Set initial rotation
    if (trainDirection < 0) {
      // Should be facing TRAIN_TRACK_START from TRAIN_TRACK_END
      const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_START, TRAIN_TRACK_END).normalize();
      const target = new THREE.Vector3().copy(train.position).add(dirVector);
      train.lookAt(target);
    } else {
      // Should be facing TRAIN_TRACK_END from TRAIN_TRACK_START
      const dirVector = new THREE.Vector3().subVectors(TRAIN_TRACK_END, TRAIN_TRACK_START).normalize();
      const target = new THREE.Vector3().copy(train.position).add(dirVector);
      train.lookAt(target);
    }
    
    console.log(`Train positioned at progress=${trainProgress.toFixed(4)}`);
  } else {
    console.log("Train model not loaded yet, will position when available");
  }
  
  trainInitialized = true;
  
  // Disable verbose logging after 5 seconds
  setTimeout(() => {
    trainLogMessages = false;
    console.log("Train logging reduced");
  }, 5000);
}

/**
 * Updates train state from server updates
 * @param {Object} data - Train state update from server
 */
export function updateTrainState(data) {
  // Process if we haven't initialized yet
  if (!trainInitialized) {
    console.log("Processing train state as initial");
    setTrainInitialState(data);
  } else if (trainLogMessages) {
    // Only log if verbose logging is enabled
    console.log("Received train update (already initialized)");
  }
}

/**
 * Updates the FPS counter and handles animation
 * @param {THREE.WebGLRenderer} renderer - The renderer.
 * @param {THREE.Camera} camera - The camera.
 * @param {number} deltaTime - Time since last frame in seconds.
 */
export function updateFPS(renderer, camera, deltaTime) {
  // Safely rotate the sky part of the skybox if it exists
  if (skyMesh && skyMesh.rotation) {
    skyMesh.rotation.y += SKYBOX_ROTATION_SPEED * deltaTime * 1000; // Convert to milliseconds
  } else if (!skyMesh && !texturesLoaded.skyLoaded) {
    // If skyMesh doesn't exist but should be loaded, attempt recovery
    if (texturesLoaded.skyAttempts < 4) {
      console.warn("Sky mesh missing in animation loop, attempting recovery");
      loadTwoPartSkybox();
    }
  }
  
  // Update FPS counter if enabled
  if (window.fpsCounterEnabled) {
    fpsUpdateCounter++;
    if (fpsUpdateCounter >= 10) { // Update every 10 frames
      const fps = Math.round(1 / deltaTime);
      const fpsElement = document.getElementById('fps-counter');
      if (fpsElement) {
        fpsElement.textContent = `FPS: ${fps}`;
      }
      fpsUpdateCounter = 0;
    }
  }
  
  // Update tumbleweed positions if manager exists
  if (tumbleweedManager) {
    tumbleweedManager.update(deltaTime);
  }
  
  // Update train position
  updateTrain(deltaTime);
  
  // Render the final scene
  renderer.render(scene, camera);
}

/**
 * Creates desert terrain around the town
 */
function createDesertTerrain() {
  // Create desert terrain after town dimensions are set
  if (window.townDimensions) {
    console.log("Creating desert terrain around town...");
    const desertTerrain = new DesertTerrain(scene, window.townDimensions);
    desertTerrain.generate();
    
    // Store terrain instance for potential access later
    window.desertTerrain = desertTerrain;
    
    // Initialize tumbleweed manager after terrain is created
    initializeTumbleweedManager();
  } else {
    // If town dimensions aren't available yet, wait for them
    console.log("Waiting for town dimensions before creating desert terrain...");
    const checkInterval = setInterval(() => {
      if (window.townDimensions) {
        console.log("Town dimensions available, creating desert terrain...");
        const desertTerrain = new DesertTerrain(scene, window.townDimensions);
        desertTerrain.generate();
        
        // Store terrain instance for potential access later
        window.desertTerrain = desertTerrain;
        
        // Initialize tumbleweed manager after terrain is created
        initializeTumbleweedManager();
        
        clearInterval(checkInterval);
      }
    }, 100);
  }
}

/**
 * Initializes the tumbleweed manager
 */
function initializeTumbleweedManager() {
  if (window.townDimensions) {
    console.log("Initializing tumbleweed manager...");
    
    // Dispose of the previous manager if it exists
    if (tumbleweedManager) {
      tumbleweedManager.dispose();
    }
    
    tumbleweedManager = new TumbleweedManager(scene, window.townDimensions);
    
    // Store manager instance for potential access later
    window.tumbleweedManager = tumbleweedManager;
  }
}

/**
 * Cleans up resources when switching scene or closing
 */
export function cleanupScene() {
  console.log("Cleaning up scene resources...");
  
  // Dispose of tumbleweed manager
  if (tumbleweedManager) {
    tumbleweedManager.dispose();
    tumbleweedManager = null;
  }
  
  // Clean up other resources as needed
}

================================================
File: /public/js/smokeRingEffect.js
================================================
/**
 * Smoke Ring Effect implementation for the Western Shooter game
 * Creates a stylized low-poly smoke ring when firing
 * Optimized for performance to reduce frame drops
 */
export class SmokeRingEffect {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.scene.add(this.group);
        
        this.puffs = [];
        this.active = false;
        
        // Use an object pool for particles to reduce GC
        this.particlePool = [];
        this.materialsPool = [];
        
        // Create shared geometries that will be reused - MUCH LARGER BASE GEOMETRY
        this.puffGeometry = new THREE.IcosahedronGeometry(0.2, 0); // Increased from 0.05
        this.muzzleGeometry = new THREE.IcosahedronGeometry(0.25, 0); // Increased from 0.06
    }
    
    /**
     * Preload all resources needed for the smoke ring effect
     * Call this during initialization to avoid FPS drops on first use
     */
    preload() {
        // Create and cache particles
        const numToPreload = 25; // Slightly more than used in a single effect
        
        for (let i = 0; i < numToPreload; i++) {
            // Create standard particles
            this._getParticle(false);
            
            // Create a few muzzle particles too
            if (i < 5) {
                this._getParticle(true);
            }
        }
        
        // Make them all invisible and return to pool
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        
        // Store original position of the group
        const originalPosition = this.group.position.clone();
        
        // Move group far below scene to hide preload animations
        this.group.position.set(0, -1000, 0);
        
        // Create a dummy direction for the effect
        const dummyDirection = new THREE.Vector3(0, 0, 1);
        
        // Create a full smoke ring effect in the hidden location
        this._createSmokeRing();
        this.active = true;
        
        // Simulate animation frames manually for each effect
        // This forces shader compilation and resource allocation before the user sees it
        const timesteps = [0, 16, 32, 48, 64, 80, 96, 112, 128];
        
        // Manually advance animation by simulating update calls
        for (const timestep of timesteps) {
            this.update(timestep / 1000); // Convert ms to seconds for the update method
        }
        
        // Reset everything after preloading
        this.puffs = [];
        this.active = false;
        
        // Return group to original position
        this.group.position.copy(originalPosition);
        
        // Clear all used particles back to pool
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        
        return this; // For chaining
    }
    
    /**
     * Create a smoke ring effect at the specified position and direction
     * @param {THREE.Vector3} position - The position to create the smoke ring
     * @param {THREE.Vector3} direction - The direction the weapon is firing
     * @param {Object} options - Optional positioning overrides
     */
    create(position, direction, options = null) {
        // Reuse particles instead of removing them
        for (let i = 0; i < this.group.children.length; i++) {
            const mesh = this.group.children[i];
            mesh.visible = false;
            this.particlePool.push(mesh);
        }
        this.puffs = [];
        
        // Get effect configuration - either from options or from default constants
        let forwardOffset = 0.05;
        let xOffset = 0;
        let yOffset = 0;
        let scale = 1.0;
        
        // If we have options from the viewmodel, use those for positioning
        if (options) {
            forwardOffset = options.forward_offset || forwardOffset;
            xOffset = options.x_offset || xOffset;
            yOffset = options.y_offset || yOffset;
            scale = options.scale || scale;
        }
        
        // Position the smoke ring with the appropriate offsets
        const adjustedPosition = position.clone();
        
        // Apply direction-based forward offset
        const forwardDir = direction.clone().normalize().multiplyScalar(forwardOffset);
        adjustedPosition.add(forwardDir);
        
        // Apply lateral offsets if specified
        if (xOffset !== 0 || yOffset !== 0) {
            // We need to calculate the right and up vectors relative to the firing direction
            // to apply the x/y offsets correctly
            const right = new THREE.Vector3();
            const up = new THREE.Vector3(0, 1, 0);
            right.crossVectors(direction, up).normalize();
            
            // Recalculate up to ensure it's perpendicular
            up.crossVectors(right, direction).normalize();
            
            // Apply offsets
            if (xOffset !== 0) {
                adjustedPosition.add(right.multiplyScalar(xOffset));
            }
            
            if (yOffset !== 0) {
                adjustedPosition.add(up.multiplyScalar(yOffset));
            }
        }
        
        // Position the smoke ring at the adjusted position
        this.group.position.copy(adjustedPosition);
        this.group.lookAt(adjustedPosition.clone().add(direction));
        
        // Apply scale if different from default
        if (scale !== 1.0) {
            this.group.scale.set(scale, scale, scale);
        } else {
            this.group.scale.set(1, 1, 1);
        }
        
        // Create the smoke ring effect
        this._createSmokeRing();
        
        this.active = true;
    }
    
    /**
     * Get a particle mesh from the pool or create a new one
     * @param {boolean} isMuzzle - Whether this is a muzzle blast particle
     * @returns {THREE.Mesh} - The particle mesh
     * @private
     */
    _getParticle(isMuzzle = false) {
        if (this.particlePool.length > 0) {
            const mesh = this.particlePool.pop();
            mesh.visible = true;
            return mesh;
        }
        
        // Create new material with proper settings
        const material = new THREE.MeshPhongMaterial({
            color: 0xCCCCCC,
            flatShading: true,
            shininess: 0,
            transparent: true,
            depthWrite: false
        });
        
        this.materialsPool.push(material);
        
        // Create new mesh with the proper geometry
        const geometry = isMuzzle ? this.muzzleGeometry : this.puffGeometry;
        const mesh = new THREE.Mesh(geometry, material);
        
        // Set renderOrder on the mesh itself where it belongs
        mesh.renderOrder = 1000;
        
        this.group.add(mesh);
        return mesh;
    }
    
    /**
     * Create a smoke ring with proper radial particles
     * @private
     */
    _createSmokeRing() {
        // Keep just a handful of puffs with better size distribution
        const numRingParticles = 5; // 5 total puffs for outer ring
        const initialRingRadius = 0.35; // Reduced from 0.5 for less spread
        
        // Number of small inner puffs
        const numInnerPuffs = 3; // Add small puffs in the inner area
        const innerRingRadius = 0.18; // Reduced from 0.25 for less spread
        
        // Pre-determine which particles will be the large ones (1 or 2 max)
        const largeParticleIndices = [];
        const numLargeParticles = Math.random() < 0.5 ? 1 : 2; // Either 1 or 2 large particles
        
        while (largeParticleIndices.length < numLargeParticles) {
            const idx = Math.floor(Math.random() * numRingParticles);
            if (!largeParticleIndices.includes(idx)) {
                largeParticleIndices.push(idx);
            }
        }
        
        // Create outer ring puffs (larger ones)
        for (let i = 0; i < numRingParticles; i++) {
            // Much wider distribution around the circle
            // More randomness in angle placement for less uniform pattern
            const angle = (i / numRingParticles) * Math.PI * 2 + (Math.random() - 0.5) * 0.7;
            
            // Less radius spread for tighter dispersion
            const radiusVariation = initialRingRadius * (0.8 + Math.random() * 0.8); // Reduced from 1.0 + random * 1.2
            
            // Get a particle from the pool or create a new one
            const puffMesh = this._getParticle(false);
            
            // Compute normals for flat shading
            if (puffMesh.geometry.attributes.normal) {
                puffMesh.geometry.computeVertexNormals();
            }
            
            // All particles initially start near the origin (gun position)
            // They'll move to their final positions quickly during the first frames
            puffMesh.position.x = Math.cos(angle) * 0.05; // Start close to center
            puffMesh.position.y = Math.sin(angle) * 0.05; // Start close to center
            puffMesh.position.z = 0.01; // Start very close to gun
            
            // Target positions for quick interpolation - closer to gun
            const targetX = Math.cos(angle) * radiusVariation;
            const targetY = Math.sin(angle) * radiusVariation;
            const targetZ = 0.05 + Math.random() * 0.2; // Reduced from 0.3 for less z-spread
            
            // Fixed random rotation for initial appearance - don't animate rotation later
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Determine size based on whether this is one of the pre-selected large particles
            let baseSize;
            if (largeParticleIndices.includes(i)) {
                // This is one of the 1-2 large particles
                baseSize = 1.4 + Math.random() * 0.8; // 1.4-2.2 size
            } else {
                // Regular smaller particles
                baseSize = 0.6 + Math.random() * 0.4; // 0.6-1.0 size
            }
            
            // Start with a very small scale (originating from gun)
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            // Slower outward speed for less spread
            const outwardSpeed = largeParticleIndices.includes(i) ? 
                1.0 + Math.random() * 0.6 : // Reduced from 1.5 + random * 0.8 
                0.9 + Math.random() * 0.7;  // Reduced from 1.4 + random * 1.0
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: largeParticleIndices.includes(i) ?
                    1.0 + Math.random() * 1.2 : // Longer lifespan for larger clouds
                    0.7 + Math.random() * 0.5,  // Shorter for smaller clouds
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    largeParticleIndices.includes(i) ?
                        0.01 + Math.random() * 0.1 : // Less vertical for big clouds
                        0.05 + Math.random() * 0.2   // Reduced from 0.25 for less upward movement
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize, // Store the initial size for reference
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete
                initialExpansionSpeed: largeParticleIndices.includes(i) ?
                    30 + Math.random() * 15 : // Much faster expansion for large particles
                    20 + Math.random() * 10   // Fast expansion for other particles
            });
        }
        
        // Create inner core small puffs
        for (let i = 0; i < numInnerPuffs; i++) {
            // Distribute small puffs randomly in the inner area
            const angle = Math.random() * Math.PI * 2;
            
            // Use smaller radius for inner puffs with less spread
            const radiusVariation = innerRingRadius * (0.5 + Math.random() * 0.7); // Reduced from 0.6 + random * 1.0
            
            // Get a particle from the pool or create a new one
            const puffMesh = this._getParticle(false);
            
            // Compute normals for flat shading
            if (puffMesh.geometry.attributes.normal) {
                puffMesh.geometry.computeVertexNormals();
            }
            
            // Start at the origin (gun position)
            puffMesh.position.x = Math.cos(angle) * 0.03;
            puffMesh.position.y = Math.sin(angle) * 0.03;
            puffMesh.position.z = 0.01;
            
            // Target positions for quick interpolation - closer to gun
            const targetX = Math.cos(angle) * radiusVariation;
            const targetY = Math.sin(angle) * radiusVariation;
            const targetZ = 0.02 + Math.random() * 0.1; // Reduced from 0.15 for less z-spread
            
            // Fixed random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Small size for inner puffs
            const baseSize = 0.2 + Math.random() * 0.2; // 0.2-0.4 size
            
            // Start very small
            puffMesh.scale.set(0.03, 0.03, 0.03);
            
            // Slower outward speed for less spread
            const outwardSpeed = 0.6 + Math.random() * 0.6; // Reduced from 0.9 + random * 0.8
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.5 + Math.random() * 0.4, // Shorter lifespan for small inner puffs
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    0.03 + Math.random() * 0.09 // Reduced from 0.12 for less upward movement
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize,
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete
                initialExpansionSpeed: 25 + Math.random() * 10 // Fast expansion speed
            });
        }
        
        // Original muzzle blast particles for visual fidelity
        for (let i = 0; i < 1; i++) {
            const puffMesh = this._getParticle(true);
            
            // Position very close to origin with minimal spread
            const smallOffset = 0.03; // Start even closer to gun
            puffMesh.position.set(
                (Math.random() - 0.5) * smallOffset,
                (Math.random() - 0.5) * smallOffset,
                0
            );
            
            // Target positions - muzzle particles expand in place - closer to gun
            const targetX = (Math.random() - 0.5) * 0.08; // Reduced from 0.12
            const targetY = (Math.random() - 0.5) * 0.08; // Reduced from 0.12
            const targetZ = 0.02 + Math.random() * 0.02; // Reduced from 0.03
            
            // Fixed random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Moderate muzzle particles
            const baseSize = 0.6 + Math.random() * 0.2; // 0.6-0.8 size
            
            // Start extremely small
            puffMesh.scale.set(0.01, 0.01, 0.01);
            
            // Random outward direction with slower speed
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.9 + Math.random() * 0.6; // Reduced from 1.3 + random * 0.8
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.6 + Math.random() * 0.3,
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    0.15 + Math.random() * 0.2 // Reduced from 0.2 + random * 0.3
                ),
                rotationSpeed: new THREE.Vector3(0, 0, 0), // No rotation
                initialSize: baseSize,
                // Add target position data for fast initial interpolation
                targetPos: new THREE.Vector3(targetX, targetY, targetZ),
                initialExpansionDone: false, // Track if initial expansion is complete  
                initialExpansionSpeed: 20 + Math.random() * 10 // Very fast expansion for muzzle flash
            });
        }
    }
    
    /**
     * Update the smoke ring effect
     * @param {number} deltaTime - Time elapsed since last frame
     * @returns {boolean} - Whether the effect is still active
     */
    update(deltaTime) {
        if (!this.active) return false;
        
        let allExpired = true;
        
        // Limit delta time to avoid large jumps that cause performance issues
        const clampedDelta = Math.min(deltaTime, 0.05);
        
        for (let i = 0; i < this.puffs.length; i++) {
            const puff = this.puffs[i];
            puff.age += clampedDelta;
            
            // If puff still alive, update it
            if (puff.age < puff.lifespan) {
                allExpired = false;
                
                // Calculate life ratio
                const lifeRatio = puff.age / puff.lifespan;
                
                // Fast initial position interpolation (first ~50ms - even faster)
                if (!puff.initialExpansionDone) {
                    // Check if we're still in the initial fast expansion phase (now only 50ms)
                    const initialPhaseComplete = puff.age > 0.05; // Reduced from 100ms to 50ms
                    
                    if (initialPhaseComplete) {
                        // Mark initial expansion as done
                        puff.initialExpansionDone = true;
                        
                        // Set position to target to ensure we reached it
                        puff.mesh.position.copy(puff.targetPos);
                    } else {
                        // Very fast interpolation toward target position
                        const lerpFactor = clampedDelta * puff.initialExpansionSpeed;
                        
                        puff.mesh.position.x += (puff.targetPos.x - puff.mesh.position.x) * lerpFactor;
                        puff.mesh.position.y += (puff.targetPos.y - puff.mesh.position.y) * lerpFactor;
                        puff.mesh.position.z += (puff.targetPos.z - puff.mesh.position.z) * lerpFactor;
                        
                        // Quickly scale up to initial size
                        const targetScale = puff.initialSize * 0.9; // Target 90% of final size initially
                        const currentScale = puff.mesh.scale.x;
                        const newScale = currentScale + (targetScale - currentScale) * lerpFactor;
                        puff.mesh.scale.set(newScale, newScale, newScale);
                    }
                } else {
                    // Normal movement after initial expansion
                    const positionX = puff.mesh.position.x + puff.velocity.x * clampedDelta;
                    const positionY = puff.mesh.position.y + puff.velocity.y * clampedDelta;
                    const positionZ = puff.mesh.position.z + puff.velocity.z * clampedDelta;
                    puff.mesh.position.set(positionX, positionY, positionZ);
                
                    // Scale curve for visual fidelity after initial expansion - REDUCE MAX SCALE
                    let scaleFactor;
                    
                    if (lifeRatio < 0.2) {
                        // Quick growth phase - 0 to 0.2 - REDUCE PEAK
                        scaleFactor = 0.9 + (lifeRatio / 0.2) * 0.2; // Start from 90% to 110% (down from 130%)
                    } else if (lifeRatio < 0.7) {
                        // Maintain size with slight growth - 0.2 to 0.7 - REDUCE PEAK
                        scaleFactor = 1.1 + (lifeRatio - 0.2) * 0.1; // 110% to 120% (down from 130% to 150%)
                    } else {
                        // Shrink phase - 0.7 to 1.0
                        scaleFactor = 1.2 - (lifeRatio - 0.7) * (1.2 / 0.3); // Shrink from 120% to 0%
                    }
                    
                    // Apply scale based on the initial size to maintain relative proportions
                    const scale = puff.initialSize * scaleFactor;
                    puff.mesh.scale.set(scale, scale, scale);
                }
                
                // Handle transparency in final phase
                if (lifeRatio > 0.7) {
                    const opacity = 1 - ((lifeRatio - 0.7) / 0.3);
                    puff.mesh.material.opacity = opacity;
                } else {
                    // Reset opacity for particles not in final phase
                    puff.mesh.material.opacity = 1.0;
                }
                
                // Almost no drag to allow particles to travel much further
                const dragFactor = lifeRatio < 0.5 ? 0.995 : 0.99;
                puff.velocity.multiplyScalar(dragFactor);
            } else {
                // Add expired puffs back to the pool instead of making them invisible
                puff.mesh.visible = false;
                this.particlePool.push(puff.mesh);
            }
        }
        
        // If all puffs have expired, clean up and set active to false
        if (allExpired) {
            this.puffs = [];
            this.active = false;
            return false;
        }
        
        return true;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        // Clean up all meshes and properly dispose materials
        while(this.group.children.length > 0) {
            const mesh = this.group.children[0];
            this.group.remove(mesh);
        }
        
        // Clear the particle pool
        this.particlePool = [];
        this.puffs = [];
        
        // Dispose of all materials in the pool
        for (let i = 0; i < this.materialsPool.length; i++) {
            if (this.materialsPool[i]) {
                this.materialsPool[i].dispose();
            }
        }
        this.materialsPool = [];
        
        // Dispose of shared geometries
        if (this.puffGeometry) this.puffGeometry.dispose();
        if (this.muzzleGeometry) this.muzzleGeometry.dispose();
        
        // Remove group from scene
        if (this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
}

================================================
File: /public/js/soundManager.js
================================================
export class SoundManager {
  constructor() {
    // Initialize Web Audio API context
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Sound buffers and pools
    this.buffers = {};
    this.soundPools = {};
    this.soundCategories = {
      'weapon': { maxInstances: 3, volume: 1.0 },  // Limit weapon sounds like gunshots
      'impact': { maxInstances: 5, volume: 0.8 },  // Hit sounds
      'footstep': { maxInstances: 6, volume: 0.7 }, // Footstep sounds
      'ui': { maxInstances: 3, volume: 0.6 },      // UI sounds
      'ambient': { maxInstances: 5, volume: 0.5 }, // Background sounds
      'voice': { maxInstances: 2, volume: 1.0 }    // Voice sounds
    };
    
    // Default category mapping for common sounds
    this.soundCategoryMap = {
      'shot': 'weapon',
      'shotgunshot': 'weapon',  // Explicitly add shotgunshot to ensure it's properly categorized
      'revolverdraw': 'ui',
      'shotgundraw': 'ui',
      'reloading': 'weapon',
      'bellstart': 'ui',
      'woodimpact': 'impact',
      'fleshimpact': 'impact',
      'leftstep': 'footstep',
      'rightstep': 'footstep',
      'jumpup': 'ui',         // Change from footstep to ui for higher priority
      'jumpland': 'footstep',
      'recoiljump': 'footstep',
      'headshotmarker': 'ui',
      'dramatic': 'ui',
      'eaglescream': 'ui',
      'quickdrawending': 'ui',
      'playerfall': 'impact',
      'revolverholstering': 'weapon',  // Add the new sound name
      'shotgunholstering': 'weapon',   // Add the new sound name
      'shotgunempty': 'weapon',        // Add shotgun empty sound
      'eagledeath': 'ui',              // Keep only eagledeath
      'ambience': 'ambient'
    };
    
    // Main mixer channels
    this.masterGain = this.audioContext.createGain();
    
    // Create audio processing for better sound quality
    this.setupAudioProcessing();
    
    this.categoryGains = {};
    for (const category in this.soundCategories) {
      this.categoryGains[category] = this.audioContext.createGain();
      this.categoryGains[category].gain.value = this.soundCategories[category].volume;
      this.categoryGains[category].connect(this.masterGain);
    }
    
    // For sound cooldowns (prevent sound spam)
    this.soundCooldowns = {};
    
    // Track currently playing sounds by category
    this.activeSounds = {};
    for (const category in this.soundCategories) {
      this.activeSounds[category] = [];
    }
    
    // Set initial master volume
    this.setMasterVolume(0.8);
  }
  
  /**
   * Sets up audio processing chain for better sound
   */
  setupAudioProcessing() {
    // Create a compressor to prevent audio clipping and make overall sound fuller
    this.compressor = this.audioContext.createDynamicsCompressor();
    this.compressor.threshold.value = -24;    // Start compressing at -24dB
    this.compressor.knee.value = 10;          // Smooth knee for more natural sound
    this.compressor.ratio.value = 4;          // 4:1 compression ratio
    this.compressor.attack.value = 0.005;     // Fast attack (5ms)
    this.compressor.release.value = 0.1;      // Medium release (100ms)
    
    // Optional: Add a subtle reverb for weapon sounds
    if (this.audioContext.createConvolver) {
      try {
        // Setup convolver for reverb
        this.convolver = this.audioContext.createConvolver();
        
        // Create a simple impulse response for a small reverb
        const sampleRate = this.audioContext.sampleRate;
        const length = Math.floor(sampleRate * 0.5); // 500ms impulse response
        const impulseBuffer = this.audioContext.createBuffer(2, length, sampleRate);
        
        // Fill both channels with an exponentially decaying noise
        for (let channel = 0; channel < 2; channel++) {
          const impulseData = impulseBuffer.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            // Create exponentially decaying noise
            impulseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
          }
        }
        
        // Set the impulse response
        this.convolver.buffer = impulseBuffer;
        
        // Create a send gain for the reverb
        this.reverbSend = this.audioContext.createGain();
        this.reverbSend.gain.value = 0.1; // Very subtle reverb
        
        // Connect reverb to the chain
        this.reverbSend.connect(this.convolver);
        this.convolver.connect(this.compressor);
        console.log("Reverb effect initialized");
      } catch (e) {
        console.warn("Failed to initialize reverb", e);
        // Fallback: No reverb
        this.reverbSend = null;
        this.convolver = null;
      }
    }
    
    // Connect the audio chain
    this.masterGain.connect(this.compressor);
    this.compressor.connect(this.audioContext.destination);
    
    console.log("Audio processing chain configured");
  }
  
  /**
   * Sets the master volume for all sounds
   * @param {number} value - Volume from 0 to 1
   */
  setMasterVolume(value) {
    this.masterGain.gain.value = Math.max(0, Math.min(1, value));
  }
  
  /**
   * Sets the volume for a specific sound category
   * @param {string} category - Category name
   * @param {number} value - Volume from 0 to 1
   */
  setCategoryVolume(category, value) {
    if (this.categoryGains[category]) {
      this.categoryGains[category].gain.value = Math.max(0, Math.min(1, value));
    }
  }
  
  /**
   * Gets the appropriate category for a sound
   * @param {string} name - Sound name
   * @returns {string} Category name
   */
  _getSoundCategory(name) {
    return this.soundCategoryMap[name] || 'ambient';
  }
  
  /**
   * Loads an audio file and caches it.
   * @param {string} name - Sound key.
   * @param {string} url - Audio file URL.
   * @param {string} category - Optional override for the sound category
   */
  loadSound(name, url, category = null) {
    // If category is provided, map this sound to that category
    if (category && this.soundCategories[category]) {
      this.soundCategoryMap[name] = category;
    }
    
    // Load sound using fetch for Web Audio API
    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`Network response failed for sound ${name}: ${response.status} ${response.statusText}`);
        }
        return response.arrayBuffer();
      })
      .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        this.buffers[name] = audioBuffer;
        console.log(`Loaded sound "${name}" as AudioBuffer from ${url}`);
        
        // Initialize sound pool for this sound
        const soundCategory = this._getSoundCategory(name);
        const poolSize = this.soundCategories[soundCategory].maxInstances;
        
        // Create pool for this sound
        this.soundPools[name] = Array(poolSize).fill().map(() => ({
          source: null,
          gainNode: null,
          panner: null,
          active: false,
          startTime: 0
        }));
      })
      .catch(error => {
        console.error(`Error loading sound buffer "${name}" from ${url}:`, error);
      });
  }
  
  /**
   * Registers a sound as preloaded - used when sounds were preloaded during the name entry
   * @param {string} name - Sound key to register
   * @param {string} category - Optional override for the sound category
   */
  registerPreloadedSound(name, category = null) {
    // If category is provided, map this sound to that category
    if (category && this.soundCategories[category]) {
      this.soundCategoryMap[name] = category;
    }
    
    // Detect URL based on name
    const url = `sounds/${name}.mp3`;
    
    // When a sound is played, it will be lazy-loaded on first play
    console.log(`Registered preloaded sound "${name}" (will be loaded on first play)`);
    
    // Initialize sound pool for this sound
    const soundCategory = this._getSoundCategory(name);
    const poolSize = this.soundCategories[soundCategory].maxInstances;
    
    // Create pool for this sound
    this.soundPools[name] = Array(poolSize).fill().map(() => ({
      source: null,
      gainNode: null,
      panner: null,
      active: false,
      startTime: 0
    }));
  }
  
  /**
   * Adds a preloaded audio buffer directly to the SoundManager
   * @param {string} name - Sound name
   * @param {AudioBuffer} buffer - Preloaded audio buffer
   * @param {string} category - Optional category override 
   */
  addPreloadedBuffer(name, buffer, category = null) {
    // If category is provided, map this sound to that category
    if (category && this.soundCategories[category]) {
      this.soundCategoryMap[name] = category;
    }
    
    // Store the buffer directly
    this.buffers[name] = buffer;
    console.log(`Added preloaded audio buffer for "${name}"`);
    
    // Initialize sound pool for this sound
    const soundCategory = this._getSoundCategory(name);
    const poolSize = this.soundCategories[soundCategory].maxInstances;
    
    // Create pool for this sound
    this.soundPools[name] = Array(poolSize).fill().map(() => ({
      source: null,
      gainNode: null,
      panner: null,
      active: false,
      startTime: 0
    }));
  }
  
  /**
   * Cleanups and returns an available sound object from the pool
   * @param {string} name - Sound name
   * @returns {Object|null} Sound object from pool or null if none available
   */
  _getAvailableSoundFromPool(name) {
    if (!this.soundPools[name]) return null;
    
    const now = this.audioContext.currentTime;
    let oldestSoundIndex = -1;
    let oldestStartTime = Infinity;
    
    // First try to find an inactive sound
    for (let i = 0; i < this.soundPools[name].length; i++) {
      const sound = this.soundPools[name][i];
      
      // If sound is not active, use it
      if (!sound.active) {
        return sound;
      }
      
      // Keep track of the oldest sound in case we need to override it
      if (sound.startTime < oldestStartTime) {
        oldestStartTime = sound.startTime;
        oldestSoundIndex = i;
      }
    }
    
    // If we get here, all sounds are active, so use the oldest one
    if (oldestSoundIndex >= 0) {
      const sound = this.soundPools[name][oldestSoundIndex];
      
      // Stop the current sound if it's playing
      if (sound.source) {
        try {
          sound.source.stop();
        } catch (e) {
          // Ignore errors if already stopped
        }
      }
      
      return sound;
    }
    
    return null;
  }
  
  /**
   * Manage active sounds for a category, stopping older sounds if needed
   * @param {string} category - Sound category
   * @param {Object} soundObj - Sound object from pool
   */
  _manageActiveSoundsForCategory(category, soundObj) {
    const maxInstances = this.soundCategories[category].maxInstances;
    
    // Add this sound to the active sounds for this category
    this.activeSounds[category].push(soundObj);
    
    // If we have too many active sounds in this category, stop the oldest ones
    if (this.activeSounds[category].length > maxInstances) {
      // Sort by start time (oldest first)
      this.activeSounds[category].sort((a, b) => a.startTime - b.startTime);
      
      // Stop the oldest sounds to get back to the max
      while (this.activeSounds[category].length > maxInstances) {
        const oldestSound = this.activeSounds[category].shift();
        
        if (oldestSound && oldestSound.source) {
          try {
            oldestSound.source.stop();
          } catch (e) {
            // Ignore errors if already stopped
          }
          oldestSound.active = false;
        }
      }
    }
  }
  
  /**
   * Plays a sound with optional volume control
   * @param {string} name - The name of the sound to play
   * @param {number} cooldown - Minimum time between sound plays (ms)
   * @param {number} volume - Volume multiplier for this sound (0-1)
   * @param {boolean} loop - Whether the sound should loop
   * @returns {Object|null} Sound object for further control or null if not played
   */
  playSound(name, cooldown = 0, volume = 1.0, loop = false) {
    // Stronger duplicate protection for all sounds, especially gunshots
    const now = Date.now();
    
    // Group similar sounds together for cooldown purposes
    let soundGroup = name;
    
    // Special handling for shot sounds - treat them as the same group
    if (name === "shot" || name === "shotgunshot") {
      soundGroup = "gunshotSounds";
      cooldown = Math.max(cooldown, 50); // Use at least 50ms cooldown for shots
      
      // Check if any shot sound is in cooldown
      if (this.soundCooldowns[soundGroup] && (now - this.soundCooldowns[soundGroup] < cooldown)) {
        console.log(`Skipping ${name} sound (gunshot cooldown still active)`);
        return null;
      }
      
      // Record the time for the entire group
      this.soundCooldowns[soundGroup] = now;
      
      // Record time for the specific sound name too to track which one played
      this.soundCooldowns[name] = now;
      
      // Record the last shot time for other effects
      this.lastShotTime = now;
    }
    // For other sounds, use normal cooldown behavior
    else if (cooldown > 0) {
      if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
        return null;
      }
      this.soundCooldowns[name] = now;
    }
    
    // Special handling for gunshot sounds on mobile to prevent duplication issues
    if ((name === "shot" || name === "shotgunshot") && window.isMobile) {
      // On mobile, always use a compact sound buffer for gunshots to prevent issues
      // This helps with memory and performance on mobile devices
      if (window.isMobile && !this._mobileOptimized) {
        this._mobileOptimized = true;
        console.log("Optimizing audio for mobile device");
      }
    }
    
    if (!this.buffers[name]) {
      console.warn(`Sound "${name}" not loaded`);
      return null;
    }

    // Get category info
    const category = this._getSoundCategory(name);
    const maxInstances = this.soundCategories[category].maxInstances;

    // Find a free sound in the pool or create a new one
    let soundObj = this._getAvailableSoundFromPool(name);
    if (!soundObj) {
      return null; // No available sound in pool
    }

    // Get buffer
    const buffer = this.buffers[name];

    // Setup audio source
    soundObj.source = this.audioContext.createBufferSource();
    soundObj.source.buffer = buffer;
    soundObj.source.loop = loop;

    // Create a gain node for volume control
    soundObj.gainNode = this.audioContext.createGain();
    soundObj.gainNode.gain.value = volume;

    // Connect the source to gain, then gain to the category gain
    soundObj.source.connect(soundObj.gainNode);
    soundObj.gainNode.connect(this.categoryGains[category]);

    // Add reverb if available for certain categories
    if (category === 'weapon' && this.reverbSend && this.convolver) {
      // Create a gain node for reverb send amount
      soundObj.reverbAmount = this.audioContext.createGain();
      soundObj.reverbAmount.gain.value = 0.1; // 10% reverb
      
      // Send from gainNode to reverb
      soundObj.gainNode.connect(soundObj.reverbAmount);
      soundObj.reverbAmount.connect(this.reverbSend);
    }

    // Mark as active
    soundObj.active = true;
    soundObj.startTime = this.audioContext.currentTime;
    soundObj.source.onended = () => {
      soundObj.active = false;
      
      // Remove from active sounds list
      const index = this.activeSounds[category].indexOf(soundObj);
      if (index !== -1) {
        this.activeSounds[category].splice(index, 1);
      }
    };

    // Start playback
    try {
      soundObj.source.start(0);
      
      // Add to active sounds for this category
      this.activeSounds[category].push(soundObj);
      
      return soundObj;
    } catch (e) {
      console.error(`Error playing sound "${name}":`, e);
      return null;
    }
  }
  
  /**
   * Plays a sound at a given 3D position using the Web Audio API.
   * @param {string} name - Sound key.
   * @param {THREE.Vector3} position - 3D position for the sound.
   * @param {number} cooldown - Optional cooldown in milliseconds.
   * @param {number} volume - Optional volume multiplier.
   * @param {boolean} loop - Whether the sound should loop
   * @param {boolean} spatialize - Whether to apply 3D audio positioning (default: true)
   * @returns {Object} - Sound object for reference
   */
  playSoundAt(name, position, cooldown = 0, volume = 1.0, loop = false, spatialize = true) {
    if (!this.buffers[name]) {
      // Only log this error once per sound name to reduce log spam
      if (!this._reportedMissingSounds) {
        this._reportedMissingSounds = new Set();
      }
      
      if (!this._reportedMissingSounds.has(name)) {
        console.error(`Sound "${name}" not loaded.`);
        this._reportedMissingSounds.add(name);
      }
      return;
    }
    
    // Check cooldown if specified
    if (cooldown > 0) {
      const now = Date.now();
      if (this.soundCooldowns[name] && now - this.soundCooldowns[name] < cooldown) {
        // Still in cooldown period
        return;
      }
      this.soundCooldowns[name] = now;
    }
    
    // Get sound category
    const category = this._getSoundCategory(name);
    
    // Get an available sound from the pool
    const soundObj = this._getAvailableSoundFromPool(name);
    if (!soundObj) {
      console.warn(`No available sound objects for ${name}`);
      return;
    }
    
    try {
      // Clean up previous nodes if they exist
      if (soundObj.gainNode) {
        soundObj.gainNode.disconnect();
      }
      if (soundObj.panner) {
        soundObj.panner.disconnect();
      }
      
      // Create new audio nodes
      soundObj.source = this.audioContext.createBufferSource();
      soundObj.source.buffer = this.buffers[name];
      soundObj.source.loop = loop;
      
      // Create gain node for individual volume control
      soundObj.gainNode = this.audioContext.createGain();
      soundObj.gainNode.gain.value = volume;
      
      // For spatialized audio, create and configure a panner node
      if (spatialize) {
        // Create 3D panner node with improved settings
        soundObj.panner = this.audioContext.createPanner();
        soundObj.panner.panningModel = 'HRTF';
        soundObj.panner.distanceModel = 'inverse';
        
        // Adjust reference distance based on sound type for better perception
        if (category === 'weapon') {
          // For weapon sounds, add a subtle highpass filter to make them sharper
          soundObj.filter = this.audioContext.createBiquadFilter();
          soundObj.filter.type = 'highpass';
          soundObj.filter.frequency.value = 80; // Cut very low frequencies
          
          // Gunshots should sound closer and louder
          soundObj.panner.refDistance = 2;
          soundObj.panner.maxDistance = 10000;
          soundObj.panner.rolloffFactor = 0.8; // Reduced rolloff for weapons
          
          // Connect source -> filter -> panner -> gain
          soundObj.source.connect(soundObj.filter);
          soundObj.filter.connect(soundObj.panner);
          
          // If reverb is available, send a portion of the sound to reverb
          if (this.reverbSend && this.convolver) {
            // Create a gain node for reverb send amount
            soundObj.reverbAmount = this.audioContext.createGain();
            soundObj.reverbAmount.gain.value = 0.15; // 15% reverb
            
            // Send from filter to reverb
            soundObj.filter.connect(soundObj.reverbAmount);
            soundObj.reverbAmount.connect(this.reverbSend);
          }
        } else if (category === 'impact') {
          // Impact sounds should be distinct
          soundObj.panner.refDistance = 1.5;
          soundObj.panner.maxDistance = 5000;
          soundObj.panner.rolloffFactor = 1;
          
          // Connect source -> panner
          soundObj.source.connect(soundObj.panner);
        } else {
          // Default settings for other sounds
          soundObj.panner.refDistance = 1;
          soundObj.panner.maxDistance = 10000;
          soundObj.panner.rolloffFactor = 1;
          
          // Connect source -> panner
          soundObj.source.connect(soundObj.panner);
        }
        
        // Omnidirectional cone settings
        soundObj.panner.coneInnerAngle = 360;
        soundObj.panner.coneOuterAngle = 0;
        soundObj.panner.coneOuterGain = 0;
        soundObj.panner.setPosition(position.x, position.y, position.z);
        
        // Connect panner -> gain
        soundObj.panner.connect(soundObj.gainNode);
      } else {
        // Add similar processing for non-spatialized sounds
        if (category === 'weapon') {
          // For weapon sounds, add a subtle highpass filter
          soundObj.filter = this.audioContext.createBiquadFilter();
          soundObj.filter.type = 'highpass';
          soundObj.filter.frequency.value = 80;
          
          // Connect source -> filter -> gain
          soundObj.source.connect(soundObj.filter);
          soundObj.filter.connect(soundObj.gainNode);
          
          // If reverb is available, send a portion of the sound to reverb
          if (this.reverbSend && this.convolver) {
            // Create a gain node for reverb send amount
            soundObj.reverbAmount = this.audioContext.createGain();
            soundObj.reverbAmount.gain.value = 0.15; // 15% reverb
            
            // Send from filter to reverb
            soundObj.filter.connect(soundObj.reverbAmount);
            soundObj.reverbAmount.connect(this.reverbSend);
          }
        } else {
          // Non-spatialized audio connects directly to gain
          soundObj.source.connect(soundObj.gainNode);
        }
      }
      
      // Final connection to category gain
      soundObj.gainNode.connect(this.categoryGains[category]);
      
      // Mark as active and track start time
      soundObj.active = true;
      soundObj.startTime = this.audioContext.currentTime;
      
      // Start playing
      soundObj.source.start(0);
      
      // When the sound ends, mark it as inactive
      soundObj.source.onended = () => {
        soundObj.active = false;
        // Remove from active sounds list
        const index = this.activeSounds[category].indexOf(soundObj);
        if (index !== -1) {
          this.activeSounds[category].splice(index, 1);
        }
      };
      
      // Manage active sounds for this category
      this._manageActiveSoundsForCategory(category, soundObj);
      
      // Return the sound object for reference
      return soundObj;
    } catch (error) {
      console.error(`Error playing positional sound "${name}":`, error);
      soundObj.active = false;
      return null;
    }
  }
  
  /**
   * Updates the position of the listener in 3D space
   * @param {THREE.Vector3} position - Position of the listener
   * @param {THREE.Vector3} front - Front direction vector
   * @param {THREE.Vector3} up - Up direction vector
   */
  updateListenerPosition(position, front, up) {
    if (!position || !front || !up) return;
    
    try {
      const listener = this.audioContext.listener;
      
      // Set position
      if (listener.positionX) {
        // Modern browsers with AudioListener object
        listener.positionX.setValueAtTime(position.x, this.audioContext.currentTime);
        listener.positionY.setValueAtTime(position.y, this.audioContext.currentTime);
        listener.positionZ.setValueAtTime(position.z, this.audioContext.currentTime);
        
        // Set orientation (forward and up vectors)
        listener.forwardX.setValueAtTime(front.x, this.audioContext.currentTime);
        listener.forwardY.setValueAtTime(front.y, this.audioContext.currentTime);
        listener.forwardZ.setValueAtTime(front.z, this.audioContext.currentTime);
        listener.upX.setValueAtTime(up.x, this.audioContext.currentTime);
        listener.upY.setValueAtTime(up.y, this.audioContext.currentTime);
        listener.upZ.setValueAtTime(up.z, this.audioContext.currentTime);
      } else {
        // Older browsers with deprecated methods
        listener.setPosition(position.x, position.y, position.z);
        listener.setOrientation(front.x, front.y, front.z, up.x, up.y, up.z);
      }
    } catch (error) {
      console.error('Error updating listener position:', error);
    }
  }
  
  /**
   * Stops all currently playing sounds in a category
   * @param {string} category - Sound category to stop
   */
  stopCategorySounds(category) {
    if (!this.activeSounds[category]) return;
    
    for (const sound of this.activeSounds[category]) {
      if (sound.source) {
        try {
          sound.source.stop();
        } catch (e) {
          // Ignore errors if already stopped
        }
        sound.active = false;
      }
    }
    
    // Clear the active sounds array for this category
    this.activeSounds[category] = [];
  }
  
  /**
   * Stops all currently playing sounds
   */
  stopAllSounds() {
    for (const category in this.activeSounds) {
      this.stopCategorySounds(category);
    }
  }
  
  /**
   * Optimized method for footstep sounds
   * @param {string} foot - 'left' or 'right'
   * @param {THREE.Vector3} position - 3D position
   * @param {number} volume - Volume
   */
  playFootstep(foot, position, volume = 1.0) {
    const soundName = foot === 'left' ? 'leftstep' : 'rightstep';
    
    // Footsteps use a mix of non-spatial and spatial audio for better perception
    // Play a direct sound at lower volume
    this.playSound(soundName, 50, volume * 0.4);
    
    // And a spatial sound at the foot position
    this.playSoundAt(soundName, position, 50, volume * 0.7);
  }
}

================================================
File: /public/js/train-animation.js
================================================
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // Sky blue background

// Camera setup
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 50, 100);

// Renderer setup
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 5, 5);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
scene.add(directionalLight);

// Ground
const groundGeometry = new THREE.PlaneGeometry(200, 200);
const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x228B22,  // Forest green
    side: THREE.DoubleSide 
});
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// Create a circular path
const radius = 50; // 100m diameter means 50m radius
const numPoints = 100;
const points = [];

for (let i = 0; i < numPoints; i++) {
    const angle = (i / numPoints) * Math.PI * 2;
    const x = Math.cos(angle) * radius;
    const z = Math.sin(angle) * radius;
    points.push(new THREE.Vector3(x, 0, z));
}

// Create closed loop
points.push(points[0].clone());

// Create spline from points
const spline = new THREE.CatmullRomCurve3(points);
spline.closed = true;

// Visualize the path with a line
const pathGeometry = new THREE.BufferGeometry().setFromPoints(spline.getPoints(200));
const pathMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
const pathLine = new THREE.Line(pathGeometry, pathMaterial);
scene.add(pathLine);

// Variables for animation
let train;
let trainLoaded = false;
let progress = 0;

// Load train model
const loader = new GLTFLoader();
loader.load(
    '../models/train.glb',
    (gltf) => {
        train = gltf.scene;
        train.traverse((node) => {
            if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // Scale and position the train
        train.scale.set(2, 2, 2);
        train.position.y = 0; // Adjust as needed based on the model
        
        // Add to scene
        scene.add(train);
        trainLoaded = true;
        
        console.log('Train model loaded successfully');
    },
    (xhr) => {
        console.log(`Loading: ${(xhr.loaded / xhr.total) * 100}% loaded`);
    },
    (error) => {
        console.error('Error loading train model:', error);
    }
);

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    
    // Update controls
    controls.update();
    
    // Move the train along the path
    if (trainLoaded) {
        // Increment progress
        progress += 0.0005; // Adjust speed here
        if (progress > 1) progress = 0;
        
        // Get position on the path
        const position = spline.getPointAt(progress);
        train.position.copy(position);
        
        // Orient the train to follow the path
        const tangent = spline.getTangentAt(progress).normalize();
        
        // Make the train rotate to face the direction of motion
        // We're assuming the train's forward axis is along the z-axis
        const up = new THREE.Vector3(0, 1, 0);
        const axis = new THREE.Vector3().crossVectors(up, tangent).normalize();
        
        // Calculate the rotation angle
        const radians = Math.acos(up.dot(tangent));
        
        // Apply the rotation - use quaternion to avoid gimbal lock
        train.quaternion.setFromAxisAngle(axis, radians);
        
        // Rotate 90 degrees on Y to align with track
        train.rotateY(Math.PI / 2);
    }
    
    // Render
    renderer.render(scene, camera);
}

animate(); 

================================================
File: /public/js/tumbleweed.js
================================================
/**
 * Handles tumbleweeds that spawn around the town and travel across the desert.
 */

/**
 * Represents a single tumbleweed in the world.
 */
export class Tumbleweed {
    constructor(scene, position, direction) {
      this.scene = scene;
      this.position = position || new THREE.Vector3(0, 0, 0);
      this.direction = direction || new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
      
      // Initialize properties
      this.initProperties();
      
      // Create group and add to scene
      this.group = new THREE.Group();
      this.group.position.copy(this.position);
      this.isLoaded = false;
      scene.add(this.group);
      
      // Load the model
      this.loadTumbleweedModel();
    }
  
    initProperties() {
      // Speed variables
      this.baseSpeed = 0.05 + Math.random() * 0.03;
      this.currentSpeed = this.baseSpeed;
      this.targetSpeed = this.currentSpeed;
      this.minSpeedMultiplier = 0.5;
      this.maxSpeedMultiplier = 1.8;
      this.speedChangeTimer = 0;
      this.speedChangeInterval = 2 + Math.random() * 3;
      
      // Bounce variables
      this.baseHeight = 0.2;
      this.bounceHeight = 0.5 + Math.random() * 0.8;
      this.currentBounceHeight = 0;
      this.isBouncing = Math.random() < 0.7;
      this.targetBounceHeight = this.isBouncing ? this.bounceHeight : 0;
      this.bounceFrequency = 0.3 + Math.random() * 0.3;
      this.bounceTime = Math.random() * Math.PI * 2;
      this.bouncePhaseTimer = 0;
      this.bouncePhaseInterval = 3 + Math.random() * 5;
      
      // Transition rates
      this.speedTransitionRate = 0.5;
      this.bounceTransitionRate = 0.2;
      
      // Animation properties
      this.animationMixer = null;
      this.animations = {};
      this.rotationAxis = new THREE.Vector3(0, 1, 0);
      this.rotationSpeed = 0.5 + Math.random() * 0.5;
      this.lastBounceHeight = 0;
      
      // Distance properties
      this.maxDistance = 800;
      this.distanceTraveled = 0;
      
      // Collision properties
      this.hitbox = new THREE.Sphere(this.position.clone(), 2.0);
      this.isExploding = false;
      this.explosionStartTime = 0;
      this.explosionDuration = 3.0;
      this.fragmentMeshes = [];
      this.fragmentVelocities = [];
      this.fragmentRotations = [];
      this.fragmentGroundTime = [];
      this.dustParticles = null;
    }
  
    /**
     * Loads the tumbleweed model and animations
     */
    loadTumbleweedModel() {
      // Try to use preloaded model first
      if (window.preloadedModels && (window.preloadedModels.tumbleweed || window.preloadedModels.tumbleweed_clone)) {
        try {
          const preloadedModel = window.preloadedModels.tumbleweed_clone || window.preloadedModels.tumbleweed;
          const gltf = {
            scene: preloadedModel.scene.clone(),
            animations: preloadedModel.animations
          };
          
          this.setupModel(gltf);
          return;
        } catch (e) {
          console.error('Error using preloaded tumbleweed model:', e);
        }
      }
      
      // Fall back to loading model from file
      new THREE.GLTFLoader().load(
        'models/tumbleweed.glb', 
        gltf => this.setupModel(gltf),
        undefined,
        error => console.error('Error loading tumbleweed.glb model:', error)
      );
    }
    
    setupModel(gltf) {
      this.model = gltf.scene;
      this.model.position.set(0, 0, 0);
      
      // Scale model
      const scale = 1.5 + Math.random() * 1.0;
      this.model.scale.set(scale, scale, scale);
      
      this.group.add(this.model);
      
      // Setup materials and shadows
      this.model.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
          
          if (child.material) {
            if (child.isSkinnedMesh) child.material.skinning = true;
            child.material.needsUpdate = true;
          }
        }
      });
      
      // Set up animations
      if (gltf.animations && gltf.animations.length > 0) {
        this.setupAnimations(gltf.animations);
      }
      
      this.storeFragmentMeshes();
      this.isLoaded = true;
    }
    
    /**
     * Store references to fragment meshes
     */
    storeFragmentMeshes() {
      this.fragmentMeshes = [];
      
      this.model.traverse(child => {
        if (child.isMesh && child.name && child.name.match(/fragment[1-8]/i)) {
          this.fragmentMeshes.push(child);
          
          // Store original transform data
          child.userData = {
            originalPosition: child.position.clone(),
            originalRotation: child.rotation.clone(),
            originalQuaternion: child.quaternion.clone(),
            originalScale: child.scale.clone(),
            originalVisibility: child.visible
          };
        }
      });
    }
  
    /**
     * Sets up animations from the loaded model
     * @param {Array} animations - The animations from the GLB file
     */
    setupAnimations(animations) {
      if (!animations || animations.length === 0) return;
      
      this.animationMixer = new THREE.AnimationMixer(this.model);
      
      animations.forEach(animation => {
        this.animations[animation.name] = this.animationMixer.clipAction(animation);
        
        if (animation.name === 'tumble') {
          const anim = this.animations[animation.name];
          anim.setLoop(THREE.LoopRepeat);
          anim.clampWhenFinished = false;
          anim.fadeIn(0.5);
          anim.zeroSlopeAtEnd = true;
          anim.zeroSlopeAtStart = true;
          anim.play();
        }
      });
    }
    
    /**
     * Handles collision with a bullet
     * @returns {boolean} True if hit was successful
     */
    hit() {
      if (!this.isLoaded || this.isExploding) return false;
      this.explode();
      return true;
    }
    
    /**
     * Start the explosion/shattering effect
     */
    explode() {
      if (!this.isLoaded || this.isExploding) return;
      
      this.isExploding = true;
      this.explosionStartTime = performance.now() / 1000.0;
      
      if (this.animations['tumble']) {
        this.animations['tumble'].stop();
      }
      
      this.playExplosionSound();
      this.setupFragmentPhysics();
      this.createDustEffect();
    }
    
    playExplosionSound() {
      const soundSources = [
        window.soundManager,
        window.localPlayer?.soundManager
      ];
      
      const soundSource = soundSources.find(s => s);
      if (!soundSource) return;
      
      if (!soundSource.buffers['tumbleweedexplode']) {
        soundSource.loadSound('tumbleweedexplode', 'sounds/tumbleweedexplode.mp3', 'impact');
      }
      
      soundSource.playSound('tumbleweedexplode', 0, 0.8 + Math.random() * 0.4, false);
    }
    
    setupFragmentPhysics() {
      this.fragmentVelocities = [];
      this.fragmentRotations = [];
      this.fragmentGroundTime = [];
      
      for (let i = 0; i < this.fragmentMeshes.length; i++) {
        const angle = Math.random() * Math.PI * 2;
        const upwardBias = 0.3 + Math.random() * 0.5;
        
        const velocity = new THREE.Vector3(
          Math.cos(angle) * (0.15 + Math.random() * 0.25),
          upwardBias,
          Math.sin(angle) * (0.15 + Math.random() * 0.25)
        );
        
        const rotation = new THREE.Vector3(
          (Math.random() - 0.5) * 5,
          (Math.random() - 0.5) * 5,
          (Math.random() - 0.5) * 5
        );
        
        this.fragmentVelocities.push(velocity);
        this.fragmentRotations.push(rotation);
        this.fragmentGroundTime.push(0);
      }
    }
    
    /**
     * Creates a dust particle effect for the tumbleweed explosion
     */
    createDustEffect() {
      if (window.effects && window.effects.createSmokeEffect) {
        this.dustParticles = window.effects.createSmokeEffect(
          this.group.position.clone(),
          new THREE.Vector3(0, 1, 0),
          this.scene
        );
        return;
      }
      
      // Create custom particle system
      const numParticles = 25;
      const dustGroup = new THREE.Group();
      dustGroup.position.copy(this.group.position);
      this.scene.add(dustGroup);
      
      const particles = [];
      
      for (let i = 0; i < numParticles; i++) {
        const size = 0.08 + Math.random() * 0.25;
        const geometry = i % 5 === 0 ? 
          new THREE.IcosahedronGeometry(size, 1) : 
          new THREE.IcosahedronGeometry(size, 0);
        
        const colorVariation = Math.random();
        const dustColor = new THREE.Color(
          0.6 + colorVariation * 0.2,
          0.5 + colorVariation * 0.2,
          0.4 + colorVariation * 0.15
        );
        
        const material = new THREE.MeshBasicMaterial({
          color: dustColor,
          transparent: true,
          opacity: 0.15 + Math.random() * 0.2,
          depthWrite: false
        });
        
        const particle = new THREE.Mesh(geometry, material);
        
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 0.5;
        const isGroundDust = Math.random() < 0.4;
        
        particle.position.set(
          Math.cos(angle) * radius,
          isGroundDust ? 0.05 + Math.random() * 0.1 : 0.1 + Math.random() * 0.4,
          Math.sin(angle) * radius
        );
        
        particle.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        dustGroup.add(particle);
        
        const vel = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          isGroundDust ? 0.05 + Math.random() * 0.15 : 0.2 + Math.random() * 0.4,
          (Math.random() - 0.5) * 0.5
        );
        
        particles.push({
          mesh: particle,
          velocity: vel,
          rotationSpeed: new THREE.Vector3(
            (Math.random() - 0.5) * 1.5,
            (Math.random() - 0.5) * 1.5,
            (Math.random() - 0.5) * 1.5
          ),
          life: 0,
          maxLife: isGroundDust ? 1.5 + Math.random() * 1.0 : 1.0 + Math.random() * 1.5,
          isGroundDust
        });
      }
      
      this.dustParticles = { dustGroup, particles };
    }
  
    /**
     * Updates the tumbleweed's position and animation
     * @param {number} deltaTime - Time elapsed since last frame
     */
    update(deltaTime) {
      if (!this.isLoaded) return false;
      
      const cappedDelta = Math.min(deltaTime, 0.1);
      this.hitbox.center.copy(this.group.position);
      
      return this.isExploding ? 
        this.updateExploding(cappedDelta) : 
        this.updateNormal(cappedDelta);
    }
    
    updateNormal(deltaTime) {
      // Update speed
      this.updateSpeed(deltaTime);
      
      // Update bounce
      this.updateBounce(deltaTime);
      
      // Update animation
      if (this.animationMixer) {
        this.animationMixer.update(deltaTime);
      }
      
      // Calculate movement
      const movement = this.direction.clone().multiplyScalar(this.currentSpeed);
      
      // Update position
      this.group.position.x += movement.x;
      this.group.position.z += movement.z;
      
      // Calculate bounce offset
      const bounceWave = Math.abs(Math.sin(this.bounceTime));
      const smoothBounceOffset = bounceWave * this.currentBounceHeight;
      this.lastBounceHeight = smoothBounceOffset;
      
      // Apply vertical position
      this.group.position.y = this.baseHeight + smoothBounceOffset;
      
      // Update distance traveled
      this.distanceTraveled += movement.length();
      
      // Update orientation
      this.group.lookAt(this.group.position.clone().add(this.direction));
      
      return this.distanceTraveled > this.maxDistance;
    }
    
    updateSpeed(deltaTime) {
      // Update speed change timer
      this.speedChangeTimer += deltaTime;
      if (this.speedChangeTimer >= this.speedChangeInterval) {
        this.speedChangeTimer = 0;
        this.targetSpeed = this.baseSpeed * (this.minSpeedMultiplier + Math.random() * (this.maxSpeedMultiplier - this.minSpeedMultiplier));
        this.speedChangeInterval = 2 + Math.random() * 3;
      }
      
      // Smooth transition to target speed
      const speedDiff = this.targetSpeed - this.currentSpeed;
      if (Math.abs(speedDiff) > 0.0001) {
        const step = Math.min(Math.abs(speedDiff), this.speedTransitionRate * deltaTime);
        this.currentSpeed += Math.sign(speedDiff) * step;
      }
    }
    
    updateBounce(deltaTime) {
      // Update bounce phase timer
      this.bouncePhaseTimer += deltaTime;
      if (this.bouncePhaseTimer >= this.bouncePhaseInterval) {
        this.bouncePhaseTimer = 0;
        this.isBouncing = Math.random() < 0.7;
        this.targetBounceHeight = this.isBouncing ? this.bounceHeight : 0;
        this.bouncePhaseInterval = 3 + Math.random() * 5;
      }
      
      // Smooth transition to target bounce height
      const bounceDiff = this.targetBounceHeight - this.currentBounceHeight;
      if (Math.abs(bounceDiff) > 0.0001) {
        const step = Math.min(Math.abs(bounceDiff), this.bounceTransitionRate * deltaTime);
        this.currentBounceHeight += Math.sign(bounceDiff) * step;
      }
      
      // Update bounce time
      this.bounceTime += deltaTime * this.bounceFrequency * Math.PI * 2;
    }
    
    updateExploding(deltaTime) {
      const currentTime = performance.now() / 1000.0;
      const explosionTime = currentTime - this.explosionStartTime;
      const explosionProgress = Math.min(explosionTime / this.explosionDuration, 1.0);
      
      // Update fragments
      this.updateFragments(deltaTime);
      
      // Update dust particles
      this.updateDustEffect(deltaTime, explosionProgress);
      
      // Return true when explosion is complete
      return explosionTime > this.explosionDuration;
    }
    
    updateFragments(deltaTime) {
      for (let i = 0; i < this.fragmentMeshes.length; i++) {
        const fragment = this.fragmentMeshes[i];
        const velocity = this.fragmentVelocities[i];
        const rotation = this.fragmentRotations[i];
        
        const isOnGround = fragment.position.y <= 0.05;
        
        if (isOnGround) {
          // Ground logic
          this.fragmentGroundTime[i] += deltaTime;
          fragment.position.y = 0.05;
          
          velocity.y = 0;
          velocity.x *= 0.7;
          velocity.z *= 0.7;
          
          if (this.fragmentGroundTime[i] > 0.2) {
            rotation.set(0, 0, 0);
          } else {
            rotation.x *= 0.7;
            rotation.z *= 0.7;
          }
          
          if (this.fragmentGroundTime[i] > 1.5) {
            const sinkProgress = Math.min((this.fragmentGroundTime[i] - 1.5) / 0.8, 1.0);
            fragment.position.y = 0.05 * (1.0 - sinkProgress);
            
            if (fragment.material && fragment.material.opacity !== undefined) {
              fragment.material.opacity = 1.0 - sinkProgress;
              fragment.material.transparent = true;
            }
          }
        } else {
          // Air logic
          velocity.y -= deltaTime * 0.9;
          
          fragment.position.x += velocity.x * deltaTime * 8;
          fragment.position.y += velocity.y * deltaTime * 8;
          fragment.position.z += velocity.z * deltaTime * 8;
          
          fragment.rotation.x += rotation.x * deltaTime;
          fragment.rotation.y += rotation.y * deltaTime;
          fragment.rotation.z += rotation.z * deltaTime;
          
          velocity.x *= 0.95;
          velocity.z *= 0.95;
          
          this.fragmentGroundTime[i] = 0;
        }
      }
    }
    
    updateDustEffect(deltaTime, explosionProgress) {
      if (!this.dustParticles) return;
      if (!this.dustParticles.particles) return;
      
      let anyAlive = false;
      
      for (const particle of this.dustParticles.particles) {
        particle.life += deltaTime;
        
        if (particle.life >= particle.maxLife) {
          particle.mesh.visible = false;
          continue;
        }
        
        anyAlive = true;
        const lifeProgress = particle.life / particle.maxLife;
        
        if (particle.isGroundDust) {
          this.updateGroundDustParticle(particle, deltaTime, lifeProgress);
        } else {
          this.updateAirborneDustParticle(particle, deltaTime, lifeProgress);
        }
      }
      
      if (!anyAlive && explosionProgress > 0.5) {
        this.cleanupDustEffect();
      }
    }
    
    updateGroundDustParticle(particle, deltaTime, lifeProgress) {
      particle.velocity.y -= deltaTime * 0.1;
      
      if (particle.mesh.position.y < 0.02) {
        particle.mesh.position.y = 0.02;
        particle.velocity.y = Math.max(0, particle.velocity.y);
      }
      
      const groundDampening = 1.0 - lifeProgress * 0.7;
      
      particle.mesh.position.x += particle.velocity.x * deltaTime * groundDampening * 1.5;
      particle.mesh.position.y += particle.velocity.y * deltaTime * groundDampening;
      particle.mesh.position.z += particle.velocity.z * deltaTime * groundDampening * 1.5;
      
      particle.mesh.rotation.x += particle.rotationSpeed.x * deltaTime * 0.5;
      particle.mesh.rotation.y += particle.rotationSpeed.y * deltaTime * 0.5;
      particle.mesh.rotation.z += particle.rotationSpeed.z * deltaTime * 0.5;
      
      const opacityFactor = lifeProgress < 0.6 ? 0.5 : 0.5 - (lifeProgress - 0.6) * 2.5;
      particle.mesh.material.opacity = 0.25 * opacityFactor;
      
      const scale = 1.0 + lifeProgress * 2.5;
      particle.mesh.scale.set(scale, scale * 0.6, scale);
    }
    
    updateAirborneDustParticle(particle, deltaTime, lifeProgress) {
      particle.velocity.y -= deltaTime * 0.2;
      
      const dampening = 1.0 - lifeProgress * 0.5;
      
      particle.mesh.position.x += particle.velocity.x * deltaTime * dampening;
      particle.mesh.position.y += particle.velocity.y * deltaTime * dampening;
      particle.mesh.position.z += particle.velocity.z * deltaTime * dampening;
      
      particle.mesh.rotation.x += particle.rotationSpeed.x * deltaTime * dampening;
      particle.mesh.rotation.y += particle.rotationSpeed.y * deltaTime * dampening;
      particle.mesh.rotation.z += particle.rotationSpeed.z * deltaTime * dampening;
      
      const opacityFactor = Math.pow(1.0 - lifeProgress, 1.5);
      particle.mesh.material.opacity = 0.2 * opacityFactor;
      
      const scale = 1.0 + lifeProgress * 2.0;
      particle.mesh.scale.set(scale, scale, scale);
    }
    
    cleanupDustEffect() {
      if (!this.dustParticles || !this.dustParticles.particles) return;
      
      this.scene.remove(this.dustParticles.dustGroup);
      
      for (const particle of this.dustParticles.particles) {
        if (particle.mesh) {
          if (particle.mesh.geometry) particle.mesh.geometry.dispose();
          if (particle.mesh.material) particle.mesh.material.dispose();
        }
      }
      
      this.dustParticles = null;
    }
  
    /**
     * Removes the tumbleweed from the scene
     */
    remove() {
      this.scene.remove(this.group);
      
      if (this.dustParticles) {
        this.cleanupDustEffect();
      }
      
      if (this.model) {
        this.model.traverse(child => {
          if (child.isMesh) {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(material => material.dispose());
              } else {
                child.material.dispose();
              }
            }
          }
        });
      }
    }
    
    /**
     * Resets the tumbleweed for reuse
     */
    reset() {
      this.isExploding = false;
      
      if (this.fragmentMeshes && this.fragmentMeshes.length > 0) {
        for (const fragment of this.fragmentMeshes) {
          // Restore original transform
          if (fragment.userData.originalPosition) {
            fragment.position.copy(fragment.userData.originalPosition);
          }
          
          if (fragment.userData.originalRotation) {
            fragment.rotation.copy(fragment.userData.originalRotation);
          }
          
          if (fragment.userData.originalQuaternion) {
            fragment.quaternion.copy(fragment.userData.originalQuaternion);
          }
          
          if (fragment.userData.originalScale) {
            fragment.scale.copy(fragment.userData.originalScale);
          }
          
          fragment.visible = fragment.userData.originalVisibility !== undefined ? 
            fragment.userData.originalVisibility : true;
        }
      }
      
      if (this.dustParticles) {
        this.cleanupDustEffect();
      }
      
      if (this.animations['tumble']) {
        this.animations['tumble'].reset();
        this.animations['tumble'].play();
      }
    }
  }
  
  /**
   * Manages multiple tumbleweeds in the scene
   */
  export class TumbleweedManager {
    constructor(scene, townDimensions) {
      this.scene = scene;
      this.townDimensions = townDimensions;
      this.tumbleweeds = [];
      this.tumbleweedPool = [];
      
      this.maxTumbleweeds = 5;
      this.spawnTimer = 0;
      this.spawnInterval = 5 + Math.random() * 3;
      
      this.preloadExplosionSound();
      this.initialSpawn();
    }
  
    preloadExplosionSound() {
      const tryLoadSound = (soundManager) => {
        if (soundManager) {
          soundManager.loadSound('tumbleweedexplode', 'sounds/tumbleweedexplode.mp3', 'impact');
        }
      };
      
      tryLoadSound(window.soundManager);
      tryLoadSound(window.localPlayer?.soundManager);
      
      // Retry a few times in case sound manager isn't loaded yet
      let retryCount = 0;
      const maxRetries = 5;
      
      const retryLoad = () => {
        if (retryCount >= maxRetries) return;
        
        tryLoadSound(window.soundManager);
        tryLoadSound(window.localPlayer?.soundManager);
        
        if ((window.soundManager?.buffers?.tumbleweedexplode) || 
            (window.localPlayer?.soundManager?.buffers?.tumbleweedexplode)) {
          return;
        }
        
        retryCount++;
        setTimeout(retryLoad, 1000);
      };
      
      setTimeout(retryLoad, 1000);
    }
  
    initialSpawn() {
      const initialCount = 2 + Math.floor(Math.random() * 2);
      for (let i = 0; i < initialCount; i++) {
        this.spawnTumbleweed();
      }
    }
  
    getTumbleweed(position, direction) {
      let tumbleweed;
      
      if (this.tumbleweedPool.length > 0) {
        tumbleweed = this.tumbleweedPool.pop();
        
        // Reset tumbleweed
        tumbleweed.position.copy(position);
        tumbleweed.direction.copy(direction);
        tumbleweed.group.position.copy(position);
        tumbleweed.distanceTraveled = 0;
        tumbleweed.currentSpeed = tumbleweed.baseSpeed;
        tumbleweed.targetSpeed = tumbleweed.currentSpeed;
        tumbleweed.currentBounceHeight = 0;
        tumbleweed.targetBounceHeight = tumbleweed.isBouncing ? tumbleweed.bounceHeight : 0;
        tumbleweed.rotationSpeed = 0.5 + Math.random() * 0.5;
        
        tumbleweed.reset();
        this.scene.add(tumbleweed.group);
      } else {
        tumbleweed = new Tumbleweed(this.scene, position, direction);
      }
      
      return tumbleweed;
    }
  
    spawnTumbleweed() {
      if (this.tumbleweeds.length >= this.maxTumbleweeds) return;
      
      // Calculate spawn position
      const angle = Math.random() * Math.PI * 2;
      const townSize = Math.max(this.townDimensions.width, this.townDimensions.length);
      const distance = townSize * (0.8 + Math.random() * 0.5);
      
      const position = new THREE.Vector3(
        Math.cos(angle) * distance,
        0.5,
        Math.sin(angle) * distance
      );
      
      // Calculate direction
      let directionAngle;
      
      if (Math.random() < 0.8) {
        // 80% chance to cross through town
        directionAngle = angle + Math.PI + (Math.random() - 0.5) * Math.PI / 3;
      } else {
        // 20% chance for random direction
        directionAngle = angle + Math.PI + (Math.random() - 0.5) * Math.PI;
      }
      
      const direction = new THREE.Vector3(
        Math.cos(directionAngle),
        0,
        Math.sin(directionAngle)
      ).normalize();
      
      // Create and add tumbleweed
      const tumbleweed = this.getTumbleweed(position, direction);
      this.tumbleweeds.push(tumbleweed);
    }
  
    recycleTumbleweed(tumbleweed, index) {
      this.tumbleweeds.splice(index, 1);
      this.scene.remove(tumbleweed.group);
      this.tumbleweedPool.push(tumbleweed);
    }
    
    checkRayIntersection(raycaster) {
      for (let i = 0; i < this.tumbleweeds.length; i++) {
        const tumbleweed = this.tumbleweeds[i];
        
        if (!tumbleweed.isLoaded || tumbleweed.isExploding) continue;
        
        const intersection = raycaster.ray.intersectSphere(tumbleweed.hitbox, new THREE.Vector3());
        
        if (intersection) {
          tumbleweed.hit();
          
          return {
            tumbleweed,
            point: intersection,
            distance: intersection.distanceTo(raycaster.ray.origin)
          };
        }
      }
      
      return null;
    }
  
    update(deltaTime) {
      // Update spawn timer
      this.spawnTimer += deltaTime;
      if (this.spawnTimer >= this.spawnInterval) {
        this.spawnTimer = 0;
        this.spawnTumbleweed();
        this.spawnInterval = 5 + Math.random() * 3;
      }
      
      // Update all tumbleweeds
      for (let i = this.tumbleweeds.length - 1; i >= 0; i--) {
        const shouldRemove = this.tumbleweeds[i].update(deltaTime);
        
        if (shouldRemove) {
          this.recycleTumbleweed(this.tumbleweeds[i], i);
        }
      }
    }
    
    dispose() {
      // Remove all tumbleweeds
      this.tumbleweeds.forEach(tumbleweed => tumbleweed.remove());
      this.tumbleweeds = [];
      
      // Remove all pooled tumbleweeds
      this.tumbleweedPool.forEach(tumbleweed => tumbleweed.remove());
      this.tumbleweedPool = [];
    }
  } 

================================================
File: /public/js/ui.js
================================================
/**
 * Updates the ammo counter in the UI.
 * @param {Player} player - The player instance.
 */
export function updateAmmoUI(player) {
  const ammoCounter = document.getElementById('ammo-counter');
  if (ammoCounter && player) {
    ammoCounter.textContent = `Bullets: ${player.bullets}/${player.maxBullets}`;
  }
}

/**
* Updates the health counter in the UI.
* @param {Player|ThirdPersonModel} player - The player instance.
*/
export function updateHealthUI(player) {
  const healthCounter = document.getElementById('health-counter');
  if (healthCounter && player) {
    const healthText = `Health: ${player.health}`;
    healthCounter.textContent = healthText;
    
    // Add visual indication of health level
    if (player.health > 75) {
      healthCounter.style.color = '#4CAF50'; // Green for good health
    } else if (player.health > 30) {
      healthCounter.style.color = '#FFC107'; // Yellow/amber for medium health
    } else {
      healthCounter.style.color = '#F44336'; // Red for low health
    }
  }
}

/**
* Shows a damage indicator when the player takes damage.
* @param {number} damage - The amount of damage taken.
* @param {string} hitZone - The hit zone ('head', 'body', 'limbs').
*/
export function showDamageIndicator(damage, hitZone) {
  // Use static variables to track combined damage
  if (!showDamageIndicator.lastTime) {
    showDamageIndicator.lastTime = 0;
    showDamageIndicator.combinedDamage = 0;
    showDamageIndicator.lastHitZone = null;
    showDamageIndicator.pendingTimeoutId = null;
  }
  
  const now = performance.now();
  const timeSinceLastHit = now - showDamageIndicator.lastTime;
  
  // If this hit is within 50ms of the previous one (shotgun pellets typically arrive together),
  // or it's the same hit zone, combine the damage
  if (timeSinceLastHit < 50 || (hitZone === showDamageIndicator.lastHitZone && timeSinceLastHit < 150)) {
    // Add to the combined damage
    showDamageIndicator.combinedDamage += damage;
    showDamageIndicator.lastTime = now;
    showDamageIndicator.lastHitZone = hitZone;
    
    // Clear any pending timeout
    if (showDamageIndicator.pendingTimeoutId) {
      clearTimeout(showDamageIndicator.pendingTimeoutId);
    }
    
    // Set a new timeout to show the combined damage
    showDamageIndicator.pendingTimeoutId = setTimeout(() => {
      displayDamageIndicator(showDamageIndicator.combinedDamage, showDamageIndicator.lastHitZone);
      // Reset the tracking variables
      showDamageIndicator.combinedDamage = 0;
      showDamageIndicator.pendingTimeoutId = null;
    }, 50);
  } else {
    // This is a new hit, not part of a shotgun blast, show it immediately
    showDamageIndicator.lastTime = now;
    showDamageIndicator.lastHitZone = hitZone;
    showDamageIndicator.combinedDamage = damage;
    
    displayDamageIndicator(damage, hitZone);
  }
}

/**
* Helper function to display the damage indicator UI element
* @param {number} damage - The amount of damage to display
* @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
*/
function displayDamageIndicator(damage, hitZone) {
  // Create damage indicator element if it doesn't exist
  let damageIndicator = document.getElementById('damage-indicator');
  if (!damageIndicator) {
      damageIndicator = document.createElement('div');
      damageIndicator.id = 'damage-indicator';
      damageIndicator.style.position = 'absolute';
      damageIndicator.style.top = '40%';
      damageIndicator.style.left = '50%';
      damageIndicator.style.transform = 'translate(-50%, -50%)';
      damageIndicator.style.color = 'red';
      damageIndicator.style.fontSize = '48px';
      damageIndicator.style.fontWeight = 'bold';
      damageIndicator.style.opacity = '0';
      damageIndicator.style.textShadow = '2px 2px 4px #000000';
      damageIndicator.style.transition = 'opacity 0.3s ease-in, opacity 0.5s ease-out';
      damageIndicator.style.zIndex = '1000';
      damageIndicator.style.pointerEvents = 'none';
      document.getElementById('game-container').appendChild(damageIndicator);
  }
  
  // Set text based on hit zone
  let hitText = `-${damage}`;
  if (hitZone) {
      switch (hitZone) {
          case 'head':
              hitText += ' HEADSHOT!';
              break;
          case 'body':
              hitText += ' (Body Shot)';
              break;
          case 'limbs':
              hitText += ' (Limb Shot)';
              break;
      }
  }
  
  // Display damage indicator
  damageIndicator.textContent = hitText;
  damageIndicator.style.opacity = '1';
  
  // Set color based on damage
  if (damage >= 100) {
      damageIndicator.style.color = '#FF0000'; // Bright red for headshots
      damageIndicator.style.fontSize = '64px';
  } else if (damage >= 40) {
      damageIndicator.style.color = '#FF4500'; // Orange-red for body shots
  } else {
      damageIndicator.style.color = '#FFA500'; // Orange for limb shots
  }
  
  // Fade out after a delay
  setTimeout(() => {
      damageIndicator.style.opacity = '0';
  }, 800);
}

/**
* Updates all UI elements related to player status.
* @param {Player} player - The player instance.
*/
export function updatePlayerUI(player) {
  updateAmmoUI(player);
  updateHealthUI(player);
}

================================================
File: /public/js/viewmodel-config.js
================================================
/**
 * Viewmodel Configuration Helper
 * Allows runtime adjustment of viewmodel position and scale
 */

// Disable debug mode for production
window.debugMode = false;

// Initialize viewmodel configuration when window loads
window.addEventListener('load', () => {
  // Check if we're in debug mode
  if (!window.debugMode) return;
  
  createViewmodelConfigUI();
});

/**
 * Creates a UI panel for configuring the viewmodel
 */
function createViewmodelConfigUI() {
  // Create container
  const container = document.createElement('div');
  container.id = 'viewmodel-config';
  container.style.position = 'fixed';
  container.style.top = '10px';
  container.style.right = '10px';
  container.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
  container.style.color = 'white';
  container.style.padding = '10px';
  container.style.borderRadius = '5px';
  container.style.zIndex = '1000';
  container.style.fontFamily = 'monospace';
  container.style.fontSize = '12px';
  container.style.width = '200px';
  
  // Create title
  const title = document.createElement('div');
  title.textContent = 'Viewmodel Config';
  title.style.fontWeight = 'bold';
  title.style.marginBottom = '10px';
  title.style.textAlign = 'center';
  container.appendChild(title);
  
  // Minimize button
  const minimizeBtn = document.createElement('button');
  minimizeBtn.textContent = '-';
  minimizeBtn.style.position = 'absolute';
  minimizeBtn.style.top = '5px';
  minimizeBtn.style.right = '5px';
  minimizeBtn.style.width = '20px';
  minimizeBtn.style.height = '20px';
  minimizeBtn.style.padding = '0';
  minimizeBtn.style.border = 'none';
  minimizeBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
  minimizeBtn.style.cursor = 'pointer';
  container.appendChild(minimizeBtn);
  
  // Controls content
  const content = document.createElement('div');
  content.id = 'viewmodel-config-content';
  container.appendChild(content);
  
  // Add controls
  addFOVControl(content);
  addScaleControl(content);
  addPositionControls(content);
  addRotationControls(content);
  addEffectControls(content);
  
  // Apply/Reset buttons
  const buttonContainer = document.createElement('div');
  buttonContainer.style.display = 'flex';
  buttonContainer.style.justifyContent = 'space-between';
  buttonContainer.style.marginTop = '10px';
  
  const resetBtn = document.createElement('button');
  resetBtn.textContent = 'Reset';
  resetBtn.style.padding = '5px 10px';
  resetBtn.addEventListener('click', resetViewmodelConfig);
  
  const copyBtn = document.createElement('button');
  copyBtn.textContent = 'Copy JSON';
  copyBtn.style.padding = '5px 10px';
  copyBtn.addEventListener('click', copyConfigAsJSON);
  
  buttonContainer.appendChild(resetBtn);
  buttonContainer.appendChild(copyBtn);
  content.appendChild(buttonContainer);
  
  // Add to document
  document.body.appendChild(container);
  
  // Add minimize functionality
  let isMinimized = false;
  minimizeBtn.addEventListener('click', () => {
    isMinimized = !isMinimized;
    content.style.display = isMinimized ? 'none' : 'block';
    minimizeBtn.textContent = isMinimized ? '+' : '-';
    container.style.width = isMinimized ? 'auto' : '200px';
  });
}

/**
 * Adds FOV control to the config panel
 */
function addFOVControl(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'FOV';
  container.appendChild(label);
  
  const input = document.createElement('input');
  input.type = 'range';
  input.min = '60';
  input.max = '120';
  input.step = '1';
  input.style.width = '100%';
  input.id = 'camera-fov';
  
  // Set initial value if player exists
  if (window.localPlayer && window.localPlayer.camera) {
    input.value = window.localPlayer.camera.fov;
  } else {
    input.value = 90;
  }
  
  input.addEventListener('input', () => {
    if (window.localPlayer && window.localPlayer.camera) {
      const fov = parseFloat(input.value);
      window.localPlayer.camera.fov = fov;
      window.localPlayer.camera.updateProjectionMatrix();
      updateValueDisplay('fov-value', fov.toFixed(0));
    }
  });
  
  container.appendChild(input);
  
  // Value display
  const valueDisplay = document.createElement('div');
  valueDisplay.id = 'fov-value';
  valueDisplay.textContent = input.value;
  valueDisplay.style.textAlign = 'right';
  valueDisplay.style.fontSize = '10px';
  container.appendChild(valueDisplay);
  
  parent.appendChild(container);
}

/**
 * Adds scale control to the config panel
 */
function addScaleControl(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'Scale';
  container.appendChild(label);
  
  const input = document.createElement('input');
  input.type = 'range';
  input.min = '0.01';
  input.max = '1.0';
  input.step = '0.01';
  input.style.width = '100%';
  input.id = 'viewmodel-scale';
  
  // Set initial value if player exists
  if (window.localPlayer && window.localPlayer.viewmodel) {
    input.value = window.localPlayer.viewmodel.SCALE;
  } else {
    input.value = 0.05;
  }
  
  input.addEventListener('input', () => {
    if (window.localPlayer && window.localPlayer.viewmodel) {
      const scale = parseFloat(input.value);
      window.localPlayer.viewmodel.SCALE = scale;
      window.localPlayer.viewmodel.group.scale.set(scale, scale, scale);
      updateValueDisplay('scale-value', scale.toFixed(3));
    }
  });
  
  container.appendChild(input);
  
  // Value display
  const valueDisplay = document.createElement('div');
  valueDisplay.id = 'scale-value';
  valueDisplay.textContent = input.value;
  valueDisplay.style.textAlign = 'right';
  valueDisplay.style.fontSize = '10px';
  container.appendChild(valueDisplay);
  
  parent.appendChild(container);
}

/**
 * Adds position controls to the config panel
 */
function addPositionControls(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'Position';
  container.appendChild(label);
  
  // X, Y, Z controls
  const axes = ['x', 'y', 'z'];
  axes.forEach(axis => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';
    
    const axisLabel = document.createElement('div');
    axisLabel.textContent = axis.toUpperCase();
    axisLabel.style.width = '20px';
    row.appendChild(axisLabel);
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = '-3';
    input.max = '3';
    input.step = '0.05';
    input.style.flexGrow = '1';
    input.id = `viewmodel-pos-${axis}`;
    
    // Set initial value if player exists
    if (window.localPlayer && window.localPlayer.viewmodel) {
      if (axis === 'z') {
        // Z position includes forward clip
        input.value = window.localPlayer.viewmodel.group.position[axis] - 
                      window.localPlayer.viewmodel.FORWARD_CLIP;
      } else {
        input.value = window.localPlayer.viewmodel.group.position[axis];
      }
    } else {
      input.value = 0;
    }
    
    input.addEventListener('input', () => {
      if (window.localPlayer && window.localPlayer.viewmodel) {
        const position = parseFloat(input.value);
        
        // Update viewmodel object
        window.localPlayer.viewmodel.POSITION[axis] = position;
        
        // Update actual position in scene
        if (axis === 'z') {
          // Add forward clip for z-axis
          window.localPlayer.viewmodel.group.position[axis] = 
            position + window.localPlayer.viewmodel.FORWARD_CLIP;
        } else {
          window.localPlayer.viewmodel.group.position[axis] = position;
        }
        
        updateValueDisplay(`pos-${axis}-value`, position.toFixed(2));
      }
    });
    
    row.appendChild(input);
    
    // Value display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = `pos-${axis}-value`;
    valueDisplay.textContent = input.value;
    valueDisplay.style.width = '40px';
    valueDisplay.style.textAlign = 'right';
    valueDisplay.style.fontSize = '10px';
    row.appendChild(valueDisplay);
    
    container.appendChild(row);
  });
  
  parent.appendChild(container);
}

/**
 * Adds rotation controls to the config panel
 */
function addRotationControls(parent) {
  const container = document.createElement('div');
  container.style.marginBottom = '10px';
  
  const label = document.createElement('div');
  label.textContent = 'Rotation';
  container.appendChild(label);
  
  // X, Y, Z controls
  const axes = ['x', 'y', 'z'];
  axes.forEach(axis => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';
    
    const axisLabel = document.createElement('div');
    axisLabel.textContent = axis.toUpperCase();
    axisLabel.style.width = '20px';
    row.appendChild(axisLabel);
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = '-3.14';
    input.max = '3.14';
    input.step = '0.05';
    input.style.flexGrow = '1';
    input.id = `viewmodel-rot-${axis}`;
    
    // Set initial value if player exists
    if (window.localPlayer && window.localPlayer.viewmodel) {
      input.value = window.localPlayer.viewmodel.group.rotation[axis];
    } else {
      input.value = 0;
    }
    
    input.addEventListener('input', () => {
      if (window.localPlayer && window.localPlayer.viewmodel) {
        const rotation = parseFloat(input.value);
        
        // Update viewmodel object
        window.localPlayer.viewmodel.ROTATION[axis] = rotation;
        window.localPlayer.viewmodel.group.rotation[axis] = rotation;
        
        updateValueDisplay(`rot-${axis}-value`, rotation.toFixed(2));
      }
    });
    
    row.appendChild(input);
    
    // Value display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = `rot-${axis}-value`;
    valueDisplay.textContent = input.value;
    valueDisplay.style.width = '40px';
    valueDisplay.style.textAlign = 'right';
    valueDisplay.style.fontSize = '10px';
    row.appendChild(valueDisplay);
    
    container.appendChild(row);
  });
  
  parent.appendChild(container);
}

/**
 * Adds effect position controls
 */
function addEffectControls(parent) {
  const container = document.createElement('div');
  
  const label = document.createElement('div');
  label.textContent = 'Muzzle Flash';
  container.appendChild(label);
  
  // X, Y, Z controls for muzzle flash
  const axes = ['x', 'y', 'z'];
  axes.forEach(axis => {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.marginBottom = '5px';
    
    const axisLabel = document.createElement('div');
    axisLabel.textContent = axis.toUpperCase();
    axisLabel.style.width = '20px';
    row.appendChild(axisLabel);
    
    const input = document.createElement('input');
    input.type = 'range';
    input.min = '-10';
    input.max = '10';
    input.step = '0.1';
    input.style.flexGrow = '1';
    input.id = `muzzle-${axis}`;
    
    // Set initial value if player exists
    if (window.localPlayer && window.localPlayer.viewmodel) {
      input.value = window.localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH[axis];
    } else {
      input.value = axis === 'z' ? -1.67 : (axis === 'x' ? 0.33 : -0.17);
    }
    
    input.addEventListener('input', () => {
      if (window.localPlayer && window.localPlayer.viewmodel) {
        const position = parseFloat(input.value);
        
        // Update viewmodel object
        window.localPlayer.viewmodel.EFFECTS.MUZZLE_FLASH[axis] = position;
        
        // Update actual position if muzzle anchor exists
        if (window.localPlayer.viewmodel.muzzleFlashAnchor) {
          window.localPlayer.viewmodel.muzzleFlashAnchor.position[axis] = position;
        }
        
        updateValueDisplay(`muzzle-${axis}-value`, position.toFixed(2));
      }
    });
    
    row.appendChild(input);
    
    // Value display
    const valueDisplay = document.createElement('div');
    valueDisplay.id = `muzzle-${axis}-value`;
    valueDisplay.textContent = input.value;
    valueDisplay.style.width = '40px';
    valueDisplay.style.textAlign = 'right';
    valueDisplay.style.fontSize = '10px';
    row.appendChild(valueDisplay);
    
    container.appendChild(row);
  });
  
  parent.appendChild(container);
}

/**
 * Updates a value display element
 */
function updateValueDisplay(id, value) {
  const element = document.getElementById(id);
  if (element) {
    element.textContent = value;
  }
}

/**
 * Resets all viewmodel configuration to defaults
 */
function resetViewmodelConfig() {
  if (!window.localPlayer || !window.localPlayer.viewmodel) return;
  
  const viewmodel = window.localPlayer.viewmodel;
  
  // Reset FOV
  if (window.localPlayer.camera) {
    window.localPlayer.camera.fov = 90;
    window.localPlayer.camera.updateProjectionMatrix();
  }
  
  // Reset scale
  viewmodel.SCALE = 1.0;
  viewmodel.group.scale.set(1.0, 1.0, 1.0);
  
  // Reset position
  viewmodel.POSITION = { x: 0, y: 0, z: -0.5 };
  viewmodel.group.position.set(0, 0, -0.5 + viewmodel.FORWARD_CLIP);
  
  // Reset rotation
  viewmodel.ROTATION = { x: 0, y: 0, z: 0 };
  viewmodel.group.rotation.set(0, 0, 0);
  
  // Reset muzzle flash position
  viewmodel.EFFECTS.MUZZLE_FLASH = {
    x: 0.33,
    y: -0.17,
    z: -1.67,
    scale: 0.1
  };
  
  if (viewmodel.muzzleFlashAnchor) {
    viewmodel.muzzleFlashAnchor.position.set(0.33, -0.17, -1.67);
  }
  
  // Update all input fields to match the reset values
  updateConfigInputs();
}

/**
 * Updates all input fields to match current values
 */
function updateConfigInputs() {
  if (!window.localPlayer || !window.localPlayer.viewmodel) return;
  
  const viewmodel = window.localPlayer.viewmodel;
  
  // Update FOV input
  const fovInput = document.getElementById('camera-fov');
  if (fovInput && window.localPlayer.camera) {
    fovInput.value = window.localPlayer.camera.fov;
    updateValueDisplay('fov-value', window.localPlayer.camera.fov.toFixed(0));
  }
  
  // Update scale input
  const scaleInput = document.getElementById('viewmodel-scale');
  if (scaleInput) {
    scaleInput.value = viewmodel.SCALE;
    updateValueDisplay('scale-value', viewmodel.SCALE.toFixed(3));
  }
  
  // Update position inputs
  ['x', 'y', 'z'].forEach(axis => {
    const input = document.getElementById(`viewmodel-pos-${axis}`);
    if (input) {
      const value = axis === 'z' ? 
        viewmodel.group.position[axis] - viewmodel.FORWARD_CLIP : 
        viewmodel.group.position[axis];
      
      input.value = value;
      updateValueDisplay(`pos-${axis}-value`, value.toFixed(2));
    }
  });
  
  // Update rotation inputs
  ['x', 'y', 'z'].forEach(axis => {
    const input = document.getElementById(`viewmodel-rot-${axis}`);
    if (input) {
      input.value = viewmodel.group.rotation[axis];
      updateValueDisplay(`rot-${axis}-value`, viewmodel.group.rotation[axis].toFixed(2));
    }
  });
  
  // Update muzzle flash inputs
  ['x', 'y', 'z'].forEach(axis => {
    const input = document.getElementById(`muzzle-${axis}`);
    if (input) {
      input.value = viewmodel.EFFECTS.MUZZLE_FLASH[axis];
      updateValueDisplay(`muzzle-${axis}-value`, viewmodel.EFFECTS.MUZZLE_FLASH[axis].toFixed(2));
    }
  });
}

/**
 * Copies the current viewmodel configuration as JSON
 */
function copyConfigAsJSON() {
  if (!window.localPlayer || !window.localPlayer.viewmodel) return;
  
  const viewmodel = window.localPlayer.viewmodel;
  
  const config = {
    FOV: window.localPlayer.camera ? window.localPlayer.camera.fov : 90,
    SCALE: viewmodel.SCALE,
    POSITION: {
      x: viewmodel.POSITION.x,
      y: viewmodel.POSITION.y,
      z: viewmodel.POSITION.z
    },
    ROTATION: {
      x: viewmodel.ROTATION.x,
      y: viewmodel.ROTATION.y,
      z: viewmodel.ROTATION.z
    },
    FORWARD_CLIP: viewmodel.FORWARD_CLIP,
    EFFECTS: {
      MUZZLE_FLASH: {
        x: viewmodel.EFFECTS.MUZZLE_FLASH.x,
        y: viewmodel.EFFECTS.MUZZLE_FLASH.y,
        z: viewmodel.EFFECTS.MUZZLE_FLASH.z,
        scale: viewmodel.EFFECTS.MUZZLE_FLASH.scale
      },
      SMOKE_RING: viewmodel.EFFECTS.SMOKE_RING,
      BULLET_SPAWN: viewmodel.EFFECTS.BULLET_SPAWN
    }
  };
  
  const json = JSON.stringify(config, null, 2);
  navigator.clipboard.writeText(json).then(() => {
    console.log('Viewmodel config copied to clipboard');
    
    // Flash the copy button to indicate success
    const copyBtn = document.querySelector('#viewmodel-config button:nth-child(2)');
    if (copyBtn) {
      copyBtn.textContent = 'Copied!';
      setTimeout(() => {
        copyBtn.textContent = 'Copy JSON';
      }, 1000);
    }
  });
} 

================================================
File: /public/js/viewmodel.js
================================================
/**
 * A proper FPS viewmodel implementation with animation support
 * Handles animations for aim, fakeshoot, holster, idle, reload, and shoot actions
 */
export class Viewmodel {
  constructor() {
    // Adjustable constants for positioning the viewmodel
    this.SCALE = 1.0;  // Updated based on user preference
    this.POSITION = {
      x: 0,   // positive moves right
      y: 0,   // negative moves down 
      z: -0.5 // negative moves closer to camera, updated based on user preference
    };
    
    // Rotation adjustment (in radians)
    this.ROTATION = {
      x: 0,     // pitch
      y: 0,     // yaw
      z: 0      // roll
    };
    
    // Forward clipping offset - how far forward to position model
    this.FORWARD_CLIP = 0.18; // Increased from 0.16 to push model further from camera
    
    // Effect positioning constants
    this.EFFECTS = {
      // Muzzle flash anchor position (relative to model)
      MUZZLE_FLASH: {
        x: -0.05,       // Left/right offset of muzzle flash
        y: 0.1,      // Up/down offset of muzzle flash
        z: -0.1,      // Forward/backward offset of muzzle flash (negative = forward)
        scale: 0.1     // Scale of muzzle flash effect
      },
      
      // Smoke ring effect positioning
      SMOKE_RING: {
        forward_offset: 0.05,  // Forward offset from barrel
        x_offset: 0,           // Left/right offset from barrel
        y_offset: 0,           // Up/down offset from barrel
        scale: 1.0             // Scale of smoke ring effect
      },
      
      // Bullet spawn position (forward offset from muzzle)
      BULLET_SPAWN: {
        forward_offset: 0.1   // Forward distance from muzzle to spawn bullets
      }
    };
    
    this.group = new THREE.Group();
    this.animations = {};
    this.mixer = null;
    this.actions = {}; // Named references to configured actions
    this.currentAction = null;
    this.primaryAction = null; // The main active action
    this.secondaryAction = null; // Secondary blended action
    this.model = null;
    this.muzzleFlashAnchor = null;
    this.isLoaded = false;
    this.animationsConfigured = false;
    
    // Animation states and transitions
    this.animationState = 'none';
    this.transitionInProgress = false;
    this.queue = []; // Queue for animations to play in sequence
    this.pendingAimTransition = false; // Flag to track pending transition to aim from draw
    
    // Timeout tracking for animation callbacks
    this._actionTimeoutId = null;
    this._holsterTimeoutId = null;
    
    // Flags to prevent holstering and keep viewmodel visible
    this.blockHolster = false;
    this.pendingHolster = false;
    this.forceVisible = false; // New flag to keep viewmodel visible
    
    // Skin system
    this.activeSkin = null;
    this.availableSkins = {
      default: null, // Default texture will be stored here after loading
      bananaSkin: null // Will be loaded on demand
    };
    this.skinPermissions = {
      bananaSkin: false // By default, skin is locked until verified with NFT
    };
    
    // Set up with proper scale and position
    this.group.scale.set(this.SCALE, this.SCALE, this.SCALE);
    this.group.position.set(
      this.POSITION.x, 
      this.POSITION.y, 
      this.POSITION.z + this.FORWARD_CLIP
    );
    this.group.rotation.set(
      this.ROTATION.x,
      this.ROTATION.y,
      this.ROTATION.z
    );
    
    // Load the viewmodel with its animations
    this._loadModel();
    
    // Initially hidden until the player aims
    this.group.visible = false;
  }
  
  /**
   * Loads the viewmodel and its animations
   * @private
   */
  _loadModel() {
    // Check if we have a preloaded viewmodel
    if (window.preloadedModels && (window.preloadedModels.viewmodel || window.preloadedModels.viewmodel_clone)) {
      console.log("Using preloaded viewmodel");
      try {
        // Use the clone version to avoid reference issues
        const preloadedModel = window.preloadedModels.viewmodel_clone || window.preloadedModels.viewmodel;
        const gltf = {
          scene: preloadedModel.scene.clone(),
          animations: preloadedModel.animations
        };
        
        this.model = gltf.scene;
        this.group.add(this.model);
        
        // Setup animations
        this.mixer = new THREE.AnimationMixer(this.model);
        
        // Remove verbose animation logging
        if (gltf.animations && gltf.animations.length) {
          this._setupActions(gltf.animations);
        } else {
          console.warn('No animations found in preloaded viewmodel!');
        }
        
        // Keep this single log to confirm successful loading
        console.log('Viewmodel loaded successfully from preload');
        this.isLoaded = true;
        
        // Create a muzzle flash anchor
        this._createMuzzleFlashAnchor();
        return; // Exit early since we've handled the model
      } catch (e) {
        console.error('Error using preloaded viewmodel:', e);
        // Fall through to regular loading method if preloaded model fails
      }
    }
    
    const loader = new THREE.GLTFLoader();
    loader.load(
      'models/viewmodel.glb',
      (gltf) => {
        this.model = gltf.scene;
        this.group.add(this.model);
        
        // Setup animations
        this.mixer = new THREE.AnimationMixer(this.model);
        
        // Remove verbose animation logging
        if (gltf.animations && gltf.animations.length) {
          this._setupActions(gltf.animations);
        } else {
          console.warn('No animations found in viewmodel.glb!');
        }
        
        // Keep this single log to confirm successful loading
        console.log('Viewmodel loaded successfully');
        this.isLoaded = true;
        
        // Create a muzzle flash anchor
        this._createMuzzleFlashAnchor();
      },
      undefined,
      (error) => {
        console.error('Error loading viewmodel:', error);
      }
    );
  }
  
  /**
   * Set up all animation actions with proper configuration
   * @param {Array} animations - Array of AnimationClips from the loaded model
   * @private
   */
  _setupActions(animations) {
    // Index all animations by name
    animations.forEach(clip => {
      // Create action but don't play it yet
      const action = this.mixer.clipAction(clip);
      this.animations[clip.name] = action;
      
      // Default configuration
      action.enabled = false;
      action.setEffectiveWeight(0);
      action.loop = THREE.LoopOnce;
      action.clampWhenFinished = true;
      action.reset();
    });

    // Configure the new animation names
    this._findAndConfigureAction('idle', {
      loop: THREE.LoopRepeat, // This should loop continuously
      clampWhenFinished: false,
      alternatives: ['Idle']
    });
    
    this._findAndConfigureAction('revolverdraw', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['DrawAim', 'Draw', 'draw', 'drawaim']
    });
    
    this._findAndConfigureAction('revolveraim', {
      loop: THREE.LoopRepeat, // Should loop as long as player is aiming
      clampWhenFinished: false,
      alternatives: ['Aim', 'aim', 'AimLoop', 'aimloop']
    });
    
    this._findAndConfigureAction('revolverholster', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['Holster', 'holstering', 'holster']
    });
    
    this._findAndConfigureAction('revolvershot', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['Shoot', 'shoot', 'Fire', 'fire', 'shooting']
    });
    
    this._findAndConfigureAction('revolverreload', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['Reload', 'reload_gun', 'reload']
    });
    
    this._findAndConfigureAction('revolverempty', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['fakeshoot', 'empty', 'dryfire', 'no_ammo']
    });
    
    // Configure shotgun animation actions
    this._findAndConfigureAction('shotgundraw', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunDraw', 'ShotgunDraw']
    });
    
    this._findAndConfigureAction('shotgunaim', {
      loop: THREE.LoopRepeat,
      clampWhenFinished: false,
      alternatives: ['shotgunAim', 'ShotgunAim', 'shotgunaimloop', 'ShotgunAimLoop']
    });
    
    this._findAndConfigureAction('shotgunholster', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunHolster', 'ShotgunHolster', 'shotgunholstering']
    });
    
    this._findAndConfigureAction('shotgunshot', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunShoot', 'ShotgunShoot', 'shotgunfire', 'ShotgunFire']
    });
    
    this._findAndConfigureAction('shotgunreload', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunReload', 'ShotgunReload']
    });
    
    this._findAndConfigureAction('shotgunempty', {
      loop: THREE.LoopOnce,
      clampWhenFinished: true,
      alternatives: ['shotgunEmpty', 'ShotgunEmpty', 'shotgundryfire', 'ShotgunDryFire']
    });
    
    // Initialize with the idle animation
    if (this.actions.idle) {
      const idleAction = this.actions.idle;
      idleAction.enabled = true;
      idleAction.setEffectiveWeight(1);
      idleAction.play();
      
      this.primaryAction = idleAction;
      this.animationState = 'idle';
    }

    this.animationsConfigured = true;
  }
  
  /**
   * Find and configure an action, storing it in the actions object
   * @param {string} name - The action name to use as key
   * @param {Object} options - Configuration options for the action
   * @private
   * @returns {THREE.AnimationAction|null} - The configured action
   */
  _findAndConfigureAction(name, options) {
    const action = this._findAnimation(name, options.alternatives || []);
    if (!action) return null;
    
    // Apply configuration
    action.loop = options.loop || THREE.LoopOnce;
    action.clampWhenFinished = options.clampWhenFinished !== undefined ? options.clampWhenFinished : true;
    if (options.timeScale) action.timeScale = options.timeScale;
    
    // Store in actions map
    this.actions[name] = action;
    return action;
  }
  
  /**
   * Create and position the muzzle flash anchor
   * @private
   */
  _createMuzzleFlashAnchor() {
    // Create an anchor point for muzzle flash effects
    this.muzzleFlashAnchor = new THREE.Group();
    
    // Try to find the barrel / muzzle in the model
    const muzzle = this.model.getObjectByName('barrel') || 
                   this.model.getObjectByName('muzzle') ||
                   this.model.getObjectByName('barrelEnd') ||
                   this.model.getObjectByName('barrel_end');
    
    if (muzzle) {
      // If found, attach to the muzzle
      muzzle.add(this.muzzleFlashAnchor);
      // Adjust forward position using the constants
      this.muzzleFlashAnchor.position.set(
        this.EFFECTS.MUZZLE_FLASH.x,
        this.EFFECTS.MUZZLE_FLASH.y,
        this.EFFECTS.MUZZLE_FLASH.z
      );
      // Only log in debug mode
      if (window.debugMode) {
        console.log("Muzzle flash anchor attached to barrel");
      }
    } else {
      // If not found, attach to model root with an estimated position
      this.model.add(this.muzzleFlashAnchor);
      
      // Position the muzzle flash anchor using the constants
      this.muzzleFlashAnchor.position.set(
        this.EFFECTS.MUZZLE_FLASH.x,
        this.EFFECTS.MUZZLE_FLASH.y,
        this.EFFECTS.MUZZLE_FLASH.z
      );
      // Only log in debug mode
      if (window.debugMode) {
        console.log("Muzzle flash anchor attached to model root - no barrel found");
      }
    }
  }
  
  /**
   * Find an animation by name with various fallbacks
   * @param {string} baseName - The base animation name to find
   * @param {string[]} alternatives - Alternative names to try
   * @returns {THREE.AnimationAction|null} - The found animation action or null
   * @private
   */
  _findAnimation(baseName, alternatives = []) {
    // First try the exact name
    if (this.animations[baseName]) {
      return this.animations[baseName];
    }
    
    // Try alternatives
    for (const name of alternatives) {
      if (this.animations[name]) {
        return this.animations[name];
      }
    }
    
    // Try matching case-insensitively with all animations
    const lowerName = baseName.toLowerCase();
    for (const key of Object.keys(this.animations)) {
      if (key.toLowerCase() === lowerName || key.toLowerCase().includes(lowerName)) {
        return this.animations[key];
      }
    }
    
    // If nothing found, log error and return null
    console.warn(`Animation "${baseName}" not found! Available:`, Object.keys(this.animations));
    return null;
  }
  
  /**
   * Helper method to check if an animation can interrupt the current one
   * @param {string} newActionName - The action name that wants to play
   * @returns {boolean} - Whether interruption is allowed
   * @private
   */
  _canInterruptCurrentAnimation(newActionName) {
    const state = this.animationState;
    
    // Reload can interrupt any animation
    if (newActionName.includes('reload')) return true;
    
    // Empty can only be interrupted by reload
    if (state.includes('empty') && !newActionName.includes('reload')) return false;
    
    // Holster animation with blockHolster flag set has limited interruptions
    if (state.includes('holster') && this.blockHolster && 
        !newActionName.includes('idle') && 
        !newActionName.includes('empty') && 
        !newActionName.includes('reload')) {
      return false;
    }
    
    // Always allow draw to interrupt holster (re-aiming)
    if ((newActionName === 'revolverdraw' && state === 'revolverholster') ||
        (newActionName === 'shotgundraw' && state === 'shotgunholster')) {
      return true;
    }
    
    // Always allow holster to interrupt aim
    if ((newActionName === 'revolverholster' && state === 'revolveraim') ||
        (newActionName === 'shotgunholster' && state === 'shotgunaim')) {
      return true;
    }
    
    return true;
  }
  
  /**
   * Transition to a new animation state with abrupt stitching instead of blending
   * @param {string} actionName - The action name to transition to
   * @param {Object} options - Transition options
   * @private
   */
  _transitionTo(actionName, options = {}) {
    if (!this.isLoaded || !this.mixer || !this.animationsConfigured) return;
    
    // Handle aim transitions with pending holster
    if ((actionName === 'revolveraim' || actionName === 'shotgunaim') && this.pendingHolster) {
      this.pendingHolster = false;
      this.pendingAimTransition = false;
      this.playHolsterAnim();
      return;
    }
    
    // Handle cancelled aim transitions
    if ((actionName === 'revolveraim' && !this.pendingAimTransition && this.animationState === 'revolverdraw') ||
        (actionName === 'shotgunaim' && !this.pendingAimTransition && this.animationState === 'shotgundraw')) {
      this._transitionTo('idle', { resetTimeOnPlay: true });
      return;
    }
    
    // Check if the current animation can be interrupted
    if (!this._canInterruptCurrentAnimation(actionName)) {
      // Queue critical animations for later
      if (actionName.includes('empty') || actionName.includes('reload')) {
        this._queueAnimation(actionName, options);
      }
      return;
    }
    
    // Handle specific transition cases
    if (actionName.includes('draw') && this.animationState.includes('holster')) {
      // Interrupting holster to draw - allow it
      this.blockHolster = false;
      this._clearTimeouts();
    } 
    else if (actionName.includes('holster') && this.animationState.includes('aim')) {
      // Always allow holstering from aim state
      this.blockHolster = false;
    }
    else if (actionName.includes('reload')) {
      // Clear flags for reload
      this.pendingAimTransition = false;
      this.blockHolster = false;
      this._clearTimeouts();
    }
    else if ((this.animationState === 'revolverempty' || this.animationState === 'shotgunempty') && 
             (actionName === 'idle' || actionName.includes('aim'))) {
      // Reset flags when transitioning from empty animation
      this.blockHolster = false;
      this.pendingHolster = false;
      this.pendingAimTransition = false;
    }
    
    const action = this.actions[actionName];
    if (!action) {
      console.warn(`Action "${actionName}" not found for transition`);
      return;
    }
    
    // Default options
    const settings = {
      resetAction: true,
      resetTimeOnPlay: true,
      stopPrevious: true,
      onComplete: null,
      ...options
    };
    
    this.transitionInProgress = true;
    
    // Reset and prepare action
    if (settings.resetAction) action.reset();
    if (settings.resetTimeOnPlay) action.time = 0;
    action.enabled = true;
    
    // Stop previous action
    if (this.primaryAction && settings.stopPrevious && this.primaryAction !== action) {
      if (this._actionTimeoutId) {
        clearTimeout(this._actionTimeoutId);
        this._actionTimeoutId = null;
      }
      
      this.primaryAction.enabled = false;
      this.primaryAction.setEffectiveWeight(0);
    }
    
    // Set new action
    this.primaryAction = action;
    this.currentAction = action;
    action.setEffectiveWeight(1);
    action.play();
    
    // Update animation state
    this.animationState = actionName;
    
    // Set up completion callback
    if (settings.onComplete && action.loop !== THREE.LoopRepeat) {
      const clipDuration = action._clip.duration;
      const timeoutDuration = actionName.includes('holster') 
        ? clipDuration * 1000 
        : clipDuration * 1000 - 50;
      
      const timeoutId = setTimeout(() => {
        if (this.primaryAction === action) {
          if (actionName.includes('holster')) {
            this._holsterTimeoutId = null;
          } else {
            this._actionTimeoutId = null;
          }
          settings.onComplete();
        }
      }, timeoutDuration);
      
      if (actionName.includes('holster')) {
        this._holsterTimeoutId = timeoutId;
      } else {
        this._actionTimeoutId = timeoutId;
      }
    }
    
    this.transitionInProgress = false;
    this._processQueue();
  }
  
  /**
   * Queue an animation to play when current animation completes
   * @param {string} actionName - The action name to queue
   * @param {Object} options - Transition options
   * @private 
   */
  _queueAnimation(actionName, options = {}) {
    this.queue.push({ actionName, options });
    
    // If no transition in progress, process queue immediately
    if (!this.transitionInProgress) {
      this._processQueue();
    }
  }
  
  /**
   * Process the animation queue
   * @private
   */
  _processQueue() {
    if (this.queue.length > 0) {
      const next = this.queue.shift();
      this._transitionTo(next.actionName, next.options);
    }
  }
  
  /**
   * Play the draw animation when starting to aim.
   * Transitions to aim when completed.
   */
  playDrawAim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    this.pendingHolster = false;
    
    // If we're already in aim mode, we don't need to do anything
    if (this.animationState === `${weaponPrefix}aim`) return;
    
    // Make sure the model is visible during draw
    this.group.visible = true;
    
    // If we're holstering, interrupt it and switch to draw
    if (this.animationState === `${weaponPrefix}holster`) {
      // Cancel any pending callbacks from the holster animation
      if (this.primaryAction === this.actions[`${weaponPrefix}holster`]) {
        this.blockHolster = false;
      }
      
      this._clearTimeouts();
      
      this._transitionTo(`${weaponPrefix}draw`, {
        resetTimeOnPlay: true,
        onComplete: () => {
          if (!this.pendingHolster) {
            this.pendingAimTransition = true;
            this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
            this.pendingAimTransition = false;
          } else {
            this.pendingHolster = false;
            this.playHolsterAnim();
          }
        }
      });
      return;
    }
    
    this._clearTimeouts();
    this.blockHolster = false;
    
    this._transitionTo(`${weaponPrefix}draw`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        if (!this.pendingHolster) {
          this.pendingAimTransition = true;
          this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
          this.pendingAimTransition = false;
        } else {
          this.pendingHolster = false;
          this.playHolsterAnim();
        }
      }
    });
  }
  
  /**
   * Play the shooting animation while aiming
   */
  playShootAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    this.group.visible = true;
    
    // Can only shoot if in aim mode or already shooting
    if (this.animationState !== `${weaponPrefix}aim` && 
        this.animationState !== `${weaponPrefix}draw` && 
        this.animationState !== `${weaponPrefix}shot`) {
      return;
    }
    
    const completeAction = () => {
      if (!this.blockHolster && !this.pendingHolster) {
        this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
      } else if (this.pendingHolster) {
        this.pendingHolster = false;
        this.playHolsterAnim();
      }
    };
    
    // For rapid fire shooting, if we're already in the shoot animation,
    // cancel the current animation and any pending callback
    if (this.animationState === `${weaponPrefix}shot`) {
      this._clearTimeouts();
      
      // Reset the shot animation to play from the beginning
      const shootAction = this.actions[`${weaponPrefix}shot`];
      shootAction.reset();
      shootAction.time = 0;
      shootAction.enabled = true;
      shootAction.setEffectiveWeight(1);
      shootAction.play();
      
      // Set up a new completion callback
      const clipDuration = shootAction._clip.duration;
      this._actionTimeoutId = setTimeout(() => {
        if (this.primaryAction === shootAction) {
          this._actionTimeoutId = null;
          completeAction();
        }
      }, clipDuration * 1000 - 50);
      
      return;
    }
    
    // For first shot, transition to shoot animation normally
    this._transitionTo(`${weaponPrefix}shot`, {
      resetTimeOnPlay: true,
      onComplete: completeAction
    });
  }
  
  /**
   * Play the empty gun animation (when trying to shoot without ammo)
   */
  playFakeShootAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    this.group.visible = true;
    
    // Block everything until empty animation completes
    this.blockHolster = true;
    this.pendingHolster = false;
    this.forceVisible = true;
    
    this._clearTimeouts();
    
    // Reset all animations to ensure clean state
    Object.values(this.actions).forEach(action => {
      if (action !== this.actions[`${weaponPrefix}empty`]) {
        action.reset();
        action.setEffectiveWeight(0);
      }
    });
    
    // Transition to empty animation
    this._transitionTo(`${weaponPrefix}empty`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        this._resetAnimationFlags();
        
        // Get current aim state
        const isAimingNow = window.localPlayer?.isAiming || false;
        
        // Transition based on current aim state
        if (isAimingNow) {
          this._transitionTo(`${weaponPrefix}aim`, { resetTimeOnPlay: true });
        } else {
          this._transitionTo('idle', { resetTimeOnPlay: true });
        }
      }
    });
  }
  
  /**
   * Play the holster animation (when stopping aiming)
   */
  playHolsterAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    
    // If we're currently playing empty or reload animations, don't interrupt
    if (this.blockHolster && this.animationState !== `${weaponPrefix}aim`) {
      this.pendingHolster = true;
      return;
    }
    
    // If we're in aim state, we should always be able to holster
    if (this.animationState === `${weaponPrefix}aim`) {
      this.blockHolster = false;
    }
    
    // Cancel any pending transition to aim state if we're still in drawing phase
    if (this.animationState === `${weaponPrefix}draw` && this.pendingAimTransition) {
      this.pendingAimTransition = false;
    }
    
    this._clearTimeouts();
    this.forceVisible = true;
    
    // Reset holster animation if interrupted during draw or aim
    if ((this.animationState === `${weaponPrefix}draw` || this.animationState === `${weaponPrefix}aim`) && 
         this.actions[`${weaponPrefix}holster`]) {
      this.actions[`${weaponPrefix}holster`].reset();
    }
    
    // Ensure holster animation can't be interrupted once started
    this.blockHolster = true;
    
    // Play the gun holster sound
    if (window.localPlayer?.soundManager) {
      const soundName = weaponPrefix === 'shotgun' ? "shotgunholstering" : "revolverholstering";
      window.localPlayer.soundManager.playSound(soundName, 0, 0.6);
    }
    
    // Transition to holster animation
    this._transitionTo(`${weaponPrefix}holster`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        // After holster completes, transition to idle and hide model
        this._transitionTo('idle', {
          resetTimeOnPlay: true,
          onComplete: () => {
            this.blockHolster = false;
            this.pendingHolster = false;
            this.forceVisible = false;
            
            // Hide viewmodel when transitioning back to idle from holster
            setTimeout(() => {
              if (!this.forceVisible) this.group.visible = false;
            }, 50);
          }
        });
      }
    });
  }
  
  /**
   * Play the reload animation
   */
  playReloadAnim() {
    if (!this.isLoaded) return;
    
    const weaponPrefix = this._getWeaponPrefix();
    
    // Make sure the model is visible during reload
    this.group.visible = true;
    
    // Reset ALL animation state flags completely when starting reload
    this.forceVisible = true;
    this.blockHolster = true;
    this.pendingHolster = false;
    this.pendingAimTransition = false;
    
    this._clearTimeouts();
    
    // Reset all animations to ensure clean state
    Object.values(this.actions).forEach(action => {
      if (action !== this.actions[`${weaponPrefix}reload`]) {
        action.reset();
        action.enabled = false;
        action.setEffectiveWeight(0);
      }
    });
    
    // Play reload sound
    if (window.localPlayer?.soundManager) {
      const soundName = weaponPrefix === 'shotgun' ? "shotgunreloading" : "reloading";
      window.localPlayer.soundManager.playSound(soundName, 0, 0.6);
    }
    
    // Transition to reload animation
    this._transitionTo(`${weaponPrefix}reload`, {
      resetTimeOnPlay: true,
      onComplete: () => {
        // After reload completes, go back to idle animation first
        this._transitionTo('idle', {
          resetTimeOnPlay: true,
          onComplete: () => {
            this._resetAnimationFlags();
            
            // If player is still aiming after reload, immediately transition to draw
            const isAimingNow = window.localPlayer?.isAiming;
            if (isAimingNow) {
              this.animationState = 'idle';
              this.primaryAction = this.actions.idle;
              this.currentAction = this.actions.idle;
              
              // Start the draw animation with a slight delay to ensure clean state
              setTimeout(() => {
                if (window.localPlayer?.isAiming) this.playDrawAim();
              }, 10);
            }
          }
        });
      }
    });
  }
  
  /**
   * Play the idle animation - always looping
   */
  playIdle() {
    if (!this.isLoaded) return;
    
    // Only play idle if we're not in another animation
    if (!this.animationState || this.animationState === 'none') {
      this._transitionTo('idle', {
        resetTimeOnPlay: true
      });
    }
  }
  
  /**
   * Returns true if the current animation is a shooting animation
   * @returns {boolean} True if currently in shooting animation
   */
  isInShootAnimation() {
    return this.animationState === 'revolvershot' || 
           this.animationState === 'revolverempty' ||
           this.animationState === 'shotgunshot' ||
           this.animationState === 'shotgunempty';
  }
  
  /**
   * Updates the animation mixer
   * @param {number} deltaTime - Time since last frame in seconds
   */
  update(deltaTime) {
    if (!this.isLoaded || !this.mixer) return;
    
    this.mixer.update(deltaTime);
    
    // Add animation state monitoring to detect and recover from stuck animations
    if (!this._stateStartTime) {
      this._stateStartTime = {};
      this._lastAnimationState = '';
    }
    
    // If animation state changed, record the start time
    if (this.animationState !== this._lastAnimationState) {
      this._stateStartTime[this.animationState] = Date.now();
      this._lastAnimationState = this.animationState;
    }
    
    // Check for stuck animations - if an animation has been playing too long
    if (this.animationState && this._stateStartTime[this.animationState]) {
      const timeInState = Date.now() - this._stateStartTime[this.animationState];
      
      // Empty and holster animations can get stuck
      if ((this.animationState.includes('empty') || this.animationState.includes('holster')) && 
          timeInState > 5000) { // 5 seconds is too long for these animations
        console.warn(`Animation stuck in ${this.animationState} for ${timeInState}ms, resetting`);
        
        // Force reset animation flags
        this.blockHolster = false;
        this.pendingHolster = false;
        this.forceVisible = false;
        
        // Reset to idle state
        this._transitionTo('idle', {
          resetTimeOnPlay: true
        });
        
        // Reset timer
        this._stateStartTime = {};
      }
    }
  }
  
  /**
   * Returns the world position of the gun barrel tip
   * @returns {THREE.Vector3} The world position for spawning bullets and effects
   */
  getBarrelTipWorldPosition() {
    if (this.muzzleFlashAnchor) {
      const worldPos = new THREE.Vector3();
      this.muzzleFlashAnchor.getWorldPosition(worldPos);
      
      // Add a small forward offset to ensure effects appear in front of the barrel
      // This is in world space, so we need the camera's forward direction
      const forward = new THREE.Vector3(0, 0, -1);
      forward.applyQuaternion(this.group.getWorldQuaternion(new THREE.Quaternion()));
      forward.multiplyScalar(this.EFFECTS.BULLET_SPAWN.forward_offset); // Forward offset amount
      
      worldPos.add(forward);
      return worldPos;
    }
    
    // Fallback if muzzle flash anchor isn't ready yet
    return this.group.localToWorld(new THREE.Vector3(0, 0, -0.5));
  }
  
  /**
   * Updates the model's skin based on skin ID
   * @param {string} skinId - The skin ID to apply
   * @returns {boolean} - Whether the skin was successfully applied
   */
  updateSkin(skinId) {
    // Check if this is a valid skin
    if (!skinId || !this.availableSkins.hasOwnProperty(skinId)) {
      console.warn(`Invalid skin ID: ${skinId}`);
      return false;
    }
    
    // Check if player has permission for this skin
    if (skinId !== 'default' && !this.skinPermissions[skinId]) {
      console.warn(`Player does not have permission for skin: ${skinId}`);
      return false;
    }
    
    // Check if the texture was already loaded for this skin
    if (!this.availableSkins[skinId]) {
      this.loadSkinTexture(skinId);
      return false; // Will be applied once loaded
    }
    
    // Apply the skin texture to the model
    this.applyTextureToModel(this.availableSkins[skinId]);
    this.activeSkin = skinId;
    
    console.log(`Applied skin '${skinId}' to viewmodel`);
    return true;
  }
  
  /**
   * Loads a skin texture by ID
   * @param {string} skinId - The skin ID to load
   */
  loadSkinTexture(skinId) {
    if (!skinId || skinId === 'default') return;
    
    const texturePath = `models/textures/${skinId}.png`;
    
    console.log(`Loading skin texture for viewmodel: ${texturePath}`);
    
    new THREE.TextureLoader().load(
      texturePath,
      (texture) => {
        // Store the loaded texture
        this.availableSkins[skinId] = texture;
        
        // Apply if we have permission
        if (this.skinPermissions[skinId]) {
          this.applyTextureToModel(texture);
          this.activeSkin = skinId;
          console.log(`Applied newly loaded skin '${skinId}' to viewmodel`);
        }
      },
      undefined,
      (error) => console.error(`Error loading skin texture '${skinId}':`, error)
    );
  }
  
  /**
   * Applies a texture to the viewmodel
   * @param {THREE.Texture} texture - The texture to apply
   */
  applyTextureToModel(texture) {
    if (!this.model || !texture) return;
    
    // List of revolver part names to look for
    const revolverParts = ['barrel', 'drum', 'grip', 'revolver', 'gun'];
    
    // Apply the texture to all relevant meshes in the model
    this.model.traverse(child => {
      if (!child.isMesh || !child.material) return;
      
      // Check if this is a relevant part to apply the texture to
      const isRevolverMaterial = child.material.name?.includes('Material.002');
      const isRevolverPart = revolverParts.some(part => 
        child.name.toLowerCase().includes(part.toLowerCase())
      );
      
      if (isRevolverMaterial || isRevolverPart) {
        // Store the original/default texture if not already stored
        if (!this.availableSkins.default && child.material.map) {
          this.availableSkins.default = child.material.map.clone();
        }
        
        // Clone the original material to preserve all properties
        if (child.material._originalMaterial === undefined) {
          child.material._originalMaterial = child.material.clone();
        }
        
        // Copy properties from original texture
        if (child.material._originalMaterial?.map) {
          const originalTexture = child.material._originalMaterial.map;
          
          // Copy texture properties
          const props = ['wrapS', 'wrapT', 'flipY', 'encoding', 'generateMipmaps', 'minFilter', 'magFilter'];
          props.forEach(prop => texture[prop] = originalTexture[prop]);
          
          // Copy vector properties
          texture.repeat.copy(originalTexture.repeat);
          texture.offset.copy(originalTexture.offset);
          texture.center.copy(originalTexture.center);
          texture.rotation = originalTexture.rotation;
        }
        
        // Apply the new texture
        child.material.map = texture;
        child.material.needsUpdate = true;
      }
    });
  }
  
  /**
   * Updates skin permissions based on server data
   * @param {Object} skinData - Skin permission data from server
   */
  updateSkinPermissions(skinData) {
    if (!skinData) return;
    
    let skinChanged = false;
    
    // Update permissions for each skin
    Object.keys(skinData).forEach(skinId => {
      if (this.skinPermissions.hasOwnProperty(skinId)) {
        const oldPermission = this.skinPermissions[skinId];
        const newPermission = skinData[skinId];
        
        this.skinPermissions[skinId] = newPermission;
        
        // If permission was granted, preload the skin
        if (!oldPermission && newPermission) {
          this.loadSkinTexture(skinId);
          skinChanged = true;
        }
      }
    });
    
    // Reset to default skin if current skin is no longer permitted
    if (skinChanged && this.activeSkin && !this.skinPermissions[this.activeSkin]) {
      this.updateSkin('default');
    }
  }
  
  /**
   * Cancels the current reload animation and resets animation state
   */
  cancelReload() {
    if (!this.isLoaded) return;
    
    // Determine which weapon prefix to use
    const weaponPrefix = window.localPlayer && window.localPlayer.activeWeapon === 'shotgun' ? 'shotgun' : 'revolver';
    
    // Reset animation flags
    this.forceVisible = false;
    this.blockHolster = false;
    this.pendingHolster = false;
    this.pendingAimTransition = false;
    
    // Clear any pending animation timeouts
    if (this._actionTimeoutId) {
      clearTimeout(this._actionTimeoutId);
      this._actionTimeoutId = null;
    }
    if (this._holsterTimeoutId) {
      clearTimeout(this._holsterTimeoutId);
      this._holsterTimeoutId = null;
    }
    
    // Stop the reload animation
    if (this.actions[`${weaponPrefix}reload`]) {
      this.actions[`${weaponPrefix}reload`].stop();
    }
    
    // Transition to idle animation
    this._transitionTo(`${weaponPrefix}idle`, {
      resetTimeOnPlay: true
    });
    
    // If player isn't aiming, hide the viewmodel
    if (window.localPlayer && !window.localPlayer.isAiming) {
      setTimeout(() => {
        this.group.visible = false;
      }, 100); // Short delay to ensure animation transition starts
    }
    
    console.log(`Canceled ${weaponPrefix} reload animation`);
  }

  _getWeaponPrefix() {
    return window.localPlayer && window.localPlayer.activeWeapon === 'shotgun' ? 'shotgun' : 'revolver';
  }

  _clearTimeouts() {
    if (this._actionTimeoutId) {
      clearTimeout(this._actionTimeoutId);
      this._actionTimeoutId = null;
    }
    if (this._holsterTimeoutId) {
      clearTimeout(this._holsterTimeoutId);
      this._holsterTimeoutId = null;
    }
  }

  _resetAnimationFlags() {
    this.blockHolster = false;
    this.pendingHolster = false;
    this.forceVisible = false;
    this.pendingAimTransition = false;
  }
} 

================================================
File: /public/wallet-demo.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phantom Wallet Demo</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    h1 {
      color: #333;
    }
    
    .info-section {
      margin-top: 20px;
      padding: 15px;
      background-color: #f0f0f0;
      border-radius: 6px;
    }
    
    .info-section h2 {
      margin-top: 0;
      font-size: 18px;
    }
    
    .wallet-info {
      display: none;
    }
    
    .wallet-info.active {
      display: block;
    }
    
    #wallet-address {
      word-break: break-all;
      font-family: monospace;
      padding: 8px;
      background-color: #e5e5e5;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Phantom Wallet Integration Demo</h1>
    
    <div class="info-section">
      <h2>About This Demo</h2>
      <p>This page demonstrates a simple Phantom wallet integration for Solana. You can connect your wallet using the purple button in the top-right corner.</p>
    </div>
    
    <div class="info-section wallet-info" id="wallet-info">
      <h2>Connected Wallet Information</h2>
      <p><strong>Wallet Address:</strong></p>
      <div id="wallet-address">Not connected</div>
      
      <p><strong>Connection Status:</strong> <span id="connection-status">Disconnected</span></p>
    </div>
  </div>
  
  <!-- Load Solana Web3.js from CDN -->
  <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
  
  <!-- Load our Phantom Wallet Adapter -->
  <script type="module">
    import phantomWalletAdapter from './js/phantom-wallet.js';
    
    // Initialize the adapter when the page loads
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize the wallet adapter
      phantomWalletAdapter.init();
      
      // Set up event listeners to update UI when wallet connects
      document.addEventListener('walletConnected', (e) => {
        updateWalletInfo(e.detail.publicKey);
      });
      
      // Try to auto-connect if previously connected
      if (phantomWalletAdapter.isPhantomInstalled()) {
        const provider = window.phantom?.solana;
        if (provider) {
          provider.on('connect', (publicKey) => {
            phantomWalletAdapter.wallet = provider;
            phantomWalletAdapter.publicKey = publicKey.toString();
            phantomWalletAdapter.isConnected = true;
            phantomWalletAdapter.updateConnectButtonStatus(true);
            updateWalletInfo(publicKey.toString());
          });
          
          provider.on('disconnect', () => {
            phantomWalletAdapter.wallet = null;
            phantomWalletAdapter.publicKey = null;
            phantomWalletAdapter.isConnected = false;
            phantomWalletAdapter.updateConnectButtonStatus(false);
            updateWalletInfo(null);
          });
        }
      }
      
      // Custom event listeners for wallet adapter
      phantomWalletAdapter.onConnect = (publicKey) => {
        updateWalletInfo(publicKey);
      };
      
      phantomWalletAdapter.onDisconnect = () => {
        updateWalletInfo(null);
      };
    });
    
    // Update the wallet info UI
    function updateWalletInfo(publicKey) {
      const walletInfoSection = document.getElementById('wallet-info');
      const walletAddressElem = document.getElementById('wallet-address');
      const connectionStatusElem = document.getElementById('connection-status');
      
      if (publicKey) {
        walletInfoSection.classList.add('active');
        walletAddressElem.textContent = publicKey;
        connectionStatusElem.textContent = 'Connected';
        connectionStatusElem.style.color = 'green';
      } else {
        walletInfoSection.classList.remove('active');
        walletAddressElem.textContent = 'Not connected';
        connectionStatusElem.textContent = 'Disconnected';
        connectionStatusElem.style.color = 'red';
      }
    }
  </script>
</body>
</html> 

================================================
File: /readme.md
================================================
henlo

================================================
File: /server.js
================================================
// server.js
require('dotenv').config();
console.log("Starting server initialization...");
const express = require('express');
console.log("Express loaded");
const http = require('http');
console.log("HTTP loaded");
const WebSocket = require('ws');
console.log("WebSocket loaded");
const url = require('url');
console.log("URL loaded");
const app = express();
console.log("Express app created");
// Native fetch is available in Node.js v22, no need to require node-fetch

// Add Telegram Bot API support
const TelegramBot = require('node-telegram-bot-api');
console.log("Telegram Bot API loaded");

// Use environment variable for the bot token from Replit Secrets
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN || 'YOUR_TELEGRAM_BOT_TOKEN';
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID || 1517919597; // Numeric ID for @erikszo

// Initialize the Telegram bot
const telegramBot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: false });
console.log("Telegram bot initialized");

// Function to send Telegram notifications
function sendTelegramNotification(message) {
  try {
    telegramBot.sendMessage(TELEGRAM_CHAT_ID, message)
      .then(() => {
        console.log(`Notification sent to ${TELEGRAM_CHAT_ID}: ${message}`);
      })
      .catch((error) => {
        console.error(`Failed to send Telegram notification: ${error.message}`);
      });
  } catch (error) {
    console.error(`Error in Telegram notification: ${error.message}`);
  }
}

// Standard HTTP port for the server
const PORT = process.env.PORT || 80;
console.log("Port set to", PORT);

// Serve static files from "public"
app.use(express.static('public'));
console.log("Static file serving configured");

// Add a specific route for the wallet demo page
app.get('/wallet', (req, res) => {
  res.sendFile(__dirname + '/public/wallet-demo.html');
  console.log("Wallet demo page requested");
});

const server = http.createServer(app);
console.log("HTTP server created");
const wss = new WebSocket.Server({ server, clientTracking: true });
console.log("WebSocket server created");

// Track connected players
const players = new Map();    // playerId -> { ws, sessionId, position, rotation, health, ... }
const sessions = new Set();   // tracks sessionIds to prevent duplicate connections
let nextPlayerId = 1;
console.log("Player tracking variables initialized");

// Track bot players (new)
const botPlayers = new Map(); // botId -> { position, rotation, health, ... }
console.log("Bot player tracking initialized");

// NPC system - Server-controlled NPCs
const npcs = new Map(); // npcId -> { id, position, rotation, health, isWalking, path, etc. }
let nextNpcId = 1;
console.log("Server-controlled NPC system initialized");

// New: Track persistent player identities
const playerIdentities = new Map(); // clientId -> { username, playerId, token, lastSeen }
console.log("Player identity tracking initialized");

// Production mode
const isDevMode = false;
console.log(`Server running in ${isDevMode ? 'DEVELOPMENT' : 'PRODUCTION'} mode`);

// Position history tracking to reduce unnecessary corrections
const playerPositionHistory = new Map(); // playerId -> array of recent positions
const POSITION_HISTORY_SIZE = 10; // Number of positions to track per player
const CORRECTION_COOLDOWN = 5000; // Minimum ms between position corrections
console.log("Position history tracking initialized");

// Track Quick Draw game mode queues and active duels
// Support for 5 concurrent lobbies
const MAX_ARENAS = 5;
const quickDrawQueues = Array(MAX_ARENAS).fill(null).map(() => []);  // Array of queues for each arena
const quickDrawDuels = new Map(); // Map of duelId -> { player1Id, player2Id, state, arenaIndex, ... }
console.log("Quick Draw game mode variables initialized");

// Anti-cheat: Game physics constants
const GAME_CONSTANTS = {
  // Weapon constraints
  BULLET_SPEED: 80,           // Bullet speed units/second
  MAX_BULLET_DISTANCE: 100,   // Maximum distance a bullet can travel
  WEAPON_COOLDOWN: 250,       // Minimum time between shots in ms
  RELOAD_TIME: 4000,          // Time required to reload in ms
  DAMAGE_PER_HIT: 20,         // Health points reduced per hit
  // Town boundaries
  TOWN_WIDTH: 60,             // Width of the town
  TOWN_LENGTH: 100,           // Length of the town
  // Physics update rate
  PHYSICS_UPDATE_INTERVAL: 16 // ms (approx 60fps)
};

// Anti-cheat: Active bullets map
const activeBullets = new Map(); // bulletId -> {sourcePlayerId, position, direction, timeCreated, etc}
let nextBulletId = 1;

// Anti-cheat: Timeout tracking (for rate limiting and cooldowns)
const playerTimeouts = new Map(); // playerId -> { lastShot, lastReload, lastTeleport, etc }

// Anti-cheat: Nonce tracking (for anti-replay protection)
const playerNonces = new Map(); // playerId -> Set of used nonces
const playerSequences = new Map(); // playerId -> last sequence number

// Add NFT verification configuration
// Hardcoded NFT token address for now (this would be a specific NFT or collection address)
const SPECIAL_SKIN_NFT_ADDRESS = "3j4UKuFb7FDQ4ZNSbSujiak6Ps7AQVE9ynnLHorArzGz"; // Replace with actual Solana NFT mint address
// You can add additional NFT addresses here
const SPECIAL_SKIN_NFT_ADDRESSES = [
  "3j4UKuFb7FDQ4ZNSbSujiak6Ps7AQVE9ynnLHorArzGz",
  "81FNAomj6H5r2VJ3e5J6NLDShqiUaEbMwVuCssYpVm9E",
  "58NysJG5K18zgLMN4uKVJ8HhetwwGz5fUDBCk52UfMtA",
  "EsT86r7ZRAeqGaczHidEH8byaWjt4zgAWDLqRgNSN3i5",
  // Add more NFT mint addresses here
];
const HELIUS_API_KEY = process.env.HELIUS_API_KEY; // Helius API key
const HELIUS_API_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;

// Map to store wallet to skin permission mappings
const walletSkins = new Map(); // walletAddress -> { skins: { skinId: true }, ... }

/**
 * Checks if a wallet owns a specific NFT or any from a list via Helius API
 * @param {string} walletAddress - The wallet address to check
 * @param {string|string[]} nftAddresses - Single NFT mint address or array of NFT mint addresses to verify ownership
 * @returns {Promise<boolean>} Whether the wallet owns any of the NFTs
 */
async function checkNftOwnership(walletAddress, nftAddresses) {
  try {
    // Convert single address to array if needed
    const addresses = Array.isArray(nftAddresses) ? nftAddresses : [nftAddresses];
    
    console.log(`Checking if wallet ${walletAddress} owns any of ${addresses.length} NFTs`);
    
    const response = await fetch(HELIUS_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 'helius-test',
        method: 'getAssetsByOwner',
        params: {
          ownerAddress: walletAddress,
          page: 1,
          limit: 100,
        },
      }),
    });
    
    const data = await response.json();
    
    if (data.error) {
      console.error('Helius API error:', data.error);
      return false;
    }
    
    // Check if the wallet owns any of the NFTs
    const assets = data.result.items;
    const ownsNft = assets.some(asset => addresses.includes(asset.id));
    
    console.log(`Wallet ${walletAddress} ${ownsNft ? 'owns' : 'does not own'} one of the specified NFTs`);
    
    return ownsNft;
  } catch (error) {
    console.error('Error checking NFT ownership:', error);
    return false;
  }
}

/**
 * Updates the player's skin based on wallet NFT ownership
 * @param {string} playerId - The player ID
 * @param {string} walletAddress - The wallet address
 */
async function updatePlayerSkin(playerId, walletAddress) {
  try {
    // Check if the wallet owns any of the special NFTs
    const ownsSpecialSkin = await checkNftOwnership(walletAddress, SPECIAL_SKIN_NFT_ADDRESSES);
    
    // Update the player's skin permissions
    walletSkins.set(walletAddress, {
      skins: {
        bananaSkin: ownsSpecialSkin
      }
    });
    
    // Get the player from the players map
    const player = players.get(playerId);
    if (!player) return;
    
    // Update the player data with skin information
    player.skins = {
      bananaSkin: ownsSpecialSkin
    };
    
    // Broadcast the skin update to all players
    broadcastToAll({
      type: 'playerSkinUpdate',
      playerId: playerId,
      skins: {
        bananaSkin: ownsSpecialSkin
      }
    });
    
    // Send confirmation to the player
    player.ws.send(JSON.stringify({
      type: 'skinPermissionUpdate',
      skins: {
        bananaSkin: ownsSpecialSkin
      }
    }));
    
    console.log(`Updated skin permissions for player ${playerId} (wallet: ${walletAddress}): bananaSkin=${ownsSpecialSkin}`);
  } catch (error) {
    console.error(`Error updating player skin for ${playerId}:`, error);
  }
}

// Create helper function for sanitizing text to prevent XSS
function sanitizeText(text) {
  if (!text || typeof text !== 'string') return '';
  
  // Remove potentially dangerous content first
  text = text
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, '') // Remove event handlers
    .trim();
    
  // Limit length for usernames
  if (text.length > 20) {
    text = text.substring(0, 20);
  }
  
  // Perform HTML escaping
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// On new connection
wss.on('connection', (ws, req) => {
  // Parse parameters from query string
  const parameters = url.parse(req.url, true).query;
  const sessionId = parameters.sessionId;
  const clientId = parameters.clientId;
  let username = parameters.username;
  const token = parameters.token;
  const walletAddress = parameters.walletAddress; // New: Get wallet address if provided
  
  // Sanitize username to prevent XSS
  username = sanitizeText(username || 'Anonymous');

  // Check if this is a development mode connection
  const isDev = isDevMode && (parameters.dev === 'true' || parameters.newplayer === 'true');
  
  if (isDev) {
    console.log("Development mode connection detected");
  }

  // If we already have this sessionId, reject as duplicate
  // Skip this check for development mode connections
  if (sessionId && sessions.has(sessionId) && !isDev) {
    console.log(`Rejecting duplicate connection with sessionId: ${sessionId}`);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Duplicate connection detected',
      fatal: true
    }));
    return ws.close(1008, 'Duplicate connection');
  }

  if (sessionId) {
    sessions.add(sessionId);
  }

  // Verify player identity if clientId and token provided
  // Skip verification for development mode connections
  if (clientId && token && !isDev) {
    const storedIdentity = playerIdentities.get(clientId);
    
    // If we have this player's identity stored already
    if (storedIdentity) {
      // Check if token matches
      if (storedIdentity.token !== token) {
        console.log(`Token mismatch for clientId: ${clientId}`);
        ws.send(JSON.stringify({
          type: 'authFailure',
          reason: 'invalidToken',
          message: 'Invalid authentication token'
        }));
        return ws.close(1008, 'Authentication failure');
      }
      
      // Update the stored player identity
      storedIdentity.lastSeen = Date.now();
      storedIdentity.username = sanitizeText(username || storedIdentity.username);
      
      // Use the existing player ID for this client
      const playerId = storedIdentity.playerId;
      console.log(`Recognized returning player ${playerId} (clientId: ${clientId}, username: ${sanitizeText(username || storedIdentity.username)})`);
      
      // Send Telegram notification for returning player
      if (!isDev) {
        sendTelegramNotification(`🔄 Player reconnected: ${sanitizeText(username || storedIdentity.username)} (ID: ${playerId})`);
      }
      
      // Initialize player with recognized identity
      initializePlayer(ws, playerId, sessionId, clientId, sanitizeText(username || storedIdentity.username), token, isDev);
      return;
    }
  }

  // If we reach here, it's a new player or unrecognized returning player
  const playerId = nextPlayerId++;
  console.log(`Player ${playerId} connected (sessionId: ${sessionId || 'none'}, username: ${username}, isDev: ${isDev})`);

  // Store player identity information if provided (unless in dev mode with newplayer=true)
  if (clientId && !isDev) {
    playerIdentities.set(clientId, {
      username: username,
      playerId,
      token: token || '',
      lastSeen: Date.now()
    });
    console.log(`Associated player ${playerId} with clientId ${clientId} and username ${username}`);
    
    // Send Telegram notification for new player
    sendTelegramNotification(`🎮 New player joined: ${username} (ID: ${playerId})`);
  }

  // Initialize the new player
  initializePlayer(ws, playerId, sessionId, clientId, username, token, isDev);
});

// Extract player initialization to a separate function
function initializePlayer(ws, playerId, sessionId, clientId, username, token, isDev = false) {
  // Create initial player data with health and QuickDraw info
  players.set(playerId, {
    ws,
    sessionId,
    clientId,
    username,
    isDev, // Store dev mode flag for reference
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { y: 0 },
    isAiming: false,
    isShooting: false,
    isReloading: false,
    health: 100,
    lastActivity: Date.now(),
    quickDrawLobbyIndex: -1, // -1 means not in any lobby
    inQuickDrawQueue: false,
    inQuickDrawDuel: false,
    quickDrawDuelId: null,
    // Additional player state
    bullets: 6,
    maxBullets: 6,
    lastUpdateTime: Date.now(),
    // Initialize skin data for new players
    skins: {
      bananaSkin: false // Default to no special skin
    }
  });

  // Anti-cheat: Initialize timeout tracking
  playerTimeouts.set(playerId, {
    lastShot: 0,
    lastMovement: 0,
    lastReload: 0,
    lastPositionUpdate: 0,
    lastPositionCorrection: 0,
    reloadStartTime: 0,
    isReloading: false
  });

  // Anti-cheat: Initialize nonce/sequence tracking
  playerNonces.set(playerId, new Set());
  playerSequences.set(playerId, 0);

  // Send init data to this client (their ID + existing players)
  // FIXED: Ensure we don't include the player's own ID in the list of players sent
  ws.send(JSON.stringify({
    type: 'init',
    id: playerId,
    players: Array.from(players.entries())
      .filter(([pid]) => pid !== playerId) // Make sure to exclude the player's own ID
      .map(([pid, p]) => ({
        id: pid,
        position: p.position,
        rotation: p.rotation,
        isAiming: p.isAiming,
        isShooting: p.isShooting,
        isReloading: p.isReloading,
        health: p.health,
        username: p.username,
        quickDrawLobbyIndex: p.quickDrawLobbyIndex,
        skins: p.skins || { bananaSkin: false } // Include skin information for existing players
      }))
  }));

  // Send initial train state
  sendInitialTrainState(ws);

  // Notify others that a new player joined
  broadcastToOthers(playerId, {
    type: 'playerJoined',
    id: playerId,
    position: players.get(playerId).position,
    rotation: players.get(playerId).rotation,
    health: players.get(playerId).health,
    username: players.get(playerId).username,
    quickDrawLobbyIndex: players.get(playerId).quickDrawLobbyIndex,
    skins: players.get(playerId).skins // Include skins in the join message
  });

  // Handle incoming messages
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);

      // Update lastActivity
      const player = players.get(playerId);
      if (!player) return;
      
      player.lastActivity = Date.now();

      // Anti-cheat: Sequence number validation
      if (data.sequenceNumber !== undefined) {
        const lastSequence = playerSequences.get(playerId) || 0;
        
        // Reject if sequence number is not greater than the last one
        if (data.sequenceNumber <= lastSequence) {
          console.log(`Rejecting message with old sequence number: ${data.sequenceNumber} (last: ${lastSequence})`);
          return sendErrorToPlayer(playerId, "Invalid sequence number", false);
        }
        
        // Update the last sequence number
        playerSequences.set(playerId, data.sequenceNumber);
      }

      // Anti-cheat: Nonce validation for critical actions
      if ((data.type === 'shoot' || data.type === 'playerHit') && data.nonce) {
        const playerNonceSet = playerNonces.get(playerId);
        
        // Check if nonce has been used before
        if (playerNonceSet && playerNonceSet.has(data.nonce)) {
          console.log(`Rejecting repeated nonce: ${data.nonce} from player ${playerId}`);
          return sendErrorToPlayer(playerId, "Duplicate nonce detected", false);
        }
        
        // Store the nonce
        if (playerNonceSet) {
          playerNonceSet.add(data.nonce);
          
          // Limit nonce set size to prevent memory issues
          if (playerNonceSet.size > 1000) {
            // Keep only the most recent 500 nonces
            const nonceArray = Array.from(playerNonceSet);
            const newNonceSet = new Set(nonceArray.slice(nonceArray.length - 500));
            playerNonces.set(playerId, newNonceSet);
          }
        }
      }

      switch (data.type) {
        case 'update':
          handlePlayerUpdate(playerId, data);
          break;

        case 'shoot':
          handlePlayerShoot(playerId, data);
          break;

        case 'playerHit':
          handlePlayerHit(playerId, data.targetId, data.hitData, data.bulletId);
          break;

        case 'reload':
          handlePlayerReload(playerId, data);
          break;

        case 'ping':
          // respond
          ws.send(JSON.stringify({ type: 'pong' }));
          break;
          
        case 'quickDrawJoin':
          handleQuickDrawJoin(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawLeave':
          handleQuickDrawLeave(playerId);
          break;
          
        case 'quickDrawReady':
          handleQuickDrawReady(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawShoot':
          // Pass the hit zone and damage if provided
          handleQuickDrawShoot(
            playerId, 
            data.opponentId, 
            data.arenaIndex, 
            data.hitZone || 'body', 
            data.damage || 40,
            data.hitDetected || false
          );
          break;
          
        // Add new handlers for direct challenge system
        case 'quickDrawChallenge':
          handleQuickDrawChallenge(playerId, data.targetPlayerId);
          break;
          
        case 'quickDrawAccept':
          handleQuickDrawAcceptChallenge(playerId, data.challengerId);
          break;
          
        case 'quickDrawDecline':
          handleQuickDrawDeclineChallenge(playerId, data.challengerId);
          break;

        // Handle chat messages
        case 'chat':
          handleChatMessage(playerId, data.message);
          break;

        // Handle bot player updates
        case 'bot_update':
          handleBotUpdate(data);
          break;
        
        // Handle bot player removal
        case 'bot_remove':
          handleBotRemove(data);
          break;

        // Handle wallet connection from client
        case 'walletConnect':
          if (!data.walletAddress) {
            console.error(`Invalid wallet connection from player ${playerId}: No wallet address provided`);
            return;
          }
          
          const player = players.get(playerId);
          if (!player) {
            console.error(`Wallet connection received for unknown player ${playerId}`);
            return;
          }
          
          console.log(`Player ${playerId} connected wallet: ${data.walletAddress}`);
          
          // Update player record with wallet address
          player.walletAddress = data.walletAddress;
          
          // Check NFT ownership and update skin permissions
          updatePlayerSkin(playerId, data.walletAddress);
          break;

        // Handle train state request
        case 'requestTrainState':
          console.log(`Player ${playerId} requested train state`);
          sendInitialTrainState(player.ws);
          return;

        default:
          break;
      }
    } catch (err) {
      console.error(`Error handling message from player ${playerId}:`, err);
    }
  });

  // On close
  ws.on('close', () => {
    cleanupPlayer(playerId);
  });

  // On error
  ws.on('error', (err) => {
    console.error(`WebSocket error for player ${playerId}:`, err);
    cleanupPlayer(playerId);
  });

  // Update the global player count UI
  updatePlayerCount();
}

// Handle player updates - removed speed/position validation
function handlePlayerUpdate(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Basic rate limit for position updates only
  if (now - timeouts.lastPositionUpdate < 16) { // Max 60 updates per second
    return; // Silently ignore too frequent updates
  }
  timeouts.lastPositionUpdate = now;
  
  // Update player data - town boundary check removed to allow players to explore freely
  if (data.position) {
    player.position = data.position;
  }
  
  // Update other player properties
  player.rotation = data.rotation || player.rotation;
  player.isAiming = data.isAiming !== undefined ? data.isAiming : player.isAiming;
  player.isReloading = data.isReloading !== undefined ? data.isReloading : player.isReloading;
  
  // Update QuickDraw lobby index if provided
  if (data.quickDrawLobbyIndex !== undefined) {
    player.quickDrawLobbyIndex = data.quickDrawLobbyIndex;
  }
  
  if (data.isSprinting !== undefined) {
    player.isSprinting = data.isSprinting;
  }
  
  // Broadcast valid update to others
  broadcastToOthers(playerId, {
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    rotation: player.rotation,
    isAiming: player.isAiming,
    isShooting: player.isShooting,
    isReloading: player.isReloading,
    health: player.health,
    username: player.username,
    quickDrawLobbyIndex: player.quickDrawLobbyIndex
  });
}

// Anti-cheat: Handle player shooting with validation and server-side trajectory
function handlePlayerShoot(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Anti-cheat: Check if player has bullets
  if (player.bullets <= 0) {
    return sendErrorToPlayer(playerId, "Cannot shoot: out of ammo", false);
  }
  
  // Anti-cheat: Check if player is reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Cannot shoot while reloading", false);
  }
  
  // Anti-cheat: Enforce weapon cooldown
  if (now - timeouts.lastShot < GAME_CONSTANTS.WEAPON_COOLDOWN) {
    console.log(`Rate limit exceeded: Player ${playerId} attempted to shoot too quickly`);
    return sendErrorToPlayer(playerId, "Shooting too fast", false);
  }
  
  // Quick Draw gun lock validation
  if (player.inQuickDrawDuel && player.quickDrawDuelId) {
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel && duel.state !== 'draw') {
      return sendErrorToPlayer(playerId, "Cannot shoot before draw signal", false);
    }
  }
  
  // Validate bullet data
  if (!data.bulletData || !data.bulletData.position || !data.bulletData.direction) {
    return sendErrorToPlayer(playerId, "Invalid bullet data", false);
  }
  
  // Validate bullet direction (must be normalized)
  const direction = data.bulletData.direction;
  const dirMagnitude = Math.sqrt(direction.x*direction.x + direction.y*direction.y + direction.z*direction.z);
  
  if (Math.abs(dirMagnitude - 1) > 0.01) {
    console.log(`Invalid bullet direction: not normalized for player ${playerId} (magnitude: ${dirMagnitude.toFixed(2)})`);
    
    // Normalize the direction
    direction.x /= dirMagnitude;
    direction.y /= dirMagnitude;
    direction.z /= dirMagnitude;
  }
  
  // All validations passed, decrement bullet count
  player.bullets--;
  
  // Update lastShot timestamp
  timeouts.lastShot = now;
  
  // Handle shotgun pellets - generate multiple projectiles with spread
  const isShotgun = player.activeWeapon === 'shotgun';
  const bulletCount = isShotgun ? 10 : 1; // 10 pellets for shotgun, 1 for revolver
  
  // If multiple bullets come from revolver in a single shot, it's likely cheating
  if (!isShotgun && data.bulletData.pelletCount && data.bulletData.pelletCount > 1) {
    console.log(`Potential cheating detected: Player ${playerId} tried to fire multiple revolver bullets at once`);
    return sendErrorToPlayer(playerId, "Invalid bullet count for weapon type", true);
  }
  
  // Create server-side bullets (one bullet for revolver, multiple pellets for shotgun)
  for (let i = 0; i < bulletCount; i++) {
    const bulletId = nextBulletId++;
    
    // For shotgun, apply spread to each pellet except the first one (which uses the original aim direction)
    let pelletDirection = { ...direction };
    
    if (isShotgun && i > 0) {
      // Apply realistic shotgun spread
      const spread = 0.08; // Match client-side spread value
      pelletDirection = {
        x: direction.x + (Math.random() - 0.5) * spread,
        y: direction.y + (Math.random() - 0.5) * spread,
        z: direction.z + (Math.random() - 0.5) * spread
      };
      
      // Normalize the direction after applying spread
      const pelletDirMag = Math.sqrt(
        pelletDirection.x * pelletDirection.x + 
        pelletDirection.y * pelletDirection.y + 
        pelletDirection.z * pelletDirection.z
      );
      
      pelletDirection.x /= pelletDirMag;
      pelletDirection.y /= pelletDirMag;
      pelletDirection.z /= pelletDirMag;
    }
    
    const bullet = {
      id: bulletId,
      sourcePlayerId: playerId,
      position: data.bulletData.position,
      direction: pelletDirection,
      distanceTraveled: 0,
      maxDistance: GAME_CONSTANTS.MAX_BULLET_DISTANCE,
      speed: GAME_CONSTANTS.BULLET_SPEED,
      timeCreated: now,
      active: true,
      isShotgunPellet: isShotgun,
      pelletIndex: i
    };
    
    // Add to active bullets
    activeBullets.set(bulletId, bullet);
    
    // For the first bullet/pellet or if it's a revolver shot, notify all clients
    // For shotgun pellets after the first, only notify about first pellet to save bandwidth
    if (i === 0 || !isShotgun) {
      broadcastToAll({
        type: 'playerShoot',
        id: playerId,
        bulletId: bulletId,
        bulletData: {
          position: data.bulletData.position,
          direction: pelletDirection,
          isShotgunPellet: isShotgun
        }
      });
    }
  }
  
  // Update the player's shooting state
  player.isShooting = true;
  
  // Reset shooting state after a short delay
  setTimeout(() => {
    if (players.has(playerId)) {
      players.get(playerId).isShooting = false;
    }
  }, 100);
}

// Anti-cheat: Handle player reload with validation
function handlePlayerReload(playerId, data) {
  const player = players.get(playerId);
  const timeouts = playerTimeouts.get(playerId);
  
  if (!player || !timeouts) return;
  
  const now = Date.now();
  
  // Check if player is already reloading
  if (player.isReloading) {
    return sendErrorToPlayer(playerId, "Already reloading", false);
  }
  
  // Check if player has full ammo
  if (player.bullets >= player.maxBullets) {
    return sendErrorToPlayer(playerId, "Ammo already full", false);
  }
  
  // Start reload process
  player.isReloading = true;
  timeouts.isReloading = true;
  timeouts.reloadStartTime = now;
  
  // Notify all players about reload start
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    isReloading: true
  });
  
  // Schedule reload completion
  setTimeout(() => {
    if (!players.has(playerId)) return;
    
    const timeouts = playerTimeouts.get(playerId);
    if (!timeouts) return;
    
    // Check if player is still reloading (could have been cancelled)
    if (timeouts.isReloading) {
      const player = players.get(playerId);
      
      // Complete reload
      player.bullets = player.maxBullets;
      player.isReloading = false;
      timeouts.isReloading = false;
      
      // Notify all players about reload completion
      broadcastToAll({
        type: 'playerUpdate',
        id: playerId,
        isReloading: false,
        bullets: player.maxBullets
      });
    }
  }, GAME_CONSTANTS.RELOAD_TIME);
}

// Anti-cheat: Handle player hit validation
function handlePlayerHit(playerId, targetId, hitData, bulletId) {
  console.log(`Player ${playerId} claims hit on player/npc ${targetId}`);
  
  // Basic validation
  const isPlayerTarget = players.has(targetId);
  const isNpcTarget = npcs.has(targetId);
  
  if (!players.has(playerId) || (!isPlayerTarget && !isNpcTarget)) {
    console.log(`Hit claim invalid - player ${playerId} or target ${targetId} not found`);
    return;
  }
  
  const player = players.get(playerId);
  
  // Get target (player or NPC)
  let target;
  let isNpc = false;
  
  if (isPlayerTarget) {
    target = players.get(targetId);
  } else if (isNpcTarget) {
    target = npcs.get(targetId);
    isNpc = true;
  }
  
  // Check if bullet ID is valid, if provided
  if (bulletId && !activeBullets.has(bulletId)) {
    console.log(`Invalid bullet ID: ${bulletId}`);
    return sendErrorToPlayer(playerId, "Invalid bullet ID", false);
  }
  
  // Track hit timestamps to prevent double-counting hits
  // Initialize hit tracking structure if not already present
  if (!player.recentHits) {
    player.recentHits = new Map();
  }
  
  // Check for duplicate/too frequent hits on the same target
  const now = Date.now();
  const lastHitTime = player.recentHits.get(targetId) || 0;
  
  // If this is a shotgun hit, use a shorter debounce time to allow multiple pellets to hit
  const isShotgunHit = player.activeWeapon === 'shotgun' || 
                      (bulletId && activeBullets.has(bulletId) && activeBullets.get(bulletId).isShotgunPellet);
  
  // Use a shorter debounce time for shotgun pellets (50ms) vs regular bullets (300ms)
  const hitDebounceTime = isShotgunHit ? 50 : 300;
  
  if (now - lastHitTime < hitDebounceTime) {
    console.log(`Hit debounced: Player ${playerId} hit ${targetId} too quickly after last hit (${now - lastHitTime}ms)`);
    return; // Silently ignore too-frequent hits
  }
  
  // Update last hit time for this target
  player.recentHits.set(targetId, now);
  
  // ADDED: Check if this is a quickdraw duel hit
  // If the players are in a quickdraw duel, handle it using the quickdraw logic
  if (!isNpc && player.inQuickDrawDuel && target.inQuickDrawDuel && player.quickDrawDuelId === target.quickDrawDuelId) {
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel && duel.state === 'draw') {
      console.log(`Handling hit as part of QuickDraw duel ${player.quickDrawDuelId}`);
      // Calculate damage based on hit zone
      let finalDamage = 40; // Default body shot
      
      if (hitData.hitZone === 'head') {
        finalDamage = 100; // One-shot kill for headshots
      } else if (hitData.hitZone === 'limbs') {
        finalDamage = Math.round(40 * 0.6); // Reduced damage for limb shots
      } else if (hitData.hitZone === 'body') {
        finalDamage = 40; // Standard body shot damage
      }
      
      // Use the quickdraw handler with the appropriate damage and hit zone
      handleQuickDrawShoot(playerId, targetId, undefined, hitData.hitZone, finalDamage, true);
      return;
    }
  }
  
  // Rest of original hit handling for non-quickdraw hits
  // Get bullet data if available
  let bullet = null;
  if (bulletId && activeBullets.has(bulletId)) {
    bullet = activeBullets.get(bulletId);
  }
  
  // Calculate damage based on hit zone and weapon type
  let damage = GAME_CONSTANTS.DAMAGE_PER_HIT;
  
  // Check if this is a shotgun pellet hit
  const isShotgunPellet = player.activeWeapon === 'shotgun' || 
                         (bullet && bullet.isShotgunPellet);
  
  if (isShotgunPellet) {
    // Shotgun pellet damage
    if (hitData.hitZone === 'head') {
      damage = 10; // Per pellet headshot damage
    } else {
      damage = 5;  // Per pellet body/limb damage
    }
  } else {
    // Regular bullet damage
    if (hitData.hitZone === 'head') {
      damage = 100; // One-shot kill for headshots
    } else if (hitData.hitZone === 'body') {
      damage = 40; // Standard body shot
    } else if (hitData.hitZone === 'limbs') {
      damage = 20; // Reduced damage for limbs
    }
  }
  
  // Apply damage to target
  target.health = Math.max(0, target.health - damage);
  
  // If NPC was hit and survived, make them fight back
  if (isNpc && target.health > 0) {
    handleNpcAttacked(targetId, playerId);
  }
  
  // Notify both target and shooter
  if (!isNpc && target.ws && target.ws.readyState === WebSocket.OPEN) {
    target.ws.send(JSON.stringify({
      type: 'hit',
      sourceId: playerId,
      hitData: hitData,
      hitZone: hitData.hitZone,
      health: target.health
    }));
  }
  
  if (player.ws && player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'playerHit',
      targetId: targetId,
      sourceId: playerId,
      hitPosition: hitData.position,
      health: target.health,
      hitZone: hitData.hitZone,
      damage: damage,
      isNpc: isNpc
    }));
  }
  
  // Broadcast hit to other players for visual effects
  broadcastToOthers([playerId, isNpc ? null : targetId], {
    type: 'playerHit',
    targetId: targetId,
    sourceId: playerId,
    hitPosition: hitData.position,
    health: target.health,
    hitZone: hitData.hitZone,
    damage: damage,
    isNpc: isNpc
  });
  
  // Check if target has been defeated
  if (target.health <= 0) {
    if (isNpc) {
      handleNpcDeath(targetId, playerId);
    } else {
      handlePlayerDeath(targetId, playerId);
    }
  }
}

// Anti-cheat: Bullet-player collision detection
function isPlayerHitByBullet(player, bullet) {
  // Calculate player hitbox (simple cylinder)
  const playerRadius = 0.6;  // Increased horizontal radius to match client's bodyWidth
  const playerHeight = 2.0;  // vertical height
  
  // Calculate distance from bullet to player (horizontal only)
  const dx = bullet.position.x - player.position.x;
  const dz = bullet.position.z - player.position.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  // Check if bullet is within player's horizontal radius
  if (horizontalDist > playerRadius) {
    return false;
  }
  
  // Check if bullet is within player's vertical bounds
  const bulletY = bullet.position.y;
  const playerBottom = player.position.y - 1.6; // Adjust based on your coordinate system
  const playerTop = playerBottom + playerHeight;
  
  // Add some tolerance to vertical bounds
  const tolerance = 0.2;
  if (bulletY < playerBottom - tolerance || bulletY > playerTop + tolerance) {
    return false;
  }
  
  // Bullet is inside player's hitbox
  return true;
}

// Anti-cheat: Handle player death
function handlePlayerDeath(playerId, killedById) {
  const player = players.get(playerId);
  if (!player) return;
  
  console.log(`Player ${playerId} was killed by player ${killedById}`);
  
  // Skip handling if player is in QuickDraw duel
  // QuickDraw duels handle their own death/end conditions
  if (player.inQuickDrawDuel) {
    console.log(`Player ${playerId} is in a QuickDraw duel - skipping regular death handling`);
    return;
  }
  
  // Send death notification to all clients
  broadcastToAll({
    type: 'playerDeath',
    id: playerId,
    killedById: killedById
  });
  
  // Send death notification to the killed player
  if (player.ws && player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'death',
      killerId: killedById
    }));
  }
  
  // Send kill notification to the killer
  const killer = players.get(killedById);
  if (killer && killer.ws && killer.ws.readyState === WebSocket.OPEN) {
    killer.ws.send(JSON.stringify({
      type: 'kill',
      targetId: playerId
    }));
  }
  
  // Delay respawn to allow death animation to complete
  setTimeout(() => {
    // Check if player is still connected
    if (players.has(playerId)) {
      respawnPlayer(playerId);
    }
  }, 2000); // 2 second delay for death animation
}

// Anti-cheat: Respawn a player
function respawnPlayer(playerId) {
  const player = players.get(playerId);
  if (!player) return;
  
  // Reset player state
  player.health = 100;
  
  // Reset weapon state based on active weapon
  if (!player.activeWeapon) {
    player.activeWeapon = 'revolver'; // Default if not set
  }
  
  // Define weapon capacities
  const weaponCapacity = {
    revolver: 6,
    shotgun: 2
  };
  
  // Set max bullets based on active weapon
  player.maxBullets = weaponCapacity[player.activeWeapon] || 6;
  
  // Reset ammo to maximum
  player.bullets = player.maxBullets;
  
  // Reset states
  player.isReloading = false;
  player.isAiming = false;
  player.isShooting = false;
  
  // Generate random spawn position within town
  const spawnX = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_WIDTH * 0.8;
  const spawnY = 1.6;
  const spawnZ = (Math.random() - 0.5) * GAME_CONSTANTS.TOWN_LENGTH * 0.8;
  
  // Set spawn position
  player.position = { x: spawnX, y: spawnY, z: spawnZ };
  
  // Reset QuickDraw-related state if not in a duel
  if (!player.inQuickDrawDuel) {
    player.quickDrawLobbyIndex = -1;
  }
  
  // Notify the player they're respawning
  if (player.ws.readyState === WebSocket.OPEN) {
    player.ws.send(JSON.stringify({
      type: 'respawn',
      position: player.position,
      health: player.health,
      bullets: player.bullets,
      maxBullets: player.maxBullets,
      activeWeapon: player.activeWeapon
    }));
  }
  
  // Broadcast the respawn to all players
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    position: player.position,
    health: player.health,
    isReloading: false,
    isAiming: false,
    isDying: false,             // Explicitly reset death animation state
    resetAnimationState: true,  // Special flag to trigger animation reset on clients
    activeWeapon: player.activeWeapon
  });
}

// Anti-cheat: Check if position is within town boundaries
function isPositionInTown(position) {
  // Modified to always return true, allowing players to leave town
  return true;
}

// Anti-cheat: Check if position is in arena
function isPositionInArena(position, arenaIndex) {
  // Define arena positions and radius
  const arenaRadius = 15;
  
  // Calculate arena center position based on index
  const spacingX = 50;
  const baseZ = GAME_CONSTANTS.TOWN_LENGTH + 50;
  
  const offsetX = (arenaIndex - 2) * spacingX; // Center on zero, spread outward
  const arenaCenter = { x: offsetX, y: 0, z: baseZ };
  
  // Check if point is inside arena (horizontally)
  const dx = position.x - arenaCenter.x;
  const dz = position.z - arenaCenter.z;
  const horizontalDist = Math.sqrt(dx * dx + dz * dz);
  
  return horizontalDist < arenaRadius;
}

// Anti-cheat: Send position correction to player
function sendPositionCorrection(playerId, correctPosition) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  const now = Date.now();
  const timeouts = playerTimeouts.get(playerId);
  
  // Skip if we've recently sent a correction
  if (timeouts && timeouts.lastPositionCorrection && 
      now - timeouts.lastPositionCorrection < CORRECTION_COOLDOWN) {
    return;
  }
  
  // Calculate distance between current position and correction
  const currentPos = player.position;
  const distance = Math.sqrt(
    Math.pow(currentPos.x - correctPosition.x, 2) +
    Math.pow(currentPos.y - correctPosition.y, 2) +
    Math.pow(currentPos.z - correctPosition.z, 2)
  );
  
  // Only send significant corrections (>5 units) to avoid unnecessary resets
  if (distance > 5) {
    console.log(`Sending position correction to player ${playerId}, distance: ${distance.toFixed(2)}`);
    
    // Update last correction time
    if (timeouts) {
      timeouts.lastPositionCorrection = now;
    }
    
    player.ws.send(JSON.stringify({
      type: 'positionCorrection',
      position: correctPosition
    }));
  }
}

// Anti-cheat: Send error message to player
function sendErrorToPlayer(playerId, message, fatal = false) {
  const player = players.get(playerId);
  if (!player || player.ws.readyState !== WebSocket.OPEN) return;
  
  player.ws.send(JSON.stringify({
    type: 'error',
    message: message,
    fatal: fatal
  }));
}

// Cleanup a disconnected or stale player
function cleanupPlayer(playerId) {
  const player = players.get(playerId);
  
  if (!player) return;
  
  console.log(`Cleaning up player ${playerId}`);
  
  // If this player has a clientId, update their lastSeen time
  if (player.clientId) {
    const identity = playerIdentities.get(player.clientId);
    if (identity) {
      identity.lastSeen = Date.now();
      console.log(`Updated lastSeen for identity ${player.clientId}`);
    }
  }
  
  if (player.sessionId) {
    sessions.delete(player.sessionId);
  }
  
  // Quick Draw cleanup
  if (player.inQuickDrawQueue && player.quickDrawLobbyIndex >= 0) {
    // Remove from the appropriate queue
    const queueIndex = player.quickDrawLobbyIndex;
    if (queueIndex >= 0 && queueIndex < MAX_ARENAS) {
      const queue = quickDrawQueues[queueIndex];
      const index = queue.indexOf(playerId);
      if (index !== -1) {
        queue.splice(index, 1);
      }
    }
  }
  
  if (player.inQuickDrawDuel && player.quickDrawDuelId) {
    // End any active duel
    const duel = quickDrawDuels.get(player.quickDrawDuelId);
    if (duel) {
      // The other player wins by default
      const winnerId = duel.player1Id === playerId ? duel.player2Id : duel.player1Id;
      endQuickDrawDuel(player.quickDrawDuelId, winnerId);
    }
  }
  
  players.delete(playerId);
  
  // Anti-cheat: Clean up associated data
  playerTimeouts.delete(playerId);
  playerNonces.delete(playerId);
  playerSequences.delete(playerId);
  playerPositionHistory.delete(playerId);
  
  // Send Telegram notification for player disconnect
  if (player.username && !player.isDev) {
    sendTelegramNotification(`👋 Player left: ${player.username} (ID: ${playerId})`);
  }

  // Notify all that the player left
  broadcastToAll({
    type: 'playerLeft',
    id: playerId
  });

  updatePlayerCount();
}

// Broadcast a "playerCount" update to all
function updatePlayerCount() {
  broadcastToAll({
    type: 'playerCount',
    count: players.size
  });
}

// Broadcast to all except a given playerId
function broadcastToOthers(excludeId, data) {
  for (const [pid, pl] of players.entries()) {
    // Skip if this is the excluded player ID (could be a number or an array of numbers)
    if (Array.isArray(excludeId) ? excludeId.includes(pid) : pid === excludeId) continue;
    
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Broadcast to all players
function broadcastToAll(data) {
  players.forEach((player, id) => {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.send(JSON.stringify(data));
    }
  });
}

/**
 * Handle a player joining a specific Quick Draw queue.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index to join (0-4)
 */
function handleQuickDrawJoin(playerId, arenaIndex) {
  // Validate arena index
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    console.error(`Invalid arena index: ${arenaIndex}`);
    return;
  }
  
  console.log(`Player ${playerId} joined Quick Draw queue for arena ${arenaIndex + 1}`);
  const playerData = players.get(playerId);
  
  if (!playerData || playerData.inQuickDrawQueue || playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  // Add to the specific queue
  quickDrawQueues[arenaIndex].push(playerId);
  
  // Update player state
  playerData.inQuickDrawQueue = true;
  playerData.quickDrawLobbyIndex = arenaIndex;
  
  // Notify the player and everyone else
  if (playerData.ws.readyState === WebSocket.OPEN) {
    playerData.ws.send(JSON.stringify({
      type: 'joinedQuickDrawQueue',
      arenaIndex: arenaIndex
    }));
  }
  
  // Broadcast to all players
  broadcastToAll({
    type: 'playerUpdate',
    id: playerId,
    quickDrawLobbyIndex: arenaIndex
  });
  
  // Check if we can now start a duel
  checkQuickDrawQueue(arenaIndex);
}

/**
 * Handle a player leaving the Quick Draw queue.
 * @param {number} playerId - The player's ID
 */
function handleQuickDrawLeave(playerId) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawQueue) {
    return; // Invalid state
  }
  
  // Get the arena index
  const arenaIndex = playerData.quickDrawLobbyIndex;
  if (arenaIndex >= 0 && arenaIndex < MAX_ARENAS) {
    console.log(`Player ${playerId} left Quick Draw queue for arena ${arenaIndex + 1}`);
    
    // Remove from appropriate queue
    const index = quickDrawQueues[arenaIndex].indexOf(playerId);
    if (index !== -1) {
      quickDrawQueues[arenaIndex].splice(index, 1);
    }
  }
  
  // Reset player state
  playerData.inQuickDrawQueue = false;
  playerData.quickDrawLobbyIndex = -1;
}

/**
 * Check if we have enough players in a specific Quick Draw queue to start a match.
 * @param {number} arenaIndex - The arena index to check
 */
function checkQuickDrawQueue(arenaIndex) {
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    return; // Invalid arena index
  }
  
  const queue = quickDrawQueues[arenaIndex];
  
  if (queue.length < 2) {
    return; // Not enough players in this queue
  }
  
  // Get the two players who have been waiting the longest
  const player1Id = queue.shift();
  const player2Id = queue.shift();
  
  // Make sure both players are still connected
  const player1 = players.get(player1Id);
  const player2 = players.get(player2Id);
  
  if (!player1 || !player2) {
    // Put the valid player back in the queue
    if (player1) queue.push(player1Id);
    if (player2) queue.push(player2Id);
    return;
  }
  
  // Create a new duel
  const duelId = `duel_${arenaIndex}_${player1Id}_${player2Id}`;
  quickDrawDuels.set(duelId, {
    id: duelId,
    arenaIndex: arenaIndex,
    player1Id,
    player2Id,
    state: 'starting',
    startTime: Date.now()
  });
  
  // Mark players as in a duel
  player1.inQuickDrawQueue = false;
  player1.inQuickDrawDuel = true;
  player1.quickDrawDuelId = duelId;
  
  player2.inQuickDrawQueue = false;
  player2.inQuickDrawDuel = true;
  player2.quickDrawDuelId = duelId;
  
  // Reset player health to full at the start of the duel
  player1.health = 100;
  player2.health = 100;
  
  // Notify players of the match
  player1.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player2Id,
    position: 'left', // Player 1 spawns on the left
    arenaIndex: arenaIndex
  }));
  
  player2.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player1Id,
    position: 'right', // Player 2 spawns on the right
    arenaIndex: arenaIndex
  }));
  
  console.log(`Started Quick Draw duel ${duelId} between players ${player1Id} and ${player2Id} in arena ${arenaIndex + 1}`);
}

/**
 * Handle a player being ready in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index for the duel
 */
function handleQuickDrawReady(playerId, arenaIndex) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  const duelId = playerData.quickDrawDuelId;
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  // Verify arena index matches
  if (arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
    console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
    return;
  }
  
  // Mark this player as ready
  if (duel.player1Id === playerId) {
    duel.player1Ready = true;
  } else if (duel.player2Id === playerId) {
    duel.player2Ready = true;
  }
  
  // If both players are ready, start the duel sequence
  if (duel.player1Ready && duel.player2Ready) {
    startQuickDrawDuel(duelId);
  }
}

/**
 * Start the Quick Draw duel sequence.
 * @param {string} duelId - The duel ID
 */
function startQuickDrawDuel(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'countdown';
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Send Telegram notification for Quick Draw duel
  sendTelegramNotification(`🤠 Quick Draw duel started between ${player1.username} and ${player2.username} in arena ${duel.arenaIndex + 1}`);
  
  // Send countdown signal immediately
  player1.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
  
  // Set a random time for the draw signal (1-5 seconds)
  const drawTime = 1000 + Math.floor(Math.random() * 4000);
  duel.drawTimeout = setTimeout(() => {
    if (quickDrawDuels.has(duelId)) {
      sendDrawSignal(duelId);
    }
  }, drawTime);
}

/**
 * Update the game state to "draw" phase without sending a visual message.
 * @param {string} duelId - The duel ID
 */
function sendDrawSignal(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'draw';
  duel.drawTime = Date.now();
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Send draw signal to both players without visual text
  player1.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  
  console.log(`Draw signal sent for duel ${duelId}`);
}

/**
 * Handle a player shooting in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} targetId - The target player's ID
 * @param {number} arenaIndex - The arena index for the duel (optional for direct duels)
 * @param {string} hitZone - The hit zone ('head', 'body', 'limbs')
 * @param {number} damage - The damage amount
 */
function handleQuickDrawShoot(playerId, targetId, arenaIndex, hitZone = 'body', damage = 40, hitDetected = false) {
    playerId = Number(playerId);
    targetId = Number(targetId);
    
    console.log(`Quick Draw shoot: Player ${playerId} shot player ${targetId} (${hitZone}, ${damage} damage, hitDetected: ${hitDetected})`);
    
    const playerData = players.get(playerId);
    
    if (!playerData || !playerData.inQuickDrawDuel) {
        console.log(`Quick Draw shoot rejected: Player ${playerId} not in a duel`);
        return; // Invalid state
    }
    
    const duelId = playerData.quickDrawDuelId;
    const duel = quickDrawDuels.get(duelId);
    
    if (!duel) {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not found`);
        return; // Invalid duel
    }
    
    // For direct duels, no arena index check is needed
    if (!duel.isDirect && arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
        console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
        return;
    }
    
    // Verify that the target is the opponent in this duel
    if ((duel.player1Id === playerId && duel.player2Id !== targetId) ||
        (duel.player2Id === playerId && duel.player1Id !== targetId)) {
        console.log(`Quick Draw shoot rejected: Target ${targetId} is not the opponent in duel ${duelId}`);
        return;
    }
    
    // Verify the duel is in the 'draw' state
    if (duel.state !== 'draw') {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not in 'draw' state (${duel.state})`);
        return;
    }
    
    // If hitDetected is false and it's not a miss, don't apply damage
    if (!hitDetected && hitZone !== 'miss') {
        console.log(`Quick Draw shot without proper hit detection from player ${playerId} - ignoring damage`);
        
        // Send a debug message to the client
        if (playerData.ws && playerData.ws.readyState === WebSocket.OPEN) {
            playerData.ws.send(JSON.stringify({
                type: 'debug',
                message: 'Shot ignored - hit detection failed'
            }));
        }
        
        // Consider this a miss
        hitZone = 'miss';
        damage = 0;
    }
    
    // Add hit debouncing to prevent double counting - track the last hit time
    // Initialize the lastHitTime map on the duel object if it doesn't exist
    if (!duel.lastHitTime) {
        duel.lastHitTime = new Map();
    }
    
    const now = Date.now();
    const lastHitTime = duel.lastHitTime.get(targetId) || 0;
    const hitDebounceTime = 300; // 300ms minimum time between hits
    
    if (now - lastHitTime < hitDebounceTime) {
        console.log(`Quick Draw shoot debounced: Too soon after last hit (${now - lastHitTime}ms)`);
        return; // Ignore rapid-fire hit reports that are too close together
    }
    
    // If it's a miss, don't apply damage
    if (hitZone === 'miss') {
        console.log(`Player ${playerId} missed - no damage applied`);
        
        // Send miss notification to both players
        const missData = {
            type: 'quickDrawMiss',
            playerId: playerId,
            targetId: targetId
        };
        
        if (playerData.ws && playerData.ws.readyState === WebSocket.OPEN) {
            playerData.ws.send(JSON.stringify(missData));
        }
        
        const targetPlayer = players.get(targetId);
        if (targetPlayer && targetPlayer.ws && targetPlayer.ws.readyState === WebSocket.OPEN) {
            targetPlayer.ws.send(JSON.stringify(missData));
        }
        
        return;
    }
    
    // Update the last hit time for this target
    duel.lastHitTime.set(targetId, now);
    
    // Calculate reaction time
    const reactionTime = now - duel.drawTime;
    
    // Calculate damage based on hit zone
    let finalDamage = damage;
    if (hitZone === 'head') {
        finalDamage = 100; // One-shot kill for headshots
    } else if (hitZone === 'limbs') {
        finalDamage = Math.round(damage * 0.6); // Reduced damage for limb shots
    } else if (hitZone === 'body') {
        finalDamage = 40; // Standard body shot damage
    }
    
    // Apply damage to target
    const targetPlayer = players.get(targetId);
    if (!targetPlayer) {
        console.log(`Target player ${targetId} not found`);
        return;
    }
    
    // Get current health before applying damage
    const currentHealth = targetPlayer.health || 100;
    
    // Calculate new health after damage
    const newHealth = Math.max(0, currentHealth - finalDamage);
    
    // Debug info for health calculation
    console.log(`[DEBUG] Health calculation: ${currentHealth} - ${finalDamage} = ${newHealth}`);
    
    // Store the new health
    targetPlayer.health = newHealth;
    
    console.log(`Player ${targetId} hit for ${finalDamage} damage, health now ${targetPlayer.health}`);
    
    // Send health update to both players
    if (targetPlayer.ws && targetPlayer.ws.readyState === WebSocket.OPEN) {
        console.log(`Sending health update to target: ${targetId} - health: ${newHealth}`);
        targetPlayer.ws.send(JSON.stringify({
            type: 'playerHealthUpdate',
            playerId: targetId,
            health: newHealth,
            damage: finalDamage,
            hitBy: playerId
        }));
    }
    
    if (playerData.ws && playerData.ws.readyState === WebSocket.OPEN) {
        console.log(`Sending health update to shooter: ${playerId} - target health: ${newHealth}`);
        playerData.ws.send(JSON.stringify({
            type: 'playerHealthUpdate',
            playerId: targetId, 
            health: newHealth,
            damage: finalDamage,
            hitBy: playerId
        }));
    }
    
    // Only end the duel if target's health is 0 or less
    if (newHealth <= 0) {
        console.log(`Player ${targetId} defeated in duel - health reduced to 0`);
        
        // Send death flag to all other players to trigger death animation
        broadcastToOthers(targetId, {
            type: 'playerUpdate',
            id: targetId,
            position: targetPlayer.position,
            rotation: targetPlayer.rotation,
            health: 0,
            isDying: true // Trigger death animation on client
        });
        
        // End the duel with shooter as winner
        endQuickDrawDuel(duelId, playerId);
    } else {
        console.log(`Player ${targetId} was hit but still has ${newHealth} health - duel continues`);
    }
}

/**
 * End a Quick Draw duel and notify players of the result.
 * @param {string} duelId - The duel ID
 * @param {number} winnerId - The winner's player ID (if any)
 */
function endQuickDrawDuel(duelId, winnerId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  // Get player objects for notification
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  // Determine the winner username for notification
  let winnerUsername = 'Unknown';
  let loserUsername = 'Unknown';
  
  if (winnerId) {
    // If we have a winner, determine usernames
    if (winnerId === duel.player1Id && player1) {
      winnerUsername = player1.username;
      loserUsername = player2 ? player2.username : 'Disconnected player';
    } else if (winnerId === duel.player2Id && player2) {
      winnerUsername = player2.username;
      loserUsername = player1 ? player1.username : 'Disconnected player';
    }
    
    // Send Telegram notification about duel result
    sendTelegramNotification(`🏆 Quick Draw duel ended: ${winnerUsername} defeated ${loserUsername} in arena ${duel.arenaIndex + 1}`);
  } else {
    // No winner (both disconnected or other reason)
    sendTelegramNotification(`🚫 Quick Draw duel ended with no winner in arena ${duel.arenaIndex + 1}`);
  }
  
  console.log(`Ending Quick Draw duel ${duelId} with winner: ${winnerId || 'none'}`);
  
  // Clear any pending timeouts
  if (duel.drawTimeout) {
    clearTimeout(duel.drawTimeout);
  }
  
  // First notify players of the duel result
  if (player1 && player1.ws.readyState === WebSocket.OPEN) {
    player1.inQuickDrawDuel = false;
    player1.quickDrawDuelId = null;
    player1.quickDrawLobbyIndex = -1;
    
    // Send standard QuickDraw end notification
    player1.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId
    }));
    
    // If this player lost, also send death notification
    if (winnerId && winnerId !== duel.player1Id) {
      // Set loser's health to 0
      player1.health = 0;
      
      // Send death notification (same as regular deaths)
      player1.ws.send(JSON.stringify({
        type: 'death',
        killerId: winnerId
      }));
      
      // Broadcast death animation to all clients
      broadcastToAll({
        type: 'playerDeath',
        id: duel.player1Id,
        killedById: winnerId
      });
    }
    
    // If this player won, send kill notification
    if (winnerId && winnerId === duel.player1Id) {
      player1.ws.send(JSON.stringify({
        type: 'kill',
        targetId: duel.player2Id
      }));
    }
  }
  
  if (player2 && player2.ws.readyState === WebSocket.OPEN) {
    player2.inQuickDrawDuel = false;
    player2.quickDrawDuelId = null;
    player2.quickDrawLobbyIndex = -1;
    
    // Send standard QuickDraw end notification
    player2.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId
    }));
    
    // If this player lost, also send death notification
    if (winnerId && winnerId !== duel.player2Id) {
      // Set loser's health to 0
      player2.health = 0;
      
      // Send death notification (same as regular deaths)
      player2.ws.send(JSON.stringify({
        type: 'death',
        killerId: winnerId
      }));
      
      // Broadcast death animation to all clients
      broadcastToAll({
        type: 'playerDeath',
        id: duel.player2Id,
        killedById: winnerId
      });
    }
    
    // If this player won, send kill notification
    if (winnerId && winnerId === duel.player2Id) {
      player2.ws.send(JSON.stringify({
        type: 'kill',
        targetId: duel.player1Id
      }));
    }
  }
  
  // Wait for animation to complete before sending respawn
  setTimeout(() => {
    // Respawn both players in their new positions
    if (player1 && players.has(duel.player1Id)) {
      respawnPlayer(duel.player1Id);
    }
    
    if (player2 && players.has(duel.player2Id)) {
      respawnPlayer(duel.player2Id);
    }
    
    // Finally, remove the duel from the active duels map
    quickDrawDuels.delete(duelId);
    
    // Update arena status
    const arenaIndex = duel.arenaIndex;
    if (arenaIndex !== undefined) {
      arenaInUse[arenaIndex] = false;
    }
    
  }, 2000); // 2 second delay for death animation, same as regular kills
}

/**
 * Handle a player challenging another player to a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} targetPlayerId - The target player's ID
 */
function handleQuickDrawChallenge(playerId, targetPlayerId) {
  const player = players.get(playerId);
  const targetPlayer = players.get(targetPlayerId);
  
  if (!player || !targetPlayer) {
    return; // Invalid players
  }
  
  if (player.inQuickDrawQueue || player.inQuickDrawDuel) {
    return; // Challenger can't be in another game mode
  }
  
  if (targetPlayer.inQuickDrawQueue || targetPlayer.inQuickDrawDuel) {
    return; // Target can't be in another game mode
  }
  
  console.log(`Player ${playerId} challenged player ${targetPlayerId} to a Quick Draw duel`);
  
  // Send challenge to target player
  targetPlayer.ws.send(JSON.stringify({
    type: 'quickDrawChallengeReceived',
    challengerId: playerId,
    challengerPosition: player.position
  }));
}

/**
 * Generate random positions on the main street for a Quick Draw duel.
 * This ensures players spawn in the open street and not inside buildings.
 * @returns {Object} An object containing two positions and their facing rotations
 */
function generateQuickDrawStreetPositions() {
  // Define the town boundaries
  const townWidth = GAME_CONSTANTS.TOWN_WIDTH;
  const townLength = GAME_CONSTANTS.TOWN_LENGTH;
  
  // Fixed eye level height
  const eyeLevel = 2.72;
  
  console.log(`[DEBUG] QuickDraw duel - Setting player eye level to ${eyeLevel} (feet should be at ground level)`);
  
  // Create 5 parallel lanes with realistic spacing for a line formation
  const numLanes = 5;
  const laneSpacing = 3.0; // 3 meters between each lane - realistic spacing for people standing side by side
  const totalLineWidth = (numLanes - 1) * laneSpacing; // Total width of the line formation
  const startX = -totalLineWidth / 2; // Center the formation in the town
  
  // Choose a random lane (0-4)
  const laneIndex = Math.floor(Math.random() * numLanes);
  const laneX = startX + (laneIndex * laneSpacing);
  
  console.log(`[DEBUG] Chosen quickdraw lane ${laneIndex + 1} of ${numLanes} at X=${laneX.toFixed(2)}`);
  
  // Position at north/south of the chosen lane, maintaining the same Z position for all lanes
  // This creates a straight line of duelists on each side
  const position1 = {
    x: laneX,
    y: eyeLevel,
    z: -20 // North line position
  };
  
  const position2 = {
    x: laneX,
    y: eyeLevel,
    z: 20 // South line position
  };
  
  // Calculate vector from player1 to player2
  const dx = position2.x - position1.x;
  const dz = position2.z - position1.z;
  
  // Calculate angle from positive Z axis (which is the "forward" direction in THREE.js)
  // Add Math.PI (180 degrees) to make players FACE each other instead of facing away
  const rotation1 = Math.atan2(dx, dz) + Math.PI;
  
  // For player2, we need to calculate the angle from the positive Z axis to the vector pointing to player1
  // This is the opposite direction, so we use negative dx and dz, plus 180 degrees correction
  const rotation2 = Math.atan2(-dx, -dz) + Math.PI;
  
  // Log positions
  console.log(`[DEBUG] DUEL POSITIONS (LANE ${laneIndex + 1} SPAWN):`);
  console.log(`  Player1: (${position1.x.toFixed(2)}, ${position1.y.toFixed(2)}, ${position1.z.toFixed(2)}) facing ${rotation1.toFixed(4)} radians (${(rotation1 * 180 / Math.PI).toFixed(1)}°)`);
  console.log(`  Player2: (${position2.x.toFixed(2)}, ${position2.y.toFixed(2)}, ${position2.z.toFixed(2)}) facing ${rotation2.toFixed(4)} radians (${(rotation2 * 180 / Math.PI).toFixed(1)}°)`);
  console.log(`  Lane ${laneIndex + 1} of ${numLanes}, Line Formation Width: ${totalLineWidth.toFixed(2)}m`);
  console.log(`  Exact distance between players: 40.00 meters, Vector: (${dx.toFixed(2)}, ${dz.toFixed(2)})`);
  
  return {
    position1: position1,
    position2: position2,
    rotation1: rotation1,
    rotation2: rotation2
  };
}

/**
 * Handle a player accepting a Quick Draw challenge
 * @param {number} playerId - The accepting player's ID
 * @param {number} challengerId - The challenging player's ID
 */
function handleQuickDrawAcceptChallenge(playerId, challengerId) {
  const player = players.get(playerId);
  const challenger = players.get(challengerId);
  
  if (!player || !challenger) {
    return; // Invalid players
  }
  
  if (player.inQuickDrawQueue || player.inQuickDrawDuel ||
      challenger.inQuickDrawQueue || challenger.inQuickDrawDuel) {
    return; // Players can't be in another game mode
  }
  
  console.log(`Player ${playerId} accepted a Quick Draw challenge from player ${challengerId}`);
  
  // Notify challenger that the challenge was accepted
  challenger.ws.send(JSON.stringify({
    type: 'quickDrawChallengeAccepted',
    targetId: playerId
  }));
  
  // Generate controlled street positions for the duel
  const spawnPositions = generateQuickDrawStreetPositions();
  
  // Create a new duel
  const duelId = `duel_direct_${challengerId}_${playerId}`;
  quickDrawDuels.set(duelId, {
    id: duelId,
    player1Id: challengerId,
    player2Id: playerId,
    state: 'starting',
    startTime: Date.now(),
    isDirect: true
  });
  
  // Mark players as in a duel
  challenger.inQuickDrawQueue = false;
  challenger.inQuickDrawDuel = true;
  challenger.quickDrawDuelId = duelId;
  
  player.inQuickDrawQueue = false;
  player.inQuickDrawDuel = true;
  player.quickDrawDuelId = duelId;
  
  // Reset player health to full at the start of the duel
  challenger.health = 100;
  player.health = 100;
  
  // Store original positions to return players after the duel
  challenger.preQuickDrawPosition = { ...challenger.position };
  player.preQuickDrawPosition = { ...player.position };
  
  // Notify players of the match
  challenger.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: playerId,
    isDirect: true,
    startPosition: spawnPositions.position1,
    startRotation: spawnPositions.rotation1,
    movementLocked: true
  }));
  
  player.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: challengerId,
    isDirect: true,
    startPosition: spawnPositions.position2,
    startRotation: spawnPositions.rotation2,
    movementLocked: true
  }));
  
  // Extra debugging to verify positions are correct in match notification
  console.log(`[POSITION DEBUG] Match notification positions sent:
    Challenger(${challengerId}): (${spawnPositions.position1.x}, ${spawnPositions.position1.y}, ${spawnPositions.position1.z})
    Player(${playerId}): (${spawnPositions.position2.x}, ${spawnPositions.position2.y}, ${spawnPositions.position2.z})
    Should be distance: ${Math.sqrt(
      Math.pow(spawnPositions.position1.x - spawnPositions.position2.x, 2) +
      Math.pow(spawnPositions.position1.z - spawnPositions.position2.z, 2)
    ).toFixed(2)} meters
  `);
  
  console.log(`Started direct Quick Draw duel ${duelId} between players ${challengerId} and ${playerId}`);
}

/**
 * Handle a player declining a Quick Draw challenge
 * @param {number} playerId - The declining player's ID
 * @param {number} challengerId - The challenging player's ID
 */
function handleQuickDrawDeclineChallenge(playerId, challengerId) {
  const player = players.get(playerId);
  const challenger = players.get(challengerId);
  
  if (!player || !challenger) {
    return; // Invalid players
  }
  
  console.log(`Player ${playerId} declined a Quick Draw challenge from player ${challengerId}`);
  
  // Notify challenger that the challenge was declined
  challenger.ws.send(JSON.stringify({
    type: 'quickDrawChallengeDeclined',
    targetId: playerId
  }));
}

// Anti-cheat: Server-side bullet physics update
function updateBullets() {
  const now = Date.now();
  
  // Update each active bullet
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) continue;
    
    // Calculate time since last update
    const deltaTime = (now - bullet.timeCreated) / 1000;
    
    // Calculate new position
    const distanceThisFrame = bullet.speed * deltaTime;
    bullet.position.x += bullet.direction.x * distanceThisFrame;
    bullet.position.y += bullet.direction.y * distanceThisFrame;
    bullet.position.z += bullet.direction.z * distanceThisFrame;
    
    // Update total distance traveled
    bullet.distanceTraveled += distanceThisFrame;
    
    // Check if bullet has traveled too far
    if (bullet.distanceTraveled >= bullet.maxDistance) {
      bullet.active = false;
      continue;
    }
  }
  
  // Clean up inactive bullets
  for (const [bulletId, bullet] of activeBullets.entries()) {
    if (!bullet.active) {
      activeBullets.delete(bulletId);
    }
  }
}

// Heartbeat to remove stale connections
const HEARTBEAT_INTERVAL = 30000; // 30s
const CONNECTION_TIMEOUT = 60000; // 60s

setInterval(() => {
  const now = Date.now();
  for (const [id, player] of players.entries()) {
    if (now - player.lastActivity > CONNECTION_TIMEOUT) {
      console.log(`Removing stale connection for player ${id}`);
      if (player.ws.readyState === WebSocket.OPEN) {
        player.ws.close(1000, 'Connection timeout');
      }
      cleanupPlayer(id);
    } else if (player.ws.readyState === WebSocket.OPEN) {
      // keep alive
      player.ws.send(JSON.stringify({ type: 'ping' }));
    }
  }
}, HEARTBEAT_INTERVAL);

// Anti-cheat: Run physics update loop
setInterval(updateBullets, GAME_CONSTANTS.PHYSICS_UPDATE_INTERVAL);

// Start server
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Server shutting down...');
  
  // End all Quick Draw duels
  for (const duelId of quickDrawDuels.keys()) {
    endQuickDrawDuel(duelId, null);
  }
  
  for (const [id, player] of players.entries()) {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.close(1000, 'Server shutting down');
    }
  }
  server.close(() => {
    console.log('Server shutdown complete.');
    process.exit(0);
  });
});

/**
 * Handle chat messages from players and broadcast them
 * @param {number} playerId - The ID of the player sending the message 
 * @param {string} message - The chat message
 */
function handleChatMessage(playerId, message) {
  // Get player info
  const player = players.get(playerId);
  if (!player) return;
  
  // Rate limiting - max one message per 2 seconds
  const now = Date.now();
  const timeouts = playerTimeouts.get(playerId);
  if (timeouts) {
    if (!timeouts.lastChat) {
      timeouts.lastChat = 0;
    }
    
    // Rate limiting
    if (now - timeouts.lastChat < 2000) {
      console.log(`Chat rate limited for player ${playerId}`);
      return;
    }
    
    timeouts.lastChat = now;
  }
  
  // Validate and sanitize message
  if (!message || typeof message !== 'string') return;
  
  // Limit message length (chat messages can be longer than usernames)
  if (message.length > 60) {
    message = message.substring(0, 60);
  }
  
  // Sanitize the message
  message = sanitizeText(message);
  
  console.log(`Chat message from ${player.username} (${playerId}): ${message}`);
  
  // Broadcast the message to all players
  broadcastToAll({
    type: 'chatMessage',
    senderId: playerId,
    username: player.username,
    message: message
  });
}

// Handle bot player updates
function handleBotUpdate(data) {
  // This function is deprecated as NPCs are now server-controlled
  console.log("Warning: Client attempted to update bot state. Ignoring as NPCs are now server-controlled.");
}

// Handle bot player removal
function handleBotRemove(data) {
  // This function is deprecated as NPCs are now server-controlled
  console.log("Warning: Client attempted to remove bot. Ignoring as NPCs are now server-controlled.");
}

/**
 * Creates a new NPC with the given properties
 * @param {Object} npcData - NPC configuration data
 * @returns {string} The ID of the created NPC
 */
function createNpc(npcData = {}) {
  const id = `npc_${nextNpcId++}`;
  const defaultPosition = { x: 0, y: 2.72, z: 0 };
  
  // Create NPC data structure
  const npc = {
    id: id,
    username: sanitizeText(npcData.name || 'Town NPC'),
    position: npcData.position ? {...npcData.position} : {...defaultPosition},
    // Always store a deep copy of the spawn position
    originalSpawnPosition: npcData.originalSpawnPosition ? 
      {...npcData.originalSpawnPosition} : 
      (npcData.position ? {...npcData.position} : {...defaultPosition}),
    rotation: npcData.rotation || { y: 0 },
    health: npcData.health || 100,
    isWalking: false,
    isAiming: false,
    isShooting: false,
    isIdle: true,
    walkSpeed: npcData.walkSpeed || 1.5,
    lastUpdateTime: Date.now(),
    lastBroadcastTime: 0,
    
    // Path configuration
    path: npcData.path || {
      points: [
        { x: -5, y: 2.72, z: 0 },
        { x: 5, y: 2.72, z: 0 }
      ],
      currentTarget: 0,
      pauseTime: npcData.pauseTime || 2000,
      lastPauseTime: 0,
      isPaused: false,
      pauseTimer: 0
    }
  };
  
  // Log spawn position for debugging
  console.log(`Creating NPC ${id} at position (${npc.position.x}, ${npc.position.y}, ${npc.position.z})`);
  console.log(`Original spawn position set to (${npc.originalSpawnPosition.x}, ${npc.originalSpawnPosition.y}, ${npc.originalSpawnPosition.z})`);
  
  // Store NPC in the collection
  npcs.set(id, npc);
  
  // Broadcast to all clients that a new NPC has joined
  broadcastToAll({
    type: 'playerJoined',
    id: id,
    username: npc.username,
    position: npc.position,
    rotation: npc.rotation,
    health: npc.health,
    isWalking: npc.isWalking,
    isAiming: npc.isAiming,
    isShooting: npc.isShooting,
    isNpc: true  // Mark as NPC for clients
  });
  
  console.log(`Created server-controlled NPC: ${id} (${npc.username})`);
  return id;
}

/**
 * Update an existing NPC's state
 * @param {string} npcId - The ID of the NPC to update
 * @param {Object} updateData - The data to update
 */
function updateNpc(npcId, updateData) {
  const npc = npcs.get(npcId);
  if (!npc) return;
  
  // Update NPC properties
  Object.keys(updateData).forEach(key => {
    npc[key] = updateData[key];
  });
  
  // Broadcast the update to all clients
  broadcastNpcState(npcId);
}

/**
 * Remove an NPC from the game
 * @param {string} npcId - The ID of the NPC to remove
 */
function removeNpc(npcId) {
  if (!npcs.has(npcId)) return;
  
  // Remove the NPC from our collection
  npcs.delete(npcId);
  
  // Broadcast to all clients that the NPC has left
  broadcastToAll({
    type: 'playerLeft',
    id: npcId
  });
  
  console.log(`Removed server-controlled NPC: ${npcId}`);
}

/**
 * Broadcast an NPC's current state to all clients
 * @param {string} npcId - The ID of the NPC to broadcast
 */
function broadcastNpcState(npcId) {
  const npc = npcs.get(npcId);
  if (!npc) return;
  
  // Only broadcast at a reasonable rate to reduce network traffic
  const currentTime = Date.now();
  if (currentTime - npc.lastBroadcastTime < 100) return;
  npc.lastBroadcastTime = currentTime;
  
  // Create the update data packet
  const updateData = {
    type: 'playerUpdate',
    id: npc.id,
    username: npc.username,
    position: npc.position,
    rotation: npc.rotation,
    health: npc.health,
    isWalking: npc.isWalking,
    isAiming: npc.isAiming,
    isShooting: npc.isShooting,
    isNpc: true  // Mark as NPC
  };
  
  // Broadcast to all clients
  broadcastToAll(updateData);
}

/**
 * Update the walking behavior for an NPC
 * @param {string} npcId - The ID of the NPC to update
 */
function updateNpcWalkingBehavior(npcId) {
  const npc = npcs.get(npcId);
  if (!npc) return;
  
  const currentTime = Date.now();
  const deltaTime = (currentTime - npc.lastUpdateTime) / 1000;
  npc.lastUpdateTime = currentTime;
  
  // Handle paused state
  if (npc.path.isPaused) {
    npc.path.pauseTimer += deltaTime * 1000;
    
    // Resume walking after pause time
    if (npc.path.pauseTimer >= npc.path.pauseTime) {
      npc.path.isPaused = false;
      npc.path.pauseTimer = 0;
      npc.isWalking = true;
      npc.isIdle = false;
    } else {
      // Stay in idle state while paused
      if (!npc.isIdle) {
        npc.isIdle = true;
        npc.isWalking = false;
      }
      return; // Exit early for paused NPCs - preserves initial rotation
    }
  }
  
  // Get current target and position
  const pathPoints = npc.path.points;
  const currentTargetIndex = npc.path.currentTarget;
  const targetPoint = pathPoints[currentTargetIndex];
  
  // Calculate direction and distance to target
  const directionX = targetPoint.x - npc.position.x;
  const directionZ = targetPoint.z - npc.position.z;
  const distanceSquared = directionX * directionX + directionZ * directionZ;
  
  // Check if we've reached the target (within 0.1 units)
  if (distanceSquared < 0.1) {
    // We've reached the target point, move to next one
    npc.path.currentTarget = (currentTargetIndex + 1) % pathPoints.length;
    
    // Pause at the target point before moving to next one
    npc.path.isPaused = true;
    npc.path.pauseTimer = 0;
    npc.path.lastPauseTime = currentTime;
    
    // Update animation state
    npc.isWalking = false;
    npc.isIdle = true;
  } else {
    // Normalize direction
    const distance = Math.sqrt(distanceSquared);
    const normalizedDirX = directionX / distance;
    const normalizedDirZ = directionZ / distance;
    
    // Move towards the target
    const moveSpeed = npc.walkSpeed * deltaTime;
    
    // Calculate new position
    npc.position.x += normalizedDirX * moveSpeed;
    npc.position.z += normalizedDirZ * moveSpeed;
    
    // Calculate rotation to face direction of movement (add Math.PI to face forward)
    npc.rotation.y = Math.atan2(normalizedDirX, normalizedDirZ) + Math.PI;
    
    // Ensure walking animation is playing
    if (!npc.isWalking) {
      npc.isWalking = true;
      npc.isIdle = false;
    }
  }
}

/**
 * Spawn a town NPC with a predefined path
 * @param {string} name - NPC name
 * @returns {string} - The created NPC's ID
 */
function spawnTownNpc(name = "Town Resident") {
  // Create a realistic path around town
  const townPath = [
    { x: -5, y: 2.72, z: -2 },
    { x: -3, y: 2.72, z: -10 },
    { x: 3, y: 2.72, z: -10 },
    { x: 5, y: 2.72, z: -2 },
    { x: 5, y: 2.72, z: 5 },
    { x: 0, y: 2.72, z: 8 },
    { x: -5, y: 2.72, z: 5 }
  ];
  
  // Randomize the starting position along the path
  const randomStart = Math.floor(Math.random() * townPath.length);
  const position = {
    x: townPath[randomStart].x,
    y: townPath[randomStart].y,
    z: townPath[randomStart].z
  };
  
  // Create the path configuration
  const path = {
    points: townPath,
    currentTarget: (randomStart + 1) % townPath.length,
    pauseTime: 2000,
    isPaused: false,
    pauseTimer: 0,
    lastPauseTime: 0
  };
  
  // Create the NPC with slightly randomized walk speed
  const walkSpeed = 1.2 + (Math.random() * 0.6); // 1.2 to 1.8
  
  return createNpc({
    name: name,
    position: position,
    originalSpawnPosition: {...position}, // Explicitly store original spawn position
    walkSpeed: walkSpeed,
    path: path
  });
}

// Setup NPC update interval
const NPC_UPDATE_INTERVAL = 16; // ms (approximately 60 fps)
setInterval(() => {
  // Update all NPCs
  npcs.forEach((npc, npcId) => {
    // If NPC is following a target, update movement to follow the player
    if (npc.isFollowingTarget && npc.targetPlayer && players.has(npc.targetPlayer)) {
      updateNpcFollowBehavior(npcId);
    } 
    // If NPC is returning to spawn
    else if (npc.isReturningToSpawn) {
      updateNpcReturnBehavior(npcId);
    }
    // Normal path following
    else {
      updateNpcWalkingBehavior(npcId);
    }
    
    broadcastNpcState(npcId);
  });
}, NPC_UPDATE_INTERVAL);

/**
 * Convert degrees to radians
 * @param {number} degrees - Angle in degrees
 * @returns {number} The angle in radians
 */
function degToRad(degrees) {
  return degrees * (Math.PI / 180);
}

/**
 * Update the behavior for an NPC that is following and attacking a player
 * @param {string} npcId - The ID of the NPC to update
 */
function updateNpcFollowBehavior(npcId) {
  const npc = npcs.get(npcId);
  if (!npc || !npc.targetPlayer || !players.has(npc.targetPlayer)) return;
  
  const currentTime = Date.now();
  const deltaTime = (currentTime - npc.lastUpdateTime) / 1000;
  npc.lastUpdateTime = currentTime;
  
  // Get target player
  const targetPlayer = players.get(npc.targetPlayer);
  
  // Calculate direction and distance to player
  const directionX = targetPlayer.position.x - npc.position.x;
  const directionZ = targetPlayer.position.z - npc.position.z;
  const distanceSquared = directionX * directionX + directionZ * directionZ;
  
  // Only move if we're not too close to the player (keep some distance for shooting)
  const optimalDistance = 8; // Keep 8 units away for shooting
  
  if (distanceSquared > optimalDistance * optimalDistance) {
    // We're too far, move closer
    // Normalize direction
    const distance = Math.sqrt(distanceSquared);
    const normalizedDirX = directionX / distance;
    const normalizedDirZ = directionZ / distance;
    
    // Move towards the player at increased speed
    const moveSpeed = (npc.walkSpeed * 3.5) * deltaTime;
    
    // Calculate new position
    npc.position.x += normalizedDirX * moveSpeed;
    npc.position.z += normalizedDirZ * moveSpeed;
    
    // Set walking animation
    if (!npc.isWalking) {
      npc.isWalking = true;
      npc.isIdle = false;
    }
  } else if (distanceSquared < (optimalDistance * 0.7) * (optimalDistance * 0.7)) {
    // We're too close, back up a bit
    // Normalize direction (away from player)
    const distance = Math.sqrt(distanceSquared);
    const normalizedDirX = -directionX / distance;
    const normalizedDirZ = -directionZ / distance;
    
    // Back away from the player at increased speed
    const moveSpeed = (npc.walkSpeed * 1.2) * deltaTime;
    
    // Calculate new position
    npc.position.x += normalizedDirX * moveSpeed;
    npc.position.z += normalizedDirZ * moveSpeed;
    
    // Set walking animation
    if (!npc.isWalking) {
      npc.isWalking = true;
      npc.isIdle = false;
    }
  } else {
    // We're at a good distance, just stop moving
    npc.isWalking = false;
    npc.isIdle = true;
  }
  
  // Always face the player
  npc.rotation.y = Math.atan2(directionX, directionZ) + Math.PI;
}

/**
 * Update the behavior for an NPC that is returning to its spawn position
 * @param {string} npcId - The ID of the NPC to update
 */
function updateNpcReturnBehavior(npcId) {
  const npc = npcs.get(npcId);
  if (!npc) return;
  
  const currentTime = Date.now();
  const deltaTime = (currentTime - npc.lastUpdateTime) / 1000;
  npc.lastUpdateTime = currentTime;
  
  // Get spawn position (either stored value or first point in path)
  const spawnPosition = npc.originalSpawnPosition || 
    (npc.path && npc.path.points && npc.path.points.length > 0 ? npc.path.points[0] : npc.position);
  
  // Calculate direction and distance to spawn
  const directionX = spawnPosition.x - npc.position.x;
  const directionZ = spawnPosition.z - npc.position.z;
  const distanceSquared = directionX * directionX + directionZ * directionZ;
  
  // Check if we've reached the spawn point (within 0.5 units)
  if (distanceSquared < 0.5) {
    // We've reached the spawn, resume normal path behavior
    npc.isReturningToSpawn = false;
    npc.isWalking = false;
    npc.isIdle = true;
    
    // Reset to the first point in the path
    if (npc.path && npc.path.points && npc.path.points.length > 0) {
      npc.path.currentTarget = 0;
      npc.path.isPaused = true;
      npc.path.pauseTimer = 0;
    }
    
    // Restore original rotation if available
    if (npc.originalRotation) {
      npc.rotation = {...npc.originalRotation};
      console.log(`NPC ${npcId} restored original rotation: y=${npc.rotation.y}`);
      npc.originalRotation = null;
    }
    
    console.log(`NPC ${npcId} (${npc.username}) reached spawn position`);
  } else {
    // Still need to move towards spawn
    // Normalize direction
    const distance = Math.sqrt(distanceSquared);
    const normalizedDirX = directionX / distance;
    const normalizedDirZ = directionZ / distance;
    
    // Move towards the spawn at increased speed
    const moveSpeed = (npc.walkSpeed * 1.5) * deltaTime;
    
    // Calculate new position
    npc.position.x += normalizedDirX * moveSpeed;
    npc.position.z += normalizedDirZ * moveSpeed;
    
    // Calculate rotation to face direction of movement
    npc.rotation.y = Math.atan2(normalizedDirX, normalizedDirZ) + Math.PI;
    
    // Set walking animation
    if (!npc.isWalking) {
      npc.isWalking = true;
      npc.isIdle = false;
    }
  }
}

/**
 * Handle NPC fighting back when attacked
 * @param {string} npcId - The ID of the NPC that was attacked
 * @param {string} attackerId - The ID of the player who attacked the NPC
 */
function handleNpcAttacked(npcId, attackerId) {
  const npc = npcs.get(npcId);
  const attacker = players.get(attackerId);
  
  if (!npc || !attacker) return;
  
  // Check if NPC is already targeting a different player
  if (npc.targetPlayer && npc.targetPlayer !== attackerId) {
    console.log(`NPC ${npcId} (${npc.username}) switching target from ${npc.targetPlayer} to ${attackerId}`);
    npc.targetPlayer = attackerId;
  }
  // Start fighting the attacker if not already fighting
  else if (!npc.targetPlayer) {
    console.log(`NPC ${npcId} (${npc.username}) is now fighting player ${attackerId}`);
    
    // Set the attacker as target
    npc.targetPlayer = attackerId;
    npc.lastShotTime = 0;
    
    // Start aiming at player
    npc.isAiming = true;
    
    // Store original path and rotation to restore when combat ends
    npc.originalPath = JSON.parse(JSON.stringify(npc.path));
    npc.originalRotation = {...npc.rotation}; // Store original rotation
    
    // Set NPC to follow mode instead of path following
    npc.isFollowingTarget = true;
    npc.isWalking = true;
    npc.isIdle = false;
    
    // Broadcast NPC state update to show it's now aiming
    broadcastNpcState(npcId);
    
    // Start shooting interval (store it in the NPC object)
    npc.shootIntervalId = setInterval(() => {
      // Check if NPC still exists and is targeting someone
      if (!npcs.has(npcId) || !npc.targetPlayer) {
        if (npc.shootIntervalId) {
          clearInterval(npc.shootIntervalId);
          npc.shootIntervalId = null;
        }
        return;
      }
      
      // Check if target player still exists
      if (!players.has(npc.targetPlayer)) {
        // Target player left, stop fighting
        npc.targetPlayer = null;
        npc.isAiming = false;
        npc.isShooting = false;
        npc.isFollowingTarget = false;
        
        // Restore original path
        if (npc.originalPath) {
          npc.path = npc.originalPath;
          npc.originalPath = null;
        }
        
        // Make NPC return to spawn position with original rotation
        makeNpcReturnToSpawn(npcId);
        
        if (npc.shootIntervalId) {
          clearInterval(npc.shootIntervalId);
          npc.shootIntervalId = null;
        }
        return;
      }
      
      // Shoot at player once per second
      const now = Date.now();
      if (now - npc.lastShotTime >= 1000) {
        npcShootAtPlayer(npcId, npc.targetPlayer);
        npc.lastShotTime = now;
      }
    }, 100); // Check interval faster than shooting rate for responsiveness
  }
}

/**
 * Make an NPC shoot at a player
 * @param {string} npcId - The ID of the NPC
 * @param {string} targetPlayerId - The ID of the target player
 */
function npcShootAtPlayer(npcId, targetPlayerId) {
  const npc = npcs.get(npcId);
  const targetPlayer = players.get(targetPlayerId);
  
  if (!npc || !targetPlayer) return;
  
  // Calculate direction from NPC to player
  const dirX = targetPlayer.position.x - npc.position.x;
  const dirY = targetPlayer.position.y - npc.position.y + 0.5; // Aim for upper body
  const dirZ = targetPlayer.position.z - npc.position.z;
  
  // Normalize direction
  const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
  const normalizedDir = {
    x: dirX / length,
    y: dirY / length,
    z: dirZ / length
  };
  
  // Update NPC rotation to face the player
  npc.rotation.y = Math.atan2(normalizedDir.x, normalizedDir.z) + Math.PI;
  
  // Set NPC as shooting for animation
  npc.isShooting = true;
  broadcastNpcState(npcId);
  
  // Create bullet data for visual effects
  const bulletPosition = {
    x: npc.position.x,
    y: npc.position.y - 1, // Lower gun height
    z: npc.position.z
  };
  
  // Create a server-side bullet
  const bulletId = nextBulletId++;
  const now = Date.now();
  
  const bullet = {
    id: bulletId,
    sourcePlayerId: npcId,  // Use NPC ID as source
    position: bulletPosition,
    direction: normalizedDir,
    distanceTraveled: 0,
    maxDistance: GAME_CONSTANTS.MAX_BULLET_DISTANCE,
    speed: GAME_CONSTANTS.BULLET_SPEED,
    timeCreated: now,
    active: true
  };
  
  // Add to active bullets
  activeBullets.set(bulletId, bullet);
  
  // Broadcast gunshot to all clients for visual and audio effects
  broadcastToAll({
    type: 'playerShoot', // Match the player shoot event type exactly
    id: npcId,
    bulletId: bulletId,
    bulletData: {
      position: bulletPosition,
      direction: normalizedDir
    },
    isNpc: true
  });
  
  // Wait for animation to play, then reset
  setTimeout(() => {
    if (npcs.has(npcId)) {
      npc.isShooting = false;
      broadcastNpcState(npcId);
    }
  }, 300);
  
  // Determine if hit (50% chance for body shot)
  const hitChance = 0.5;
  const hit = Math.random() < hitChance;
  
  if (hit) {
    // Create hit data
    const hitData = {
      hitZone: 'body',
      position: { 
        x: targetPlayer.position.x,
        y: targetPlayer.position.y,
        z: targetPlayer.position.z
      }
    };
    
    // Apply damage to player (40 damage for body shot)
    targetPlayer.health = Math.max(0, targetPlayer.health - 40);
    
    // Notify player of hit
    if (targetPlayer.ws && targetPlayer.ws.readyState === WebSocket.OPEN) {
      targetPlayer.ws.send(JSON.stringify({
        type: 'hit',
        sourceId: npcId,
        hitData: {
          position: hitData.position,
          hitZone: 'body',
          damage: 40 // Explicitly include damage value
        },
        hitZone: 'body',
        health: targetPlayer.health,
        isNpc: true,
        damage: 40 // Include damage at top level for backwards compatibility
      }));
    }
    
    // Broadcast hit to all players for visual effects
    broadcastToAll({
      type: 'playerHit',
      targetId: targetPlayerId,
      sourceId: npcId,
      hitPosition: hitData.position,
      health: targetPlayer.health,
      hitZone: 'body',
      damage: 40,
      isNpc: true
    });
    
    // Check if player died
    if (targetPlayer.health <= 0) {
      handlePlayerDeath(targetPlayerId, npcId);
      
      // NPC no longer has a target
      npc.targetPlayer = null;
      npc.isAiming = false;
      
      // Set NPC to return to original spawn position
      makeNpcReturnToSpawn(npcId);
    }
  }
}

/**
 * Make an NPC return to its original spawn position
 * @param {string} npcId - The ID of the NPC
 */
function makeNpcReturnToSpawn(npcId) {
  const npc = npcs.get(npcId);
  if (!npc) return;
  
  console.log(`NPC ${npcId} (${npc.username}) returning to spawn position`);
  
  // Clear any existing combat state
  npc.targetPlayer = null;
  npc.isAiming = false;
  npc.isShooting = false;
  
  // Set flag for returning mode
  npc.isReturningToSpawn = true;
  npc.isFollowingTarget = false;
  npc.isWalking = true;
  npc.isIdle = false;
  
  // Restore original path for when we get back to spawn
  if (npc.originalPath) {
    npc.path = JSON.parse(JSON.stringify(npc.originalPath));
    npc.originalPath = null;
  }
  
  // Broadcast state update
  broadcastNpcState(npcId);
}

/**
 * Handle NPC death
 * @param {string} npcId - The ID of the NPC that died
 * @param {string} killedById - The ID of the player who killed the NPC
 */
function handleNpcDeath(npcId, killedById) {
  const npc = npcs.get(npcId);
  if (!npc) return;
  
  console.log(`NPC ${npcId} (${npc.username}) was killed by player ${killedById}`);
  
  // Clean up any shooting interval
  if (npc.shootIntervalId) {
    clearInterval(npc.shootIntervalId);
    npc.shootIntervalId = null;
  }
  
  // Ensure we have the original spawn position
  // First check explicitly stored original position
  let spawnPosition;
  
  if (npc.originalSpawnPosition) {
    spawnPosition = {...npc.originalSpawnPosition};
    console.log(`Using stored originalSpawnPosition: (${spawnPosition.x}, ${spawnPosition.y}, ${spawnPosition.z})`);
  } 
  // If not available, check the first point in the original path
  else if (npc.originalPath && npc.originalPath.points && npc.originalPath.points.length > 0) {
    spawnPosition = {...npc.originalPath.points[0]};
    console.log(`Using first point from originalPath: (${spawnPosition.x}, ${spawnPosition.y}, ${spawnPosition.z})`);
  } 
  // As a last resort, use the first point in the current path
  else if (npc.path && npc.path.points && npc.path.points.length > 0) {
    spawnPosition = {...npc.path.points[0]};
    console.log(`Using first point from current path: (${spawnPosition.x}, ${spawnPosition.y}, ${spawnPosition.z})`);
  } 
  // If all else fails, use current position (shouldn't happen)
  else {
    spawnPosition = {...npc.position};
    console.log(`FALLBACK: Using current position: (${spawnPosition.x}, ${spawnPosition.y}, ${spawnPosition.z})`);
  }
  
  // Get original rotation
  let originalRotation;
  
  if (npc.originalRotation) {
    originalRotation = {...npc.originalRotation};
    console.log(`Using stored originalRotation: y=${originalRotation.y}`);
  } else {
    originalRotation = {...npc.rotation};
    console.log(`Using current rotation: y=${originalRotation.y}`);
  }
  
  // Store NPC data for respawning
  const npcData = {
    name: npc.username,
    // Explicitly set both position and originalSpawnPosition
    position: spawnPosition,
    originalSpawnPosition: spawnPosition,
    rotation: originalRotation,
    originalRotation: originalRotation,
    walkSpeed: npc.walkSpeed,
    // If we have an original path, use that instead of the current path
    path: npc.originalPath ? JSON.parse(JSON.stringify(npc.originalPath)) : JSON.parse(JSON.stringify(npc.path))
  };
  
  console.log(`NPC will respawn at position: (${spawnPosition.x}, ${spawnPosition.y}, ${spawnPosition.z}) with rotation y=${originalRotation.y}`);
  
  // Send death notification to all clients
  broadcastToAll({
    type: 'playerDeath',
    id: npcId,
    killedById: killedById,
    isNpc: true
  });
  
  // Send kill notification to the killer
  const killer = players.get(killedById);
  if (killer && killer.ws && killer.ws.readyState === WebSocket.OPEN) {
    killer.ws.send(JSON.stringify({
      type: 'kill',
      targetId: npcId,
      isNpc: true
    }));
  }
  
  // Remove the NPC temporarily
  removeNpc(npcId);
  
  // Respawn the NPC after a delay
  setTimeout(() => {
    const newNpcId = createNpc(npcData);
    console.log(`NPC ${npcId} respawned as ${newNpcId} at position (${npcData.position.x}, ${npcData.position.y}, ${npcData.position.z}) with rotation y=${npcData.rotation.y}`);
  }, 5000); // 5 second respawn delay
}

// Spawn initial NPCs when server starts
setTimeout(() => {
  try {
    // Create the sheriff with static position (standing still)
    const sheriffPosition = { x: 14, y: 2.73, z: 20 }; // Position sheriff somewhere in town
    createNpc({
      name: "Sheriff",
      position: sheriffPosition,
      originalSpawnPosition: {...sheriffPosition},
      rotation: { y: degToRad(90) }, // Facing east (90 degrees)
      path: {
        points: [sheriffPosition], // Single point path = standing still
        currentTarget: 0,
        pauseTime: 1000000, // Very long pause time to keep idle
        isPaused: true, // Start in paused mode
        pauseTimer: 0,
        lastPauseTime: 0
      }
    });
    
    // Create the bartender with static position (standing still)
    const bartenderPosition = { x: -33, y: 2.92, z: 15 }; // Position bartender in middle of town
    createNpc({
      name: "Bartender",
      position: bartenderPosition,
      originalSpawnPosition: {...bartenderPosition},
      rotation: { y: degToRad(270) }, // Facing south (180 degrees)
      path: {
        points: [bartenderPosition], // Single point path = standing still
        currentTarget: 0,
        pauseTime: 1000000, // Very long pause time to keep idle
        isPaused: true, // Start in paused mode
        pauseTimer: 0,
        lastPauseTime: 0
      }
    });
    
    // Create "notabot" NPC with path along the length of the town (rotated 90°)
    const fixedX = -15; // Center X position in town
    const startZ = -40; // North end of town
    const endZ = 40; // South end of town
    const notabotY = 2.72; // Standard ground level
    const notabotStartPosition = { x: fixedX, y: notabotY, z: startZ };

    createNpc({
      name: "notabot",
      position: notabotStartPosition,
      originalSpawnPosition: {...notabotStartPosition},
      rotation: { y: degToRad(0) }, // Initially facing south (along Z axis)
      walkSpeed: 1.4, // Moderate walking speed
      path: {
        points: [
          { x: fixedX, y: notabotY, z: startZ },
          { x: fixedX, y: notabotY, z: endZ },
          { x: fixedX, y: notabotY, z: startZ } // Loop back to start
        ],
        currentTarget: 1, // Start by walking south
        pauseTime: 500, // Very short pause at endpoints
        isPaused: false,
        pauseTimer: 0,
        lastPauseTime: 0
      }
    });
    
    // Cowboy has been removed per request
    
    console.log("Initial NPCs spawned");
  } catch (error) {
    console.error("Failed to spawn initial NPCs:", error);
  }
}, 5000); // Wait for server to fully initialize

// =============================================
// Train System - Server Side Implementation
// =============================================

// Train variables
const TRAIN_SPEED = 0.0003; // Same speed as client to maintain consistency
const TRAIN_TRACK_START = { x: 0, y: 0, z: -1000 };
const TRAIN_TRACK_END = { x: 0, y: 0, z: 1000 };
const TRAIN_TRACK_LENGTH = 2000; // Total length between start and end
const TRAIN_CYCLE_TIME = Math.floor(TRAIN_TRACK_LENGTH / (TRAIN_SPEED * 60)); // Time in ms for a full one-way trip

// Time-based tracking
const TRAIN_START_TIME = Date.now(); // Global reference time when train started
let trainDirection = 1; // Current direction (1 = forward, -1 = backward)

// Send train updates every 2 seconds
const TRAIN_BROADCAST_INTERVAL = 2000;
setInterval(() => {
  broadcastTrainState();
}, TRAIN_BROADCAST_INTERVAL);

/**
 * Get current train direction based on elapsed time
 * @returns {number} 1 for forward, -1 for backward
 */
function getCurrentTrainDirection() {
  const elapsedTime = Date.now() - TRAIN_START_TIME;
  const cycleCount = Math.floor(elapsedTime / TRAIN_CYCLE_TIME);
  // Direction changes every cycle
  return cycleCount % 2 === 0 ? 1 : -1;
}

/**
 * Calculate train progress (0-1) based on elapsed time
 * @returns {number} Progress value between 0-1
 */
function calculateTrainProgress() {
  const elapsedTime = Date.now() - TRAIN_START_TIME;
  const cycleCount = Math.floor(elapsedTime / TRAIN_CYCLE_TIME);
  const timeInCurrentCycle = elapsedTime % TRAIN_CYCLE_TIME;
  
  // Calculate progress within current cycle (0-1)
  const cycleProgress = timeInCurrentCycle / TRAIN_CYCLE_TIME;
  
  // If even cycle, progress from 0 to 1 (forward)
  // If odd cycle, progress from 1 to 0 (backward)
  return cycleCount % 2 === 0 ? cycleProgress : 1 - cycleProgress;
}

/**
 * Broadcasts the current train state to all connected clients
 */
function broadcastTrainState() {
  // Only broadcast if there are connected players
  if (players.size === 0) return;
  
  // Get current values
  const progress = calculateTrainProgress();
  const direction = getCurrentTrainDirection();
  
  const trainState = {
    type: 'trainState',
    startTime: TRAIN_START_TIME,
    cycleTime: TRAIN_CYCLE_TIME,
    speed: TRAIN_SPEED,
    trackLength: TRAIN_TRACK_LENGTH,
    timestamp: Date.now(),
    // Include current values for debugging
    progress,
    direction
  };
  
  console.log(`Broadcasting train state: startTime=${TRAIN_START_TIME}, progress=${progress.toFixed(4)}, direction=${direction}`);
  broadcastToAll(trainState);
}

/**
 * Sends initial train state when a player connects
 * @param {WebSocket} ws - Player's WebSocket connection
 */
function sendInitialTrainState(ws) {
  if (ws.readyState === WebSocket.OPEN) {
    // Get current values
    const progress = calculateTrainProgress();
    const direction = getCurrentTrainDirection();
    
    const trainStateMsg = {
      type: 'trainInit',
      startTime: TRAIN_START_TIME,
      cycleTime: TRAIN_CYCLE_TIME,
      speed: TRAIN_SPEED,
      trackLength: TRAIN_TRACK_LENGTH,
      trackStart: TRAIN_TRACK_START,
      trackEnd: TRAIN_TRACK_END,
      timestamp: Date.now(),
      // Include current values for debugging
      progress,
      direction
    };
    
    console.log(`Sending initial train state: startTime=${TRAIN_START_TIME}, progress=${progress.toFixed(4)}, direction=${direction}`);
    ws.send(JSON.stringify(trainStateMsg));
  }
}
    </codebase>
</context>

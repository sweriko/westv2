<goal>
 
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── config.yml
    ├── package.json
    ├── public/
    │   ├── css/
    │   │   └── style.css
    │   ├── index.html
    │   ├── js/
    │   │   ├── bullet.js
    │   │   ├── effects.js
    │   │   ├── input.js
    │   │   ├── main.js
    │   │   ├── multiplayerManager.js
    │   │   ├── network.js
    │   │   ├── player.js
    │   │   ├── playerModel.js
    │   │   ├── revolver.js
    │   │   ├── scene.js
    │   │   ├── soundManager.js
    │   │   └── ui.js
    │   ├── models/
    │   │   └── lowpolygun.glb
    │   └── sounds/
    └── server.js

================================================
File: /config.yml
================================================
version: "3"
credentials-file: "C:\\Users\\erase\\.cloudflared\\5615d921-4c2e-4d70-affd-8696de48a673.json"

ingress:
  # This rule forwards all requests from the tunnel hostname to the local Express server.
  - hostname: tunnel.oneclickwaitlist.com
    path: /
    service: http://localhost:8080
    originRequest:
      connectTimeout: 10s
      noTLSVerify: true
      proxyAddress: ""
      proxyPort: 0
      proxyType: ""
      kernelSocketOptions:
        - mark: 0
        - keepalive: true
      wsTunneling: true
      http2Origin: false
      httpHostHeader: "tunnel.oneclickwaitlist.com"
      disableChunkedEncoding: false

  # Fallback rule: returns 503 if no other rule matches.
  - service: http_status:503

origincert: "C:\\Users\\erase\\.cloudflared\\cert.pem"


================================================
File: /package.json
================================================
{
  "name": "wild-western-shooter",
  "version": "1.0.0",
  "description": "A Three.js Wild Western Shooter game with a Node.js server.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.13.0",
    "ngrok": "^4.3.3"
  }
}


================================================
File: /public/css/style.css
================================================
body {
  margin: 0;
  overflow: hidden;
  font-family: 'Courier New', Courier, monospace;
}
#game-container {
  position: relative;
  width: 100vw;
  height: 100vh;
}
#ammo-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
}
#reload-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  display: none;
}
#reload-progress-container {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-progress-bar {
  height: 100%;
  width: 0%;
  background-color: #FF6B00;
  border-radius: 10px;
  transition: width 0.05s linear;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border: 2px solid white;
  border-radius: 50%;
  display: none;
}
#crosshair::before,
#crosshair::after {
  content: '';
  position: absolute;
  background-color: white;
}
#crosshair::before {
  width: 2px;
  height: 10px;
  top: 5px;
  left: 9px;
}
#crosshair::after {
  width: 10px;
  height: 2px;
  top: 9px;
  left: 5px;
}
#fps-counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#player-count {
  position: absolute;
  top: 50px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#connection-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#network-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
  transition: opacity 1s;
}

================================================
File: /public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wild Western FPS – Multiplayer</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div id="game-container">
    <div id="ammo-counter">Bullets: 6/6</div>
    <div id="health-counter">Health: 100</div>
    <div id="reload-message">Hold R to reload</div>
    <div id="reload-progress-container">
      <div id="reload-progress-bar"></div>
    </div>
    <div id="crosshair"></div>
    <div id="fps-counter">FPS: 0</div>
    <div id="player-count">Players: 1</div>
    <div id="connection-status"></div>
  </div>

  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader for loading the GLB gun model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Main JS as ES6 module -->
  <script type="module" src="js/main.js"></script>
</body>
</html>


================================================
File: /public/js/bullet.js
================================================
import { createImpactEffect } from './effects.js';

/**
 * A simple bullet that checks collisions by seeing if its end position
 * is inside bounding boxes (NPC or players).
 */
export class Bullet {
  constructor(position, direction) {
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xB8860B })
    );
    this.mesh.position.copy(position);

    this.direction = direction.clone();
    this.speed = 80; // speed units/second
    this.distanceTraveled = 0;
    this.maxDistance = 100;

    // Remember previous position for some rough continuous detection
    this.lastPosition = position.clone();

    // Track which player fired this bullet
    this.sourcePlayerId = null;
  }

  /**
   * Sets the player ID that fired this bullet.
   * @param {string|number} playerId - The ID of the player who fired the bullet.
   */
  setSourcePlayer(playerId) {
    this.sourcePlayerId = playerId;
  }

  /**
   * Updates the bullet's movement & handles collisions with NPC or players.
   * Uses a simpler .containsPoint() approach so it won't throw an error on r128.
   * @param {number} deltaTime
   * @param {THREE.Group} npc
   * @param {THREE.Scene} scene
   * @param {Map<number, object>} allPlayers - Map of local + remote players.
   */
  update(deltaTime, npc, scene, allPlayers) {
    // Move the bullet
    const displacement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
    this.mesh.position.add(displacement);
    this.distanceTraveled += displacement.length();

    // Current bullet position
    const endPos = this.mesh.position.clone();

    // 1) Check collision with NPC
    if (npc) {
      const npcBox = new THREE.Box3().setFromObject(npc);
      npcBox.expandByScalar(0.2);
      if (npcBox.containsPoint(endPos)) {
        createImpactEffect(endPos, this.direction, scene, 'npc');
        return { active: false, hit: { type: 'npc', target: npc } };
      }
    }

    // 2) Check collision with players
    if (allPlayers) {
      for (const [playerId, playerObj] of allPlayers.entries()) {
        // Skip bullet’s owner by converting both IDs to numbers
        if (Number(playerId) === Number(this.sourcePlayerId)) continue;
        if (!playerObj || !playerObj.group) continue;

        // Get player's base position for collision box.
        // For local players (first-person), group.position is at eye-level so subtract 1.6.
        // Remote players (third-person) have group.position at the base.
        const playerPos = playerObj.group.position.clone();
        let baseY = playerPos.y;
        if (playerObj.camera) { // local player
          baseY = playerPos.y - 1.6;
        }
        const boxMin = new THREE.Vector3(
          playerPos.x - 0.5,
          baseY,
          playerPos.z - 0.5
        );
        const boxMax = new THREE.Vector3(
          playerPos.x + 0.5,
          baseY + 2.0,
          playerPos.z + 0.5
        );
        const playerBox = new THREE.Box3(boxMin, boxMax);
        if (playerBox.containsPoint(endPos)) {
          createImpactEffect(endPos, this.direction, scene, 'player');
          // Notify server we hit this player
          if (window.networkManager) {
            window.networkManager.sendPlayerHit(playerId, {
              position: { x: endPos.x, y: endPos.y, z: endPos.z },
              sourcePlayerId: this.sourcePlayerId
            });
          }
          return { active: false, hit: { type: 'player', playerId } };
        }
      }
    }

    // 3) Check collision with ground
    if (this.mesh.position.y <= 0.1) {
      createImpactEffect(endPos, this.direction, scene, 'ground');
      return { active: false, hit: { type: 'ground', position: endPos } };
    }

    // 4) If bullet exceeded max distance, remove it.
    if (this.distanceTraveled >= this.maxDistance) {
      return { active: false, hit: null };
    }

    // Still active
    return { active: true, hit: null };
  }
}


================================================
File: /public/js/effects.js
================================================
/**
 * Recursively disposes geometry and material for the given object.
 * @param {THREE.Object3D} object - The object to dispose.
 */
function disposeHierarchy(object) {
  object.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

/**
 * Helper for spring interpolation used in recoil recovery.
 * @param {number} start - The starting value.
 * @param {number} end - The target value.
 * @param {number} t - Normalized time.
 * @param {number} damping - Damping coefficient.
 * @param {number} frequency - Oscillation frequency.
 * @returns {number} - The interpolated value.
 */
function springInterpolation(start, end, t, damping, frequency) {
  const decay = Math.exp(-damping * t);
  return end + (start - end) * decay * (1 + (damping / frequency) * Math.sin(frequency * t));
}

/**
 * Creates a muzzle flash effect at the given position.
 * @param {THREE.Vector3} position - Effect position.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createMuzzleFlash(position, scene) {
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(position);
  scene.add(flashGroup);

  const coreGeometry = new THREE.SphereGeometry(0.05, 8, 8);
  const coreMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 1
  });
  const core = new THREE.Mesh(coreGeometry, coreMaterial);
  flashGroup.add(core);

  const middleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
  const middleMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFF00,
    transparent: true,
    opacity: 0.8
  });
  const middle = new THREE.Mesh(middleGeometry, middleMaterial);
  middle.scale.x = 1.5;
  flashGroup.add(middle);

  const outerGeometry = new THREE.SphereGeometry(0.12, 8, 8);
  const outerMaterial = new THREE.MeshBasicMaterial({
    color: 0xFF6B00,
    transparent: true,
    opacity: 0.5
  });
  const outer = new THREE.Mesh(outerGeometry, outerMaterial);
  outer.scale.x = 2;
  flashGroup.add(outer);

  const particleCount = 8;
  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFF00,
      transparent: true,
      opacity: 0.7
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    const angle = Math.random() * Math.PI * 2;
    const radius = 0.05 + Math.random() * 0.1;
    particle.position.set(
      Math.cos(angle) * radius,
      Math.sin(angle) * radius,
      (Math.random() - 0.5) * 0.1
    );
    flashGroup.add(particle);
  }

  const flashLight = new THREE.PointLight(0xFF9900, 1, 2);
  flashLight.position.set(0, 0, 0);
  flashGroup.add(flashLight);

  const duration = 100;
  const startTime = performance.now();

  function animateFlash(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      core.scale.multiplyScalar(0.95);
      const fadeOpacity = 1 - progress;
      coreMaterial.opacity = fadeOpacity;
      middleMaterial.opacity = fadeOpacity * 0.8;
      outerMaterial.opacity = fadeOpacity * 0.5;
      flashLight.intensity = 1 - progress;
      requestAnimationFrame(animateFlash);
    } else {
      scene.remove(flashGroup);
      disposeHierarchy(flashGroup);
    }
  }
  requestAnimationFrame(animateFlash);
}

/**
 * Creates a smoke effect emanating from a given position.
 * @param {THREE.Vector3} position - Start position.
 * @param {THREE.Vector3} direction - Direction of smoke.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createSmokeEffect(position, direction, scene) {
  const particleCount = 30;
  const particles = [];
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(position);
  scene.add(smokeGroup);

  const smokeColors = [
    new THREE.Color(0.9, 0.9, 0.9),
    new THREE.Color(0.8, 0.8, 0.8),
    new THREE.Color(0.7, 0.7, 0.7),
    new THREE.Color(0.6, 0.6, 0.6)
  ];

  for (let i = 0; i < particleCount; i++) {
    const size = 0.01 + Math.random() * 0.03;
    const smokeGeometry = new THREE.SphereGeometry(size, 6, 6);
    const colorIndex = Math.floor(Math.random() * smokeColors.length);
    const smokeColor = smokeColors[colorIndex];
    const smokeMaterial = new THREE.MeshBasicMaterial({
      color: smokeColor,
      transparent: true,
      opacity: 0.3 + Math.random() * 0.4
    });
    const smokeParticle = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smokeParticle.position.set(
      (Math.random() - 0.5) * 0.05,
      (Math.random() - 0.5) * 0.05,
      (Math.random() - 0.5) * 0.05
    );
    let particleDir = direction.clone();
    particleDir.x += (Math.random() - 0.5) * 0.6;
    particleDir.y += (Math.random() - 0.5) * 0.2 + 0.2;
    particleDir.z += (Math.random() - 0.5) * 0.6;
    particleDir.normalize();
    const speed = 0.02 + Math.random() * 0.08;
    const velocity = particleDir.multiplyScalar(speed);
    const rotationSpeed = {
      x: (Math.random() - 0.5) * 0.02,
      y: (Math.random() - 0.5) * 0.02,
      z: (Math.random() - 0.5) * 0.02
    };
    smokeGroup.add(smokeParticle);
    particles.push({
      mesh: smokeParticle,
      velocity: velocity,
      rotationSpeed: rotationSpeed,
      life: 40 + Math.floor(Math.random() * 60),
      maxLife: 40 + Math.floor(Math.random() * 60),
      size: size,
      growth: 0.005 + Math.random() * 0.01
    });
  }

  const interval = setInterval(() => {
    let allDead = true;
    particles.forEach(p => {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.velocity.multiplyScalar(0.98);
        p.velocity.x += (Math.random() - 0.5) * 0.001;
        p.velocity.z += (Math.random() - 0.5) * 0.001;
        p.velocity.y += 0.0008;
        p.mesh.rotation.x += p.rotationSpeed.x;
        p.mesh.rotation.y += p.rotationSpeed.y;
        p.mesh.rotation.z += p.rotationSpeed.z;
        const scale = p.size + (p.growth * (p.maxLife - p.life));
        p.mesh.scale.set(scale, scale, scale);
        const lifeRatio = p.life / p.maxLife;
        p.mesh.material.opacity = lifeRatio * 0.5;
        p.life--;
        allDead = false;
      } else {
        smokeGroup.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      }
    });
    if (allDead) {
      clearInterval(interval);
      scene.remove(smokeGroup);
    }
  }, 16);
}

/**
 * Creates a shockwave ring effect in the shooting direction.
 * @param {THREE.Vector3} position - Effect start position.
 * @param {THREE.Vector3} direction - Firing direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createShockwaveRing(position, direction, scene) {
  const shockwaveGroup = new THREE.Group();
  shockwaveGroup.position.copy(position);
  shockwaveGroup.lookAt(position.clone().add(direction));
  scene.add(shockwaveGroup);

  const distortionGeometry = new THREE.CircleGeometry(0.08, 32);
  const distortionMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 0.2,
    blending: THREE.AdditiveBlending
  });
  const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
  shockwaveGroup.add(distortion);

  const lineCount = 18;
  const speedLines = [];
  const speedLineColors = [0xFFFFFF, 0xFFFF00, 0xFF9900, 0xFF6600];

  for (let i = 0; i < lineCount; i++) {
    const lineLength = 0.2 + Math.random() * 0.6;
    const lineWidth = 0.003 + Math.random() * 0.005;
    const lineGeometry = new THREE.BoxGeometry(lineWidth, lineWidth, lineLength);
    lineGeometry.translate(0, 0, lineLength / 2);
    const colorIndex = Math.floor(Math.random() * speedLineColors.length);
    const lineColor = speedLineColors[colorIndex];
    const lineMaterial = new THREE.MeshBasicMaterial({
      color: lineColor,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending
    });
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    const spreadAngle = 15 * (Math.PI / 180);
    line.rotation.x = (Math.random() - 0.5) * spreadAngle;
    line.rotation.y = (Math.random() - 0.5) * spreadAngle;
    line.scale.z = 0.1;
    shockwaveGroup.add(line);
    speedLines.push({
      mesh: line,
      material: lineMaterial,
      maxLength: 1 + Math.random() * 2,
      speed: 0.8 + Math.random() * 0.4,
      delay: Math.random() * 50
    });
  }

  const particleCount = 12;
  const particles = [];

  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFF00,
      transparent: true,
      opacity: 0.6
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    const angle = Math.random() * Math.PI * 0.25;
    const radius = 0.02 + Math.random() * 0.06;
    particle.position.z = Math.cos(angle) * radius;
    const circleAngle = Math.random() * Math.PI * 2;
    particle.position.x = Math.sin(angle) * Math.cos(circleAngle) * radius;
    particle.position.y = Math.sin(angle) * Math.sin(circleAngle) * radius;
    const velocity = new THREE.Vector3(
      particle.position.x * (0.5 + Math.random() * 0.5),
      particle.position.y * (0.5 + Math.random() * 0.5),
      0.05 + Math.random() * 0.1
    );
    shockwaveGroup.add(particle);
    particles.push({
      mesh: particle,
      velocity: velocity,
      life: 10 + Math.floor(Math.random() * 15)
    });
  }

  const flashLight = new THREE.PointLight(0xFF9900, 1, 2);
  flashLight.position.set(0, 0, 0);
  shockwaveGroup.add(flashLight);

  const duration = 350;
  const startTime = performance.now();

  function animateShockwave(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      speedLines.forEach(line => {
        if (elapsed > line.delay) {
          const lineProgress = Math.min((elapsed - line.delay) / (duration - line.delay), 1);
          if (lineProgress < 0.5) {
            const scaleProgress = lineProgress * 2;
            line.mesh.scale.z = line.maxLength * scaleProgress;
          } else {
            line.material.opacity = 0.7 * (1 - ((lineProgress - 0.5) * 2));
          }
        }
      });
      const distortionScale = 1 + progress * 5;
      distortion.scale.set(distortionScale, distortionScale, 1);
      distortionMaterial.opacity = 0.2 * (1 - progress);

      particles.forEach(p => {
        if (p.life > 0) {
          p.mesh.position.add(p.velocity);
          p.mesh.material.opacity = (p.life / 25) * 0.6;
          p.life--;
        } else {
          shockwaveGroup.remove(p.mesh);
        }
      });

      flashLight.intensity = 1 - progress;
      requestAnimationFrame(animateShockwave);
    } else {
      scene.remove(shockwaveGroup);
      disposeHierarchy(shockwaveGroup);
    }
  }
  requestAnimationFrame(animateShockwave);
}

/**
 * Creates an impact effect when a bullet hits a target.
 * Instead of a red disk, this new effect emits particles in the opposite direction
 * of the bullet's travel. When the bullet hits a body (player or NPC), the particles
 * are red (blood). When it hits the ground/solid, the particles are brown (splatter).
 *
 * The particle velocities have been reduced so that they stay near the impact point.
 *
 * @param {THREE.Vector3} position - Impact position.
 * @param {THREE.Vector3} direction - Impact (bullet) direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 * @param {string} hitType - Type of impact: 'player', 'npc', or 'ground'.
 */
export function createImpactEffect(position, direction, scene, hitType) {
  const effectGroup = new THREE.Group();
  effectGroup.position.copy(position);
  scene.add(effectGroup);

  // Choose color: red for body impacts, brown for ground.
  const color = (hitType === 'ground') ? 0x8B4513 : 0xFF0000;

  const particleCount = 15;
  const particles = [];
  for (let i = 0; i < particleCount; i++) {
    const size = 0.03 * (0.8 + Math.random() * 0.4);
    const particleGeometry = new THREE.SphereGeometry(size, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 1
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    effectGroup.add(particle);
    // Use a reduced speed so particles stay close to the impact spot.
    const velocity = direction.clone().negate();
    const speed = 0.05 + Math.random() * 0.05;
    velocity.multiplyScalar(speed);
    velocity.x += (Math.random() - 0.5) * 0.05;
    velocity.y += (Math.random() - 0.5) * 0.05;
    velocity.z += (Math.random() - 0.5) * 0.05;
    particles.push({ mesh: particle, velocity: velocity, life: 30 + Math.floor(Math.random() * 20) });
  }

  const duration = 500; // in ms
  const startTime = performance.now();

  function animateEffect() {
    const elapsed = performance.now() - startTime;
    const t = elapsed / duration;
    for (const p of particles) {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.mesh.material.opacity = Math.max(1 - t, 0);
        if (hitType === 'ground') {
          p.velocity.y -= 0.005; // gravity effect on ground splatter
        }
        p.life--;
      }
    }
    if (elapsed < duration) {
      requestAnimationFrame(animateEffect);
    } else {
      scene.remove(effectGroup);
      effectGroup.traverse(child => {
        if (child.isMesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
  }
  requestAnimationFrame(animateEffect);
}

/**
 * Applies a realistic recoil effect.
 * @param {Player} player - The player instance.
 */
export function applyRecoil(player) {
  const originalAimOffset = player.aimOffset.clone();
  const originalFOV = player.camera.fov;
  const originalCameraPos = player.camera.position.clone();
  const originalRotation = player.camera.rotation.clone();

  // Initial recoil changes.
  player.camera.rotation.x -= 0.08;
  player.camera.rotation.z += 0.01;
  player.aimOffset.z += 0.4;
  player.aimOffset.y += 0.15;
  player.aimOffset.x += 0.05;
  player.camera.fov -= 5;
  player.camera.updateProjectionMatrix();

  const recoilSteps = [
    { time: 20, cameraX: -0.04, cameraZ: 0.005, offsetZ: 0.2, offsetY: 0.08, offsetX: 0.03 },
    { time: 40, cameraX: -0.06, cameraZ: 0.008, offsetZ: 0.3, offsetY: 0.12, offsetX: 0.04 },
    { time: 60, cameraX: -0.03, cameraZ: 0.006, offsetZ: 0.25, offsetY: 0.1, offsetX: 0.02 },
    { time: 80, cameraX: -0.02, cameraZ: 0.004, offsetZ: 0.18, offsetY: 0.07, offsetX: 0.01 },
    { time: 100, cameraX: -0.01, cameraZ: 0.002, offsetZ: 0.1, offsetY: 0.05, offsetX: 0.005 }
  ];

  recoilSteps.forEach(step => {
    setTimeout(() => {
      player.camera.rotation.x = originalRotation.x + step.cameraX;
      player.camera.rotation.z = originalRotation.z + step.cameraZ;
      player.aimOffset.z = originalAimOffset.z + step.offsetZ;
      player.aimOffset.y = originalAimOffset.y + step.offsetY;
      player.aimOffset.x = originalAimOffset.x + step.offsetX;
    }, step.time);
  });

  let shakeIntensity = 0.03;
  const shakeDecay = 0.9;
  const shakeInterval = setInterval(() => {
    if (shakeIntensity > 0.002) {
      player.camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
      player.camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity *= shakeDecay;
    } else {
      clearInterval(shakeInterval);
      player.camera.position.copy(originalCameraPos);
    }
  }, 16);

  let progress = 0;
  const duration = 400;
  const startTime = performance.now();

  function recoverFromRecoil(timestamp) {
    progress = (timestamp - startTime) / duration;
    if (progress < 1) {
      const t = progress * 4;
      player.camera.rotation.x = springInterpolation(
        player.camera.rotation.x,
        originalRotation.x,
        t,
        0.4,
        8
      );
      player.camera.rotation.z = springInterpolation(
        player.camera.rotation.z,
        originalRotation.z,
        t,
        0.4,
        8
      );
      player.aimOffset.x = springInterpolation(
        player.aimOffset.x,
        originalAimOffset.x,
        t,
        0.4,
        8
      );
      player.aimOffset.y = springInterpolation(
        player.aimOffset.y,
        originalAimOffset.y,
        t,
        0.4,
        8
      );
      player.aimOffset.z = springInterpolation(
        player.aimOffset.z,
        originalAimOffset.z,
        t,
        0.4,
        8
      );
      player.camera.fov = THREE.MathUtils.lerp(
        player.camera.fov,
        originalFOV,
        progress * 0.3
      );
      player.camera.updateProjectionMatrix();
      requestAnimationFrame(recoverFromRecoil);
    } else {
      player.camera.rotation.copy(originalRotation);
      player.aimOffset.copy(originalAimOffset);
      player.camera.fov = originalFOV;
      player.camera.updateProjectionMatrix();
      player.camera.position.copy(originalCameraPos);
    }
  }
  requestAnimationFrame(recoverFromRecoil);
}

/**
 * Enhanced shell ejection with realistic physics.
 * @param {Player} player - The player instance.
 * @param {THREE.Scene} scene - The scene to add the shell.
 * @param {SoundManager} soundManager - For playing sound effects.
 */
export function ejectShell(player, scene, soundManager) {
  const shellGroup = new THREE.Group();

  const shellGeometry = new THREE.CylinderGeometry(0.01, 0.015, 0.04, 8);
  const shellMaterial = new THREE.MeshStandardMaterial({
    color: 0xD4AF37,
    metalness: 0.8,
    roughness: 0.2
  });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shellGroup.add(shell);

  const primerGeometry = new THREE.CircleGeometry(0.006, 8);
  const primerMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0A0A0,
    metalness: 0.7,
    roughness: 0.3
  });
  const primer = new THREE.Mesh(primerGeometry, primerMaterial);
  primer.position.y = -0.02;
  primer.rotation.x = Math.PI / 2;
  shellGroup.add(primer);

  const shellStart = player.revolver.getBarrelTipWorldPosition();
  shellGroup.position.copy(shellStart);
  shellGroup.position.x += 0.05;
  shellGroup.position.y -= 0.02;
  scene.add(shellGroup);

  const physics = {
    velocity: new THREE.Vector3(
      0.8 + Math.random() * 0.4,
      0.5 + Math.random() * 0.3,
      (Math.random() - 0.5) * 0.2
    ),
    rotationSpeed: new THREE.Vector3(
      Math.random() * 0.2,
      Math.random() * 0.2,
      Math.random() * 0.2
    ),
    gravity: 0.015,
    drag: 0.99
  };

  const duration = 2000;
  const startTime = performance.now();

  function animateShell(timestamp) {
    const elapsed = timestamp - startTime;
    if (elapsed < duration) {
      shellGroup.position.x += physics.velocity.x * 0.016;
      shellGroup.position.y += physics.velocity.y * 0.016;
      shellGroup.position.z += physics.velocity.z * 0.016;
      physics.velocity.y -= physics.gravity;
      physics.velocity.multiplyScalar(physics.drag);
      shellGroup.rotation.x += physics.rotationSpeed.x;
      shellGroup.rotation.y += physics.rotationSpeed.y;
      shellGroup.rotation.z += physics.rotationSpeed.z;

      // Bounce logic on ground impact.
      if (shellGroup.position.y < 0.02 && physics.velocity.y < 0) {
        physics.velocity.y = -physics.velocity.y * 0.6;
        physics.velocity.x *= 0.8;
        physics.velocity.z *= 0.8;
        shellGroup.position.y = 0.02;
        physics.rotationSpeed.x = Math.random() * 0.4;
        physics.rotationSpeed.z = Math.random() * 0.4;
      }
      requestAnimationFrame(animateShell);
    } else {
      scene.remove(shellGroup);
      shellGeometry.dispose();
      shellMaterial.dispose();
      primerGeometry.dispose();
      primerMaterial.dispose();
    }
  }
  requestAnimationFrame(animateShell);
}


================================================
File: /public/js/input.js
================================================
/**
 * Initializes game input (keyboard + mouse) and pointer lock.
 * @param {THREE.WebGLRenderer} renderer - The renderer instance.
 * @param {Player} player - The local Player instance (first-person).
 * @param {SoundManager} soundManager - The SoundManager for audio feedback.
 */
export function initInput(renderer, player, soundManager) {
    // Request pointer lock on click
    document.body.addEventListener('click', () => {
      if (document.pointerLockElement !== renderer.domElement) {
        renderer.domElement.requestPointerLock();
      }
    });
  
    // Mouse look
    document.addEventListener('mousemove', (event) => {
      if (document.pointerLockElement === renderer.domElement) {
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;
  
        // Slightly lower sensitivity when aiming
        const sensitivity = player.isAiming ? 0.001 : 0.002;
  
        // Yaw
        player.group.rotation.y -= movementX * sensitivity;
  
        // Pitch (limit to avoid flipping)
        player.camera.rotation.x -= movementY * sensitivity;
        player.camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, player.camera.rotation.x)
        );
      }
    });
  
    // Keyboard down
    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'KeyW':
          player.moveForward = true;
          break;
        case 'KeyS':
          player.moveBackward = true;
          break;
        case 'KeyA':
          player.moveLeft = true;
          break;
        case 'KeyD':
          player.moveRight = true;
          break;
        case 'Space':
          if (player.canJump) {
            player.velocity.y = 10;
            player.canJump = false;
          }
          break;
        case 'KeyR':
          // Start reload
          player.startReload();
          break;
        default:
          break;
      }
    });
  
    // Keyboard up
    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyW':
          player.moveForward = false;
          break;
        case 'KeyS':
          player.moveBackward = false;
          break;
        case 'KeyA':
          player.moveLeft = false;
          break;
        case 'KeyD':
          player.moveRight = false;
          break;
        default:
          break;
      }
    });
  
    // Mouse down
    document.addEventListener('mousedown', (event) => {
      // Right-click => Aim
      if (event.button === 2) {
        player.isAiming = true;
        player.revolver.group.visible = true;
        // Optionally show arms in first-person
        if (player.arms) {
          player.arms.setVisible(true);
        }
        const crosshair = document.getElementById('crosshair');
        if (crosshair) crosshair.style.display = 'block';
  
        if (soundManager) {
          soundManager.playSound("aimclick");
        }
      }
      // Left-click => Shoot (only if aiming)
      else if (event.button === 0) {
        if (player.revolver.group.visible && !player.isReloading) {
          player.shoot();
        }
      }
    });
  
    // Mouse up
    document.addEventListener('mouseup', (event) => {
      // Stop aiming on right-click release
      if (event.button === 2) {
        player.isAiming = false;
        player.revolver.group.visible = false;
        if (player.arms) {
          player.arms.setVisible(false);
        }
        const crosshair = document.getElementById('crosshair');
        if (crosshair) crosshair.style.display = 'none';
      }
    });
  
    // Prevent context menu on right-click
    document.addEventListener('contextmenu', (event) => {
      event.preventDefault();
    });
  
    // Handle window resize
    window.addEventListener('resize', () => {
      player.camera.aspect = window.innerWidth / window.innerHeight;
      player.camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }
  

================================================
File: /public/js/main.js
================================================
import { initScene, createNPC, updateNPC, updateFPS, scene } from './scene.js';
import { initInput } from './input.js';
import { SoundManager } from './soundManager.js';
import { Player } from './player.js';
import { networkManager } from './network.js';
import { MultiplayerManager } from './multiplayerManager.js';
import { Bullet } from './bullet.js';
import { createMuzzleFlash, createSmokeEffect, createShockwaveRing } from './effects.js';

// Keep track of all bullets in the game, both local and remote
let bullets = [];

// We'll keep references to local player, remote players, and a combined map
let localPlayer;
let remotePlayers = new Map();  // (playerId => ThirdPersonModel)
let playersMap = new Map();     // Master map including local + remote

// Scenes, camera, etc.
let renderer, camera, npc;
let multiplayerManager;
let lastTime = 0;

function init() {
  try {
    const sceneSetup = initScene();
    camera = sceneSetup.camera;
    renderer = sceneSetup.renderer;

    const soundManager = new SoundManager();
    soundManager.loadSound("shot1", "sounds/shot1.mp3");
    soundManager.loadSound("shot2", "sounds/shot2.mp3");
    soundManager.loadSound("aimclick", "sounds/aimclick.mp3");
    soundManager.loadSound("shellejection", "sounds/shellejection.mp3");
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    
    // Initialize multiplayer manager
    multiplayerManager = new MultiplayerManager(scene, soundManager, remotePlayers);

    // Initialize the local player
    localPlayer = new Player({
      scene,
      camera,
      soundManager,
      onShoot: handleLocalPlayerShoot  // callback for local shooting
    });
    // Make localPlayer globally accessible for hit updates.
    window.localPlayer = localPlayer;

    // Create an NPC target
    npc = createNPC(scene);

    // Initialize input
    initInput(renderer, localPlayer, soundManager);

    // Show connection status
    const networkStatus = document.createElement('div');
    networkStatus.id = 'network-status';
    networkStatus.textContent = 'Connecting...';
    document.getElementById('game-container').appendChild(networkStatus);

    // Update player count UI when server broadcasts the count.
    networkManager.onPlayerCount = (count) => {
      const playerCountEl = document.getElementById('player-count');
      if (playerCountEl) {
        playerCountEl.textContent = `Players: ${count}`;
      }
    };

    // Listen for network open/close
    networkManager.socket.addEventListener('open', () => {
      networkStatus.textContent = 'Connected';
      networkStatus.style.backgroundColor = 'rgba(0,128,0,0.5)';
      setTimeout(() => { networkStatus.style.opacity = '0'; }, 2000);
    });
    networkManager.socket.addEventListener('close', () => {
      networkStatus.textContent = 'Disconnected';
      networkStatus.style.backgroundColor = 'rgba(255,0,0,0.5)';
      networkStatus.style.opacity = '1';
    });

    // Listen for remote players shooting
    networkManager.onPlayerShoot = (playerId, bulletData) => {
      handleRemotePlayerShoot(playerId, bulletData);
    };

    // Listen for updates to the remotePlayers map so we can refresh the master map
    multiplayerManager.onRemotePlayersUpdated = () => {
      updatePlayersMap();
    };

    // Start the animation loop
    animate(0);
    showGameInstructions();
    
  } catch (error) {
    console.error('Initialization failed:', error);
  }
}

/**
 * The main animation loop.
 */
function animate(time) {
  requestAnimationFrame(animate);
  const deltaTime = (time - lastTime) / 1000;
  lastTime = time;

  // Update local player
  localPlayer.update(deltaTime);

  // Update NPC using the imported updateNPC function
  updateNPC(npc, deltaTime);

  // Update remote players (animations, movement interpolation, etc.)
  multiplayerManager.update(deltaTime);

  // Update bullets (both local & remote)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    const result = bullet.update(deltaTime, npc, scene, playersMap);
    if (!result.active) {
      // If bullet hit something or traveled too far
      if (result.hit && result.hit.type === 'player') {
        console.log(`Bullet hit player ${result.hit.playerId}`);
      }
      scene.remove(bullet.mesh);
      bullets.splice(i, 1);
    }
  }

  // Update FPS display
  updateFPS(renderer, camera, deltaTime);

  // Render
  renderer.render(scene, camera);
}

/**
 * Called whenever the local player fires.
 * Spawns a bullet locally and also notifies the server.
 * @param {THREE.Vector3} bulletStart 
 * @param {THREE.Vector3} shootDir 
 */
function handleLocalPlayerShoot(bulletStart, shootDir) {
  // Spawn bullet in our local game
  const bullet = spawnBullet(localPlayer.id, bulletStart, shootDir);

  // Send bullet data over network
  networkManager.sendShoot({
    position: {
      x: bulletStart.x,
      y: bulletStart.y,
      z: bulletStart.z
    },
    direction: {
      x: shootDir.x,
      y: shootDir.y,
      z: shootDir.z
    }
  });
}

/**
 * Called whenever a remote player fires (based on network data).
 * @param {number} playerId 
 * @param {Object} bulletData 
 */
function handleRemotePlayerShoot(playerId, bulletData) {
  const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
  const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);

  spawnBullet(playerId, startPos, dir);
}

/**
 * Actually spawns a bullet in the world, complete with muzzle flash, etc.
 * @param {string|number} sourcePlayerId 
 * @param {THREE.Vector3} position 
 * @param {THREE.Vector3} direction 
 */
function spawnBullet(sourcePlayerId, position, direction) {
  const bullet = new Bullet(position, direction);
  bullet.setSourcePlayer(sourcePlayerId);
  bullets.push(bullet);
  scene.add(bullet.mesh);

  // Visual effects
  createMuzzleFlash(position, scene);
  createSmokeEffect(position, direction, scene);
  createShockwaveRing(position, direction, scene);

  // Sound
  if (localPlayer.soundManager) {
    const shotSound = Math.random() < 0.5 ? "shot1" : "shot2";
    localPlayer.soundManager.playSound(shotSound);
  }

  return bullet;
}

/**
 * Rebuilds a master map of all remote players.
 * This map is passed to bullet collision checks so bullets can hit any remote player.
 */
function updatePlayersMap() {
  playersMap.clear();
  // Only add remote players so that the local (shooter’s) model isn’t processed in bullet collisions.
  for (const [pid, remoteModel] of remotePlayers.entries()) {
    playersMap.set(pid, remoteModel);
  }
}


function showGameInstructions() {
  const instructions = document.createElement('div');
  instructions.id = 'instructions';
  instructions.style.position = 'absolute';
  instructions.style.top = '50%';
  instructions.style.left = '50%';
  instructions.style.transform = 'translate(-50%, -50%)';
  instructions.style.color = 'white';
  instructions.style.backgroundColor = 'rgba(0,0,0,0.7)';
  instructions.style.padding = '20px';
  instructions.style.borderRadius = '10px';
  instructions.style.maxWidth = '500px';
  instructions.style.textAlign = 'center';
  instructions.style.zIndex = '1000';
  
  instructions.innerHTML = 
    `<h2>Wild Western Shooter - Multiplayer</h2>
    <p>WASD: Move</p>
    <p>Right-click: Aim</p>
    <p>Left-click (while aiming): Shoot</p>
    <p>R: Reload</p>
    <p>Space: Jump</p>
    <p><strong>Click anywhere to start</strong></p>`;
  
  document.getElementById('game-container').appendChild(instructions);
  
  // Remove instructions on click
  document.addEventListener('click', () => {
    if (instructions.parentNode) {
      instructions.parentNode.removeChild(instructions);
    }
  }, { once: true });
}

init();


================================================
File: /public/js/multiplayerManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';
import { networkManager } from './network.js';

/**
 * Manages all remote players (their models, animations, etc.) but NOT bullets.
 * Bullets are now handled in main.js.
 */
export class MultiplayerManager {
  constructor(scene, soundManager, remotePlayersMap) {
    /**
     * @param remotePlayersMap {Map<number,ThirdPersonModel>}
     * A shared map that main.js also references. We'll update it here.
     */
    this.scene = scene;
    this.soundManager = soundManager;
    
    // This map is passed in from main.js; we mutate it
    this.remotePlayers = remotePlayersMap;

    // Callback that main.js uses to know we changed remotePlayers
    this.onRemotePlayersUpdated = null;

    this.localPlayerId = null;

    // Initialize network handlers
    this.initNetwork();
  }
  
  initNetwork() {
    // When we get the "init" message, set local player ID and add any existing players
    networkManager.onInit = (initData) => {
      this.localPlayerId = initData.id;
      console.log(`Local player ID: ${this.localPlayerId}`);

      // Add all existing players (these are remote from our POV)
      initData.players.forEach(playerData => {
        this.addPlayer(playerData.id, playerData);
      });
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerJoined = (playerData) => {
      if (playerData.id === this.localPlayerId) return; // skip ourself
      this.addPlayer(playerData.id, playerData);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerLeft = (playerId) => {
      this.removePlayer(playerId);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerUpdate = (playerId, updatedData) => {
      if (playerId === this.localPlayerId) return; // skip ourself
      const playerModel = this.remotePlayers.get(playerId);
      if (playerModel) {
        playerModel.update(updatedData);
      } else {
        // If we don't have this model yet, create it
        this.addPlayer(playerId, updatedData);
      }
    };

    // We no longer handle bullets here (onPlayerShoot) – that's handled in main.js

    // Player got hit (local player)
    networkManager.onPlayerHit = (sourceId, hitData) => {
      console.log(`I was hit by player ${sourceId}!`);
      this.showHitFeedback();
      // Reduce local player's health (assumes window.localPlayer is set)
      if (window.localPlayer && typeof window.localPlayer.takeDamage === 'function') {
         window.localPlayer.takeDamage(20);
      }
    };

    // Broadcast that some player was hit (for visual effects and health updates)
    networkManager.onPlayerHitBroadcast = (targetId, sourceId, hitPos) => {
      console.log(`Player ${targetId} was hit by ${sourceId}`);
      const tPlayer = this.remotePlayers.get(parseInt(targetId));
      if (tPlayer) {
        tPlayer.showHitFeedback();
        if (typeof tPlayer.takeDamage === 'function') {
          tPlayer.takeDamage(20);
        }
      }
    };
  }

  showHitFeedback() {
    // Flash the screen red briefly
    const hitOverlay = document.createElement('div');
    hitOverlay.style.position = 'absolute';
    hitOverlay.style.top = '0';
    hitOverlay.style.left = '0';
    hitOverlay.style.width = '100%';
    hitOverlay.style.height = '100%';
    hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    hitOverlay.style.pointerEvents = 'none';
    hitOverlay.style.transition = 'opacity 0.5s ease-out';
    hitOverlay.style.zIndex = '1000';
    document.body.appendChild(hitOverlay);
    
    setTimeout(() => {
      hitOverlay.style.opacity = '0';
      setTimeout(() => {
        if (hitOverlay.parentNode) {
          hitOverlay.parentNode.removeChild(hitOverlay);
        }
      }, 500);
    }, 100);

    // Optional hit sound
    if (this.soundManager) {
      this.soundManager.playSound("aimclick");
    }
  }

  addPlayer(playerId, data) {
    console.log(`Adding remote player ${playerId}`);
    const model = new ThirdPersonModel(this.scene, playerId);
    model.update(data);
    this.remotePlayers.set(playerId, model);
  }

  removePlayer(playerId) {
    console.log(`Removing remote player ${playerId}`);
    const model = this.remotePlayers.get(playerId);
    if (model) {
      model.remove();
      this.remotePlayers.delete(playerId);
    }
  }

  update(deltaTime) {
    // Animate each remote player's walk cycle and smoothly update movement
    for (const [playerId, remoteModel] of this.remotePlayers.entries()) {
      if (remoteModel.isWalking) {
        remoteModel.animateWalk(deltaTime);
      } else {
        remoteModel.resetWalkAnimation();
      }
      remoteModel.animateMovement(deltaTime);
    }
  }

  notifyPlayersUpdated() {
    if (typeof this.onRemotePlayersUpdated === 'function') {
      this.onRemotePlayersUpdated();
    }
  }
}


================================================
File: /public/js/network.js
================================================
/**
 * NetworkManager class for WebSocket communication.
 * It provides event callbacks for multiplayer events and methods to send data.
 */
export class NetworkManager {
    constructor() {
      this.socket = null;
      this.playerId = null;
      this.otherPlayers = new Map(); // Maps playerId -> playerData from the server
  
      // Callbacks
      this.onInit = null;              // Called when we first receive 'init' from server
      this.onPlayerJoined = null;
      this.onPlayerLeft = null;
      this.onPlayerUpdate = null;
      this.onPlayerShoot = null;
      this.onPlayerCount = null;
      this.onPlayerHit = null;         // When this player is hit by someone
      this.onPlayerHitBroadcast = null;// When any player is hit
      this.onOpen = null;
      this.onClose = null;
      this.onError = null;
  
      // Automatic reconnect attempts
      this.connectionAttempts = 0;
      this.maxConnectionAttempts = 5;
      this.reconnectTimer = null;
  
      // Unique sessionId to prevent multiple tabs from colliding
      this.sessionId = this._generateSessionId();
    }
  
    /**
     * Generates a unique-ish session ID to detect duplicate connections from the same tab.
     */
    _generateSessionId() {
      return Date.now().toString(36) + Math.random().toString(36).substring(2);
    }
  
    /**
     * Initiates a connection to the WebSocket server.
     */
    connect() {
      this._cleanupSocket();
  
      // Determine correct ws:// or wss:// based on current protocol
      const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsUrl = `${protocol}${window.location.host}?sessionId=${this.sessionId}`;
  
      console.log('Attempting to connect to:', wsUrl);
      this.socket = new WebSocket(wsUrl);
  
      this.socket.onopen = (event) => {
        console.log('WebSocket connected');
        this.connectionAttempts = 0;
        if (typeof this.onOpen === 'function') {
          this.onOpen(event);
        }
      };
  
      this.socket.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          this.handleMessage(message);
        } catch (err) {
          console.error('Error parsing server message:', err);
        }
      };
  
      this.socket.onclose = (event) => {
        console.log(`WebSocket closed: ${event.code} ${event.reason}`);
        if (typeof this.onClose === 'function') {
          this.onClose(event);
        }
        this._scheduleReconnect();
      };
  
      this.socket.onerror = (error) => {
        console.error('WebSocket error:', error);
        if (typeof this.onError === 'function') {
          this.onError(error);
        }
      };
    }
  
    /**
     * Clean up any existing WebSocket connection.
     */
    _cleanupSocket() {
      if (this.socket) {
        this.socket.onopen = null;
        this.socket.onmessage = null;
        this.socket.onclose = null;
        this.socket.onerror = null;
        if (
          this.socket.readyState === WebSocket.OPEN ||
          this.socket.readyState === WebSocket.CONNECTING
        ) {
          this.socket.close();
        }
        this.socket = null;
      }
  
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }
    }
  
    /**
     * Schedules a reconnect attempt if under max attempts.
     */
    _scheduleReconnect() {
      if (this.connectionAttempts < this.maxConnectionAttempts) {
        this.connectionAttempts++;
        const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
        console.log(`Reconnecting in ${(delay / 1000).toFixed(1)}s... (Attempt ${this.connectionAttempts}/${this.maxConnectionAttempts})`);
        
        this.reconnectTimer = setTimeout(() => {
          console.log(`Reconnecting now (Attempt ${this.connectionAttempts})...`);
          this.connect();
        }, delay);
      } else {
        console.error('Max reconnect attempts reached. Please refresh the page.');
      }
    }
  
    /**
     * Handles all messages from the server.
     * @param {Object} message The parsed JSON message object.
     */
    handleMessage(message) {
      switch (message.type) {
        // New connection initialization
        case 'init':
          this.playerId = message.id;
          console.log(`Assigned player ID: ${this.playerId}`);
  
          // If there's a callback
          if (typeof this.onInit === 'function') {
            this.onInit(message);
          }
  
          // Add known players
          message.players.forEach(player => {
            if (this.onPlayerJoined) {
              this.onPlayerJoined(player);
            }
            this.otherPlayers.set(player.id, player);
          });
          break;
  
        // Another player joined
        case 'playerJoined':
          console.log(`Player ${message.id} joined`);
          if (this.onPlayerJoined) {
            this.onPlayerJoined(message);
          }
          this.otherPlayers.set(message.id, {
            id: message.id,
            position: message.position,
            rotation: message.rotation,
            isAiming: false,
            isShooting: false,
            isReloading: false
          });
          break;
  
        // Player left
        case 'playerLeft':
          console.log(`Player ${message.id} left`);
          if (this.onPlayerLeft) {
            this.onPlayerLeft(message.id);
          }
          this.otherPlayers.delete(message.id);
          break;
  
        // General player update (pos/rot/aiming/etc.)
        case 'playerUpdate':
          {
            const existing = this.otherPlayers.get(message.id);
            if (existing) {
              existing.position = message.position || existing.position;
              existing.rotation = message.rotation || existing.rotation;
              existing.isAiming =
                message.isAiming !== undefined ? message.isAiming : existing.isAiming;
              existing.isShooting =
                message.isShooting !== undefined ? message.isShooting : existing.isShooting;
              existing.isReloading =
                message.isReloading !== undefined ? message.isReloading : existing.isReloading;
            }
            if (this.onPlayerUpdate) {
              this.onPlayerUpdate(message.id, existing);
            }
          }
          break;
  
        // Remote player fired
        case 'playerShoot':
          if (this.onPlayerShoot) {
            this.onPlayerShoot(message.id, message.bulletData);
          }
          break;
  
        // Current total player count
        case 'playerCount':
          if (this.onPlayerCount) {
            this.onPlayerCount(message.count);
          }
          break;
  
        // This client was hit by another player
        case 'hit':
          console.log(`I was hit by player ${message.sourceId}`);
          if (this.onPlayerHit) {
            this.onPlayerHit(message.sourceId, message.hitData);
          }
          break;
  
        // A broadcast that someone was hit
        case 'playerHit':
          console.log(`Player ${message.targetId} was hit by player ${message.sourceId}`);
          if (this.onPlayerHitBroadcast) {
            this.onPlayerHitBroadcast(
              message.targetId,
              message.sourceId,
              message.hitPosition
            );
          }
          break;
  
        // Generic error from server
        case 'error':
          console.error('Server error:', message.message);
          if (message.fatal) {
            this.connectionAttempts = this.maxConnectionAttempts; // block further reconnect
            alert(`Fatal error: ${message.message}`);
          }
          break;
  
        default:
          console.warn('Unhandled message:', message);
          break;
      }
    }
  
    /**
     * Sends local player position/rotation etc. to the server.
     * @param {Object} playerData - { position, rotation, isAiming, isReloading }
     */
    sendUpdate(playerData) {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(
          JSON.stringify({
            type: 'update',
            ...playerData
          })
        );
      }
    }
  
    /**
     * Notifies server that we fired a bullet.
     * @param {Object} bulletData - { position: {x,y,z}, direction: {x,y,z} }
     */
    sendShoot(bulletData) {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(
          JSON.stringify({
            type: 'shoot',
            bulletData
          })
        );
      }
    }
  
    /**
     * Notifies server that we hit another player.
     * @param {number|string} hitPlayerId
     * @param {Object} hitData - { position: {x,y,z}, sourcePlayerId: ... }
     */
    sendPlayerHit(hitPlayerId, hitData) {
      if (this.socket && this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(
          JSON.stringify({
            type: 'playerHit',
            targetId: hitPlayerId,
            hitData
          })
        );
      }
    }
  
    /**
     * Closes the connection manually.
     */
    disconnect() {
      this._cleanupSocket();
      console.log('WebSocket connection manually closed');
    }
  }
  
  // Export a singleton instance
  export const networkManager = new NetworkManager();
  // Make it globally accessible
  window.networkManager = networkManager;
  
  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    networkManager.disconnect();
  });
  

================================================
File: /public/js/player.js
================================================
import { Revolver } from './revolver.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { applyRecoil, ejectShell } from './effects.js';
import { networkManager } from './network.js';

/**
 * The local Player class (first-person).
 */
export class Player {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene
   * @param {THREE.PerspectiveCamera} config.camera
   * @param {SoundManager} config.soundManager
   * @param {Function} config.onShoot - A callback function called when the player fires a bullet.
   */
  constructor({ scene, camera, soundManager, onShoot }) {
    this.scene = scene;
    this.camera = camera;
    this.soundManager = soundManager;
    this.onShootCallback = onShoot;

    this.group = new THREE.Group();
    this.group.position.set(0, 1.6, 0); // Start near eye level
    this.scene.add(this.group);
    this.camera.position.set(0, 0, 0);
    this.group.add(this.camera);

    this.id = null; // will be set by networkManager.onInit
    this.velocity = new THREE.Vector3();
    this.canJump = false;

    // Movement flags
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;

    // Aiming
    this.isAiming = false;
    this.defaultFOV = 75;
    this.aimFOV = 65;
    
    // Gun
    this.revolver = new Revolver();
    this.holsterOffset = new THREE.Vector3(0.6, -0.5, -0.8);
    this.aimOffset = new THREE.Vector3(0.3, -0.3, -0.5);
    this.currentGunOffset = this.holsterOffset.clone();
    this.camera.add(this.revolver.group);

    // Reload
    this.isReloading = false;
    this.reloadTime = 2000;
    this.reloadProgress = 0;
    this.bullets = 6;
    this.maxBullets = 6;
    this.canShoot = true;

    // Health
    this.health = 100;

    // Networking
    this.lastNetworkUpdate = 0;
    this.networkUpdateInterval = 50; // ms

    // Initialize network & UI
    this.initNetworking();
    updateAmmoUI(this);
    updateHealthUI(this);
  }

  initNetworking() {
    // Start the WebSocket
    networkManager.connect();

    networkManager.onInit = (initData) => {
      this.id = initData.id;
      console.log(`Local player initialized with ID: ${this.id}`);
    };

    // We also do not handle remote players here. That is done in the MultiplayerManager.
  }

  update(deltaTime) {
    // Smoothly interpolate the gun offset & FOV
    const targetOffset = this.isAiming ? this.aimOffset : this.holsterOffset;
    this.currentGunOffset.lerp(targetOffset, 0.1);
    this.revolver.group.position.copy(this.currentGunOffset);

    this.camera.fov = THREE.MathUtils.lerp(
      this.camera.fov,
      this.isAiming ? this.aimFOV : this.defaultFOV,
      0.1
    );
    this.camera.updateProjectionMatrix();

    // Gravity
    this.velocity.y -= 20 * deltaTime;
    this.group.position.y += this.velocity.y * deltaTime;
    if (this.group.position.y < 1.6) {
      this.velocity.y = 0;
      this.group.position.y = 1.6;
      this.canJump = true;
    }

    // Movement
    const moveSpeed = 5;
    const forward = new THREE.Vector3();
    this.camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    if (this.moveForward) this.group.position.add(forward.clone().multiplyScalar(moveSpeed * deltaTime));
    if (this.moveBackward) this.group.position.add(forward.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveLeft) this.group.position.add(right.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveRight) this.group.position.add(right.clone().multiplyScalar(moveSpeed * deltaTime));

    // Send periodic network updates
    const now = performance.now();
    if (now - this.lastNetworkUpdate > this.networkUpdateInterval) {
      this.lastNetworkUpdate = now;
      this.sendNetworkUpdate();
    }
  }

  /**
   * Send position/rotation updates to the server.
   */
  sendNetworkUpdate() {
    if (this.id == null) return;
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    networkManager.sendUpdate({
      position: {
        x: this.group.position.x,
        y: this.group.position.y,
        z: this.group.position.z
      },
      rotation: {
        y: this.group.rotation.y
      },
      isAiming: this.isAiming,
      isReloading: this.isReloading,
      health: this.health
    });
  }

  shoot() {
    if (this.bullets <= 0 || !this.canShoot || this.isReloading) {
      // No bullets or can't shoot
      if (this.bullets === 0) {
        const reloadMessage = document.getElementById('reload-message');
        if (reloadMessage) reloadMessage.style.display = 'block';
      }
      return;
    }
    // Actually shoot
    this.bullets--;
    updateAmmoUI(this);

    this.canShoot = false;
    setTimeout(() => { this.canShoot = true; }, 250);

    // Find bullet spawn
    const bulletStart = this.revolver.getBarrelTipWorldPosition();
    const shootDir = new THREE.Vector3();
    this.camera.getWorldDirection(shootDir);

    // Slight random spread
    shootDir.x += (Math.random() - 0.5) * 0.02;
    shootDir.y += (Math.random() - 0.5) * 0.02;
    shootDir.z += (Math.random() - 0.5) * 0.02;
    shootDir.normalize();

    // Recoil effect
    applyRecoil(this);

    // Call the callback to spawn bullet in main.js
    if (typeof this.onShootCallback === 'function') {
      this.onShootCallback(bulletStart, shootDir);
    }

    // If out of bullets, show reload hint
    if (this.bullets === 0) {
      const reloadMessage = document.getElementById('reload-message');
      if (reloadMessage) {
        reloadMessage.style.display = 'block';
      }
    }
  }

  /**
   * Called when the player takes damage.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Player ${this.id} took ${amount} damage. Health is now ${this.health}`);
    updateHealthUI(this);
    // You could add death/respawn logic here
    if (this.health === 0) {
      console.log('Game Over');
      // Optionally, disable input or show a Game Over screen.
    }
  }

  startReload() {
    if (this.isReloading || this.bullets >= this.maxBullets) return;

    this.isReloading = true;
    this.reloadProgress = 0;
    const reloadMessage = document.getElementById('reload-message');
    const reloadProgressContainer = document.getElementById('reload-progress-container');
    if (reloadMessage) reloadMessage.style.display = 'none';
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'block';

    if (this.soundManager) {
      this.soundManager.playSound("shellejection");
      this.soundManager.playSound("reloading");
    }

    // Eject shells sequentially
    for (let i = 0; i < this.maxBullets - this.bullets; i++) {
      setTimeout(() => {
        ejectShell(this, this.scene, this.soundManager);
      }, i * 200);
    }

    const startTime = performance.now();
    const updateReload = (currentTime) => {
      const elapsed = currentTime - startTime;
      this.reloadProgress = Math.min((elapsed / this.reloadTime) * 100, 100);
      const reloadProgressBar = document.getElementById('reload-progress-bar');
      if (reloadProgressBar) {
        reloadProgressBar.style.width = this.reloadProgress + '%';
      }
      if (elapsed < this.reloadTime) {
        requestAnimationFrame(updateReload);
      } else {
        this.completeReload();
      }
    };
    requestAnimationFrame(updateReload);
  }

  completeReload() {
    this.bullets = this.maxBullets;
    updateAmmoUI(this);

    const reloadProgressContainer = document.getElementById('reload-progress-container');
    const reloadProgressBar = document.getElementById('reload-progress-bar');
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
    if (reloadProgressBar) reloadProgressBar.style.width = '0%';
    
    this.isReloading = false;
    this.sendNetworkUpdate(); // let others know
  }
}


================================================
File: /public/js/playerModel.js
================================================
// /public/js/playerModel.js
import { Revolver } from './revolver.js';

/**
 * A simple blocky first-person arms model.
 */
export class PlayerArms {
  constructor(scene) {
    this.scene = scene;
    this.group = new THREE.Group();

    // Right arm
    this.rightArm = this.createBlockyArm(0xC68642);
    this.rightArm.position.set(0.3, -0.4, -0.3);
    this.rightArm.rotation.set(0.3, 0, 0);
    this.group.add(this.rightArm);

    // Left arm
    this.leftArm = this.createBlockyArm(0xC68642);
    this.leftArm.position.set(-0.3, -0.4, -0.3);
    this.leftArm.rotation.set(0.3, 0, 0);
    this.group.add(this.leftArm);

    // Store initial positions/rotations for animations
    this.rightArmOriginalPos = this.rightArm.position.clone();
    this.rightArmOriginalRot = this.rightArm.rotation.clone();
    this.leftArmOriginalPos = this.leftArm.position.clone();
    this.leftArmOriginalRot = this.leftArm.rotation.clone();

    // Initially not visible
    this.setVisible(false);
  }

  /**
   * Creates a blocky "arm" geometry (only a small cube).
   * @param {number} color - Hex color (e.g. 0xC68642)
   * @returns {THREE.Group}
   */
  createBlockyArm(color) {
    const armGroup = new THREE.Group();

    // A small "hand" cube
    const handGeo = new THREE.BoxGeometry(0.08, 0.08, 0.08);
    const handMat = new THREE.MeshStandardMaterial({ color });
    const handMesh = new THREE.Mesh(handGeo, handMat);
    armGroup.add(handMesh);

    return armGroup;
  }

  /**
   * Sets the arms' visibility.
   * @param {boolean} visible
   */
  setVisible(visible) {
    this.group.visible = visible;
  }

  /**
   * Updates arms for aiming. (Example usage in first-person code.)
   * @param {THREE.Camera} camera
   * @param {boolean} isAiming
   * @param {THREE.Vector3} gunBarrelTip
   */
  updatePosition(camera, isAiming, gunBarrelTip = null) {
    if (isAiming) {
      // Hide left arm by default (single-handed revolver stance)
      this.leftArm.visible = false;
      // Show right arm for aiming
      this.rightArm.visible = true;

      if (gunBarrelTip) {
        // Rough alignment based on gun barrel tip if desired
        this.rightArm.position.set(0.32, -0.35, -0.5);
        this.rightArm.rotation.set(Math.PI / 2, 0, 0);
      }
    } else {
      // Hide arms when not aiming
      this.rightArm.visible = false;
      this.leftArm.visible = false;
    }
  }

  /**
   * Plays a smooth reload animation using the left arm.
   * (This method is for the first-person arms model and remains unchanged.)
   */
  playReloadAnimation() {
    const originalPos = this.leftArm.position.clone();
    const originalRot = this.leftArm.rotation.clone();

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    const frames = [
      { t: 0,   pos: { x: -0.3, y: -0.4, z: -0.3 },      rot: { x: 0, y: 0, z: 0 } },
      { t: 300, pos: { x: -0.1, y: -0.2, z: -0.3 },      rot: { x: -0.2, y: 0.1, z: 0.1 } },
      { t: 600, pos: { x: -0.1, y: -0.2, z: -0.3 },      rot: { x: -0.3, y: 0.1, z: 0.1 } },
      { t: 900, pos: { x: -0.3, y: -0.4, z: -0.3 },      rot: { x: 0, y: 0, z: 0 } }
    ];

    const startTime = performance.now();

    const animate = (time) => {
      const elapsed = time - startTime;
      let currentFrame = frames[0];
      let nextFrame = frames[frames.length - 1];
      for (let i = 0; i < frames.length - 1; i++) {
        if (elapsed >= frames[i].t && elapsed < frames[i + 1].t) {
          currentFrame = frames[i];
          nextFrame = frames[i + 1];
          break;
        }
      }
      const segmentDuration = nextFrame.t - currentFrame.t;
      let segmentTime = elapsed - currentFrame.t;
      let alpha = Math.min(segmentTime / segmentDuration, 1);
      alpha = easeInOutCubic(alpha);

      const lerp = (a, b, t) => a + (b - a) * t;
      const newPos = {
        x: lerp(currentFrame.pos.x, nextFrame.pos.x, alpha),
        y: lerp(currentFrame.pos.y, nextFrame.pos.y, alpha),
        z: lerp(currentFrame.pos.z, nextFrame.pos.z, alpha)
      };
      const newRot = {
        x: lerp(currentFrame.rot.x, nextFrame.rot.x, alpha),
        y: lerp(currentFrame.rot.y, nextFrame.rot.y, alpha),
        z: lerp(currentFrame.rot.z, nextFrame.rot.z, alpha)
      };

      this.leftArm.position.set(newPos.x, newPos.y, newPos.z);
      this.leftArm.rotation.set(newRot.x, newRot.y, newRot.z);

      if (elapsed < frames[frames.length - 1].t) {
        requestAnimationFrame(animate);
      } else {
        this.leftArm.position.copy(originalPos);
        this.leftArm.rotation.copy(originalRot);
      }
    };
    requestAnimationFrame(animate);
  }
}

/**
 * The third-person model used to represent remote players
 * (and possibly the local player in others' view).
 */
export class ThirdPersonModel {
  constructor(scene, playerId) {
    this.scene = scene;
    this.playerId = playerId;
    this.group = new THREE.Group();

    this.collisionBox = new THREE.Box3();
    this.hitboxSize = { width: 0.6, height: 1.8, depth: 0.6 };

    // Health
    this.health = 100;

    // Target position/rotation for smooth interpolation.
    this.targetPosition = this.group.position.clone();
    this.targetRotation = this.group.rotation.y;

    // Build a basic "Minecraft-like" character.
    this.createBlockyCharacter();
    scene.add(this.group);

    this.walkCycle = 0;
    this.isWalking = false;
    this.lastPosition = new THREE.Vector3();

    // To track active hit feedback timeout.
    this.hitFeedbackTimeout = null;
  }

  createBlockyCharacter() {
    // Head
    const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xC68642 });
    this.head = new THREE.Mesh(headGeo, headMat);
    this.head.position.y = 1.6;
    this.group.add(this.head);

    // Body
    const bodyGeo = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3F51B5 });
    this.body = new THREE.Mesh(bodyGeo, bodyMat);
    this.body.position.y = 1.1;
    this.group.add(this.body);

    // Arms
    this.createBlockyArms();
    // Legs
    this.createBlockyLegs();
    // Hat
    this.createCowboyHat();

    // Use the normal revolver model on the left arm.
    this.addRevolver();
  }

  createBlockyArms() {
    // Right arm
    const armGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
    const skinMat = new THREE.MeshStandardMaterial({ color: 0xC68642 });
    this.rightArm = new THREE.Group();
    const rightArmMesh = new THREE.Mesh(armGeo, skinMat);
    rightArmMesh.position.y = -0.3;
    this.rightArm.add(rightArmMesh);
    this.rightArm.position.set(0.3, 1.4, 0);
    this.group.add(this.rightArm);

    // Left arm (holding the revolver)
    this.leftArm = new THREE.Group();
    const leftArmMesh = new THREE.Mesh(armGeo, skinMat);
    leftArmMesh.position.y = -0.3;
    this.leftArm.add(leftArmMesh);
    this.leftArm.position.set(-0.3, 1.4, 0);
    this.group.add(this.leftArm);
  }

  createBlockyLegs() {
    const legGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
    const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1A237E });
    // Right leg
    this.rightLeg = new THREE.Group();
    const rightLegMesh = new THREE.Mesh(legGeo, pantsMat);
    rightLegMesh.position.y = -0.3;
    this.rightLeg.add(rightLegMesh);
    this.rightLeg.position.set(0.1, 0.8, 0);
    this.group.add(this.rightLeg);

    // Left leg
    this.leftLeg = new THREE.Group();
    const leftLegMesh = new THREE.Mesh(legGeo, pantsMat);
    leftLegMesh.position.y = -0.3;
    this.leftLeg.add(leftLegMesh);
    this.leftLeg.position.set(-0.1, 0.8, 0);
    this.group.add(this.leftLeg);
  }

  createCowboyHat() {
    const hatMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

    // Hat brim
    const brimGeo = new THREE.BoxGeometry(0.5, 0.05, 0.5);
    this.hatBrim = new THREE.Mesh(brimGeo, hatMat);
    this.hatBrim.position.y = 0.225;
    this.head.add(this.hatBrim);

    // Hat top
    const topGeo = new THREE.BoxGeometry(0.3, 0.15, 0.3);
    this.hatTop = new THREE.Mesh(topGeo, hatMat);
    this.hatTop.position.y = 0.325;
    this.head.add(this.hatTop);
  }

  /**
   * Adds the normal revolver model to the third-person model's left arm.
   * The left arm holds the revolver.
   */
  addRevolver() {
    this.revolver = new Revolver();
    // Attach the revolver to the left arm.
    this.leftArm.add(this.revolver.group);
    // Set default positions and rotations for non-aiming state.
    this.revolverDefaultRotation = new THREE.Euler(-Math.PI / -1.5, Math.PI, 0);
    this.revolverAimingRotation = new THREE.Euler(-Math.PI / 0.7, Math.PI, 0);
    this.revolver.group.position.set(0.05, -0.8, -0.1);
    this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    this.revolver.group.visible = true;
  }

  updateCollisionBox() {
    const halfWidth = this.hitboxSize.width / 2;
    const halfDepth = this.hitboxSize.depth / 2;

    this.collisionBox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - halfWidth,
        this.group.position.y,
        this.group.position.z - halfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + halfWidth,
        this.group.position.y + this.hitboxSize.height,
        this.group.position.z + halfDepth
      )
    ]);
  }

  /**
   * Smoothly updates the model’s position and rotation toward target values.
   * @param {number} deltaTime - Time elapsed since last frame.
   */
  animateMovement(deltaTime) {
    // Interpolate position and rotation for smooth remote movement
    this.group.position.lerp(this.targetPosition, 0.1);
    this.group.rotation.y = THREE.MathUtils.lerp(this.group.rotation.y, this.targetRotation, 0.1);
    this.updateCollisionBox();
  }

  /**
   * Updates the third-person model using data received from the server.
   * @param {Object} playerData
   */
  update(playerData) {
    // Update target position from network data (shifting from eye-level to model base)
    const newPos = new THREE.Vector3(
      playerData.position.x,
      playerData.position.y - 1.6,
      playerData.position.z
    );
    this.targetPosition.copy(newPos);

    // Update target rotation with a 180° offset for proper facing
    if (playerData.rotation && playerData.rotation.y !== undefined) {
      this.targetRotation = playerData.rotation.y + Math.PI;
    }

    // Check if walking based on movement.
    this.isWalking = newPos.distanceTo(this.lastPosition) > 0.01;
    this.lastPosition.copy(newPos);

    // Set pose based on whether the player is aiming.
    if (playerData.isAiming) {
      this.setAimingPose();
    } else {
      this.setNormalPose();
    }

    // If reloading, play the reload animation.
    if (playerData.isReloading) {
      this.playReloadAnimation();
    }

    // Update health if provided
    if (playerData.health !== undefined) {
      this.health = playerData.health;
    }
  }

  /**
   * Sets the model's pose for aiming.
   * The revolver (left arm) is rotated up by 90°.
   */
  setAimingPose() {
    // Right arm remains at default.
    this.rightArm.rotation.set(0, 0, 0);
    this.rightArm.position.set(0.3, 1.4, 0);

    // Left arm (holding revolver) rotates upward.
    this.leftArm.rotation.set(-Math.PI / 2, 0, 0);
    this.leftArm.position.set(-0.3, 1.4, 0);

    if (this.revolver) {
      this.revolver.group.rotation.copy(this.revolverAimingRotation);
    }

    this.head.rotation.x = 0.1;
  }

  /**
   * Sets the model's pose for normal (non-aiming) state.
   * The revolver (left arm) is rotated down a bit.
   */
  setNormalPose() {
    // Right arm stays default.
    this.rightArm.rotation.set(0, 0, 0);
    this.rightArm.position.set(0.3, 1.4, 0);

    // Left arm (holding revolver) is held lower.
    this.leftArm.rotation.set(-Math.PI / 15, 0, 0);
    this.leftArm.position.set(-0.3, 1.4, 0);

    if (this.revolver) {
      this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    }

    this.head.rotation.x = 0;
  }

  /**
   * Plays a smooth reload animation for the model.
   * The reload animation is performed by the right arm.
   */
  playReloadAnimation() {
    const originalPos = this.rightArm.position.clone();
    const originalRot = this.rightArm.rotation.clone();

    // Define keyframes (in ms) for the right arm reload motion.
    const frames = [
      { t: 0,    pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } },
      { t: 250,  pos: { x: 0.2,  y: 1.5, z: 0 },        rot: { x: -Math.PI / 4, y: 0, z: -Math.PI / 4 } },
      { t: 500,  pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } },
      { t: 750,  pos: { x: 0.2,  y: 1.5, z: 0 },        rot: { x: -Math.PI / 4, y: 0, z: -Math.PI / 4 } },
      { t: 1000, pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } }
    ];

    const startTime = performance.now();

    const animate = (time) => {
      const elapsed = time - startTime;
      let currentFrame = frames[0];
      let nextFrame = frames[frames.length - 1];
      for (let i = 0; i < frames.length - 1; i++) {
        if (elapsed >= frames[i].t && elapsed < frames[i + 1].t) {
          currentFrame = frames[i];
          nextFrame = frames[i + 1];
          break;
        }
      }
      const segmentDuration = nextFrame.t - currentFrame.t;
      let segmentTime = elapsed - currentFrame.t;
      let alpha = Math.min(segmentTime / segmentDuration, 1);

      // Cubic easing for smooth interpolation.
      const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      alpha = easeInOutCubic(alpha);

      const lerp = (a, b, t) => a + (b - a) * t;
      const newPos = {
        x: lerp(currentFrame.pos.x, nextFrame.pos.x, alpha),
        y: lerp(currentFrame.pos.y, nextFrame.pos.y, alpha),
        z: lerp(currentFrame.pos.z, nextFrame.pos.z, alpha)
      };
      const newRot = {
        x: lerp(currentFrame.rot.x, nextFrame.rot.x, alpha),
        y: lerp(currentFrame.rot.y, nextFrame.rot.y, alpha),
        z: lerp(currentFrame.rot.z, nextFrame.rot.z, alpha)
      };

      this.rightArm.position.set(newPos.x, newPos.y, newPos.z);
      this.rightArm.rotation.set(newRot.x, newRot.y, newRot.z);

      if (elapsed < frames[frames.length - 1].t) {
        requestAnimationFrame(animate);
      } else {
        this.rightArm.position.copy(originalPos);
        this.rightArm.rotation.copy(originalRot);
      }
    };

    requestAnimationFrame(animate);
  }

  /**
   * Animates the walk cycle.
   * @param {number} deltaTime
   */
  animateWalk(deltaTime) {
    this.walkCycle += deltaTime * 5;
    // Leg swing
    this.rightLeg.rotation.x = Math.sin(this.walkCycle) * 0.7;
    this.leftLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.7;

    // Arm swing (if not in an aiming pose)
    if (this.rightArm.rotation.x === 0 && this.leftArm.rotation.x === 0) {
      this.rightArm.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.5;
      this.leftArm.rotation.x = Math.sin(this.walkCycle) * 0.5;
    }

    // Subtle body bob
    this.body.position.y = 1.1 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.05;
  }

  /**
   * Resets the walk animation.
   */
  resetWalkAnimation() {
    this.rightLeg.rotation.x = 0;
    this.leftLeg.rotation.x = 0;

    if (Math.abs(this.rightArm.rotation.x) < 0.1 &&
        Math.abs(this.leftArm.rotation.x) < 0.1) {
      this.rightArm.rotation.x = 0;
      this.leftArm.rotation.x = 0;
    }
    this.body.position.y = 1.1;
  }

  /**
   * Removes the model from the scene (e.g. on player disconnect).
   * Fully disposes geometry and material.
   */
  remove() {
    this.scene.remove(this.group);
    this.group.traverse(child => {
      if (child.isMesh) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  }

  /**
   * Provides visual feedback (temporary red flash) when the model is hit.
   * The original materials are stored on each mesh (if not already stored)
   * and restored after 200ms.
   */
  showHitFeedback() {
    // Clear any existing hit feedback timeout.
    if (this.hitFeedbackTimeout) {
      clearTimeout(this.hitFeedbackTimeout);
    }
    // Traverse the model and replace each mesh's material with a red flash.
    this.group.traverse(child => {
      if (child.isMesh && child.material) {
        // Store the original material in userData if not already stored.
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        child.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        child.material.needsUpdate = true;
      }
    });
    // After 200ms, restore the original materials.
    this.hitFeedbackTimeout = setTimeout(() => {
      this.group.traverse(child => {
        if (child.isMesh && child.userData.originalMaterial) {
          child.material.dispose();
          child.material = child.userData.originalMaterial;
          child.material.needsUpdate = true;
          delete child.userData.originalMaterial;
        }
      });
      this.hitFeedbackTimeout = null;
    }, 200);
  }

  /**
   * Reduces health when hit.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Remote player ${this.playerId} took ${amount} damage. Health: ${this.health}`);
    // Optionally, you could change the model’s appearance or remove it on death.
  }
}


================================================
File: /public/js/revolver.js
================================================
/**
 * A simple Revolver class that loads a low-poly gun model (GLB) for first-person view.
 */
export class Revolver {
  constructor() {
    this.group = new THREE.Group();

    // Internal flag to log the barrel lookup only once.
    this._barrelLogged = false;
    // This will be our anchor attached to the barrel, used for muzzle flash and bullet spawn.
    this.muzzleFlashAnchor = null;

    // Use GLTFLoader to load the .glb gun model
    const loader = new THREE.GLTFLoader();
    loader.load(
      'models/lowpolygun.glb',
      (gltf) => {
        const gunModel = gltf.scene;
        gunModel.scale.set(0.5, 0.5, 0.5);
        gunModel.position.set(0, 0, 0);
        // Flip the model 180° so it points forward
        gunModel.rotation.set(0, Math.PI, 0);

        // Optional: log all child names for debugging purposes
        // gunModel.traverse(child => console.log(child.name));

        this.group.add(gunModel);
        this.gunModel = gunModel;

        // Attempt to find the barrel by its name in the imported model
        const barrel = gunModel.getObjectByName("Magnum_Barrel_Magnum_mat_0");
        if (!this._barrelLogged) {
          if (barrel) {
            console.log('Revolver barrel found: "Magnum_Barrel_Magnum_mat_0".');
          } else {
            console.warn('Revolver barrel "Magnum_Barrel_Magnum_mat_0" not found. Muzzle flash anchor will not be attached.');
          }
          this._barrelLogged = true;
        }
        if (barrel) {
          // Create a muzzle flash anchor and attach it to the barrel.
          this.muzzleFlashAnchor = new THREE.Object3D();
          // Set an upward offset on the anchor (adjust as necessary)
          this.muzzleFlashAnchor.position.set(-2, 8, -10);
          barrel.add(this.muzzleFlashAnchor);
          console.log('Muzzle flash anchor attached to barrel.');
        }
      },
      undefined,
      (error) => {
        console.error('Error loading revolver model:', error);
      }
    );

    // Initially hidden until the player aims
    this.group.visible = false;
  }

  /**
   * Returns the world position of the gun barrel tip.
   * If a muzzle flash anchor was attached to the barrel, its world position is returned,
   * ensuring that the emission point remains fixed relative to the barrel.
   * Otherwise, it falls back to a default local offset relative to the revolver group.
   *
   * @returns {THREE.Vector3} The world position for spawning bullets and muzzle flash effects.
   */
  getBarrelTipWorldPosition() {
    if (this.muzzleFlashAnchor) {
      const worldPos = new THREE.Vector3();
      this.muzzleFlashAnchor.getWorldPosition(worldPos);
      return worldPos;
    }
    // Fallback: use a default local offset relative to the revolver group
    return this.group.localToWorld(new THREE.Vector3(0, 0, -0.7));
  }
}


================================================
File: /public/js/scene.js
================================================
export let scene;

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {Object} - Contains the camera and renderer.
 */
export function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 10, 750);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // Set output encoding for consistent lighting and color reproduction.
  renderer.outputEncoding = THREE.sRGBEncoding;

  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) {
    throw new Error("Game container not found in HTML.");
  }
  gameContainer.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(1, 1, 0.5).normalize();
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);

  const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
  const groundMaterial = new THREE.MeshStandardMaterial({
    color: 0xCD853F,
    roughness: 0.8,
    metalness: 0.2
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  return { camera, renderer };
}

/**
 * Creates a simple NPC target.
 * @param {THREE.Scene} scene - The scene to add the NPC.
 * @returns {THREE.Group} - The NPC group.
 */
export function createNPC(scene) {
  const npcGroup = new THREE.Group();
  const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.9;
  npcGroup.add(body);
  const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
  const headMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 1.8;
  npcGroup.add(head);
  const hatGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8);
  const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const hat = new THREE.Mesh(hatGeometry, hatMaterial);
  hat.position.y = 2.0;
  npcGroup.add(hat);

  npcGroup.position.set(0, 0, -10);
  scene.add(npcGroup);
  return npcGroup;
}

/**
 * Updates the NPC’s position.
 * @param {THREE.Group} npc - The NPC group.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateNPC(npc, deltaTime) {
  if (npc) {
    npc.userData.direction = npc.userData.direction || 1;
    npc.position.x += npc.userData.direction * 2 * deltaTime;
    if (npc.position.x > 15) {
      npc.userData.direction = -1;
      npc.rotation.y = Math.PI / 2;
    } else if (npc.position.x < -15) {
      npc.userData.direction = 1;
      npc.rotation.y = -Math.PI / 2;
    }
  }
}

/**
 * Updates the FPS counter.
 * @param {THREE.WebGLRenderer} renderer - The renderer.
 * @param {THREE.Camera} camera - The camera.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateFPS(renderer, camera, deltaTime) {
  const fpsCounter = document.getElementById('fps-counter');
  if (fpsCounter) {
    const currentFPS = deltaTime > 0 ? Math.round(1 / deltaTime) : 0;
    fpsCounter.textContent = `FPS: ${currentFPS}`;
  }
}


================================================
File: /public/js/soundManager.js
================================================
export class SoundManager {
    constructor() {
      this.sounds = {};
    }
    
    /**
     * Loads an audio file and caches it.
     * @param {string} name - Sound key.
     * @param {string} url - Audio file URL.
     */
    loadSound(name, url) {
      try {
        const audio = new Audio();
        audio.src = url;
        audio.load();
        this.sounds[name] = audio;
      } catch (error) {
        console.error(`Error loading sound "${name}" from ${url}:`, error);
      }
    }
    
    /**
     * Plays a cached sound by cloning the node.
     * @param {string} name - Sound key.
     */
    playSound(name) {
      if (this.sounds[name]) {
        const audioClone = this.sounds[name].cloneNode();
        audioClone.play().catch(error => {
          console.error(`Error playing sound "${name}":`, error);
        });
      } else {
        console.error(`Sound "${name}" not found in cache.`);
      }
    }
    
    /**
     * Plays a sequence: after sound1 ends, sound2 plays.
     * @param {string} sound1 - First sound key.
     * @param {string} sound2 - Second sound key.
     */
    playSoundSequence(sound1, sound2) {
      if (this.sounds[sound1]) {
        const audioClone = this.sounds[sound1].cloneNode();
        audioClone.play().then(() => {
          audioClone.addEventListener('ended', () => {
            this.playSound(sound2);
          });
        }).catch(error => {
          console.error(`Error playing sound "${sound1}":`, error);
        });
      } else {
        console.error(`Sound "${sound1}" not found in cache.`);
      }
    }
  }
  

================================================
File: /public/js/ui.js
================================================
/**
 * Updates the ammo counter in the UI.
 * @param {Player} player - The player instance.
 */
export function updateAmmoUI(player) {
    const ammoCounter = document.getElementById('ammo-counter');
    if (ammoCounter && player) {
      ammoCounter.textContent = `Bullets: ${player.bullets}/${player.maxBullets}`;
    }
}

/**
 * Updates the health counter in the UI.
 * @param {Player|ThirdPersonModel} player - The player instance.
 */
export function updateHealthUI(player) {
    const healthCounter = document.getElementById('health-counter');
    if (healthCounter && player) {
      healthCounter.textContent = `Health: ${player.health}`;
    }
}


================================================
File: /server.js
================================================
// server.js
const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const url = require('url');
const app = express();

// Port default 8080 to match your previous Cloudflare Tunnel config
const PORT = process.env.PORT || 8080;

// Serve static files from "public"
app.use(express.static('public'));

const server = http.createServer(app);
const wss = new WebSocket.Server({ server, clientTracking: true });

// Track connected players
const players = new Map();    // playerId -> { ws, sessionId, position, rotation, health, ... }
const sessions = new Set();   // tracks sessionIds to prevent duplicate connections
let nextPlayerId = 1;

// On new connection
wss.on('connection', (ws, req) => {
  // Parse sessionId from query string
  const parameters = url.parse(req.url, true).query;
  const sessionId = parameters.sessionId;

  // If we already have this sessionId, reject as duplicate
  if (sessionId && sessions.has(sessionId)) {
    console.log(`Rejecting duplicate connection with sessionId: ${sessionId}`);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Duplicate connection detected',
      fatal: true
    }));
    return ws.close(1008, 'Duplicate connection');
  }

  if (sessionId) {
    sessions.add(sessionId);
  }

  const playerId = nextPlayerId++;
  console.log(`Player ${playerId} connected (sessionId: ${sessionId || 'none'})`);

  // Create initial player data with health
  players.set(playerId, {
    ws,
    sessionId,
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { y: 0 },
    isAiming: false,
    isShooting: false,
    isReloading: false,
    health: 100,
    lastActivity: Date.now()
  });

  // Send init data to this client (their ID + existing players)
  ws.send(JSON.stringify({
    type: 'init',
    id: playerId,
    players: Array.from(players.entries())
      .filter(([pid]) => pid !== playerId)
      .map(([pid, p]) => ({
        id: pid,
        position: p.position,
        rotation: p.rotation,
        isAiming: p.isAiming,
        isShooting: p.isShooting,
        isReloading: p.isReloading,
        health: p.health
      }))
  }));

  // Notify others that a new player joined
  broadcastToOthers(playerId, {
    type: 'playerJoined',
    id: playerId,
    position: players.get(playerId).position,
    rotation: players.get(playerId).rotation,
    health: players.get(playerId).health
  });

  // Handle incoming messages
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);

      // Update lastActivity
      const player = players.get(playerId);
      if (player) {
        player.lastActivity = Date.now();
      }

      switch (data.type) {
        case 'update':
          // Update local state (do not allow client to change health directly)
          if (player) {
            player.position = data.position || player.position;
            player.rotation = data.rotation || player.rotation;
            player.isAiming = data.isAiming !== undefined ? data.isAiming : player.isAiming;
            player.isShooting = data.isShooting !== undefined ? data.isShooting : player.isShooting;
            player.isReloading = data.isReloading !== undefined ? data.isReloading : player.isReloading;
            // Broadcast to others including current health
            broadcastToOthers(playerId, {
              type: 'playerUpdate',
              id: playerId,
              position: player.position,
              rotation: player.rotation,
              isAiming: player.isAiming,
              isShooting: player.isShooting,
              isReloading: player.isReloading,
              health: player.health
            });
          }
          break;

        case 'shoot':
          // Notify others that this player fired
          broadcastToOthers(playerId, {
            type: 'playerShoot',
            id: playerId,
            bulletData: data.bulletData
          });
          break;

        case 'playerHit':
          // data.targetId, data.hitData
          const targetId = parseInt(data.targetId);
          console.log(`Player ${targetId} was hit by player ${playerId}`);
          const targetPlayer = players.get(targetId);
          if (targetPlayer && targetPlayer.ws.readyState === WebSocket.OPEN) {
            // Reduce health by a fixed amount (e.g., 20)
            targetPlayer.health = Math.max(targetPlayer.health - 20, 0);
            // Inform the target
            targetPlayer.ws.send(JSON.stringify({
              type: 'hit',
              sourceId: playerId,
              hitData: data.hitData,
              health: targetPlayer.health
            }));
          }
          // Broadcast a "playerHit" to everyone with updated health
          broadcastToAll({
            type: 'playerHit',
            targetId: data.targetId,
            sourceId: playerId,
            hitPosition: data.hitData.position,
            health: targetPlayer ? targetPlayer.health : 0
          });
          break;

        case 'ping':
          // respond
          ws.send(JSON.stringify({ type: 'pong' }));
          break;

        default:
          break;
      }
    } catch (err) {
      console.error('Error processing message:', err);
    }
  });

  // On close
  ws.on('close', () => {
    cleanupPlayer(playerId);
  });

  // On error
  ws.on('error', (err) => {
    console.error(`WebSocket error for player ${playerId}:`, err);
    cleanupPlayer(playerId);
  });

  // Update the global player count UI
  updatePlayerCount();
});

// Cleanup a disconnected or stale player
function cleanupPlayer(playerId) {
  const player = players.get(playerId);
  if (player) {
    console.log(`Player ${playerId} disconnected`);
    if (player.sessionId) {
      sessions.delete(player.sessionId);
    }
    players.delete(playerId);

    // Notify all that the player left
    broadcastToAll({
      type: 'playerLeft',
      id: playerId
    });

    updatePlayerCount();
  }
}

// Broadcast a "playerCount" update to all
function updatePlayerCount() {
  broadcastToAll({
    type: 'playerCount',
    count: players.size
  });
}

// Broadcast to all except a given playerId
function broadcastToOthers(excludeId, data) {
  for (const [pid, pl] of players.entries()) {
    if (pid === excludeId) continue;
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Broadcast to all players
function broadcastToAll(data) {
  for (const [pid, pl] of players.entries()) {
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Heartbeat to remove stale connections
const HEARTBEAT_INTERVAL = 30000; // 30s
const CONNECTION_TIMEOUT = 60000; // 60s

setInterval(() => {
  const now = Date.now();
  for (const [id, player] of players.entries()) {
    if (now - player.lastActivity > CONNECTION_TIMEOUT) {
      console.log(`Removing stale connection for player ${id}`);
      if (player.ws.readyState === WebSocket.OPEN) {
        player.ws.close(1000, 'Connection timeout');
      }
      cleanupPlayer(id);
    } else if (player.ws.readyState === WebSocket.OPEN) {
      // keep alive
      player.ws.send(JSON.stringify({ type: 'ping' }));
    }
  }
}, HEARTBEAT_INTERVAL);

// Start server
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  
  // If the environment variable USE_NGROK is set to 'true', start an ngrok tunnel.
  if (process.env.USE_NGROK === 'true') {
    // Dynamically require ngrok so it is only used when needed.
    const ngrok = require('ngrok');
    (async function() {
      try {
        // Connect ngrok to the same port that the server is running on.
        const url = await ngrok.connect({
          addr: PORT,
          // You can add additional ngrok options here (e.g., authtoken, subdomain, region)
        });
        console.log(`ngrok tunnel established at ${url}`);
      } catch (error) {
        console.error('Error starting ngrok tunnel:', error);
      }
    })();
  }
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Server shutting down...');
  for (const [id, player] of players.entries()) {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.close(1000, 'Server shutting down');
    }
  }
  server.close(() => {
    console.log('Server shutdown complete.');
    process.exit(0);
  });
});
    </codebase>
</context>

<goal>
 
</goal>

<output_requirements>
- Don't be lazy, provide thorough, high-quality code.
- Provide complete file contents for any modified or new files.
- Write clean, well-documented code with appropriate error handling.
- Never use ellipsis (...) or placeholder comments, as an excuse to omit code for brewity.
</output_requirements>

<context>
    <codebase>
Directory structure:
└── /./
    ├── config.yml
    ├── package.json
    ├── public/
    │   ├── css/
    │   │   └── style.css
    │   ├── index.html
    │   ├── js/
    │   │   ├── bullet.js
    │   │   ├── effects.js
    │   │   ├── input.js
    │   │   ├── main.js
    │   │   ├── multiplayerManager.js
    │   │   ├── network.js
    │   │   ├── physics.js
    │   │   ├── player.js
    │   │   ├── playerModel.js
    │   │   ├── quickDraw.js
    │   │   ├── revolver.js
    │   │   ├── scene.js
    │   │   ├── smokeRingEffect.js
    │   │   ├── soundManager.js
    │   │   └── ui.js
    │   ├── models/
    │   │   └── lowpolygun.glb
    │   └── sounds/
    └── server.js

================================================
File: /config.yml
================================================
version: "3"
credentials-file: "C:\\Users\\erase\\.cloudflared\\5615d921-4c2e-4d70-affd-8696de48a673.json"

ingress:
  # This rule forwards all requests from the tunnel hostname to the local Express server.
  - hostname: tunnel.oneclickwaitlist.com
    path: /
    service: http://localhost:8080
    originRequest:
      connectTimeout: 10s
      noTLSVerify: true
      proxyAddress: ""
      proxyPort: 0
      proxyType: ""
      kernelSocketOptions:
        - mark: 0
        - keepalive: true
      wsTunneling: true
      http2Origin: false
      httpHostHeader: "tunnel.oneclickwaitlist.com"
      disableChunkedEncoding: false

  # Fallback rule: returns 503 if no other rule matches.
  - service: http_status:503

origincert: "C:\\Users\\erase\\.cloudflared\\cert.pem"


================================================
File: /package.json
================================================
{
  "name": "wild-western-shooter",
  "version": "1.0.0",
  "description": "A Three.js Wild Western Shooter game with a Node.js server.",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "ws": "^8.13.0",
    "ngrok": "^4.3.3",
    "cannon": "^0.6.2"
  }
}

================================================
File: /public/css/style.css
================================================
body {
  margin: 0;
  overflow: hidden;
  font-family: 'Courier New', Courier, monospace;
}
#game-container {
  position: relative;
  width: 100vw;
  height: 100vh;
}
#ammo-counter {
  position: absolute;
  bottom: 20px;
  right: 20px;
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
}
#reload-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  background-color: rgba(0,0,0,0.5);
  padding: 10px;
  border-radius: 5px;
  display: none;
}
#reload-progress-container {
  position: absolute;
  bottom: 60px;
  right: 20px;
  width: 200px;
  height: 20px;
  background-color: rgba(0,0,0,0.5);
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-progress-bar {
  height: 100%;
  width: 0%;
  background-color: #FF6B00;
  border-radius: 10px;
  transition: width 0.05s linear;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border: 2px solid white;
  border-radius: 50%;
  display: none; /* Always keep it hidden to make the game more realistic */
}
#crosshair::before,
#crosshair::after {
  content: '';
  position: absolute;
  background-color: white;
}
#crosshair::before {
  width: 2px;
  height: 10px;
  top: 5px;
  left: 9px;
}
#crosshair::after {
  width: 10px;
  height: 2px;
  top: 9px;
  left: 5px;
}
#fps-counter {
  position: absolute;
  top: 20px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#player-count {
  position: absolute;
  top: 50px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#connection-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
}
#network-status {
  position: absolute;
  top: 80px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 5px;
  border-radius: 5px;
  transition: opacity 1s;
}

/* Quick Draw game mode styles */
#quick-draw-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 48px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  z-index: 1000;
}

#draw-circle {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 300px;
  height: 300px;
  border-radius: 50%;
  border: 8px solid #FF0000;
  box-shadow: 0 0 20px #FF0000;
  opacity: 0;
  transition: transform 0.3s, opacity 0.3s;
  pointer-events: none;
  z-index: 999;
  display: none;
}

@keyframes portalPulse {
  0% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
  100% { transform: scale(1); opacity: 0.8; }
}

@keyframes drawCircleAnim {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
  80% { transform: translate(-50%, -50%) scale(3); opacity: 0.8; }
  100% { transform: translate(-50%, -50%) scale(4); opacity: 0; }
}

.portal-animation {
  animation: portalPulse 2s infinite ease-in-out;
}

.draw-circle-animation {
  animation: drawCircleAnim 0.3s ease-out forwards;
}

/* Styling for Quick Draw countdown */
#quick-draw-countdown {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 72px;
  font-weight: bold;
  text-align: center;
  display: none;
  font-family: 'Western', Arial, sans-serif;
  text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.7);
  z-index: 1001;
}

/* Styling for winner/loser message */
.quick-draw-winner {
  color: #4CAF50 !important;
  text-shadow: 0 0 10px #4CAF50, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

.quick-draw-loser {
  color: #F44336 !important;
  text-shadow: 0 0 10px #F44336, 2px 2px 6px rgba(0, 0, 0, 0.7) !important;
}

/* Styling for gun locked warning */
.gun-locked-warning {
  color: #F44336 !important;
  font-size: 36px !important;
  animation: flashWarning 0.5s infinite alternate;
}

@keyframes flashWarning {
  0% { opacity: 0.7; }
  100% { opacity: 1; }
}

#quick-draw-status {
  position: absolute;
  top: 120px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(0,0,0,0.5);
  padding: 8px 12px;
  border-radius: 5px;
  transition: background-color 0.3s ease;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

#portal-instructions {
  position: absolute;
  background-color: rgba(0,0,0,0.8);
  border: 2px solid #FF6B00;
  border-radius: 8px;
  padding: 15px;
  width: 400px;
  text-align: center;
  box-shadow: 0 0 15px rgba(255, 107, 0, 0.6);
  color: #EEEEEE;
  font-family: 'Courier New', Courier, monospace;
  z-index: 100;
  transition: opacity 0.3s ease;
}

#portal-instructions h2 {
  color: #FF6B00;
  font-family: 'Western', 'Courier New', Courier, monospace;
  text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
  margin-bottom: 10px;
  font-size: 22px;
}

#portal-instructions p {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.4;
}

#portal-instructions ul {
  text-align: left;
  margin-top: 10px;
  padding-left: 20px;
  font-size: 14px;
  line-height: 1.5;
}

#portal-instructions li {
  margin-bottom: 5px;
  list-style-type: square;
}

/* Lobby display for showing which arena the player is in */
#lobby-indicator {
  position: absolute;
  top: 150px;
  left: 20px;
  color: white;
  font-size: 16px;
  background-color: rgba(255, 107, 0, 0.7);
  padding: 8px 12px;
  border-radius: 5px;
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  display: none;
}

@font-face {
  font-family: 'Western';
  src: url('https://fonts.gstatic.com/s/oldstandard/v14/MwQrbh3o1vLImiwAVvYawgcf2eVer2i0.woff2') format('woff2');
  font-weight: bold;
  font-style: normal;
}

================================================
File: /public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wild Western FPS – Multiplayer</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div id="game-container">
    <div id="ammo-counter">Bullets: 6/6</div>
    <div id="health-counter">Health: 100</div>
    <div id="reload-message">Hold R to reload</div>
    <div id="reload-progress-container">
      <div id="reload-progress-bar"></div>
    </div>
    <div id="crosshair"></div>
    <div id="fps-counter">FPS: 0</div>
    <div id="player-count">Players: 1</div>
    <div id="connection-status"></div>
  </div>

  <!-- Three.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- GLTFLoader for loading the GLB gun model -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Cannon.js for physics (non-ES module version) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  <!-- Main JS as ES6 module -->
  <script type="module" src="js/main.js"></script>
</body>
</html>

================================================
File: /public/js/bullet.js
================================================
import { createImpactEffect } from './effects.js';

/**
 * A simple bullet that checks collisions by seeing if its end position
 * is inside bounding boxes (NPC or players).
 */
export class Bullet {
  constructor(position, direction) {
    this.mesh = new THREE.Mesh(
      new THREE.SphereGeometry(0.02, 8, 8),
      new THREE.MeshStandardMaterial({ color: 0xB8860B })
    );
    this.mesh.position.copy(position);

    this.direction = direction.clone();
    this.speed = 80; // speed units/second
    this.distanceTraveled = 0;
    this.maxDistance = 100;

    // Remember previous position for some rough continuous detection
    this.lastPosition = position.clone();

    // Track which player fired this bullet
    this.sourcePlayerId = null;
    
    // Add collision detection raycaster
    this.raycaster = new THREE.Raycaster(position.clone(), direction.clone(), 0, 0.1);
  }

  /**
   * Sets the player ID that fired this bullet.
   * @param {string|number} playerId - The ID of the player who fired the bullet.
   */
  setSourcePlayer(playerId) {
    this.sourcePlayerId = playerId;
  }

  /**
   * Updates the bullet's movement & handles collisions with NPC or players.
   * Uses a simpler .containsPoint() approach so it won't throw an error on r128.
   * @param {number} deltaTime
   * @param {THREE.Group} npc
   * @param {THREE.Scene} scene
   * @param {Map<number, object>} allPlayers - Map of local + remote players.
   */
  update(deltaTime, npc, scene, allPlayers) {
    // Previous position for boundary crossing detection
    this.lastPosition = this.mesh.position.clone();
    
    // FIRST CHECK: Before moving, check if bullet is already within arena but from an unauthorized player
    if (window.quickDraw && window.quickDraw.isPointInArena(this.mesh.position)) {
      const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
      const isPlayerInDuel = window.quickDraw.inDuel;
      const isOpponentBullet = window.quickDraw.duelOpponentId === Number(this.sourcePlayerId);
      
      // If bullet is inside arena but not from a duel player, destroy it immediately
      if (!(isPlayerInDuel && isLocalPlayerBullet) && !isOpponentBullet) {
        console.log("Destroying unauthorized bullet inside arena from player " + this.sourcePlayerId);
        createImpactEffect(this.mesh.position, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'arena', position: this.mesh.position } };
      }
    }
    
    // Move the bullet
    const displacement = this.direction.clone().multiplyScalar(this.speed * deltaTime);
    this.mesh.position.add(displacement);
    this.distanceTraveled += displacement.length();

    // Current bullet position
    const endPos = this.mesh.position.clone();
    
    // Check if crossing Quick Draw arena boundary using the physics system
    if (window.quickDraw && window.quickDraw.physics) {
      const physics = window.quickDraw.physics;
      
      // Check if bullet is crossing the arena boundary
      const bulletInArena = window.quickDraw.isPointInArena(endPos);
      const prevInArena = window.quickDraw.isPointInArena(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInArena !== prevInArena;
      
      // If the bullet is crossing the boundary
      if (bulletCrossingBoundary) {
        const playerInDuel = window.quickDraw.inDuel;
        const isLocalPlayerBullet = Number(this.sourcePlayerId) === Number(window.localPlayer.id);
        
        // Case 1: Player in duel and their bullet trying to exit
        if (playerInDuel && isLocalPlayerBullet && !bulletInArena) {
          console.log("Bullet hit arena boundary (exiting) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 2: Player outside trying to shoot in
        if (!playerInDuel && isLocalPlayerBullet && bulletInArena) {
          console.log("Bullet from outside entering arena - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 3: Bullet from duel player hitting boundary from inside
        if (playerInDuel && !isLocalPlayerBullet && !bulletInArena) {
          console.log("Bullet from other duel player hitting boundary (exiting) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
        
        // Case 4: Bullet from outside player hitting boundary from outside
        if (!playerInDuel && !isLocalPlayerBullet && bulletInArena) {
          console.log("Bullet from outside player hitting boundary (entering) - destroying it");
          createImpactEffect(endPos, this.direction, scene, 'ground');
          return { active: false, hit: { type: 'arena', position: endPos } };
        }
      }
    }

    // Check if crossing town boundary using the physics system
    if (window.physics && typeof window.physics.isPointInTown === 'function') {
      const bulletInTown = window.physics.isPointInTown(endPos);
      const prevInTown = window.physics.isPointInTown(this.lastPosition);
      
      // Calculate if bullet is crossing the boundary
      const bulletCrossingBoundary = bulletInTown !== prevInTown;
      
      // If the bullet is crossing the boundary, destroy it
      if (bulletCrossingBoundary) {
        console.log("Bullet hit town boundary - destroying it");
        createImpactEffect(endPos, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'boundary', position: endPos } };
      }
    } else if (window.townDimensions) {
      // Fallback if physics isn't available but town dimensions are
      const width = window.townDimensions.width;
      const length = window.townDimensions.length;
      
      // Check if bullet is outside town boundary
      if (
        endPos.x < -width / 2 || 
        endPos.x > width / 2 || 
        endPos.z < -length / 2 || 
        endPos.z > length / 2
      ) {
        console.log("Bullet hit town boundary - destroying it");
        createImpactEffect(endPos, this.direction, scene, 'ground');
        return { active: false, hit: { type: 'boundary', position: endPos } };
      }
    }

    // 1) Check collision with NPC
    if (npc) {
      const npcBox = new THREE.Box3().setFromObject(npc);
      npcBox.expandByScalar(0.2);
      if (npcBox.containsPoint(endPos)) {
        createImpactEffect(endPos, this.direction, scene, 'npc');
        return { active: false, hit: { type: 'npc', target: npc } };
      }
    }

    // 2) Check collision with players
    if (allPlayers) {
      for (const [playerId, playerObj] of allPlayers.entries()) {
        // Skip bullet's owner by converting both IDs to numbers
        if (Number(playerId) === Number(this.sourcePlayerId)) continue;
        if (!playerObj || !playerObj.group) continue;

        // Get player's base position for collision box.
        // For local players (first-person), group.position is at eye-level so subtract 1.6.
        // Remote players (third-person) have group.position at the base.
        const playerPos = playerObj.group.position.clone();
        let baseY = playerPos.y;
        if (playerObj.camera) { // local player
          baseY = playerPos.y - 1.6;
        }
        const boxMin = new THREE.Vector3(
          playerPos.x - 0.5,
          baseY,
          playerPos.z - 0.5
        );
        const boxMax = new THREE.Vector3(
          playerPos.x + 0.5,
          baseY + 2.0,
          playerPos.z + 0.5
        );
        const playerBox = new THREE.Box3(boxMin, boxMax);
        if (playerBox.containsPoint(endPos)) {
          createImpactEffect(endPos, this.direction, scene, 'player');
          
          // Prevent hits across arena boundary
          // Only allow hits if both players are in the same area (both in arena or both outside)
          const bulletPlayerInArena = window.quickDraw && window.quickDraw.inDuel;
          const targetPlayerInArena = window.quickDraw && 
                                     window.quickDraw.duelOpponentId === Number(playerId);
          
          if (bulletPlayerInArena !== targetPlayerInArena) {
            console.log("Bullet hit blocked - players in different areas");
            return { active: false, hit: { type: 'arena', position: endPos } };
          }
          
          // Notify server we hit this player
          if (window.networkManager) {
            window.networkManager.sendPlayerHit(playerId, {
              position: { x: endPos.x, y: endPos.y, z: endPos.z },
              sourcePlayerId: this.sourcePlayerId
            });
            
            // Quick Draw duels with better logging
            if (window.quickDraw && window.quickDraw.inDuel && 
                window.quickDraw.duelState === 'draw' && 
                Number(playerId) === Number(window.quickDraw.duelOpponentId) && 
                Number(this.sourcePlayerId) === Number(window.localPlayer.id)) {
                
                console.log('Quick Draw hit detected! Notifying server player ' + this.sourcePlayerId + ' hit player ' + playerId);
                // Send special Quick Draw hit notification
                window.networkManager.sendQuickDrawShoot(playerId);
            }
          }
          return { active: false, hit: { type: 'player', playerId } };
        }
      }
    }

    // 3) Check collision with ground
    if (this.mesh.position.y <= 0.1) {
      createImpactEffect(endPos, this.direction, scene, 'ground');
      return { active: false, hit: { type: 'ground', position: endPos } };
    }

    // 4) If bullet exceeded max distance, remove it.
    if (this.distanceTraveled >= this.maxDistance) {
      return { active: false, hit: null };
    }

    // Still active
    return { active: true, hit: null };
  }
}

================================================
File: /public/js/effects.js
================================================
// Import the SmokeRingEffect class 
import { SmokeRingEffect } from './smokeRingEffect.js';

/**
 * Recursively disposes geometry and material for the given object.
 * @param {THREE.Object3D} object - The object to dispose.
 */
function disposeHierarchy(object) {
  object.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) {
      if (Array.isArray(child.material)) {
        child.material.forEach(mat => mat.dispose());
      } else {
        child.material.dispose();
      }
    }
  });
}

/**
 * Helper for spring interpolation used in recoil recovery.
 * @param {number} start - The starting value.
 * @param {number} end - The target value.
 * @param {number} t - Normalized time.
 * @param {number} damping - Damping coefficient.
 * @param {number} frequency - Oscillation frequency.
 * @returns {number} - The interpolated value.
 */
function springInterpolation(start, end, t, damping, frequency) {
  const decay = Math.exp(-damping * t);
  return end + (start - end) * decay * (1 + (damping / frequency) * Math.sin(frequency * t));
}

/**
 * Creates a muzzle flash effect at the given position.
 * @param {THREE.Vector3} position - Effect position.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createMuzzleFlash(position, scene) {
  const flashGroup = new THREE.Group();
  flashGroup.position.copy(position);
  scene.add(flashGroup);

  const coreGeometry = new THREE.SphereGeometry(0.05, 8, 8);
  const coreMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 1
  });
  const core = new THREE.Mesh(coreGeometry, coreMaterial);
  flashGroup.add(core);

  const middleGeometry = new THREE.SphereGeometry(0.08, 8, 8);
  const middleMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFF00,
    transparent: true,
    opacity: 0.8
  });
  const middle = new THREE.Mesh(middleGeometry, middleMaterial);
  middle.scale.x = 1.5;
  flashGroup.add(middle);

  const outerGeometry = new THREE.SphereGeometry(0.12, 8, 8);
  const outerMaterial = new THREE.MeshBasicMaterial({
    color: 0xFF6B00,
    transparent: true,
    opacity: 0.5
  });
  const outer = new THREE.Mesh(outerGeometry, outerMaterial);
  outer.scale.x = 2;
  flashGroup.add(outer);

  const particleCount = 8;
  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.02, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFF00,
      transparent: true,
      opacity: 0.7
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    const angle = Math.random() * Math.PI * 2;
    const radius = 0.05 + Math.random() * 0.1;
    particle.position.set(
      Math.cos(angle) * radius,
      Math.sin(angle) * radius,
      (Math.random() - 0.5) * 0.1
    );
    flashGroup.add(particle);
  }

  const flashLight = new THREE.PointLight(0xFF9900, 1, 2);
  flashLight.position.set(0, 0, 0);
  flashGroup.add(flashLight);

  const duration = 100;
  const startTime = performance.now();

  function animateFlash(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      core.scale.multiplyScalar(0.95);
      const fadeOpacity = 1 - progress;
      coreMaterial.opacity = fadeOpacity;
      middleMaterial.opacity = fadeOpacity * 0.8;
      outerMaterial.opacity = fadeOpacity * 0.5;
      flashLight.intensity = 1 - progress;
      requestAnimationFrame(animateFlash);
    } else {
      scene.remove(flashGroup);
      disposeHierarchy(flashGroup);
    }
  }
  requestAnimationFrame(animateFlash);
}

/**
 * Creates a smoke effect emanating from a given position.
 * @param {THREE.Vector3} position - Start position.
 * @param {THREE.Vector3} direction - Direction of smoke.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createSmokeEffect(position, direction, scene) {
  const particleCount = 30;
  const particles = [];
  const smokeGroup = new THREE.Group();
  smokeGroup.position.copy(position);
  scene.add(smokeGroup);

  const smokeColors = [
    new THREE.Color(0.9, 0.9, 0.9),
    new THREE.Color(0.8, 0.8, 0.8),
    new THREE.Color(0.7, 0.7, 0.7),
    new THREE.Color(0.6, 0.6, 0.6)
  ];

  for (let i = 0; i < particleCount; i++) {
    const size = 0.01 + Math.random() * 0.03;
    const smokeGeometry = new THREE.SphereGeometry(size, 6, 6);
    const colorIndex = Math.floor(Math.random() * smokeColors.length);
    const smokeColor = smokeColors[colorIndex];
    const smokeMaterial = new THREE.MeshBasicMaterial({
      color: smokeColor,
      transparent: true,
      opacity: 0.3 + Math.random() * 0.4
    });
    const smokeParticle = new THREE.Mesh(smokeGeometry, smokeMaterial);
    smokeParticle.position.set(
      (Math.random() - 0.5) * 0.05,
      (Math.random() - 0.5) * 0.05,
      (Math.random() - 0.5) * 0.05
    );
    let particleDir = direction.clone();
    particleDir.x += (Math.random() - 0.5) * 0.6;
    particleDir.y += (Math.random() - 0.5) * 0.2 + 0.2;
    particleDir.z += (Math.random() - 0.5) * 0.6;
    particleDir.normalize();
    const speed = 0.02 + Math.random() * 0.08;
    const velocity = particleDir.multiplyScalar(speed);
    const rotationSpeed = {
      x: (Math.random() - 0.5) * 0.02,
      y: (Math.random() - 0.5) * 0.02,
      z: (Math.random() - 0.5) * 0.02
    };
    smokeGroup.add(smokeParticle);
    particles.push({
      mesh: smokeParticle,
      velocity: velocity,
      rotationSpeed: rotationSpeed,
      life: 40 + Math.floor(Math.random() * 60),
      maxLife: 40 + Math.floor(Math.random() * 60),
      size: size,
      growth: 0.005 + Math.random() * 0.01
    });
  }

  const interval = setInterval(() => {
    let allDead = true;
    particles.forEach(p => {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.velocity.multiplyScalar(0.98);
        p.velocity.x += (Math.random() - 0.5) * 0.001;
        p.velocity.z += (Math.random() - 0.5) * 0.001;
        p.velocity.y += 0.0008;
        p.mesh.rotation.x += p.rotationSpeed.x;
        p.mesh.rotation.y += p.rotationSpeed.y;
        p.mesh.rotation.z += p.rotationSpeed.z;
        const scale = p.size + (p.growth * (p.maxLife - p.life));
        p.mesh.scale.set(scale, scale, scale);
        const lifeRatio = p.life / p.maxLife;
        p.mesh.material.opacity = lifeRatio * 0.5;
        p.life--;
        allDead = false;
      } else {
        smokeGroup.remove(p.mesh);
        p.mesh.geometry.dispose();
        p.mesh.material.dispose();
      }
    });
    if (allDead) {
      clearInterval(interval);
      scene.remove(smokeGroup);
    }
  }, 16);
}

/**
 * Creates a shockwave ring effect in the shooting direction.
 * @param {THREE.Vector3} position - Effect start position.
 * @param {THREE.Vector3} direction - Firing direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 */
export function createShockwaveRing(position, direction, scene) {
  const shockwaveGroup = new THREE.Group();
  shockwaveGroup.position.copy(position);
  shockwaveGroup.lookAt(position.clone().add(direction));
  scene.add(shockwaveGroup);

  const distortionGeometry = new THREE.CircleGeometry(0.08, 32);
  const distortionMaterial = new THREE.MeshBasicMaterial({
    color: 0xFFFFFF,
    transparent: true,
    opacity: 0.2,
    blending: THREE.AdditiveBlending
  });
  const distortion = new THREE.Mesh(distortionGeometry, distortionMaterial);
  shockwaveGroup.add(distortion);

  const lineCount = 18;
  const speedLines = [];
  const speedLineColors = [0xFFFFFF, 0xFFFF00, 0xFF9900, 0xFF6600];

  for (let i = 0; i < lineCount; i++) {
    const lineLength = 0.2 + Math.random() * 0.6;
    const lineWidth = 0.003 + Math.random() * 0.005;
    const lineGeometry = new THREE.BoxGeometry(lineWidth, lineWidth, lineLength);
    lineGeometry.translate(0, 0, lineLength / 2);
    const colorIndex = Math.floor(Math.random() * speedLineColors.length);
    const lineColor = speedLineColors[colorIndex];
    const lineMaterial = new THREE.MeshBasicMaterial({
      color: lineColor,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending
    });
    const line = new THREE.Mesh(lineGeometry, lineMaterial);
    const spreadAngle = 15 * (Math.PI / 180);
    line.rotation.x = (Math.random() - 0.5) * spreadAngle;
    line.rotation.y = (Math.random() - 0.5) * spreadAngle;
    line.scale.z = 0.1;
    shockwaveGroup.add(line);
    speedLines.push({
      mesh: line,
      material: lineMaterial,
      maxLength: 1 + Math.random() * 2,
      speed: 0.8 + Math.random() * 0.4,
      delay: Math.random() * 50
    });
  }

  const particleCount = 12;
  const particles = [];

  for (let i = 0; i < particleCount; i++) {
    const particleGeometry = new THREE.SphereGeometry(0.01, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xFFFF00,
      transparent: true,
      opacity: 0.6
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    const angle = Math.random() * Math.PI * 0.25;
    const radius = 0.02 + Math.random() * 0.06;
    particle.position.z = Math.cos(angle) * radius;
    const circleAngle = Math.random() * Math.PI * 2;
    particle.position.x = Math.sin(angle) * Math.cos(circleAngle) * radius;
    particle.position.y = Math.sin(angle) * Math.sin(circleAngle) * radius;
    const velocity = new THREE.Vector3(
      particle.position.x * (0.5 + Math.random() * 0.5),
      particle.position.y * (0.5 + Math.random() * 0.5),
      0.05 + Math.random() * 0.1
    );
    shockwaveGroup.add(particle);
    particles.push({
      mesh: particle,
      velocity: velocity,
      life: 10 + Math.floor(Math.random() * 15)
    });
  }

  const flashLight = new THREE.PointLight(0xFF9900, 1, 2);
  flashLight.position.set(0, 0, 0);
  shockwaveGroup.add(flashLight);

  const duration = 350;
  const startTime = performance.now();

  function animateShockwave(timestamp) {
    const elapsed = timestamp - startTime;
    const progress = elapsed / duration;
    if (progress < 1) {
      speedLines.forEach(line => {
        if (elapsed > line.delay) {
          const lineProgress = Math.min((elapsed - line.delay) / (duration - line.delay), 1);
          if (lineProgress < 0.5) {
            const scaleProgress = lineProgress * 2;
            line.mesh.scale.z = line.maxLength * scaleProgress;
          } else {
            line.material.opacity = 0.7 * (1 - ((lineProgress - 0.5) * 2));
          }
        }
      });
      const distortionScale = 1 + progress * 5;
      distortion.scale.set(distortionScale, distortionScale, 1);
      distortionMaterial.opacity = 0.2 * (1 - progress);

      particles.forEach(p => {
        if (p.life > 0) {
          p.mesh.position.add(p.velocity);
          p.mesh.material.opacity = (p.life / 25) * 0.6;
          p.life--;
        } else {
          shockwaveGroup.remove(p.mesh);
        }
      });

      flashLight.intensity = 1 - progress;
      requestAnimationFrame(animateShockwave);
    } else {
      scene.remove(shockwaveGroup);
      disposeHierarchy(shockwaveGroup);
    }
  }
  requestAnimationFrame(animateShockwave);
}

/**
 * Creates an impact effect when a bullet hits a target.
 * Instead of a red disk, this new effect emits particles in the opposite direction
 * of the bullet's travel. When the bullet hits a body (player or NPC), the particles
 * are red (blood). When it hits the ground/solid, the particles are brown (splatter).
 *
 * The particle velocities have been reduced so that they stay near the impact point.
 *
 * Additionally, this function now plays an impact sound:
 * - If hitType is 'ground', "woodimpact.mp3" is played.
 * - If hitType is 'player', "fleshimpact.mp3" is played at the impact position.
 *
 * @param {THREE.Vector3} position - Impact position.
 * @param {THREE.Vector3} direction - Impact (bullet) direction.
 * @param {THREE.Scene} scene - The scene to add the effect.
 * @param {string} hitType - Type of impact: 'player', 'npc', or 'ground'.
 */
export function createImpactEffect(position, direction, scene, hitType) {
  const effectGroup = new THREE.Group();
  effectGroup.position.copy(position);
  scene.add(effectGroup);
  
  // Play impact sound based on hit type using positional audio
  if (window.localPlayer && window.localPlayer.soundManager) {
    if (hitType === 'ground') {
      window.localPlayer.soundManager.playSoundAt("woodimpact", position);
    } else if (hitType === 'player') {
      window.localPlayer.soundManager.playSoundAt("fleshimpact", position);
    }
  }

  // Choose color: red for body impacts, brown for ground.
  const color = (hitType === 'ground') ? 0x8B4513 : 0xFF0000;

  const particleCount = 15;
  const particles = [];
  for (let i = 0; i < particleCount; i++) {
    const size = 0.03 * (0.8 + Math.random() * 0.4);
    const particleGeometry = new THREE.SphereGeometry(size, 4, 4);
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: color,
      transparent: true,
      opacity: 1
    });
    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
    effectGroup.add(particle);
    // Use a reduced speed so particles stay close to the impact spot.
    const velocity = direction.clone().negate();
    const speed = 0.05 + Math.random() * 0.05;
    velocity.multiplyScalar(speed);
    velocity.x += (Math.random() - 0.5) * 0.05;
    velocity.y += (Math.random() - 0.5) * 0.05;
    velocity.z += (Math.random() - 0.5) * 0.05;
    particles.push({ mesh: particle, velocity: velocity, life: 30 + Math.floor(Math.random() * 20) });
  }

  const duration = 500; // in ms
  const startTime = performance.now();

  function animateEffect() {
    const elapsed = performance.now() - startTime;
    const t = elapsed / duration;
    for (const p of particles) {
      if (p.life > 0) {
        p.mesh.position.add(p.velocity);
        p.mesh.material.opacity = Math.max(1 - t, 0);
        if (hitType === 'ground') {
          p.velocity.y -= 0.005; // gravity effect on ground splatter
        }
        p.life--;
      }
    }
    if (elapsed < duration) {
      requestAnimationFrame(animateEffect);
    } else {
      scene.remove(effectGroup);
      effectGroup.traverse(child => {
        if (child.isMesh) {
          child.geometry.dispose();
          child.material.dispose();
        }
      });
    }
  }
  requestAnimationFrame(animateEffect);
}

/**
 * Applies a realistic recoil effect.
 * @param {Player} player - The player instance.
 */
export function applyRecoil(player) {
  const originalAimOffset = player.aimOffset.clone();
  const originalFOV = player.camera.fov;
  const originalCameraPos = player.camera.position.clone();
  const originalRotation = player.camera.rotation.clone();

  // Initial recoil changes.
  player.camera.rotation.x -= 0.08;
  player.camera.rotation.z += 0.01;
  player.aimOffset.z += 0.4;
  player.aimOffset.y += 0.15;
  player.aimOffset.x += 0.05;
  player.camera.fov -= 5;
  player.camera.updateProjectionMatrix();

  const recoilSteps = [
    { time: 20, cameraX: -0.04, cameraZ: 0.005, offsetZ: 0.2, offsetY: 0.08, offsetX: 0.03 },
    { time: 40, cameraX: -0.06, cameraZ: 0.008, offsetZ: 0.3, offsetY: 0.12, offsetX: 0.04 },
    { time: 60, cameraX: -0.03, cameraZ: 0.006, offsetZ: 0.25, offsetY: 0.1, offsetX: 0.02 },
    { time: 80, cameraX: -0.02, cameraZ: 0.004, offsetZ: 0.18, offsetY: 0.07, offsetX: 0.01 },
    { time: 100, cameraX: -0.01, cameraZ: 0.002, offsetZ: 0.1, offsetY: 0.05, offsetX: 0.005 }
  ];

  recoilSteps.forEach(step => {
    setTimeout(() => {
      player.camera.rotation.x = originalRotation.x + step.cameraX;
      player.camera.rotation.z = originalRotation.z + step.cameraZ;
      player.aimOffset.z = originalAimOffset.z + step.offsetZ;
      player.aimOffset.y = originalAimOffset.y + step.offsetY;
      player.aimOffset.x = originalAimOffset.x + step.offsetX;
    }, step.time);
  });

  let shakeIntensity = 0.03;
  const shakeDecay = 0.9;
  const shakeInterval = setInterval(() => {
    if (shakeIntensity > 0.002) {
      player.camera.position.x = originalCameraPos.x + (Math.random() - 0.5) * shakeIntensity;
      player.camera.position.y = originalCameraPos.y + (Math.random() - 0.5) * shakeIntensity;
      shakeIntensity *= shakeDecay;
    } else {
      clearInterval(shakeInterval);
      player.camera.position.copy(originalCameraPos);
    }
  }, 16);

  let progress = 0;
  const duration = 400;
  const startTime = performance.now();

  function recoverFromRecoil(timestamp) {
    progress = (timestamp - startTime) / duration;
    if (progress < 1) {
      const t = progress * 4;
      player.camera.rotation.x = springInterpolation(
        player.camera.rotation.x,
        originalRotation.x,
        t,
        0.4,
        8
      );
      player.camera.rotation.z = springInterpolation(
        player.camera.rotation.z,
        originalRotation.z,
        t,
        0.4,
        8
      );
      player.aimOffset.x = springInterpolation(
        player.aimOffset.x,
        originalAimOffset.x,
        t,
        0.4,
        8
      );
      player.aimOffset.y = springInterpolation(
        player.aimOffset.y,
        originalAimOffset.y,
        t,
        0.4,
        8
      );
      player.aimOffset.z = springInterpolation(
        player.aimOffset.z,
        originalAimOffset.z,
        t,
        0.4,
        8
      );
      player.camera.fov = THREE.MathUtils.lerp(
        player.camera.fov,
        originalFOV,
        progress * 0.3
      );
      player.camera.updateProjectionMatrix();
      requestAnimationFrame(recoverFromRecoil);
    } else {
      player.camera.rotation.copy(originalRotation);
      player.aimOffset.copy(originalAimOffset);
      player.camera.fov = originalFOV;
      player.camera.updateProjectionMatrix();
      player.camera.position.copy(originalCameraPos);
    }
  }
  requestAnimationFrame(recoverFromRecoil);
}

/**
 * Enhanced shell ejection with realistic physics.
 * @param {Player} player - The player instance.
 * @param {THREE.Scene} scene - The scene to add the shell.
 * @param {SoundManager} soundManager - For playing sound effects.
 */
export function ejectShell(player, scene, soundManager) {
  const shellGroup = new THREE.Group();

  const shellGeometry = new THREE.CylinderGeometry(0.01, 0.015, 0.04, 8);
  const shellMaterial = new THREE.MeshStandardMaterial({
    color: 0xD4AF37,
    metalness: 0.8,
    roughness: 0.2
  });
  const shell = new THREE.Mesh(shellGeometry, shellMaterial);
  shellGroup.add(shell);

  const primerGeometry = new THREE.CircleGeometry(0.006, 8);
  const primerMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0A0A0,
    metalness: 0.7,
    roughness: 0.3
  });
  const primer = new THREE.Mesh(primerGeometry, primerMaterial);
  primer.position.y = -0.02;
  primer.rotation.x = Math.PI / 2;
  shellGroup.add(primer);

  const shellStart = player.revolver.getBarrelTipWorldPosition();
  shellGroup.position.copy(shellStart);
  shellGroup.position.x += 0.05;
  shellGroup.position.y -= 0.02;
  scene.add(shellGroup);

  const physics = {
    velocity: new THREE.Vector3(
      0.8 + Math.random() * 0.4,
      0.5 + Math.random() * 0.3,
      (Math.random() - 0.5) * 0.2
    ),
    rotationSpeed: new THREE.Vector3(
      Math.random() * 0.2,
      Math.random() * 0.2,
      Math.random() * 0.2
    ),
    gravity: 0.015,
    drag: 0.99
  };

  const duration = 2000;
  const startTime = performance.now();

  function animateShell(timestamp) {
    const elapsed = timestamp - startTime;
    if (elapsed < duration) {
      shellGroup.position.x += physics.velocity.x * 0.016;
      shellGroup.position.y += physics.velocity.y * 0.016;
      shellGroup.position.z += physics.velocity.z * 0.016;
      physics.velocity.y -= physics.gravity;
      physics.velocity.multiplyScalar(physics.drag);
      shellGroup.rotation.x += physics.rotationSpeed.x;
      shellGroup.rotation.y += physics.rotationSpeed.y;
      shellGroup.rotation.z += physics.rotationSpeed.z;

      // Bounce logic on ground impact.
      if (shellGroup.position.y < 0.02 && physics.velocity.y < 0) {
        physics.velocity.y = -physics.velocity.y * 0.6;
        physics.velocity.x *= 0.8;
        physics.velocity.z *= 0.8;
        shellGroup.position.y = 0.02;
        physics.rotationSpeed.x = Math.random() * 0.4;
        physics.rotationSpeed.z = Math.random() * 0.4;
      }
      requestAnimationFrame(animateShell);
    } else {
      scene.remove(shellGroup);
      shellGeometry.dispose();
      shellMaterial.dispose();
      primerGeometry.dispose();
      primerMaterial.dispose();
    }
  }
  requestAnimationFrame(animateShell);
}

// Export the SmokeRingEffect class
export { SmokeRingEffect };

================================================
File: /public/js/input.js
================================================
/**
 * Initializes game input (keyboard + mouse) and pointer lock.
 * @param {THREE.WebGLRenderer} renderer - The renderer instance.
 * @param {Player} player - The local Player instance (first-person).
 * @param {SoundManager} soundManager - The SoundManager for audio feedback.
 */
export function initInput(renderer, player, soundManager) {
  // Request pointer lock on click
  document.body.addEventListener('click', () => {
    if (document.pointerLockElement !== renderer.domElement) {
      renderer.domElement.requestPointerLock();
    }
  });

  // Mouse look
  document.addEventListener('mousemove', (event) => {
    if (document.pointerLockElement === renderer.domElement) {
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;

      // Slightly lower sensitivity when aiming
      const sensitivity = player.isAiming ? 0.001 : 0.002;

      // Yaw
      player.group.rotation.y -= movementX * sensitivity;

      // Pitch (limit to avoid flipping)
      player.camera.rotation.x -= movementY * sensitivity;
      player.camera.rotation.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, player.camera.rotation.x)
      );
    }
  });

  // Keyboard down
  document.addEventListener('keydown', (event) => {
    switch (event.code) {
      case 'KeyW':
        player.moveForward = true;
        break;
      case 'KeyS':
        player.moveBackward = true;
        break;
      case 'KeyA':
        player.moveLeft = true;
        break;
      case 'KeyD':
        player.moveRight = true;
        break;
      case 'Space':
        if (player.canJump) {
          // If sprinting, jump higher
          player.velocity.y = player.isSprinting ? 15 : 10;
          player.canJump = false;
        }
        break;
      case 'KeyR':
        // Start reload
        player.startReload();
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Enable sprinting
        player.isSprinting = true;
        break;
      default:
        break;
    }
  });

  // Keyboard up
  document.addEventListener('keyup', (event) => {
    switch (event.code) {
      case 'KeyW':
        player.moveForward = false;
        break;
      case 'KeyS':
        player.moveBackward = false;
        break;
      case 'KeyA':
        player.moveLeft = false;
        break;
      case 'KeyD':
        player.moveRight = false;
        break;
      case 'ShiftLeft':
      case 'ShiftRight':
        // Disable sprinting
        player.isSprinting = false;
        break;
      default:
        break;
    }
  });

  // Mouse down
  document.addEventListener('mousedown', (event) => {
    // Right-click => Aim (only if canAim is true)
    if (event.button === 2 && player.canAim) {
      player.isAiming = true;
      player.revolver.group.visible = true;
      // Optionally show arms in first-person
      if (player.arms) {
        player.arms.setVisible(true);
      }
      // Removed crosshair display - making the game more realistic

      if (soundManager) {
        soundManager.playSound("aimclick");
      }
    }
    // Left-click => Shoot (only if aiming)
    else if (event.button === 0) {
      if (player.revolver.group.visible && !player.isReloading) {
        player.shoot();
      }
    }
  });

  // Mouse up
  document.addEventListener('mouseup', (event) => {
    // Stop aiming on right-click release
    if (event.button === 2) {
      player.isAiming = false;
      player.revolver.group.visible = false;
      if (player.arms) {
        player.arms.setVisible(false);
      }
      // Removed crosshair display code
    }
  });

  // Prevent context menu on right-click
  document.addEventListener('contextmenu', (event) => {
    event.preventDefault();
  });

  // Handle window resize
  window.addEventListener('resize', () => {
    player.camera.aspect = window.innerWidth / window.innerHeight;
    player.camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

================================================
File: /public/js/main.js
================================================
import { initScene, createNPC, updateNPC, updateFPS, scene } from './scene.js';
import { initInput } from './input.js';
import { SoundManager } from './soundManager.js';
import { Player } from './player.js';
import { networkManager } from './network.js';
import { MultiplayerManager } from './multiplayerManager.js';
import { Bullet } from './bullet.js';
import { createMuzzleFlash, createSmokeEffect, createShockwaveRing, createImpactEffect, SmokeRingEffect } from './effects.js';
import { QuickDraw } from './quickDraw.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { PhysicsSystem } from './physics.js';

// Keep track of all bullets in the game, both local and remote
let bullets = [];

// We'll keep references to local player, remote players, and a combined map
let localPlayer;
let remotePlayers = new Map();  // (playerId => ThirdPersonModel)
let playersMap = new Map();     // Master map including local + remote

// Scenes, camera, etc.
let renderer, camera, npc;
let multiplayerManager;
let quickDraw;
let physics;
let lastTime = 0;

// Smoke ring effects
let smokeRings = [];
let maxSmokeRings = 10; // Limit to prevent performance issues

function init() {
  try {
    const sceneSetup = initScene();
    camera = sceneSetup.camera;
    renderer = sceneSetup.renderer;

    const soundManager = new SoundManager();
    // Load shot sounds
    soundManager.loadSound("shot2", "sounds/shot2.mp3");
    soundManager.loadSound("shot3", "sounds/shot3.mp3");
    soundManager.loadSound("shot5", "sounds/shot5.mp3");
    soundManager.loadSound("aimclick", "sounds/aimclick.mp3");
    soundManager.loadSound("shellejection", "sounds/shellejection.mp3");
    soundManager.loadSound("reloading", "sounds/reloading.mp3");
    // Load the bell start sound for Quick Draw start signal
    soundManager.loadSound("bellstart", "sounds/bellstart.mp3");
    // Load impact sounds
    soundManager.loadSound("woodimpact", "sounds/woodimpact.mp3");
    soundManager.loadSound("fleshimpact", "sounds/fleshimpact.mp3");
    
    // Initialize physics system
    physics = new PhysicsSystem();
    window.physics = physics; // Make physics globally accessible

    // Create town boundary if dimensions are available
    if (window.townDimensions) {
      physics.createTownBoundary(
        window.townDimensions.width,
        window.townDimensions.length,
        5 // Height of the barrier
      );
    }
    
    // Initialize a smoke ring effect pool for reuse
    for (let i = 0; i < 3; i++) {
      const smokeRing = new SmokeRingEffect(scene);
      smokeRing.active = false;
      smokeRings.push(smokeRing);
    }
    
    // Initialize multiplayer manager
    multiplayerManager = new MultiplayerManager(scene, soundManager, remotePlayers);

    // Initialize the local player
    localPlayer = new Player({
      scene,
      camera,
      soundManager,
      onShoot: handleLocalPlayerShoot  // callback for local shooting
    });
    // Make localPlayer globally accessible for hit updates.
    window.localPlayer = localPlayer;

    // Create an NPC target
    npc = createNPC(scene);

    // Initialize input
    initInput(renderer, localPlayer, soundManager);
    
    // Make scene globally accessible for physics visualization
    window.scene = scene;

    // Initialize Quick Draw game mode after the local player is created
    quickDraw = new QuickDraw(scene, localPlayer, networkManager, soundManager);
    
    // Share the main physics system with QuickDraw
    quickDraw.physics = physics;
    
    // Debug toggle for physics visualization (press P)
    window.addEventListener('keydown', (event) => {
      if (event.code === 'KeyP') {
        if (physics) {
          const isDebugMode = !physics.debugMode;
          physics.setDebugMode(isDebugMode);
          console.log(`Physics debug mode: ${isDebugMode ? 'ENABLED' : 'DISABLED'}`);
        }
      }
    });
    
    // Make updateHealthUI globally accessible for the Quick Draw mode to use
    window.updateHealthUI = updateHealthUI;

    // Show connection status
    const networkStatus = document.createElement('div');
    networkStatus.id = 'network-status';
    networkStatus.textContent = 'Connecting...';
    document.getElementById('game-container').appendChild(networkStatus);

    // Update player count UI when server broadcasts the count.
    networkManager.onPlayerCount = (count) => {
      const playerCountEl = document.getElementById('player-count');
      if (playerCountEl) {
        playerCountEl.textContent = `Players: ${count}`;
      }
    };

    // Listen for network open/close
    networkManager.socket.addEventListener('open', () => {
      networkStatus.textContent = 'Connected';
      networkStatus.style.backgroundColor = 'rgba(0,128,0,0.5)';
      setTimeout(() => { networkStatus.style.opacity = '0'; }, 2000);
    });
    networkManager.socket.addEventListener('close', () => {
      networkStatus.textContent = 'Disconnected';
      networkStatus.style.backgroundColor = 'rgba(255,0,0,0.5)';
      networkStatus.style.opacity = '1';
    });

    // Listen for remote players shooting
    networkManager.onPlayerShoot = (playerId, bulletData) => {
      handleRemotePlayerShoot(playerId, bulletData);
    };

    // Listen for updates to the remotePlayers map so we can refresh the master map
    multiplayerManager.onRemotePlayersUpdated = () => {
      updatePlayersMap();
    };

    // Start the animation loop
    animate(0);
    showGameInstructions();
    
  } catch (error) {
    console.error('Initialization failed:', error);
  }
}

/**
 * The main animation loop.
 */
function animate(time) {
  requestAnimationFrame(animate);
  const deltaTime = (time - lastTime) / 1000;
  lastTime = time;

  // Update physics system
  if (physics) {
    physics.update(deltaTime);
  }

  // Update local player
  localPlayer.update(deltaTime);

  // Update NPC using the imported updateNPC function
  updateNPC(npc, deltaTime);

  // Update remote players (animations, movement interpolation, etc.)
  multiplayerManager.update(deltaTime);
  
  // Update Quick Draw game mode
  if (quickDraw) {
    quickDraw.update(deltaTime);
  }

  // Update smoke ring effects
  for (let i = smokeRings.length - 1; i >= 0; i--) {
    // If the smoke ring is inactive after update, we can remove it
    // But keep at least 3 in the pool for reuse
    if (!smokeRings[i].update(deltaTime) && smokeRings.length > 3) {
      smokeRings[i].dispose();
      smokeRings.splice(i, 1);
    }
  }

  // Update bullets (both local & remote)
  for (let i = bullets.length - 1; i >= 0; i--) {
    const bullet = bullets[i];
    const result = bullet.update(deltaTime, npc, scene, playersMap);
    if (!result.active) {
      // If bullet hit something or traveled too far
      if (result.hit && result.hit.type === 'player') {
        console.log(`Bullet hit player ${result.hit.playerId}`);
      }
      scene.remove(bullet.mesh);
      bullets.splice(i, 1);
    }
  }

  // Update FPS display
  updateFPS(renderer, camera, deltaTime);

  // Render
  renderer.render(scene, camera);
}

/**
 * Called whenever the local player fires.
 * Spawns a bullet locally and also notifies the server.
 * @param {THREE.Vector3} bulletStart 
 * @param {THREE.Vector3} shootDir 
 */
function handleLocalPlayerShoot(bulletStart, shootDir) {
  // Spawn bullet in our local game
  const bullet = spawnBullet(localPlayer.id, bulletStart, shootDir);

  // Send bullet data over network
  networkManager.sendShoot({
    position: {
      x: bulletStart.x,
      y: bulletStart.y,
      z: bulletStart.z
    },
    direction: {
      x: shootDir.x,
      y: shootDir.y,
      z: shootDir.z
    }
  });
  
  // Add this section to check for Quick Draw hit
  if (quickDraw && quickDraw.inDuel && quickDraw.duelState === 'draw' && quickDraw.duelOpponentId) {
    // We'll handle this in the bullet collision code instead
  }
}

/**
 * Called whenever a remote player fires (based on network data).
 * @param {number} playerId 
 * @param {Object} bulletData 
 */
function handleRemotePlayerShoot(playerId, bulletData) {
  const startPos = new THREE.Vector3(bulletData.position.x, bulletData.position.y, bulletData.position.z);
  const dir = new THREE.Vector3(bulletData.direction.x, bulletData.direction.y, bulletData.direction.z);

  spawnBullet(playerId, startPos, dir);
}

/**
 * Actually spawns a bullet in the world, complete with muzzle flash, etc.
 * @param {string|number} sourcePlayerId 
 * @param {THREE.Vector3} position 
 * @param {THREE.Vector3} direction 
 */
function spawnBullet(sourcePlayerId, position, direction) {
  const bullet = new Bullet(position, direction);
  bullet.setSourcePlayer(sourcePlayerId);
  bullets.push(bullet);
  scene.add(bullet.mesh);

  // Visual effects
  createMuzzleFlash(position, scene);
  createSmokeEffect(position, direction, scene);
  createShockwaveRing(position, direction, scene);
  
  // Add smoke ring effect
  let smokeRing = null;
  
  // Try to reuse an inactive smoke ring first
  for (let i = 0; i < smokeRings.length; i++) {
    if (!smokeRings[i].active) {
      smokeRing = smokeRings[i];
      break;
    }
  }
  
  // If no inactive smoke ring found, create a new one if under the limit
  if (!smokeRing && smokeRings.length < maxSmokeRings) {
    smokeRing = new SmokeRingEffect(scene);
    smokeRings.push(smokeRing);
  }
  
  // Activate the smoke ring
  if (smokeRing) {
    smokeRing.create(position, direction);
  }

  // Sound: randomly choose one of the three shot sounds
  if (localPlayer.soundManager) {
    const shotSounds = ["shot2", "shot3", "shot5"];
    const randomIndex = Math.floor(Math.random() * shotSounds.length);
    const shotSound = shotSounds[randomIndex];
    localPlayer.soundManager.playSound(shotSound);
  }

  return bullet;
}

/**
 * Rebuilds a master map of all remote players.
 * This map is passed to bullet collision checks so bullets can hit any remote player.
 */
function updatePlayersMap() {
  playersMap.clear();
  // Only add remote players so that the local (shooter's) model isn't processed in bullet collisions.
  for (const [pid, remoteModel] of remotePlayers.entries()) {
    playersMap.set(pid, remoteModel);
  }
}


function showGameInstructions() {
  const instructions = document.createElement('div');
  instructions.id = 'instructions';
  instructions.style.position = 'absolute';
  instructions.style.top = '50%';
  instructions.style.left = '50%';
  instructions.style.transform = 'translate(-50%, -50%)';
  instructions.style.color = 'white';
  instructions.style.backgroundColor = 'rgba(0,0,0,0.7)';
  instructions.style.padding = '20px';
  instructions.style.borderRadius = '10px';
  instructions.style.maxWidth = '500px';
  instructions.style.textAlign = 'center';
  instructions.style.zIndex = '1000';
  
  instructions.innerHTML = `
    <h2>Wild Western Shooter - Multiplayer</h2>
    <p>WASD: Move</p>
    <p>Shift: Sprint</p>
    <p>Right-click: Aim</p>
    <p>Left-click (while aiming): Shoot</p>
    <p>R: Reload</p>
    <p>Space: Jump</p>
    <p>P: Toggle physics debug visualization</p>
    <p><strong>Click anywhere to start</strong></p>
    <p><strong>New:</strong> Find the Quick Draw portal near spawn to duel other players!</p>
    <p><strong>Town Boundary:</strong> You must stay within the town limits and can only access the duel arena through the portal.</p>`;
  
  document.getElementById('game-container').appendChild(instructions);
  
  // Remove instructions on click
  document.addEventListener('click', () => {
    if (instructions.parentNode) {
      instructions.parentNode.removeChild(instructions);
    }
  }, { once: true });
}

// Handle window unload to cleanup physics resources
window.addEventListener('beforeunload', () => {
  if (quickDraw && quickDraw.physics) {
    quickDraw.physics.cleanup();
  }
  
  if (physics) {
    physics.cleanup();
  }
  
  // Clean up smoke rings
  for (let i = 0; i < smokeRings.length; i++) {
    smokeRings[i].dispose();
  }
  smokeRings = [];
});

init();

================================================
File: /public/js/multiplayerManager.js
================================================
import { ThirdPersonModel } from './playerModel.js';
import { networkManager } from './network.js';

/**
 * Manages all remote players (their models, animations, etc.) but NOT bullets.
 * Bullets are now handled in main.js.
 */
export class MultiplayerManager {
  constructor(scene, soundManager, remotePlayersMap) {
    /**
     * @param remotePlayersMap {Map<number,ThirdPersonModel>}
     * A shared map that main.js also references. We'll update it here.
     */
    this.scene = scene;
    this.soundManager = soundManager;
    
    // This map is passed in from main.js; we mutate it
    this.remotePlayers = remotePlayersMap;

    // Callback that main.js uses to know we changed remotePlayers
    this.onRemotePlayersUpdated = null;

    this.localPlayerId = null;

    // Initialize network handlers
    this.initNetwork();
  }
  
  initNetwork() {
    // When we get the "init" message, set local player ID and add any existing players
    networkManager.onInit = (initData) => {
      this.localPlayerId = initData.id;
      console.log(`Local player ID: ${this.localPlayerId}`);

      // Add all existing players (these are remote from our POV)
      initData.players.forEach(playerData => {
        this.addPlayer(playerData.id, playerData);
      });
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerJoined = (playerData) => {
      if (playerData.id === this.localPlayerId) return; // skip ourself
      this.addPlayer(playerData.id, playerData);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerLeft = (playerId) => {
      this.removePlayer(playerId);
      this.notifyPlayersUpdated();
    };

    networkManager.onPlayerUpdate = (playerId, updatedData) => {
      if (playerId === this.localPlayerId) return; // skip ourself
      const playerModel = this.remotePlayers.get(playerId);
      if (playerModel) {
        playerModel.update(updatedData);
      } else {
        // If we don't have this model yet, create it
        this.addPlayer(playerId, updatedData);
      }
    };

    // We no longer handle bullets here (onPlayerShoot) – that's handled in main.js

    // Player got hit (local player)
    networkManager.onPlayerHit = (sourceId, hitData) => {
      console.log(`I was hit by player ${sourceId}!`);
      this.showHitFeedback();
      // Reduce local player's health (assumes window.localPlayer is set)
      if (window.localPlayer && typeof window.localPlayer.takeDamage === 'function') {
         window.localPlayer.takeDamage(20);
      }
    };

    // Broadcast that some player was hit (for visual effects and health updates)
    networkManager.onPlayerHitBroadcast = (targetId, sourceId, hitPos) => {
      console.log(`Player ${targetId} was hit by ${sourceId}`);
      const tPlayer = this.remotePlayers.get(parseInt(targetId));
      if (tPlayer) {
        tPlayer.showHitFeedback();
        if (typeof tPlayer.takeDamage === 'function') {
          tPlayer.takeDamage(20);
        }
      }
    };
  }

  showHitFeedback() {
    // Flash the screen red briefly
    const hitOverlay = document.createElement('div');
    hitOverlay.style.position = 'absolute';
    hitOverlay.style.top = '0';
    hitOverlay.style.left = '0';
    hitOverlay.style.width = '100%';
    hitOverlay.style.height = '100%';
    hitOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    hitOverlay.style.pointerEvents = 'none';
    hitOverlay.style.transition = 'opacity 0.5s ease-out';
    hitOverlay.style.zIndex = '1000';
    document.body.appendChild(hitOverlay);
    
    setTimeout(() => {
      hitOverlay.style.opacity = '0';
      setTimeout(() => {
        if (hitOverlay.parentNode) {
          hitOverlay.parentNode.removeChild(hitOverlay);
        }
      }, 500);
    }, 100);

    // Optional hit sound
    if (this.soundManager) {
      this.soundManager.playSound("aimclick");
    }
  }

  addPlayer(playerId, data) {
    console.log(`Adding remote player ${playerId}`);
    const model = new ThirdPersonModel(this.scene, playerId);
    model.update(data);
    this.remotePlayers.set(playerId, model);
  }

  removePlayer(playerId) {
    console.log(`Removing remote player ${playerId}`);
    const model = this.remotePlayers.get(playerId);
    if (model) {
      model.remove();
      this.remotePlayers.delete(playerId);
    }
  }

  update(deltaTime) {
    // Animate each remote player's walk cycle and smoothly update movement
    for (const [playerId, remoteModel] of this.remotePlayers.entries()) {
      if (remoteModel.isWalking) {
        remoteModel.animateWalk(deltaTime);
      } else {
        remoteModel.resetWalkAnimation();
      }
      remoteModel.animateMovement(deltaTime);
    }
  }

  notifyPlayersUpdated() {
    if (typeof this.onRemotePlayersUpdated === 'function') {
      this.onRemotePlayersUpdated();
    }
  }
}


================================================
File: /public/js/network.js
================================================
/**
 * NetworkManager class for WebSocket communication.
 * It provides event callbacks for multiplayer events and methods to send data.
 */
export class NetworkManager {
  constructor() {
    this.socket = null;
    this.playerId = null;
    this.otherPlayers = new Map(); // Maps playerId -> playerData from the server

    // Callbacks
    this.onInit = null;              // Called when we first receive 'init' from server
    this.onPlayerJoined = null;
    this.onPlayerLeft = null;
    this.onPlayerUpdate = null;
    this.onPlayerShoot = null;
    this.onPlayerCount = null;
    this.onPlayerHit = null;         // When this player is hit by someone
    this.onPlayerHitBroadcast = null;// When any player is hit
    this.onOpen = null;
    this.onClose = null;
    this.onError = null;

    // Automatic reconnect attempts
    this.connectionAttempts = 0;
    this.maxConnectionAttempts = 5;
    this.reconnectTimer = null;

    // Unique sessionId to prevent multiple tabs from colliding
    this.sessionId = this._generateSessionId();
  }

  /**
   * Generates a unique-ish session ID to detect duplicate connections from the same tab.
   */
  _generateSessionId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
  }

  /**
   * Initiates a connection to the WebSocket server.
   */
  connect() {
    this._cleanupSocket();

    // Determine correct ws:// or wss:// based on current protocol
    const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = `${protocol}${window.location.host}?sessionId=${this.sessionId}`;

    console.log('Attempting to connect to:', wsUrl);
    this.socket = new WebSocket(wsUrl);

    this.socket.onopen = (event) => {
      console.log('WebSocket connected');
      this.connectionAttempts = 0;
      if (typeof this.onOpen === 'function') {
        this.onOpen(event);
      }
    };

    this.socket.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        this.handleMessage(message);
      } catch (err) {
        console.error('Error parsing server message:', err);
      }
    };

    this.socket.onclose = (event) => {
      console.log(`WebSocket closed: ${event.code} ${event.reason}`);
      if (typeof this.onClose === 'function') {
        this.onClose(event);
      }
      this._scheduleReconnect();
    };

    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      if (typeof this.onError === 'function') {
        this.onError(error);
      }
    };
  }

  /**
   * Clean up any existing WebSocket connection.
   */
  _cleanupSocket() {
    if (this.socket) {
      this.socket.onopen = null;
      this.socket.onmessage = null;
      this.socket.onclose = null;
      this.socket.onerror = null;
      if (
        this.socket.readyState === WebSocket.OPEN ||
        this.socket.readyState === WebSocket.CONNECTING
      ) {
        this.socket.close();
      }
      this.socket = null;
    }

    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
  }

  /**
   * Schedules a reconnect attempt if under max attempts.
   */
  _scheduleReconnect() {
    if (this.connectionAttempts < this.maxConnectionAttempts) {
      this.connectionAttempts++;
      const delay = Math.min(1000 * Math.pow(2, this.connectionAttempts), 30000);
      console.log(`Reconnecting in ${(delay / 1000).toFixed(1)}s... (Attempt ${this.connectionAttempts}/${this.maxConnectionAttempts})`);
      
      this.reconnectTimer = setTimeout(() => {
        console.log(`Reconnecting now (Attempt ${this.connectionAttempts})...`);
        this.connect();
      }, delay);
    } else {
      console.error('Max reconnect attempts reached. Please refresh the page.');
    }
  }

  /**
   * Handles all messages from the server.
   * @param {Object} message The parsed JSON message object.
   */
  handleMessage(message) {
    switch (message.type) {
      // New connection initialization
      case 'init':
        this.playerId = message.id;
        console.log(`Assigned player ID: ${this.playerId}`);

        // If there's a callback
        if (typeof this.onInit === 'function') {
          this.onInit(message);
        }

        // Add known players
        message.players.forEach(player => {
          if (this.onPlayerJoined) {
            this.onPlayerJoined(player);
          }
          this.otherPlayers.set(player.id, player);
        });
        break;

      // Another player joined
      case 'playerJoined':
        console.log(`Player ${message.id} joined`);
        if (this.onPlayerJoined) {
          this.onPlayerJoined(message);
        }
        this.otherPlayers.set(message.id, {
          id: message.id,
          position: message.position,
          rotation: message.rotation,
          isAiming: false,
          isShooting: false,
          isReloading: false,
          quickDrawLobbyIndex: message.quickDrawLobbyIndex || -1
        });
        break;

      // Player left
      case 'playerLeft':
        console.log(`Player ${message.id} left`);
        if (this.onPlayerLeft) {
          this.onPlayerLeft(message.id);
        }
        this.otherPlayers.delete(message.id);
        break;

      // General player update (pos/rot/aiming/etc.)
      case 'playerUpdate':
        {
          const existing = this.otherPlayers.get(message.id);
          if (existing) {
            existing.position = message.position || existing.position;
            existing.rotation = message.rotation || existing.rotation;
            existing.isAiming =
              message.isAiming !== undefined ? message.isAiming : existing.isAiming;
            existing.isShooting =
              message.isShooting !== undefined ? message.isShooting : existing.isShooting;
            existing.isReloading =
              message.isReloading !== undefined ? message.isReloading : existing.isReloading;
            existing.quickDrawLobbyIndex =
              message.quickDrawLobbyIndex !== undefined ? message.quickDrawLobbyIndex : existing.quickDrawLobbyIndex;
          }
          if (this.onPlayerUpdate) {
            this.onPlayerUpdate(message.id, existing);
          }
        }
        break;

      // Remote player fired
      case 'playerShoot':
        if (this.onPlayerShoot) {
          this.onPlayerShoot(message.id, message.bulletData);
        }
        break;

      // Current total player count
      case 'playerCount':
        if (this.onPlayerCount) {
          this.onPlayerCount(message.count);
        }
        break;

      // This client was hit by another player
      case 'hit':
        console.log(`I was hit by player ${message.sourceId}`);
        if (this.onPlayerHit) {
          this.onPlayerHit(message.sourceId, message.hitData);
        }
        break;

      // A broadcast that someone was hit
      case 'playerHit':
        console.log(`Player ${message.targetId} was hit by player ${message.sourceId}`);
        if (this.onPlayerHitBroadcast) {
          this.onPlayerHitBroadcast(
            message.targetId,
            message.sourceId,
            message.hitPosition
          );
        }
        break;

      // Generic error from server
      case 'error':
        console.error('Server error:', message.message);
        if (message.fatal) {
          this.connectionAttempts = this.maxConnectionAttempts; // block further reconnect
          alert(`Fatal error: ${message.message}`);
        }
        break;

      default:
        console.warn('Unhandled message:', message);
        break;
    }
  }

  /**
   * Sends local player position/rotation etc. to the server.
   * @param {Object} playerData - { position, rotation, isAiming, isReloading, quickDrawLobbyIndex }
   */
  sendUpdate(playerData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: 'update',
          ...playerData
        })
      );
    }
  }

  /**
   * Notifies server that we fired a bullet.
   * @param {Object} bulletData - { position: {x,y,z}, direction: {x,y,z} }
   */
  sendShoot(bulletData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: 'shoot',
          bulletData
        })
      );
    }
  }

  /**
   * Notifies server that we hit another player.
   * @param {number|string} hitPlayerId
   * @param {Object} hitData - { position: {x,y,z}, sourcePlayerId: ... }
   */
  sendPlayerHit(hitPlayerId, hitData) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: 'playerHit',
          targetId: hitPlayerId,
          hitData
        })
      );
    }
  }
  
  /**
   * Sends a request to join a specific Quick Draw arena queue.
   * @param {number} arenaIndex - The arena index (0-4)
   */
  sendQuickDrawJoin(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawJoin',
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Sends a request to leave the Quick Draw queue.
   */
  sendQuickDrawLeave() {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawLeave'
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player is ready for a Quick Draw duel.
   * @param {number} arenaIndex - The arena index for the duel
   */
  sendQuickDrawReady(arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawReady',
          arenaIndex: arenaIndex
        })
      );
    }
  }
  
  /**
   * Notifies the server that the player has shot their opponent in a Quick Draw duel.
   * @param {number|string} opponentId - The opponent's player ID
   * @param {number} arenaIndex - The arena index for the duel
   */
  sendQuickDrawShoot(opponentId, arenaIndex) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      console.log(`Sending Quick Draw hit notification to server: player ${this.playerId} hit player ${opponentId} in arena ${arenaIndex + 1}`);
      this.socket.send(
        JSON.stringify({
          type: 'quickDrawShoot',
          opponentId: opponentId,
          arenaIndex: arenaIndex
        })
      );
    }
  }

  /**
   * Closes the connection manually.
   */
  disconnect() {
    this._cleanupSocket();
    console.log('WebSocket connection manually closed');
  }
}

// Export a singleton instance
export const networkManager = new NetworkManager();
// Make it globally accessible
window.networkManager = networkManager;

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  networkManager.disconnect();
});

================================================
File: /public/js/physics.js
================================================
/**
 * Physics system using cannon.js for collision detection and physics simulation.
 * Focused on creating invisible boundaries for the QuickDraw arenas and town.
 */
export class PhysicsSystem {
    constructor() {
      // Create a physics world with gravity
      this.world = new CANNON.World();
      this.world.gravity.set(0, -9.8, 0);
      
      // Set default contact material properties
      this.defaultMaterial = new CANNON.Material('default');
      const defaultContactMaterial = new CANNON.ContactMaterial(
        this.defaultMaterial,
        this.defaultMaterial,
        {
          friction: 0.3,
          restitution: 0.3 // Slightly bouncy
        }
      );
      this.world.addContactMaterial(defaultContactMaterial);
      this.world.defaultContactMaterial = defaultContactMaterial;
      
      // Collection of bodies
      this.bodies = [];
      
      // Debug helper for visualizing physics bodies
      this.debugMeshes = [];
      this.debugMode = false;
      
      // Track arena boundaries separately
      this.arenaBoundaryBodies = [];
      
      // Initialize ground
      this.initGround();
    }
    
    /**
     * Initialize the ground plane
     */
    initGround() {
      const groundBody = new CANNON.Body({
        mass: 0, // Static body
        shape: new CANNON.Plane(),
        material: this.defaultMaterial
      });
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be flat
      this.world.addBody(groundBody);
      this.bodies.push(groundBody);
    }
    
    /**
     * Creates an invisible boundary for the town to prevent players from leaving
     * @param {number} width - Width of the town
     * @param {number} length - Length of the town
     * @param {number} height - Height of the barrier
     * @returns {CANNON.Body} - The created physics body
     */
    createTownBoundary(width, length, height) {
      // First remove any existing town boundaries
      this.removeTownBoundary();
      
      // Create a physics body for the town boundary
      const boundaryBody = new CANNON.Body({
        mass: 0, // Static body
        material: this.defaultMaterial
      });
      
      // Add a box shape for each border
      const halfWidth = width / 2;
      const halfLength = length / 2;
      const borderThickness = 0.5;
      
      // Left border (negative X)
      const leftBorderShape = new CANNON.Box(new CANNON.Vec3(
        borderThickness / 2, 
        height / 2, 
        length / 2
      ));
      boundaryBody.addShape(
        leftBorderShape, 
        new CANNON.Vec3(-halfWidth, height / 2, 0)
      );
      
      // Right border (positive X)
      const rightBorderShape = new CANNON.Box(new CANNON.Vec3(
        borderThickness / 2, 
        height / 2, 
        length / 2
      ));
      boundaryBody.addShape(
        rightBorderShape, 
        new CANNON.Vec3(halfWidth, height / 2, 0)
      );
      
      // Front border (negative Z)
      const frontBorderShape = new CANNON.Box(new CANNON.Vec3(
        width / 2, 
        height / 2, 
        borderThickness / 2
      ));
      boundaryBody.addShape(
        frontBorderShape, 
        new CANNON.Vec3(0, height / 2, -halfLength)
      );
      
      // Back border (positive Z)
      const backBorderShape = new CANNON.Box(new CANNON.Vec3(
        width / 2, 
        height / 2, 
        borderThickness / 2
      ));
      boundaryBody.addShape(
        backBorderShape, 
        new CANNON.Vec3(0, height / 2, halfLength)
      );
      
      boundaryBody.townBoundary = true; // Tag this body as a town boundary
      boundaryBody.collisionFilterGroup = 2; // Group 2 for boundaries
      
      // Add the boundary body to the world
      this.world.addBody(boundaryBody);
      this.bodies.push(boundaryBody);
      
      // Create a reference to easily find this body later
      this.townBoundaryBody = boundaryBody;
      
      // If debug mode is enabled, create a visual representation
      if (this.debugMode) {
        this.createDebugMesh(boundaryBody);
      }
      
      console.log("Created town boundary with width", width, "and length", length);
      
      return boundaryBody;
    }
    
    /**
     * Removes the town boundary if it exists
     */
    removeTownBoundary() {
      if (this.townBoundaryBody) {
        this.world.removeBody(this.townBoundaryBody);
        
        // Remove from our bodies array
        const index = this.bodies.indexOf(this.townBoundaryBody);
        if (index !== -1) {
          this.bodies.splice(index, 1);
        }
        
        // Clear the reference
        this.townBoundaryBody = null;
        console.log("Removed town boundary");
      }
    }
    
    /**
     * Creates an invisible cylindrical boundary for a QuickDraw arena
     * @param {THREE.Vector3} center - Center position of the arena
     * @param {number} radius - Radius of the cylindrical arena
     * @param {number} height - Height of the cylindrical arena
     * @param {number} arenaIndex - Index of the arena (0-4)
     * @returns {CANNON.Body} - The created physics body
     */
    createQuickDrawArenaBoundary(center, radius, height, arenaIndex = 0) {
      // First remove any existing arena boundary for this index
      this.removeQuickDrawArenaBoundaryByIndex(arenaIndex);
      
      // Create a physics body for the arena boundary
      const arenaBody = new CANNON.Body({
        mass: 0, // Static body
        material: this.defaultMaterial
      });
      
      // Position at the center
      arenaBody.position.set(center.x, center.y + height/2, center.z);
      
      // Use a hollow cylinder (cylinder + inverted cylinder)
      // We make the walls a bit thick (0.5 units) to ensure reliable collision detection
      const wallThickness = 0.5;
      
      // Outer cylinder (pushing inward)
      const outerRadius = radius + wallThickness;
      const segments = 16; // Number of sides for the cylinder approximation
      
      // Create segments around the circle to approximate the cylinder
      for (let i = 0; i < segments; i++) {
        const angle1 = (i / segments) * Math.PI * 2;
        const angle2 = ((i + 1) / segments) * Math.PI * 2;
        
        const x1 = Math.cos(angle1) * radius;
        const z1 = Math.sin(angle1) * radius;
        const x2 = Math.cos(angle2) * radius;
        const z2 = Math.sin(angle2) * radius;
        
        // Calculate the position and orientation of this wall segment
        const segCenter = {
          x: (x1 + x2) / 2,
          z: (z1 + z2) / 2
        };
        
        const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2));
        
        // Create a box shape for this wall segment
        const halfExtents = new CANNON.Vec3(length/2, height/2, wallThickness/2);
        const wallShape = new CANNON.Box(halfExtents);
        
        // Get the angle to rotate this wall segment
        const rotationY = Math.atan2(z2 - z1, x2 - x1) + Math.PI/2;
        
        // Add the shape to the body with the appropriate offset and rotation
        const offset = new CANNON.Vec3(segCenter.x, 0, segCenter.z);
        const quaternion = new CANNON.Quaternion();
        quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
        
        arenaBody.addShape(wallShape, offset, quaternion);
      }
      
      // Bottom circle to prevent falling through
      const bottomShape = new CANNON.Cylinder(radius, radius, wallThickness, segments);
      const bottomOffset = new CANNON.Vec3(0, -height/2, 0);
      const bottomQuaternion = new CANNON.Quaternion();
      bottomQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2);
      arenaBody.addShape(bottomShape, bottomOffset, bottomQuaternion);
      
      arenaBody.arenaBoundary = true; // Tag this body as an arena boundary
      arenaBody.arenaIndex = arenaIndex; // Store which arena this belongs to
      arenaBody.collisionFilterGroup = 2; // Group 2 for arena boundaries
      
      // Add the arena body to the world
      this.world.addBody(arenaBody);
      this.bodies.push(arenaBody);
      
      // Store in our array of arena boundaries
      this.arenaBoundaryBodies[arenaIndex] = arenaBody;
      
      // If debug mode is enabled, create a visual representation
      if (this.debugMode) {
        this.createDebugMesh(arenaBody);
      }
      
      console.log(`Created QuickDraw arena boundary ${arenaIndex + 1} at`, center, "with radius", radius, "and height", height);
      
      return arenaBody;
    }
    
    /**
     * Removes a QuickDraw arena boundary for a specific arena index
     * @param {number} arenaIndex - The index of the arena (0-4)
     */
    removeQuickDrawArenaBoundaryByIndex(arenaIndex) {
      if (this.arenaBoundaryBodies[arenaIndex]) {
        this.world.removeBody(this.arenaBoundaryBodies[arenaIndex]);
        
        // Remove from our bodies array
        const index = this.bodies.indexOf(this.arenaBoundaryBodies[arenaIndex]);
        if (index !== -1) {
          this.bodies.splice(index, 1);
        }
        
        // Clear the reference in our arena boundaries array
        this.arenaBoundaryBodies[arenaIndex] = null;
        console.log(`Removed QuickDraw arena boundary ${arenaIndex + 1}`);
      }
    }
    
    /**
     * Removes the QuickDraw arena boundary (legacy method for backward compatibility)
     */
    removeQuickDrawArenaBoundary() {
      // Remove all arena boundaries
      for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
        this.removeQuickDrawArenaBoundaryByIndex(i);
      }
    }
    
    /**
     * Create a physics body for a player
     * @param {THREE.Vector3} position - Initial position
     * @param {number} radius - Player collision radius
     * @param {number} height - Player height
     * @returns {CANNON.Body} - The created physics body
     */
    createPlayerBody(position, radius = 0.3, height = 1.8) {
      // Create a capsule shape (cylinder with spheres at ends)
      const playerBody = new CANNON.Body({
        mass: 70, // Player mass in kg
        material: this.defaultMaterial,
        fixedRotation: true, // Don't rotate the player when colliding
        linearDamping: 0.9 // Add some damping to prevent excessive sliding
      });
      
      // Use a cylinder for the body
      playerBody.addShape(new CANNON.Cylinder(radius, radius, height, 8));
      
      // Position the player body
      playerBody.position.set(position.x, position.y, position.z);
      
      // Add to world
      this.world.addBody(playerBody);
      this.bodies.push(playerBody);
      
      // If debug mode is enabled, create a visual representation
      if (this.debugMode) {
        this.createDebugMesh(playerBody);
      }
      
      return playerBody;
    }
    
    /**
     * Checks if a point is inside any active arena boundary
     * @param {THREE.Vector3} point - The point to check
     * @returns {boolean} - True if inside, false if outside
     */
    isPointInArenaBoundary(point) {
      // Check all arena boundaries
      for (let i = 0; i < this.arenaBoundaryBodies.length; i++) {
        if (this.isPointInSpecificArenaBoundary(point, i)) {
          return true;
        }
      }
      return false;
    }
    
    /**
     * Checks if a point is inside a specific arena boundary
     * @param {THREE.Vector3} point - The point to check
     * @param {number} arenaIndex - The arena index to check
     * @returns {boolean} - True if inside, false if outside
     */
    isPointInSpecificArenaBoundary(point, arenaIndex) {
      // If no arena boundary exists for this index, return false
      if (!this.arenaBoundaryBodies[arenaIndex]) return false;
      
      // Get arena position
      const arenaPos = this.arenaBoundaryBodies[arenaIndex].position;
      const pointVec = new CANNON.Vec3(point.x, point.y, point.z);
      
      // Calculate horizontal distance (ignoring Y) from arena center
      const dx = pointVec.x - arenaPos.x;
      const dz = pointVec.z - arenaPos.z;
      const horizontalDist = Math.sqrt(dx * dx + dz * dz);
      
      // Get the radius - assuming 15 is the standard radius for all arenas
      const radius = 15;
      
      // Check if point is inside the cylinder horizontally
      return horizontalDist < radius;
    }

    /**
     * Checks if a point is inside the town boundary
     * @param {THREE.Vector3} point - The point to check
     * @returns {boolean} - True if inside, false if outside
     */
    isPointInTown(point) {
      // If no town boundary exists, return true (no restriction)
      if (!window.townDimensions) return true;
      
      // Get town dimensions
      const width = window.townDimensions.width;
      const length = window.townDimensions.length;
      
      // Check if the point is within the town boundaries
      return (
        point.x > -width / 2 && 
        point.x < width / 2 && 
        point.z > -length / 2 && 
        point.z < length / 2
      );
    }
    
    /**
     * Creates a debug mesh to visualize a physics body
     * @param {CANNON.Body} body - The physics body to visualize
     */
    createDebugMesh(body) {
      // Only used in debug mode
      if (!this.debugMode) return;
      
      // For each shape in the body, create a wireframe mesh
      body.shapes.forEach((shape, i) => {
        let geometry;
        let mesh;
        
        // Get the shape's offset and orientation
        const offset = body.shapeOffsets[i];
        const orientation = body.shapeOrientations[i];
        
        // Create different geometries based on shape type
        if (shape instanceof CANNON.Box) {
          geometry = new THREE.BoxGeometry(
            shape.halfExtents.x * 2,
            shape.halfExtents.y * 2,
            shape.halfExtents.z * 2
          );
          
          mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              wireframe: true
            })
          );
          
          // Apply offset and orientation
          mesh.position.set(offset.x, offset.y, offset.z);
          mesh.quaternion.set(
            orientation.x,
            orientation.y,
            orientation.z,
            orientation.w
          );
        }
        else if (shape instanceof CANNON.Sphere) {
          geometry = new THREE.SphereGeometry(shape.radius, 16, 16);
          
          mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              wireframe: true
            })
          );
          
          // Apply offset
          mesh.position.set(offset.x, offset.y, offset.z);
        }
        else if (shape instanceof CANNON.Cylinder) {
          geometry = new THREE.CylinderGeometry(
            shape.radiusTop,
            shape.radiusBottom,
            shape.height,
            shape.numSegments
          );
          
          mesh = new THREE.Mesh(
            geometry,
            new THREE.MeshBasicMaterial({
              color: 0x00ff00,
              wireframe: true
            })
          );
          
          // Rotate to match cannon.js cylinders
          mesh.rotation.x = Math.PI / 2;
          
          // Apply offset and orientation
          mesh.position.set(offset.x, offset.y, offset.z);
          const quat = new THREE.Quaternion(
            orientation.x,
            orientation.y,
            orientation.z,
            orientation.w
          );
          mesh.quaternion.multiply(quat);
        }
        
        if (mesh) {
          // Add to the body's group
          const group = new THREE.Group();
          group.add(mesh);
          
          // Store reference for updating
          this.debugMeshes.push({
            mesh: group,
            body: body
          });
          
          // Add to scene
          window.scene.add(group);
        }
      });
    }
    
    /**
     * Update the physics world
     * @param {number} deltaTime - Time step in seconds
     */
    update(deltaTime) {
      // Limit delta time to prevent large jumps
      const timeStep = Math.min(deltaTime, 0.1);
      
      // Update physics world
      this.world.step(timeStep);
      
      // Update debug meshes if in debug mode
      if (this.debugMode) {
        this.updateDebugMeshes();
      }
    }
    
    /**
     * Update debug mesh positions to match their physics bodies
     */
    updateDebugMeshes() {
      if (!this.debugMode) return;
      
      this.debugMeshes.forEach(item => {
        // Update position
        item.mesh.position.set(
          item.body.position.x,
          item.body.position.y,
          item.body.position.z
        );
        
        // Update orientation
        item.mesh.quaternion.set(
          item.body.quaternion.x,
          item.body.quaternion.y,
          item.body.quaternion.z,
          item.body.quaternion.w
        );
      });
    }
    
    /**
     * Enables or disables debug visualization
     * @param {boolean} enabled - Whether debug mode should be enabled
     */
    setDebugMode(enabled) {
      this.debugMode = enabled;
      
      // If enabling, create meshes for existing bodies
      if (enabled) {
        this.bodies.forEach(body => {
          this.createDebugMesh(body);
        });
      }
      // If disabling, remove all debug meshes
      else {
        this.debugMeshes.forEach(item => {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        });
        this.debugMeshes = [];
      }
    }
    
    /**
     * Cleans up all physics resources
     */
    cleanup() {
      // Remove all bodies
      this.bodies.forEach(body => {
        this.world.removeBody(body);
      });
      
      // Remove all debug meshes
      if (this.debugMode) {
        this.debugMeshes.forEach(item => {
          window.scene.remove(item.mesh);
          item.mesh.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
          });
        });
      }
      
      this.bodies = [];
      this.debugMeshes = [];
      this.arenaBoundaryBodies = [];
    }
  }

================================================
File: /public/js/player.js
================================================
import { Revolver } from './revolver.js';
import { updateAmmoUI, updateHealthUI } from './ui.js';
import { applyRecoil, ejectShell } from './effects.js';
import { networkManager } from './network.js';

/**
 * The local Player class (first-person).
 */
export class Player {
  /**
   * @param {Object} config
   * @param {THREE.Scene} config.scene
   * @param {THREE.PerspectiveCamera} config.camera
   * @param {SoundManager} config.soundManager
   * @param {Function} config.onShoot - A callback function called when the player fires a bullet.
   */
  constructor({ scene, camera, soundManager, onShoot }) {
    this.scene = scene;
    this.camera = camera;
    this.soundManager = soundManager;
    this.onShootCallback = onShoot;

    this.group = new THREE.Group();
    
    // Start at a random spawn point in the town street
    this.spawnPlayerRandomly();
    
    this.scene.add(this.group);
    this.camera.position.set(0, 0, 0);
    this.group.add(this.camera);

    this.id = null; // will be set by networkManager.onInit
    this.velocity = new THREE.Vector3();
    this.canJump = false;

    // Movement flags
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    
    // Sprinting flag - new addition
    this.isSprinting = false;
    this.normalSpeed = 5; // Default movement speed
    this.sprintSpeed = 12; // Faster sprint speed
    this.sprintJumpBoost = 1.5; // Jump boost factor when sprinting

    // Aiming
    this.isAiming = false;
    this.defaultFOV = 75;
    this.aimFOV = 65;
    
    // Camera effects for sprinting - with smoothing parameters
    this.defaultCameraHeight = 0;
    this.bobPhase = 0; // Phase accumulator for bob effect
    this.bobIntensity = 0; // Current intensity of bobbing (interpolates)
    this.targetBobIntensity = 0; // Target bobbing intensity
    this.bobTransitionSpeed = 3; // Speed of transition to new bob intensity
    
    // Gun
    this.revolver = new Revolver();
    this.holsterOffset = new THREE.Vector3(0.6, -0.5, -0.8);
    this.aimOffset = new THREE.Vector3(0.3, -0.3, -0.5);
    this.currentGunOffset = this.holsterOffset.clone();
    this.camera.add(this.revolver.group);

    // FOV transition smoothing
    this.currentFOV = this.defaultFOV;
    this.targetFOV = this.defaultFOV;
    this.fovTransitionSpeed = 5; // Speed of FOV transitions

    // Reload
    this.isReloading = false;
    this.reloadTime = 4000; // Changed from 2000ms to 4000ms (4 seconds)
    this.reloadProgress = 0;
    this.bullets = 6;
    this.maxBullets = 6;
    this.canShoot = true;

    // Health
    this.health = 100;

    // Networking
    this.lastNetworkUpdate = 0;
    this.networkUpdateInterval = 50; // ms

    // Quick Draw mode
    this.canAim = true; // Whether the player is allowed to aim (used by Quick Draw)
    
    // Store previous position to detect collision with arena boundary
    this.previousPosition = new THREE.Vector3();

    // Quick Draw lobby information
    this.quickDrawLobbyIndex = -1; // -1 means not in a lobby

    // Initialize network & UI
    this.initNetworking();
    updateAmmoUI(this);
    updateHealthUI(this);
  }

  /**
   * Spawn the player at a random position along the main street
   */
  spawnPlayerRandomly() {
    // Default position if town dimensions aren't available
    let spawnX = 0;
    let spawnY = 1.6;
    let spawnZ = 0;

    // If town dimensions are available, use them for spawn positioning
    if (window.townDimensions) {
      const streetWidth = window.townDimensions.streetWidth;
      const townLength = window.townDimensions.length;
      
      // Random position within the street area
      spawnX = (Math.random() - 0.5) * streetWidth * 0.8; // 80% of street width to avoid edges
      spawnZ = (Math.random() - 0.5) * townLength * 0.8; // 80% of town length
    }

    this.group.position.set(spawnX, spawnY, spawnZ);
    
    // Random rotation (facing any direction)
    this.group.rotation.y = Math.random() * Math.PI * 2;
    
    console.log(`Player spawned at: X=${spawnX.toFixed(2)}, Z=${spawnZ.toFixed(2)}`);
  }

  initNetworking() {
    // Start the WebSocket
    networkManager.connect();

    networkManager.onInit = (initData) => {
      this.id = initData.id;
      console.log(`Local player initialized with ID: ${this.id}`);
    };

    // We also do not handle remote players here. That is done in the MultiplayerManager.
  }

  update(deltaTime) {
    // Store previous position before movement for collision detection
    this.previousPosition.copy(this.group.position);
    
    // Smoothly interpolate the gun offset & FOV
    const targetOffset = this.isAiming && this.canAim ? this.aimOffset : this.holsterOffset;
    this.currentGunOffset.lerp(targetOffset, 0.1);
    this.revolver.group.position.copy(this.currentGunOffset);

    // Adjust FOV based on sprinting and aiming with smoother transitions
    if (this.isAiming && this.canAim) {
      this.targetFOV = this.aimFOV;
    } else if (this.isSprinting && this.isMoving() && !window.quickDraw?.inDuel) {
      // FOV effect when sprinting, but not in QuickDraw duel
      this.targetFOV = this.defaultFOV + 7; // Less extreme FOV increase (was 10)
    } else {
      this.targetFOV = this.defaultFOV;
    }
    
    // Smooth FOV transition
    this.currentFOV = THREE.MathUtils.lerp(
      this.currentFOV, 
      this.targetFOV, 
      deltaTime * this.fovTransitionSpeed
    );
    
    // Only update camera FOV if it has changed enough to be noticeable
    if (Math.abs(this.camera.fov - this.currentFOV) > 0.01) {
      this.camera.fov = this.currentFOV;
      this.camera.updateProjectionMatrix();
    }

    // Handle head bob effect when moving - with improvements
    this.updateHeadBob(deltaTime);

    // Gravity
    this.velocity.y -= 20 * deltaTime;
    this.group.position.y += this.velocity.y * deltaTime;
    if (this.group.position.y < 1.6) {
      this.velocity.y = 0;
      this.group.position.y = 1.6;
      this.canJump = true;
    }

    // Movement - now with sprint capability
    const moveSpeed = this.getMoveSpeed();
    const forward = new THREE.Vector3();
    this.camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

    // Calculate new position based on movement input
    const newPosition = this.group.position.clone();
    
    if (this.moveForward) newPosition.add(forward.clone().multiplyScalar(moveSpeed * deltaTime));
    if (this.moveBackward) newPosition.add(forward.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveLeft) newPosition.add(right.clone().multiplyScalar(-moveSpeed * deltaTime));
    if (this.moveRight) newPosition.add(right.clone().multiplyScalar(moveSpeed * deltaTime));

    // Check for boundary collisions before applying the new position
    const canMove = this.checkBoundaryCollision(newPosition);
    
    if (canMove) {
      this.group.position.copy(newPosition);
    } else {
      // If can't move to the new position, try to slide along the boundary
      // This gives a better feeling than just stopping
      if (this.moveForward || this.moveBackward) {
        const slideX = this.group.position.clone();
        slideX.x = newPosition.x;
        if (this.checkBoundaryCollision(slideX)) {
          this.group.position.copy(slideX);
        }
      }
      
      if (this.moveLeft || this.moveRight) {
        const slideZ = this.group.position.clone();
        slideZ.z = newPosition.z;
        if (this.checkBoundaryCollision(slideZ)) {
          this.group.position.copy(slideZ);
        }
      }
    }

    // Send periodic network updates
    const now = performance.now();
    if (now - this.lastNetworkUpdate > this.networkUpdateInterval) {
      this.lastNetworkUpdate = now;
      this.sendNetworkUpdate();
    }
  }

  /**
   * Updates camera head bobbing effect for walking/running with much smoother transitions
   * @param {number} deltaTime - Time elapsed since last frame
   */
  updateHeadBob(deltaTime) {
    // Update target bobbing intensity based on movement
    if (this.isMoving() && this.canJump) {
      // Very subtle bobbing values
      this.targetBobIntensity = this.isSprinting ? 0.02 : 0.01;
    } else {
      this.targetBobIntensity = 0;
    }
    
    // Smoothly transition bob intensity
    this.bobIntensity = THREE.MathUtils.lerp(
      this.bobIntensity,
      this.targetBobIntensity,
      Math.min(1, deltaTime * this.bobTransitionSpeed)
    );
    
    // Only calculate bob if intensity is significant
    if (this.bobIntensity > 0.001) {
      // Update phase at a speed proportional to movement
      // Use different frequencies for vertical and horizontal to create more natural movement
      this.bobPhase += deltaTime * (this.isSprinting ? 10 : 6);
      
      // Calculate vertical and horizontal components
      const verticalBob = Math.sin(this.bobPhase * 2) * this.bobIntensity;
      // Much smaller horizontal component
      const horizontalBob = Math.cos(this.bobPhase) * this.bobIntensity * 0.3;
      
      // Apply to camera position smoothly
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight + verticalBob,
        Math.min(1, deltaTime * 8)
      );
      
      // Extremely subtle horizontal movement
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        horizontalBob,
        Math.min(1, deltaTime * 3)
      );
    } else {
      // Smoothly return to default position when not moving
      this.camera.position.y = THREE.MathUtils.lerp(
        this.camera.position.y,
        this.defaultCameraHeight,
        Math.min(1, deltaTime * 4)
      );
      
      this.camera.position.x = THREE.MathUtils.lerp(
        this.camera.position.x,
        0,
        Math.min(1, deltaTime * 3)
      );
    }
  }

  /**
   * Returns the current movement speed based on sprint state and location
   * @returns {number} The current movement speed
   */
  getMoveSpeed() {
    // Disable sprinting in QuickDraw duels
    if (window.quickDraw && window.quickDraw.inDuel) {
      return this.normalSpeed;
    }
    
    // Apply sprint speed if sprint key is pressed
    return this.isSprinting ? this.sprintSpeed : this.normalSpeed;
  }
  
  /**
   * Checks if the player is currently moving
   * @returns {boolean} True if any movement key is pressed
   */
  isMoving() {
    return this.moveForward || this.moveBackward || this.moveLeft || this.moveRight;
  }

  /**
   * Check if a position is valid regarding boundaries
   * @param {THREE.Vector3} position - The position to check
   * @returns {boolean} - True if the position is valid
   */
  checkBoundaryCollision(position) {
    // First check Quick Draw arena boundary
    if (window.quickDraw) {
      const inArena = window.quickDraw.isPointInArena(position);
      const wasInArena = window.quickDraw.isPointInArena(this.previousPosition);
      
      // If player is in a duel, they must stay inside
      if (window.quickDraw.inDuel && !inArena && wasInArena) {
        return false; // Can't leave arena during duel
      }
      
      // If player is not in a duel, they must stay outside
      if (!window.quickDraw.inDuel && inArena && !wasInArena) {
        return false; // Can't enter arena from outside (except via the portal)
      }
    }
    
    // Check town boundary
    if (window.physics && typeof window.physics.isPointInTown === 'function') {
      if (!window.physics.isPointInTown(position)) {
        return false; // Can't leave town
      }
    } else if (window.townDimensions) {
      // Fallback if physics isn't available but town dimensions are
      const width = window.townDimensions.width;
      const length = window.townDimensions.length;
      
      if (
        position.x < -width / 2 || 
        position.x > width / 2 || 
        position.z < -length / 2 || 
        position.z > length / 2
      ) {
        return false; // Can't leave town
      }
    }
    
    return true; // No collision
  }

  /**
   * Send position/rotation updates to the server.
   */
  sendNetworkUpdate() {
    if (this.id == null) return;
    const direction = new THREE.Vector3();
    this.camera.getWorldDirection(direction);

    networkManager.sendUpdate({
      position: {
        x: this.group.position.x,
        y: this.group.position.y,
        z: this.group.position.z
      },
      rotation: {
        y: this.group.rotation.y
      },
      isAiming: this.isAiming,
      isReloading: this.isReloading,
      health: this.health,
      quickDrawLobbyIndex: this.quickDrawLobbyIndex
    });
  }

  shoot() {
    if (this.bullets <= 0 || !this.canShoot || this.isReloading) {
      // No bullets or can't shoot
      if (this.bullets === 0) {
        const reloadMessage = document.getElementById('reload-message');
        if (reloadMessage) reloadMessage.style.display = 'block';
      }
      return;
    }
    // Actually shoot
    this.bullets--;
    updateAmmoUI(this);

    this.canShoot = false;
    setTimeout(() => { this.canShoot = true; }, 250);

    // Find bullet spawn
    const bulletStart = this.revolver.getBarrelTipWorldPosition();
    const shootDir = new THREE.Vector3();
    this.camera.getWorldDirection(shootDir);

    // Slight random spread
    shootDir.x += (Math.random() - 0.5) * 0.02;
    shootDir.y += (Math.random() - 0.5) * 0.02;
    shootDir.z += (Math.random() - 0.5) * 0.02;
    shootDir.normalize();

    // Recoil effect
    applyRecoil(this);

    // Call the callback to spawn bullet in main.js
    if (typeof this.onShootCallback === 'function') {
      this.onShootCallback(bulletStart, shootDir);
    }

    // If out of bullets, show reload hint
    if (this.bullets === 0) {
      const reloadMessage = document.getElementById('reload-message');
      if (reloadMessage) {
        reloadMessage.style.display = 'block';
      }
    }
  }

  /**
   * Called when the player takes damage.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Player ${this.id} took ${amount} damage. Health is now ${this.health}`);
    updateHealthUI(this);
    // You could add death/respawn logic here
    if (this.health === 0) {
      console.log('Game Over');
      // Optionally, disable input or show a Game Over screen.
      this.respawn();
    }
  }

  /**
   * Respawn the player after death
   */
  respawn() {
    // Reset health
    this.health = 100;
    updateHealthUI(this);
    
    // Spawn at a random position
    this.spawnPlayerRandomly();
    
    // Reset weapon state
    this.bullets = this.maxBullets;
    this.isReloading = false;
    this.canAim = true;
    this.isAiming = false;
    updateAmmoUI(this);
    
    // Reset vertical velocity
    this.velocity.y = 0;
    
    // Reset Quick Draw lobby information
    this.quickDrawLobbyIndex = -1;
    
    console.log('Player respawned');
  }

  startReload() {
    if (this.isReloading || this.bullets >= this.maxBullets) return;

    this.isReloading = true;
    this.reloadProgress = 0;
    const reloadMessage = document.getElementById('reload-message');
    const reloadProgressContainer = document.getElementById('reload-progress-container');
    if (reloadMessage) reloadMessage.style.display = 'none';
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'block';

    if (this.soundManager) {
      this.soundManager.playSound("shellejection");
      this.soundManager.playSound("reloading");
    }

    // Eject shells sequentially
    for (let i = 0; i < this.maxBullets - this.bullets; i++) {
      setTimeout(() => {
        ejectShell(this, this.scene, this.soundManager);
      }, i * 200);
    }

    const startTime = performance.now();
    const updateReload = (currentTime) => {
      const elapsed = currentTime - startTime;
      this.reloadProgress = Math.min((elapsed / this.reloadTime) * 100, 100);
      const reloadProgressBar = document.getElementById('reload-progress-bar');
      if (reloadProgressBar) {
        reloadProgressBar.style.width = this.reloadProgress + '%';
      }
      if (elapsed < this.reloadTime) {
        requestAnimationFrame(updateReload);
      } else {
        this.completeReload();
      }
    };
    requestAnimationFrame(updateReload);
  }

  completeReload() {
    this.bullets = this.maxBullets;
    updateAmmoUI(this);

    const reloadProgressContainer = document.getElementById('reload-progress-container');
    const reloadProgressBar = document.getElementById('reload-progress-bar');
    if (reloadProgressContainer) reloadProgressContainer.style.display = 'none';
    if (reloadProgressBar) reloadProgressBar.style.width = '0%';
    
    this.isReloading = false;
    this.sendNetworkUpdate(); // let others know
  }
  
  /**
   * Set the Quick Draw lobby index for this player
   * @param {number} index - The lobby index (0-4) or -1 for none
   */
  setQuickDrawLobby(index) {
    this.quickDrawLobbyIndex = index;
    
    // Update UI indicator
    const lobbyIndicator = document.getElementById('lobby-indicator');
    if (lobbyIndicator) {
      if (index >= 0) {
        lobbyIndicator.textContent = `Arena ${index + 1}`;
        lobbyIndicator.style.display = 'block';
      } else {
        lobbyIndicator.style.display = 'none';
      }
    }
    
    // Send update to server
    this.sendNetworkUpdate();
  }
}

================================================
File: /public/js/playerModel.js
================================================
// /public/js/playerModel.js
import { Revolver } from './revolver.js';

/**
 * A simple blocky first-person arms model.
 */
export class PlayerArms {
  constructor(scene) {
    this.scene = scene;
    this.group = new THREE.Group();

    // Right arm
    this.rightArm = this.createBlockyArm(0xC68642);
    this.rightArm.position.set(0.3, -0.4, -0.3);
    this.rightArm.rotation.set(0.3, 0, 0);
    this.group.add(this.rightArm);

    // Left arm
    this.leftArm = this.createBlockyArm(0xC68642);
    this.leftArm.position.set(-0.3, -0.4, -0.3);
    this.leftArm.rotation.set(0.3, 0, 0);
    this.group.add(this.leftArm);

    // Store initial positions/rotations for animations
    this.rightArmOriginalPos = this.rightArm.position.clone();
    this.rightArmOriginalRot = this.rightArm.rotation.clone();
    this.leftArmOriginalPos = this.leftArm.position.clone();
    this.leftArmOriginalRot = this.leftArm.rotation.clone();

    // Initially not visible
    this.setVisible(false);
  }

  /**
   * Creates a blocky "arm" geometry (only a small cube).
   * @param {number} color - Hex color (e.g. 0xC68642)
   * @returns {THREE.Group}
   */
  createBlockyArm(color) {
    const armGroup = new THREE.Group();

    // A small "hand" cube
    const handGeo = new THREE.BoxGeometry(0.08, 0.08, 0.08);
    const handMat = new THREE.MeshStandardMaterial({ color });
    const handMesh = new THREE.Mesh(handGeo, handMat);
    armGroup.add(handMesh);

    return armGroup;
  }

  /**
   * Sets the arms' visibility.
   * @param {boolean} visible
   */
  setVisible(visible) {
    this.group.visible = visible;
  }

  /**
   * Updates arms for aiming. (Example usage in first-person code.)
   * @param {THREE.Camera} camera
   * @param {boolean} isAiming
   * @param {THREE.Vector3} gunBarrelTip
   */
  updatePosition(camera, isAiming, gunBarrelTip = null) {
    if (isAiming) {
      // Hide left arm by default (single-handed revolver stance)
      this.leftArm.visible = false;
      // Show right arm for aiming
      this.rightArm.visible = true;

      if (gunBarrelTip) {
        // Rough alignment based on gun barrel tip if desired
        this.rightArm.position.set(0.32, -0.35, -0.5);
        this.rightArm.rotation.set(Math.PI / 2, 0, 0);
      }
    } else {
      // Hide arms when not aiming
      this.rightArm.visible = false;
      this.leftArm.visible = false;
    }
  }

  /**
   * Plays a smooth reload animation using the left arm.
   * (This method is for the first-person arms model and remains unchanged.)
   */
  playReloadAnimation() {
    const originalPos = this.leftArm.position.clone();
    const originalRot = this.leftArm.rotation.clone();

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    const frames = [
      { t: 0,   pos: { x: -0.3, y: -0.4, z: -0.3 },      rot: { x: 0, y: 0, z: 0 } },
      { t: 300, pos: { x: -0.1, y: -0.2, z: -0.3 },      rot: { x: -0.2, y: 0.1, z: 0.1 } },
      { t: 600, pos: { x: -0.1, y: -0.2, z: -0.3 },      rot: { x: -0.3, y: 0.1, z: 0.1 } },
      { t: 900, pos: { x: -0.3, y: -0.4, z: -0.3 },      rot: { x: 0, y: 0, z: 0 } }
    ];

    const startTime = performance.now();

    const animate = (time) => {
      const elapsed = time - startTime;
      let currentFrame = frames[0];
      let nextFrame = frames[frames.length - 1];
      for (let i = 0; i < frames.length - 1; i++) {
        if (elapsed >= frames[i].t && elapsed < frames[i + 1].t) {
          currentFrame = frames[i];
          nextFrame = frames[i + 1];
          break;
        }
      }
      const segmentDuration = nextFrame.t - currentFrame.t;
      let segmentTime = elapsed - currentFrame.t;
      let alpha = Math.min(segmentTime / segmentDuration, 1);
      alpha = easeInOutCubic(alpha);

      const lerp = (a, b, t) => a + (b - a) * t;
      const newPos = {
        x: lerp(currentFrame.pos.x, nextFrame.pos.x, alpha),
        y: lerp(currentFrame.pos.y, nextFrame.pos.y, alpha),
        z: lerp(currentFrame.pos.z, nextFrame.pos.z, alpha)
      };
      const newRot = {
        x: lerp(currentFrame.rot.x, nextFrame.rot.x, alpha),
        y: lerp(currentFrame.rot.y, nextFrame.rot.y, alpha),
        z: lerp(currentFrame.rot.z, nextFrame.rot.z, alpha)
      };

      this.leftArm.position.set(newPos.x, newPos.y, newPos.z);
      this.leftArm.rotation.set(newRot.x, newRot.y, newRot.z);

      if (elapsed < frames[frames.length - 1].t) {
        requestAnimationFrame(animate);
      } else {
        this.leftArm.position.copy(originalPos);
        this.leftArm.rotation.copy(originalRot);
      }
    };
    requestAnimationFrame(animate);
  }
}

/**
 * The third-person model used to represent remote players
 * (and possibly the local player in others' view).
 */
export class ThirdPersonModel {
  constructor(scene, playerId) {
    this.scene = scene;
    this.playerId = playerId;
    this.group = new THREE.Group();

    this.collisionBox = new THREE.Box3();
    this.hitboxSize = { width: 0.6, height: 1.8, depth: 0.6 };

    // Health
    this.health = 100;

    // Target position/rotation for smooth interpolation.
    this.targetPosition = this.group.position.clone();
    this.targetRotation = this.group.rotation.y;

    // Build a basic "Minecraft-like" character.
    this.createBlockyCharacter();
    scene.add(this.group);

    this.walkCycle = 0;
    this.isWalking = false;
    this.lastPosition = new THREE.Vector3();

    // To track active hit feedback timeout.
    this.hitFeedbackTimeout = null;
  }

  createBlockyCharacter() {
    // Head
    const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xC68642 });
    this.head = new THREE.Mesh(headGeo, headMat);
    this.head.position.y = 1.6;
    this.group.add(this.head);

    // Body
    const bodyGeo = new THREE.BoxGeometry(0.4, 0.6, 0.2);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3F51B5 });
    this.body = new THREE.Mesh(bodyGeo, bodyMat);
    this.body.position.y = 1.1;
    this.group.add(this.body);

    // Arms
    this.createBlockyArms();
    // Legs
    this.createBlockyLegs();
    // Hat
    this.createCowboyHat();

    // Use the normal revolver model on the left arm.
    this.addRevolver();
  }

  createBlockyArms() {
    // Right arm
    const armGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
    const skinMat = new THREE.MeshStandardMaterial({ color: 0xC68642 });
    this.rightArm = new THREE.Group();
    const rightArmMesh = new THREE.Mesh(armGeo, skinMat);
    rightArmMesh.position.y = -0.3;
    this.rightArm.add(rightArmMesh);
    this.rightArm.position.set(0.3, 1.4, 0);
    this.group.add(this.rightArm);

    // Left arm (holding the revolver)
    this.leftArm = new THREE.Group();
    const leftArmMesh = new THREE.Mesh(armGeo, skinMat);
    leftArmMesh.position.y = -0.3;
    this.leftArm.add(leftArmMesh);
    this.leftArm.position.set(-0.3, 1.4, 0);
    this.group.add(this.leftArm);
  }

  createBlockyLegs() {
    const legGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
    const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1A237E });
    // Right leg
    this.rightLeg = new THREE.Group();
    const rightLegMesh = new THREE.Mesh(legGeo, pantsMat);
    rightLegMesh.position.y = -0.3;
    this.rightLeg.add(rightLegMesh);
    this.rightLeg.position.set(0.1, 0.8, 0);
    this.group.add(this.rightLeg);

    // Left leg
    this.leftLeg = new THREE.Group();
    const leftLegMesh = new THREE.Mesh(legGeo, pantsMat);
    leftLegMesh.position.y = -0.3;
    this.leftLeg.add(leftLegMesh);
    this.leftLeg.position.set(-0.1, 0.8, 0);
    this.group.add(this.leftLeg);
  }

  createCowboyHat() {
    const hatMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

    // Hat brim
    const brimGeo = new THREE.BoxGeometry(0.5, 0.05, 0.5);
    this.hatBrim = new THREE.Mesh(brimGeo, hatMat);
    this.hatBrim.position.y = 0.225;
    this.head.add(this.hatBrim);

    // Hat top
    const topGeo = new THREE.BoxGeometry(0.3, 0.15, 0.3);
    this.hatTop = new THREE.Mesh(topGeo, hatMat);
    this.hatTop.position.y = 0.325;
    this.head.add(this.hatTop);
  }

  /**
   * Adds the normal revolver model to the third-person model's left arm.
   * The left arm holds the revolver.
   */
  addRevolver() {
    this.revolver = new Revolver();
    // Attach the revolver to the left arm.
    this.leftArm.add(this.revolver.group);
    // Set default positions and rotations for non-aiming state.
    this.revolverDefaultRotation = new THREE.Euler(-Math.PI / -1.5, Math.PI, 0);
    this.revolverAimingRotation = new THREE.Euler(-Math.PI / 0.7, Math.PI, 0);
    this.revolver.group.position.set(0.05, -0.8, -0.1);
    this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    this.revolver.group.visible = true;
  }

  updateCollisionBox() {
    const halfWidth = this.hitboxSize.width / 2;
    const halfDepth = this.hitboxSize.depth / 2;

    this.collisionBox.setFromPoints([
      new THREE.Vector3(
        this.group.position.x - halfWidth,
        this.group.position.y,
        this.group.position.z - halfDepth
      ),
      new THREE.Vector3(
        this.group.position.x + halfWidth,
        this.group.position.y + this.hitboxSize.height,
        this.group.position.z + halfDepth
      )
    ]);
  }

  /**
   * Smoothly updates the model’s position and rotation toward target values.
   * @param {number} deltaTime - Time elapsed since last frame.
   */
  animateMovement(deltaTime) {
    // Interpolate position and rotation for smooth remote movement
    this.group.position.lerp(this.targetPosition, 0.1);
    this.group.rotation.y = THREE.MathUtils.lerp(this.group.rotation.y, this.targetRotation, 0.1);
    this.updateCollisionBox();
  }

  /**
   * Updates the third-person model using data received from the server.
   * @param {Object} playerData
   */
  update(playerData) {
    // Update target position from network data (shifting from eye-level to model base)
    const newPos = new THREE.Vector3(
      playerData.position.x,
      playerData.position.y - 1.6,
      playerData.position.z
    );
    this.targetPosition.copy(newPos);

    // Update target rotation with a 180° offset for proper facing
    if (playerData.rotation && playerData.rotation.y !== undefined) {
      this.targetRotation = playerData.rotation.y + Math.PI;
    }

    // Check if walking based on movement.
    this.isWalking = newPos.distanceTo(this.lastPosition) > 0.01;
    this.lastPosition.copy(newPos);

    // Set pose based on whether the player is aiming.
    if (playerData.isAiming) {
      this.setAimingPose();
    } else {
      this.setNormalPose();
    }

    // If reloading, play the reload animation.
    if (playerData.isReloading) {
      this.playReloadAnimation();
    }

    // Update health if provided
    if (playerData.health !== undefined) {
      this.health = playerData.health;
    }
  }

  /**
   * Sets the model's pose for aiming.
   * The revolver (left arm) is rotated up by 90°.
   */
  setAimingPose() {
    // Right arm remains at default.
    this.rightArm.rotation.set(0, 0, 0);
    this.rightArm.position.set(0.3, 1.4, 0);

    // Left arm (holding revolver) rotates upward.
    this.leftArm.rotation.set(-Math.PI / 2, 0, 0);
    this.leftArm.position.set(-0.3, 1.4, 0);

    if (this.revolver) {
      this.revolver.group.rotation.copy(this.revolverAimingRotation);
    }

    this.head.rotation.x = 0.1;
  }

  /**
   * Sets the model's pose for normal (non-aiming) state.
   * The revolver (left arm) is rotated down a bit.
   */
  setNormalPose() {
    // Right arm stays default.
    this.rightArm.rotation.set(0, 0, 0);
    this.rightArm.position.set(0.3, 1.4, 0);

    // Left arm (holding revolver) is held lower.
    this.leftArm.rotation.set(-Math.PI / 15, 0, 0);
    this.leftArm.position.set(-0.3, 1.4, 0);

    if (this.revolver) {
      this.revolver.group.rotation.copy(this.revolverDefaultRotation);
    }

    this.head.rotation.x = 0;
  }

  /**
   * Plays a smooth reload animation for the model.
   * The reload animation is performed by the right arm.
   */
  playReloadAnimation() {
    const originalPos = this.rightArm.position.clone();
    const originalRot = this.rightArm.rotation.clone();

    // Define keyframes (in ms) for the right arm reload motion.
    const frames = [
      { t: 0,    pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } },
      { t: 250,  pos: { x: 0.2,  y: 1.5, z: 0 },        rot: { x: -Math.PI / 4, y: 0, z: -Math.PI / 4 } },
      { t: 500,  pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } },
      { t: 750,  pos: { x: 0.2,  y: 1.5, z: 0 },        rot: { x: -Math.PI / 4, y: 0, z: -Math.PI / 4 } },
      { t: 1000, pos: { x: 0.3,  y: 1.4, z: 0 },        rot: { x: 0,       y: 0, z: 0 } }
    ];

    const startTime = performance.now();

    const animate = (time) => {
      const elapsed = time - startTime;
      let currentFrame = frames[0];
      let nextFrame = frames[frames.length - 1];
      for (let i = 0; i < frames.length - 1; i++) {
        if (elapsed >= frames[i].t && elapsed < frames[i + 1].t) {
          currentFrame = frames[i];
          nextFrame = frames[i + 1];
          break;
        }
      }
      const segmentDuration = nextFrame.t - currentFrame.t;
      let segmentTime = elapsed - currentFrame.t;
      let alpha = Math.min(segmentTime / segmentDuration, 1);

      // Cubic easing for smooth interpolation.
      const easeInOutCubic = t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      alpha = easeInOutCubic(alpha);

      const lerp = (a, b, t) => a + (b - a) * t;
      const newPos = {
        x: lerp(currentFrame.pos.x, nextFrame.pos.x, alpha),
        y: lerp(currentFrame.pos.y, nextFrame.pos.y, alpha),
        z: lerp(currentFrame.pos.z, nextFrame.pos.z, alpha)
      };
      const newRot = {
        x: lerp(currentFrame.rot.x, nextFrame.rot.x, alpha),
        y: lerp(currentFrame.rot.y, nextFrame.rot.y, alpha),
        z: lerp(currentFrame.rot.z, nextFrame.rot.z, alpha)
      };

      this.rightArm.position.set(newPos.x, newPos.y, newPos.z);
      this.rightArm.rotation.set(newRot.x, newRot.y, newRot.z);

      if (elapsed < frames[frames.length - 1].t) {
        requestAnimationFrame(animate);
      } else {
        this.rightArm.position.copy(originalPos);
        this.rightArm.rotation.copy(originalRot);
      }
    };

    requestAnimationFrame(animate);
  }

  /**
   * Animates the walk cycle.
   * @param {number} deltaTime
   */
  animateWalk(deltaTime) {
    this.walkCycle += deltaTime * 5;
    // Leg swing
    this.rightLeg.rotation.x = Math.sin(this.walkCycle) * 0.7;
    this.leftLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.7;

    // Arm swing (if not in an aiming pose)
    if (this.rightArm.rotation.x === 0 && this.leftArm.rotation.x === 0) {
      this.rightArm.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.5;
      this.leftArm.rotation.x = Math.sin(this.walkCycle) * 0.5;
    }

    // Subtle body bob
    this.body.position.y = 1.1 + Math.abs(Math.sin(this.walkCycle * 2)) * 0.05;
  }

  /**
   * Resets the walk animation.
   */
  resetWalkAnimation() {
    this.rightLeg.rotation.x = 0;
    this.leftLeg.rotation.x = 0;

    if (Math.abs(this.rightArm.rotation.x) < 0.1 &&
        Math.abs(this.leftArm.rotation.x) < 0.1) {
      this.rightArm.rotation.x = 0;
      this.leftArm.rotation.x = 0;
    }
    this.body.position.y = 1.1;
  }

  /**
   * Removes the model from the scene (e.g. on player disconnect).
   * Fully disposes geometry and material.
   */
  remove() {
    this.scene.remove(this.group);
    this.group.traverse(child => {
      if (child.isMesh) {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => mat.dispose());
          } else {
            child.material.dispose();
          }
        }
      }
    });
  }

  /**
   * Provides visual feedback (temporary red flash) when the model is hit.
   * The original materials are stored on each mesh (if not already stored)
   * and restored after 200ms.
   */
  showHitFeedback() {
    // Clear any existing hit feedback timeout.
    if (this.hitFeedbackTimeout) {
      clearTimeout(this.hitFeedbackTimeout);
    }
    // Traverse the model and replace each mesh's material with a red flash.
    this.group.traverse(child => {
      if (child.isMesh && child.material) {
        // Store the original material in userData if not already stored.
        if (!child.userData.originalMaterial) {
          child.userData.originalMaterial = child.material;
        }
        child.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        child.material.needsUpdate = true;
      }
    });
    // After 200ms, restore the original materials.
    this.hitFeedbackTimeout = setTimeout(() => {
      this.group.traverse(child => {
        if (child.isMesh && child.userData.originalMaterial) {
          child.material.dispose();
          child.material = child.userData.originalMaterial;
          child.material.needsUpdate = true;
          delete child.userData.originalMaterial;
        }
      });
      this.hitFeedbackTimeout = null;
    }, 200);
  }

  /**
   * Reduces health when hit.
   * @param {number} amount - Damage amount.
   */
  takeDamage(amount) {
    this.health = Math.max(this.health - amount, 0);
    console.log(`Remote player ${this.playerId} took ${amount} damage. Health: ${this.health}`);
    // Optionally, you could change the model’s appearance or remove it on death.
  }
}


================================================
File: /public/js/quickDraw.js
================================================
/**
 * Quick Draw game mode implementation
 * Players face off in a wild west duel where they must wait for the "draw" signal
 * before pulling their revolvers and shooting at each other.
 * Now with a single portal that automatically assigns players to available arenas.
 */

import { PhysicsSystem } from './physics.js';

export class QuickDraw {
    constructor(scene, localPlayer, networkManager, soundManager) {
        this.scene = scene;
        this.localPlayer = localPlayer;
        this.networkManager = networkManager;
        this.soundManager = soundManager;
        
        // Game state
        this.inLobby = false;
        this.inDuel = false;
        this.duelOpponentId = null;
        this.duelState = 'none'; // 'none', 'ready', 'countdown', 'draw'
        this.gunLocked = false;
        this.originalCanAim = true;
        // Record the time (in ms) until which the gun remains locked
        this.penaltyEndTime = 0;
        
        // Current active arena index (0-4, -1 means none)
        this.activeArenaIndex = -1;
        
        // Arena configurations
        this.maxArenas = 5; // Support for 5 concurrent lobbies as requested
        this.arenaConfigs = this.createArenaConfigs();
        
        // Initialize physics system for collision detection
        this.physics = new PhysicsSystem();
        
        // Track arena physics bodies
        this.arenaBoundaries = new Array(this.maxArenas).fill(null);
        
        // Initialize the single portal, duel areas, and network handlers
        this.initPortal();
        this.createDuelAreas();
        this.initNetworkHandlers();
        this.createUI();

        // Make this instance globally accessible for network handlers
        window.quickDraw = this;
    }
    
    /**
     * Create arena configurations with different positions
     */
    createArenaConfigs() {
        const configs = [];
        // Positioning logic - arenas are placed in a row with proper spacing
        
        // Calculate base position - if town dimensions are available, place them outside town
        let baseZ = 0;
        if (window.townDimensions) {
            baseZ = window.townDimensions.length + 50; // Position outside town boundary
        } else {
            baseZ = 100; // Default position if town dimensions aren't available
        }
        
        // Arena spacing - make sure they don't overlap
        const spacingX = 50; // Allow enough space between arenas
        
        // Create 5 arena configs
        for (let i = 0; i < this.maxArenas; i++) {
            // Calculate position - arrange in a row along X axis
            let offsetX = (i - 2) * spacingX; // Center on zero, spread outward
            
            configs.push({
                index: i,
                center: new THREE.Vector3(offsetX, 0, baseZ),
                radius: 15,  // Arena radius
                height: 5,   // Arena height
                portalColor: this.getPortalColor(i),
                active: false, // Whether this arena is currently in use
                portalCollider: null, // Will store collision box for the portal
                duelArea: null, // Will store the THREE.Group for the arena
                duelAreaActive: false // Track if this duel area is currently visible
            });
        }
        
        return configs;
    }
    
    /**
     * Get a unique color for each portal
     */
    getPortalColor(index) {
        const colors = [
            0xFF6B00, // Orange (original)
            0x4CAF50, // Green
            0x2196F3, // Blue
            0x9C27B0, // Purple
            0xFFEB3B  // Yellow
        ];
        
        return colors[index % colors.length];
    }
    
    /**
     * Create UI elements for Quick Draw game mode.
     */
    createUI() {
        // Text overlay for messages
        this.messageOverlay = document.createElement('div');
        this.messageOverlay.id = 'quick-draw-message';
        this.messageOverlay.style.position = 'absolute';
        this.messageOverlay.style.top = '50%';
        this.messageOverlay.style.left = '50%';
        this.messageOverlay.style.transform = 'translate(-50%, -50%)';
        this.messageOverlay.style.color = 'white';
        this.messageOverlay.style.fontSize = '48px';
        this.messageOverlay.style.fontWeight = 'bold';
        this.messageOverlay.style.textAlign = 'center';
        this.messageOverlay.style.display = 'none';
        this.messageOverlay.style.fontFamily = 'Western, Arial, sans-serif';
        this.messageOverlay.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.5)';
        this.messageOverlay.style.zIndex = '1000';
        document.getElementById('game-container').appendChild(this.messageOverlay);
        
        // Draw circle animation
        this.drawCircle = document.createElement('div');
        this.drawCircle.id = 'draw-circle';
        this.drawCircle.style.position = 'absolute';
        this.drawCircle.style.top = '50%';
        this.drawCircle.style.left = '50%';
        this.drawCircle.style.transform = 'translate(-50%, -50%) scale(0)';
        this.drawCircle.style.width = '600px';
        this.drawCircle.style.height = '600px';
        this.drawCircle.style.borderRadius = '50%';
        this.drawCircle.style.border = '8px solid #FF0000';
        this.drawCircle.style.boxShadow = '0 0 20px #FF0000';
        this.drawCircle.style.opacity = '0';
        this.drawCircle.style.transition = 'transform 0.3s, opacity 0.3s';
        this.drawCircle.style.pointerEvents = 'none';
        this.drawCircle.style.zIndex = '999';
        this.drawCircle.style.display = 'none';
        document.getElementById('game-container').appendChild(this.drawCircle);
        
        // Add status indicator
        this.statusIndicator = document.createElement('div');
        this.statusIndicator.id = 'quick-draw-status';
        this.statusIndicator.style.position = 'absolute';
        this.statusIndicator.style.top = '120px';
        this.statusIndicator.style.left = '20px';
        this.statusIndicator.style.color = 'white';
        this.statusIndicator.style.fontSize = '16px';
        this.statusIndicator.style.backgroundColor = 'rgba(0,0,0,0.5)';
        this.statusIndicator.style.padding = '5px';
        this.statusIndicator.style.borderRadius = '5px';
        this.statusIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.statusIndicator);
        
        // Add lobby indicator
        this.lobbyIndicator = document.createElement('div');
        this.lobbyIndicator.id = 'lobby-indicator';
        this.lobbyIndicator.style.position = 'absolute';
        this.lobbyIndicator.style.top = '150px';
        this.lobbyIndicator.style.left = '20px';
        this.lobbyIndicator.style.color = 'white';
        this.lobbyIndicator.style.fontSize = '16px';
        this.lobbyIndicator.style.backgroundColor = 'rgba(255, 107, 0, 0.7)';
        this.lobbyIndicator.style.padding = '8px 12px';
        this.lobbyIndicator.style.borderRadius = '5px';
        this.lobbyIndicator.style.display = 'none';
        document.getElementById('game-container').appendChild(this.lobbyIndicator);
    }
    
    /**
     * Initialize the single portal for all Quick Draw arenas
     */
    initPortal() {
        this.portalGroup = new THREE.Group();
        
        // Calculate portal position
        let portalX = 0;
        let portalY = 2.5; // Increased Y position for a taller portal
        let portalZ = 0;
        
        // If town dimensions are available, use them for positioning
        if (window.townDimensions) {
            const streetWidth = window.townDimensions.streetWidth;
            const townLength = window.townDimensions.length;
            
            // Position portal on the side of the street in the center of town
            portalX = streetWidth * 0.4; // Move to the right side of the street
            portalZ = 0; // Center of town (Z axis)
        }
        
        // Create a wooden frame portal
        this.createWoodenFramePortal(portalX, portalY, portalZ);
        
        // Create collision detector for the portal - make it larger to match the bigger portal
        const portalCollider = new THREE.Box3(
            new THREE.Vector3(portalX - 2.5, 0, portalZ - 1),
            new THREE.Vector3(portalX + 2.5, portalY * 2, portalZ + 1)
        );
        
        // Store the collider for all arena configs to reference the same portal
        for (let i = 0; i < this.maxArenas; i++) {
            this.arenaConfigs[i].portalCollider = portalCollider;
        }
        
        this.scene.add(this.portalGroup);
        
        // Create portal instructions
        this.createPortalInstructions(new THREE.Vector3(portalX, portalY, portalZ));
    }
    
    /**
     * Creates a wooden frame portal with Minecraft-like portal filling and a wooden sign on top
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} z - Z position
     */
    createWoodenFramePortal(x, y, z) {
        const frameWidth = 5; // Wider frame
        const frameHeight = 7; // Taller frame
        const beamThickness = 0.25; // Thicker beams
        
        // Create wooden beam material with more texture
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,  // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        // Create the wooden frame beams
        // Top beam
        const topBeam = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, beamThickness, beamThickness),
            woodMaterial
        );
        topBeam.position.set(0, frameHeight/2, 0);
        this.portalGroup.add(topBeam);
        
        // Bottom beam
        const bottomBeam = new THREE.Mesh(
            new THREE.BoxGeometry(frameWidth, beamThickness, beamThickness),
            woodMaterial
        );
        bottomBeam.position.set(0, -frameHeight/2, 0);
        this.portalGroup.add(bottomBeam);
        
        // Left beam
        const leftBeam = new THREE.Mesh(
            new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness),
            woodMaterial
        );
        leftBeam.position.set(-frameWidth/2, 0, 0);
        this.portalGroup.add(leftBeam);
        
        // Right beam
        const rightBeam = new THREE.Mesh(
            new THREE.BoxGeometry(beamThickness, frameHeight, beamThickness),
            woodMaterial
        );
        rightBeam.position.set(frameWidth/2, 0, 0);
        this.portalGroup.add(rightBeam);
        
        // Create the Minecraft-like portal filling with a more static appearance
        const fillingGeometry = new THREE.PlaneGeometry(frameWidth - beamThickness, frameHeight - beamThickness, 32, 32); // More segments for wave effect
        
        // Create a custom shader material for Minecraft nether portal effect - more static version
        const fillingMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                uniform float time;
                
                void main() {
                    vUv = uv;
                    // Add very subtle displacement to vertices
                    vec3 pos = position;
                    pos.x += sin(position.y * 2.0 + time * 0.5) * 0.01;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                varying vec2 vUv;
                
                // Simple noise function
                float noise(vec2 p) {
                    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                }
                
                void main() {
                    // Static blue base with subtle animated swirls
                    vec3 baseColor = vec3(0.0, 0.3, 0.8); // Blue base
                    
                    // Add subtle swirl pattern
                    float swirl = sin(vUv.x * vUv.y * 10.0 + time * 0.2) * 0.1;
                    
                    // Add a bit of noise pattern
                    float noiseVal = noise(vUv * 5.0 + vec2(time * 0.05, time * 0.03));
                    
                    // Mix colors for subtle effect
                    vec3 color = mix(baseColor, vec3(0.2, 0.6, 1.0), swirl + noiseVal * 0.1);
                    
                    // Add edge glow
                    float edgeX = smoothstep(0.0, 0.07, vUv.x) * smoothstep(1.0, 0.93, vUv.x);
                    float edgeY = smoothstep(0.0, 0.07, vUv.y) * smoothstep(1.0, 0.93, vUv.y);
                    float edge = edgeX * edgeY;
                    
                    // Subtle pulsing
                    float pulse = 0.9 + sin(time * 0.5) * 0.1;
                    color = mix(color, vec3(0.4, 0.7, 1.0), (1.0 - edge) * pulse * 0.2);
                    
                    gl_FragColor = vec4(color, 0.9); // Slightly transparent
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        const filling = new THREE.Mesh(fillingGeometry, fillingMaterial);
        filling.position.set(0, 0, -0.05);
        this.portalGroup.add(filling);
        
        // Update the time uniform in the shader
        this.animatePortalFilling(fillingMaterial);
        
        // Create a wooden sign on top of the portal
        this.createWoodenSign(frameWidth, frameHeight);
        
        // Add particle effect around the portal
        this.addPortalParticles(frameWidth, frameHeight);
        
        // Position the portal
        this.portalGroup.position.set(x, y, z);
        this.portalGroup.rotation.y = Math.PI / 2; // Make it vertical and facing the street
    }
    
    /**
     * Creates a wooden sign on top of the portal with text visible from both sides
     * @param {number} frameWidth - Width of the portal frame
     * @param {number} frameHeight - Height of the portal frame
     */
    createWoodenSign(frameWidth, frameHeight) {
        // Create wooden sign material
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x8B4513,  // Brown
            roughness: 0.9,
            metalness: 0.1
        });
        
        // Create sign post
        const signWidth = frameWidth * 0.8;
        const signHeight = 0.8;
        const signDepth = 0.1;
        
        // Create the wooden sign board
        const signGeometry = new THREE.BoxGeometry(signWidth, signHeight, signDepth);
        const sign = new THREE.Mesh(signGeometry, woodMaterial);
        
        // Position the sign above the portal
        sign.position.set(0, frameHeight/2 + signHeight/2 + 0.1, 0);
        
        // Create two small posts to connect the sign to the portal frame
        const postGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
        
        // Left post
        const leftPost = new THREE.Mesh(postGeometry, woodMaterial);
        leftPost.position.set(-signWidth/3, frameHeight/2 + 0.2, 0);
        
        // Right post
        const rightPost = new THREE.Mesh(postGeometry, woodMaterial);
        rightPost.position.set(signWidth/3, frameHeight/2 + 0.2, 0);
        
        // Create text for both sides of the sign
        const createSignText = (isBack) => {
            const textCanvas = document.createElement('canvas');
            const context = textCanvas.getContext('2d');
            textCanvas.width = 512;
            textCanvas.height = 128;
            
            // Clear background
            context.fillStyle = '#8B4513'; // Match the wood color
            context.fillRect(0, 0, textCanvas.width, textCanvas.height);
            
            // Add wood grain texture
            context.strokeStyle = '#6B3F13'; // Darker wood color for grain
            context.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                const y = i * 7;
                context.beginPath();
                context.moveTo(0, y);
                // Wavy line for wood grain
                for (let x = 0; x < textCanvas.width; x += 20) {
                    context.lineTo(x + 10, y + (Math.random() * 4 - 2));
                }
                context.stroke();
            }
            
            // Add text
            context.fillStyle = 'white';
            context.font = 'bold 70px Western, Arial, sans-serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('Join 1v1', 256, 64);
            
            // Add a slightly darker stroke to make text more readable
            context.strokeStyle = 'rgba(0,0,0,0.5)';
            context.lineWidth = 2;
            context.strokeText('Join 1v1', 256, 64);
            
            const texture = new THREE.CanvasTexture(textCanvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.FrontSide
            });
            
            // Create text plane slightly larger than the sign to avoid z-fighting
            const textGeometry = new THREE.PlaneGeometry(signWidth - 0.05, signHeight - 0.05);
            const textMesh = new THREE.Mesh(textGeometry, material);
            
            // Position text just in front of the sign
            const zOffset = isBack ? -signDepth/2 - 0.01 : signDepth/2 + 0.01;
            textMesh.position.set(0, 0, zOffset);
            
            // If this is the back face, rotate it 180 degrees
            if (isBack) {
                textMesh.rotation.y = Math.PI;
            }
            
            return textMesh;
        };
        
        // Create front and back text
        const frontText = createSignText(false);
        const backText = createSignText(true);
        
        // Add text to sign
        sign.add(frontText);
        sign.add(backText);
        
        // Add everything to the portal group
        this.portalGroup.add(sign);
        this.portalGroup.add(leftPost);
        this.portalGroup.add(rightPost);
    }
    
    /**
     * Adds particle effects around the portal to enhance the Minecraft feel
     * @param {number} width - Width of the portal
     * @param {number} height - Height of the portal
     */
    addPortalParticles(width, height) {
        const particleCount = 50;
        const particleGroup = new THREE.Group();
        
        // Create particle material (white to contrast with blue portal)
        const particleMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.15,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
        });
        
        // Create particle geometry
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = []; // Store velocities for animation
        
        // Create particles around the frame
        for (let i = 0; i < particleCount; i++) {
            // Position particles around the portal frame
            const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = (Math.random() - 0.5) * width;
                    y = height/2 + Math.random() * 0.5;
                    break;
                case 1: // right
                    x = width/2 + Math.random() * 0.5;
                    y = (Math.random() - 0.5) * height;
                    break;
                case 2: // bottom
                    x = (Math.random() - 0.5) * width;
                    y = -height/2 - Math.random() * 0.5;
                    break;
                case 3: // left
                    x = -width/2 - Math.random() * 0.5;
                    y = (Math.random() - 0.5) * height;
                    break;
            }
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2; // Small Z variation
            
            // Random velocities moving toward the portal
            velocities.push({
                x: -x * 0.01 * (0.5 + Math.random() * 0.5),
                y: -y * 0.01 * (0.5 + Math.random() * 0.5),
                z: (Math.random() - 0.5) * 0.01,
                life: 0,
                maxLife: 60 + Math.floor(Math.random() * 60) // Random lifetime
            });
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particleGroup.add(particles);
        this.portalGroup.add(particleGroup);
        
        // Animate particles
        const animateParticles = () => {
            const positions = particles.geometry.attributes.position.array;
            
            // Update each particle
            for (let i = 0; i < particleCount; i++) {
                // Update position based on velocity
                positions[i * 3] += velocities[i].x;
                positions[i * 3 + 1] += velocities[i].y;
                positions[i * 3 + 2] += velocities[i].z;
                
                // Update life
                velocities[i].life++;
                
                // If particle has reached end of life or center of portal, reset it
                if (velocities[i].life >= velocities[i].maxLife || 
                    (Math.abs(positions[i * 3]) < 0.3 && Math.abs(positions[i * 3 + 1]) < 0.3)) {
                    
                    // Reset to edge of portal
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    
                    switch(side) {
                        case 0: // top
                            x = (Math.random() - 0.5) * width;
                            y = height/2 + Math.random() * 0.5;
                            break;
                        case 1: // right
                            x = width/2 + Math.random() * 0.5;
                            y = (Math.random() - 0.5) * height;
                            break;
                        case 2: // bottom
                            x = (Math.random() - 0.5) * width;
                            y = -height/2 - Math.random() * 0.5;
                            break;
                        case 3: // left
                            x = -width/2 - Math.random() * 0.5;
                            y = (Math.random() - 0.5) * height;
                            break;
                    }
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                    
                    // New velocity
                    velocities[i] = {
                        x: -x * 0.01 * (0.5 + Math.random() * 0.5),
                        y: -y * 0.01 * (0.5 + Math.random() * 0.5),
                        z: (Math.random() - 0.5) * 0.01,
                        life: 0,
                        maxLife: 60 + Math.floor(Math.random() * 60)
                    };
                }
            }
            
            // Update geometry
            particles.geometry.attributes.position.needsUpdate = true;
            
            requestAnimationFrame(animateParticles);
        };
        
        requestAnimationFrame(animateParticles);
    }
    
    /**
     * Animate the portal filling shader
     * @param {THREE.ShaderMaterial} material - The shader material to animate
     */
    animatePortalFilling(material) {
        const animate = () => {
            material.uniforms.time.value += 0.01;
            requestAnimationFrame(animate);
        };
        
        requestAnimationFrame(animate);
    }
    
    /**
     * Creates a floating instruction panel for the portal
     * @param {THREE.Vector3} portalPosition - The position of the portal
     */
    createPortalInstructions(portalPosition) {
        // Create a container for the instructions
        const instructionsId = 'portal-instructions';
        
        // Check if it already exists
        let instructionsElement = document.getElementById(instructionsId);
        if (!instructionsElement) {
            instructionsElement = document.createElement('div');
            instructionsElement.id = instructionsId;
            instructionsElement.className = 'portal-instructions';
            instructionsElement.style.position = 'absolute';
            instructionsElement.style.top = '35%';
            instructionsElement.style.left = '50%';
            instructionsElement.style.transform = 'translate(-50%, -50%)';
            instructionsElement.style.color = 'white';
            instructionsElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
            instructionsElement.style.padding = '20px';
            instructionsElement.style.borderRadius = '10px';
            instructionsElement.style.textAlign = 'center';
            instructionsElement.style.width = '400px';
            instructionsElement.style.display = 'none';
            instructionsElement.style.zIndex = '500';
            instructionsElement.style.fontFamily = 'Arial, sans-serif';
            
            instructionsElement.innerHTML = `
                <h2 style="color:#FF6B00; margin-bottom:10px;">Quick Draw Duel</h2>
                <p>Step into the portal to challenge another player to a classic western showdown!</p>
                <ul style="text-align:left; margin-top:10px; padding-left:20px;">
                    <li>Wait for opponent and follow the "READY?" signal</li>
                    <li>Keep your gun holstered until you see "DRAW!"</li>
                    <li>Drawing too early will lock your gun for 3 seconds</li>
                    <li>First player to hit their opponent wins!</li>
                </ul>
            `;
            
            document.getElementById('game-container').appendChild(instructionsElement);
        }
        
        // Show instructions when player gets close to portal
        // Adjust the proximity box based on portal position
        const proximityBox = new THREE.Box3(
            new THREE.Vector3(portalPosition.x - 4, portalPosition.y - 4, portalPosition.z - 4),
            new THREE.Vector3(portalPosition.x + 4, portalPosition.y + 4, portalPosition.z + 4)
        );
        
        // Store the box reference and element for the portal
        this.portalProximityBox = proximityBox;
        this.instructionsElement = instructionsElement;
    }
    
    /**
     * Check if player is near the portal and show appropriate instructions
     */
    updatePortalInstructions() {
        if (!this.localPlayer || !this.localPlayer.group) {
            return;
        }
        
        const playerPos = this.localPlayer.group.position.clone();
        
        // Check if near portal
        if (this.portalProximityBox && this.portalProximityBox.containsPoint(playerPos) && 
            !this.inLobby && !this.inDuel) {
            // Show portal instructions
            if (this.instructionsElement) {
                this.instructionsElement.style.display = 'block';
            }
        } else {
            // Hide instructions
            if (this.instructionsElement) {
                this.instructionsElement.style.display = 'none';
            }
        }
    }
    
    /**
     * Create all duel areas
     */
    createDuelAreas() {
        for (let i = 0; i < this.maxArenas; i++) {
            this.createDuelArea(i);
        }
    }
    
    /**
     * Create a duel area for a specific arena index
     * @param {number} arenaIndex - The arena index (0-4)
     */
    createDuelArea(arenaIndex) {
        const config = this.arenaConfigs[arenaIndex];
        const duelArea = new THREE.Group();
        
        // Ground platform
        const groundGeometry = new THREE.CircleGeometry(config.radius, 32);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xCD853F, // Sandy color
            roughness: 0.9,
            metalness: 0.1
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.copy(config.center);
        ground.position.y = 0.01; // Slightly above main ground
        ground.receiveShadow = true;
        duelArea.add(ground);
        
        // Add western-themed props
        this.addDuelProps(duelArea, arenaIndex);
        
        // Initially hide the duel area
        duelArea.visible = false;
        this.scene.add(duelArea);
        
        // Store in arena config
        config.duelArea = duelArea;
    }
    
    /**
     * Add western-themed props to a specific duel area
     * @param {THREE.Group} duelArea - The duel area group to add props to
     * @param {number} arenaIndex - The arena index for variations
     */
    addDuelProps(duelArea, arenaIndex) {
        const config = this.arenaConfigs[arenaIndex];
        
        // Add cacti around the edge with variations based on arenaIndex
        const cactusCount = 6 + arenaIndex % 3; // Vary cactus count by arena
        
        for (let i = 0; i < cactusCount; i++) {
            const angle = (i / cactusCount) * Math.PI * 2;
            const distance = 12 + Math.random() * 2;
            
            const x = config.center.x + Math.cos(angle) * distance;
            const z = config.center.z + Math.sin(angle) * distance;
            
            this.createCactus(x, z, duelArea, arenaIndex);
        }
        
        // Add arena number marker in the center
        this.createArenaMarker(config.center, arenaIndex, duelArea);
    }
    
    /**
     * Create a central marker showing the arena number
     * @param {THREE.Vector3} center - The center position of the arena
     * @param {number} arenaIndex - The arena index (0-4)
     * @param {THREE.Group} duelArea - The duel area group to add the marker to
     */
    createArenaMarker(center, arenaIndex, duelArea) {
        // Create a standalone sign post
        const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
        const woodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const post = new THREE.Mesh(postGeometry, woodMaterial);
        post.position.set(center.x, 1, center.z);
        duelArea.add(post);
        
        // Create a sign with the arena number
        const signGeometry = new THREE.BoxGeometry(1, 0.7, 0.1);
        const signMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
        const sign = new THREE.Mesh(signGeometry, signMaterial);
        sign.position.set(center.x, 1.8, center.z);
        duelArea.add(sign);
        
        // Create a texture for the text
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 128;
        canvas.height = 64;
        context.fillStyle = 'white';
        context.font = 'bold 40px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(`#${arenaIndex + 1}`, 64, 32);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        // Apply texture to a plane in front of the sign
        const textGeometry = new THREE.PlaneGeometry(0.8, 0.5);
        const textMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
        });
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(center.x, 1.8, center.z + 0.06);
        duelArea.add(textMesh);
    }
    
    /**
     * Create a simple cactus model at the given position with variations based on arena index
     * @param {number} x - X position
     * @param {number} z - Z position
     * @param {THREE.Group} duelArea - The duel area group to add the cactus to
     * @param {number} arenaIndex - Arena index for variations
     */
    createCactus(x, z, duelArea, arenaIndex) {
        const cactusGroup = new THREE.Group();
        
        // Different cactus colors based on arena index
        const cactusColors = [
            0x2E8B57, // Sea green (default)
            0x006400, // Dark green
            0x228B22, // Forest green
            0x3CB371, // Medium sea green
            0x32CD32  // Lime green
        ];
        
        const cactusColor = cactusColors[arenaIndex % cactusColors.length];
        
        // Main body
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
        const cactusMaterial = new THREE.MeshStandardMaterial({ color: cactusColor });
        const body = new THREE.Mesh(bodyGeometry, cactusMaterial);
        body.position.y = 1;
        cactusGroup.add(body);
        
        // Add arms
        const armCount = (arenaIndex % 3) + 1; // 1, 2, or 3 arms based on arena index
        
        for (let i = 0; i < armCount; i++) {
            const armGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const arm = new THREE.Mesh(armGeometry, cactusMaterial);
            
            const angle = Math.random() * Math.PI * 2;
            const height = 0.5 + Math.random() * 1;
            
            arm.position.set(
                Math.cos(angle) * 0.3,
                height,
                Math.sin(angle) * 0.3
            );
            
            arm.rotation.z = Math.PI / 4 * (Math.random() > 0.5 ? 1 : -1);
            arm.rotation.y = angle;
            
            cactusGroup.add(arm);
        }
        
        cactusGroup.position.set(x, 0, z);
        cactusGroup.castShadow = true;
        duelArea.add(cactusGroup);
    }
    
    /**
     * Initialize network handlers for Quick Draw game mode.
     */
    initNetworkHandlers() {
        // Extend existing network manager with Quick Draw methods
        this.networkManager.sendQuickDrawJoin = (arenaIndex) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawJoin',
                    arenaIndex: arenaIndex
                }));
            }
        };
        
        this.networkManager.sendQuickDrawLeave = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawLeave'
                }));
            }
        };
        
        this.networkManager.sendQuickDrawShoot = (opponentId) => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                console.log(`Sending Quick Draw hit notification to server: player ${this.localPlayer.id} hit player ${opponentId}`);
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawShoot',
                    opponentId: opponentId,
                    arenaIndex: this.activeArenaIndex
                }));
            }
        };
        
        this.networkManager.sendQuickDrawReady = () => {
            if (this.networkManager.socket && this.networkManager.socket.readyState === WebSocket.OPEN) {
                this.networkManager.socket.send(JSON.stringify({
                    type: 'quickDrawReady',
                    arenaIndex: this.activeArenaIndex
                }));
            }
        };
        
        // Hook into the existing socket onmessage handler
        const originalOnMessage = this.networkManager.socket.onmessage;
        this.networkManager.socket.onmessage = (event) => {
            // Call original handler
            if (originalOnMessage) {
                originalOnMessage(event);
            }
            
            try {
                const message = JSON.parse(event.data);
                
                // Handle Quick Draw specific messages
                switch (message.type) {
                    case 'quickDrawJoin':
                        this.handleQueueJoin(message);
                        break;
                    case 'quickDrawMatch':
                        this.handleMatchFound(message);
                        break;
                    case 'quickDrawReady':
                        this.showReadyMessage();
                        break;
                    case 'quickDrawCountdown':
                        this.startDuelCountdown();
                        break;
                    case 'quickDrawDraw':
                        this.triggerDraw();
                        break;
                    case 'quickDrawEnd':
                        this.endDuel(message.winnerId);
                        break;
                }
            } catch (err) {
                console.error('Error parsing Quick Draw message:', err);
            }
        };
    }
    
    /**
     * Creates an invisible cylindrical boundary for a specific QuickDraw arena
     * @param {number} arenaIndex - The arena index (0-4)
     */
    createQuickDrawArenaBoundary(arenaIndex) {
        if (!this.physics) return null;
        
        const config = this.arenaConfigs[arenaIndex];
        
        // Create the physics boundary for this arena
        const arenaBody = this.physics.createQuickDrawArenaBoundary(
            config.center,
            config.radius,
            config.height
        );
        
        // Store the arena body for this arena
        this.arenaBoundaries[arenaIndex] = arenaBody;
        
        return arenaBody;
    }
    
    /**
     * Removes a specific QuickDraw arena boundary
     * @param {number} arenaIndex - The arena index (0-4)
     */
    removeQuickDrawArenaBoundary(arenaIndex) {
        if (!this.physics) return;
        
        // If there's a boundary for this arena, remove it
        if (this.arenaBoundaries[arenaIndex]) {
            this.physics.removeQuickDrawArenaBoundaryByIndex(arenaIndex);
            this.arenaBoundaries[arenaIndex] = null;
        }
    }
    
    /**
     * Check if a point is inside any active arena
     * @param {THREE.Vector3} point - The point to check
     * @returns {boolean} - True if inside an active arena
     */
    isPointInArena(point) {
        // First check if any arena is active
        if (this.activeArenaIndex < 0 || !this.arenaConfigs[this.activeArenaIndex].duelAreaActive) {
            return false;
        }
        
        const config = this.arenaConfigs[this.activeArenaIndex];
        
        // Use the physics system to check if the point is inside the active arena boundary
        if (this.physics && this.physics.isPointInArenaBoundary) {
            return this.physics.isPointInArenaBoundary(point);
        }
        
        // Fallback to simple cylindrical check if physics is not available
        const dx = point.x - config.center.x;
        const dz = point.z - config.center.z;
        const distanceFromCenter = Math.sqrt(dx * dx + dz * dz);
        
        // Check if within radius and height
        return distanceFromCenter <= config.radius && point.y >= 0 && point.y <= config.height;
    }
    
    /**
     * Check if a point is inside a specific arena
     * @param {THREE.Vector3} point - The point to check
     * @param {number} arenaIndex - The arena index to check
     * @returns {boolean} - True if inside the specified arena
     */
    isPointInSpecificArena(point, arenaIndex) {
        if (arenaIndex < 0 || arenaIndex >= this.maxArenas) {
            return false;
        }
        
        const config = this.arenaConfigs[arenaIndex];
        
        // Simple cylindrical check
        const dx = point.x - config.center.x;
        const dz = point.z - config.center.z;
        const distanceFromCenter = Math.sqrt(dx * dx + dz * dz);
        
        // Check if within radius and height
        return distanceFromCenter <= config.radius && point.y >= 0 && point.y <= config.height;
    }
    
    /**
     * Find the optimal arena index to join by checking where other players are waiting
     * @returns {number} - The arena index to join
     */
    getOptimalArenaIndex() {
        // Get information about other players from the network manager
        const arenaPlayerCounts = Array(this.maxArenas).fill(0);
        let foundWaitingPlayer = false;
        
        // If we can access the other players through networkManager
        if (this.networkManager && this.networkManager.otherPlayers) {
            // Count players in each lobby/queue
            for (const [_, playerData] of this.networkManager.otherPlayers) {
                // Check if player is in a Quick Draw lobby but not in a duel
                if (playerData.quickDrawLobbyIndex >= 0 && 
                    playerData.quickDrawLobbyIndex < this.maxArenas) {
                    arenaPlayerCounts[playerData.quickDrawLobbyIndex]++;
                    
                    // If this player appears to be waiting alone in a queue
                    if (arenaPlayerCounts[playerData.quickDrawLobbyIndex] === 1) {
                        foundWaitingPlayer = true;
                    }
                }
            }
            
            // If we found at least one player waiting in a queue
            if (foundWaitingPlayer) {
                // Find all arenas with exactly one player waiting
                const queuesWithOnePlayer = [];
                for (let i = 0; i < this.maxArenas; i++) {
                    if (arenaPlayerCounts[i] === 1) {
                        queuesWithOnePlayer.push(i);
                    }
                }
                
                // If we found arenas with one player waiting, join one of them
                if (queuesWithOnePlayer.length > 0) {
                    // If multiple arenas have one player, pick one randomly
                    const randomIndex = Math.floor(Math.random() * queuesWithOnePlayer.length);
                    return queuesWithOnePlayer[randomIndex];
                }
            }
        }
        
        // If we couldn't find a player waiting or couldn't access player data,
        // look for completely empty arenas
        const emptyArenas = [];
        for (let i = 0; i < this.maxArenas; i++) {
            if (arenaPlayerCounts[i] === 0) {
                emptyArenas.push(i);
            }
        }
        
        // If we found empty arenas, pick one randomly
        if (emptyArenas.length > 0) {
            const randomIndex = Math.floor(Math.random() * emptyArenas.length);
            return emptyArenas[randomIndex];
        }
        
        // If all arenas have players, pick the one with the fewest players
        let minPlayers = Infinity;
        let minArenas = [];
        
        for (let i = 0; i < this.maxArenas; i++) {
            if (arenaPlayerCounts[i] < minPlayers) {
                minPlayers = arenaPlayerCounts[i];
                minArenas = [i];
            } else if (arenaPlayerCounts[i] === minPlayers) {
                minArenas.push(i);
            }
        }
        
        // If we found arenas with the minimum number of players, pick one randomly
        if (minArenas.length > 0) {
            const randomIndex = Math.floor(Math.random() * minArenas.length);
            return minArenas[randomIndex];
        }
        
        // Fallback to a random arena if something went wrong
        return Math.floor(Math.random() * this.maxArenas);
    }
    
    /**
     * Update method called from main animation loop.
     */
    update(deltaTime) {
        // Skip if player not loaded
        if (!this.localPlayer || !this.localPlayer.group) {
            return;
        }
        
        // Update physics system
        if (this.physics) {
            this.physics.update(deltaTime);
            
            // If the player is in the arena, enforce arena boundary collision
            if (this.inDuel && this.activeArenaIndex >= 0 && this.arenaBoundaries[this.activeArenaIndex]) {
                const playerPos = this.localPlayer.group.position.clone();
                const config = this.arenaConfigs[this.activeArenaIndex];
                const isInArena = this.isPointInSpecificArena(playerPos, this.activeArenaIndex);
                
                if (!isInArena) {
                    // If player is outside the arena but should be inside, push them back in
                    const dirToCenter = new THREE.Vector3(
                        config.center.x - playerPos.x,
                        0,
                        config.center.z - playerPos.z
                    ).normalize();
                    
                    // Move player back inside
                    this.localPlayer.group.position.x += dirToCenter.x * 0.1;
                    this.localPlayer.group.position.z += dirToCenter.z * 0.1;
                }
            }
        }
        
        // Check for portal collision when not in lobby or duel
        if (!this.inLobby && !this.inDuel) {
            const playerPos = this.localPlayer.group.position.clone();
            
            // Check if player is colliding with the single portal
            if (this.arenaConfigs[0].portalCollider && this.arenaConfigs[0].portalCollider.containsPoint(playerPos)) {
                this.joinQueue(this.getOptimalArenaIndex());
            }
        }
        
        // If in countdown phase, check for early aiming
        if (this.inDuel && this.duelState === 'countdown') {
            if (this.localPlayer.isAiming && !this.gunLocked) {
                this.penalizeEarlyDraw();
            }
        }
        
        // Enforce penalty lock regardless of duel state if penalty is active
        if (performance.now() < this.penaltyEndTime) {
            this.localPlayer.canAim = false;
            this.localPlayer.isAiming = false;
            this.localPlayer.revolver.group.visible = false;
        }
        
        // Update portal instruction visibility
        this.updatePortalInstructions();
    }
    
    /**
     * Updates the Quick Draw status indicator.
     */
    updateStatusIndicator() {
        if (!this.statusIndicator) return;
        
        if (this.inLobby) {
            const arenaNum = this.activeArenaIndex + 1;
            this.statusIndicator.textContent = `Quick Draw Arena ${arenaNum}: Waiting for opponent...`;
            this.statusIndicator.style.display = 'block';
            this.statusIndicator.style.backgroundColor = 'rgba(33, 150, 243, 0.7)';
        } else if (this.inDuel) {
            const arenaNum = this.activeArenaIndex + 1;
            let statusText = `Quick Draw Arena ${arenaNum}: Duel in progress`;
            let bgColor = 'rgba(255, 87, 34, 0.7)';
            
            if (this.duelState === 'ready') {
                statusText = `Quick Draw Arena ${arenaNum}: Get ready!`;
            } else if (this.duelState === 'countdown') {
                statusText = `Quick Draw Arena ${arenaNum}: Wait for the signal...`;
            } else if (this.duelState === 'draw') {
                statusText = `Quick Draw Arena ${arenaNum}: DRAW!`;
                bgColor = 'rgba(244, 67, 54, 0.7)';
            }
            
            this.statusIndicator.textContent = statusText;
            this.statusIndicator.style.display = 'block';
            this.statusIndicator.style.backgroundColor = bgColor;
        } else {
            this.statusIndicator.style.display = 'none';
        }
    }
    
    /**
     * Join the Quick Draw queue for a specific arena.
     * @param {number} arenaIndex - The arena index to join (0-4)
     */
    joinQueue(arenaIndex) {
        if (this.inLobby || this.inDuel) {
            return; // Already in queue or duel
        }
        
        if (arenaIndex < 0 || arenaIndex >= this.maxArenas) {
            console.error(`Invalid arena index: ${arenaIndex}`);
            return;
        }
        
        this.inLobby = true;
        this.activeArenaIndex = arenaIndex;
        
        // Update the player's lobby index
        this.localPlayer.setQuickDrawLobby(arenaIndex);
        
        this.showMessage(`Joining Quick Draw Arena ${arenaIndex + 1} queue...`);
        this.updateStatusIndicator();
        
        // Send join request to server with arena index
        this.networkManager.sendQuickDrawJoin(arenaIndex);
        
        console.log(`Joined Quick Draw queue for arena ${arenaIndex + 1}`);
    }
    
    /**
     * Handle queue join confirmation from server.
     */
    handleQueueJoin(message) {
        // Make sure the arena index matches what we expect
        if (message.arenaIndex !== undefined && message.arenaIndex !== this.activeArenaIndex) {
            this.activeArenaIndex = message.arenaIndex;
            this.localPlayer.setQuickDrawLobby(message.arenaIndex);
        }
        
        this.showMessage(`Waiting for opponent in Arena ${this.activeArenaIndex + 1}...`);
        this.updateStatusIndicator();
        console.log(`Quick Draw queue joined for arena ${this.activeArenaIndex + 1}, waiting for opponent`);
    }
    
    /**
     * Handle match found notification from server.
     */
    handleMatchFound(message) {
        this.inLobby = false;
        this.inDuel = true;
        this.duelOpponentId = message.opponentId;
        
        // Make sure we're using the correct arena
        if (message.arenaIndex !== undefined) {
            this.activeArenaIndex = message.arenaIndex;
            this.localPlayer.setQuickDrawLobby(message.arenaIndex);
        }
        
        this.updateStatusIndicator();
        
        this.showMessage(`Opponent found! Preparing duel in Arena ${this.activeArenaIndex + 1}...`);
        
        const config = this.arenaConfigs[this.activeArenaIndex];
        
        // Teleport to the correct duel area
        // For "left" side, spawn on the left; for "right", spawn on the right
        const playerPosition = message.position === 'left' ?
            new THREE.Vector3(config.center.x - 5, 1.6, config.center.z) : 
            new THREE.Vector3(config.center.x + 5, 1.6, config.center.z);
        
        this.localPlayer.group.position.copy(playerPosition);
        
        // Invert player orientation by 180°:
        // For left side, set rotation.y to (Math.PI/2 + Math.PI) = 3π/2; for right, (-Math.PI/2 + Math.PI) = π/2
        if (message.position === 'left') {
            this.localPlayer.group.rotation.y = 3 * Math.PI / 2;
        } else {
            this.localPlayer.group.rotation.y = Math.PI / 2;
        }
        
        // Make the correct duel area visible
        if (config.duelArea) {
            config.duelArea.visible = true;
            config.duelAreaActive = true;
        }
        
        // Create the arena physics boundary
        this.createQuickDrawArenaBoundary(this.activeArenaIndex);
        
        // Disable weapon drawing immediately and forcefully
        this.originalCanAim = this.localPlayer.canAim !== false;
        this.localPlayer.canAim = false;
        this.localPlayer.isAiming = false;
        this.localPlayer.revolver.group.visible = false;
        
        // Tell server we're ready after a moment
        setTimeout(() => {
            this.networkManager.sendQuickDrawReady();
        }, 1000);
    }
    
    /**
     * Show the "READY?" message with enhanced typography.
     */
    showReadyMessage() {
        this.duelState = 'ready';
        this.updateStatusIndicator();
        this.messageOverlay.textContent = 'READY?';
        this.messageOverlay.style.display = 'block';
        this.messageOverlay.style.fontSize = '64px';
        this.messageOverlay.style.color = '#FFFFFF';
        
        // Use a slight scale animation
        this.messageOverlay.style.transition = 'transform 0.2s ease-in-out';
        this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
        
        // Trigger animation
        setTimeout(() => {
            this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1.1)';
            setTimeout(() => {
                this.messageOverlay.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 200);
        }, 10);
        
        // Hide after 1 second
        setTimeout(() => {
            this.hideMessage();
        }, 1000);
    }
    
    /**
     * Start the countdown phase of the duel.
     */
    startDuelCountdown() {
        this.duelState = 'countdown';
        this.updateStatusIndicator();
        this.hideMessage();
        
        // Explicitly disable aiming during countdown
        this.localPlayer.canAim = false;
        
        console.log('Duel countdown started - waiting for draw signal');
    }
    
    /**
     * Trigger the "DRAW!" signal with just the expanding circle.
     */
    triggerDraw() {
        this.duelState = 'draw';
        this.updateStatusIndicator();
        
        // Show animated circle with CSS animation
        this.drawCircle.style.display = 'block';
        this.drawCircle.classList.add('draw-circle-animation');
        
        // Only enable aiming if the penalty period has expired.
        if (performance.now() >= this.penaltyEndTime) {
            this.localPlayer.canAim = this.originalCanAim;
        } else {
            console.log("Penalty still active; gun remains locked.");
        }
        
        console.log('DRAW signal triggered - players can now shoot (if not penalized)');
        
        // Play bell start sound instead of a gunshot
        if (this.soundManager) {
            this.soundManager.playSound("bellstart");
        }
        
        // Remove animation class after it completes
        setTimeout(() => {
            this.drawCircle.classList.remove('draw-circle-animation');
            this.drawCircle.style.display = 'none';
        }, 400);
    }
    
    /**
     * Apply a penalty with dramatic red flashing warning.
     * Once triggered, records a penalty end time so that gun drawing remains locked
     * for a full 3 seconds even if the "DRAW!" signal comes.
     */
    penalizeEarlyDraw() {
        if (this.gunLocked) return;
        
        this.gunLocked = true;
        this.penaltyEndTime = performance.now() + 3000;
        
        // Show the message with a warning style
        this.showMessage('TOO EARLY!', 3000);
        this.messageOverlay.classList.add('gun-locked-warning');
        
        // Disable aiming for penalty duration
        this.localPlayer.canAim = false;
        this.localPlayer.isAiming = false;
        this.localPlayer.revolver.group.visible = false;
        
        // Add a subtle screen flash
        const penaltyFlash = document.createElement('div');
        penaltyFlash.style.position = 'absolute';
        penaltyFlash.style.top = '0';
        penaltyFlash.style.left = '0';
        penaltyFlash.style.width = '100%';
        penaltyFlash.style.height = '100%';
        penaltyFlash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
        penaltyFlash.style.opacity = '0';
        penaltyFlash.style.transition = 'opacity 0.3s ease-in-out';
        penaltyFlash.style.pointerEvents = 'none';
        penaltyFlash.style.zIndex = '990';
        document.getElementById('game-container').appendChild(penaltyFlash);
        
        // Flash the screen
        setTimeout(() => {
            penaltyFlash.style.opacity = '1';
            setTimeout(() => {
                penaltyFlash.style.opacity = '0';
                setTimeout(() => {
                    if (penaltyFlash.parentNode) {
                        penaltyFlash.parentNode.removeChild(penaltyFlash);
                    }
                }, 300);
            }, 200);
        }, 10);
        
        // Play error sound
        if (this.soundManager) {
            this.soundManager.playSound("aimclick");
        }
        
        // Countdown timer text update
        let secondsLeft = 3;
        const updateCountdown = () => {
            this.messageOverlay.textContent = `TOO EARLY! Gun locked (${secondsLeft}s)`;
            secondsLeft--;
            
            if (secondsLeft >= 0) {
                this.penaltyTimer = setTimeout(updateCountdown, 1000);
            }
        };
        updateCountdown();
        
        // After 3 seconds, clear the penalty
        setTimeout(() => {
            this.gunLocked = false;
            this.penaltyEndTime = 0;
            this.hideMessage();
            this.messageOverlay.classList.remove('gun-locked-warning');
        }, 3000);
    }
    
    /**
     * End the duel with enhanced win/lose UI effects.
     */
    endDuel(winnerId) {
        const isWinner = winnerId === this.localPlayer.id;
        
        // Show winner/loser message with dramatic styling
        if (isWinner) {
            this.showMessage('YOU WIN!', 2000);
            this.messageOverlay.classList.add('quick-draw-winner');
            
            // Add a subtle victory flash
            const victoryFlash = document.createElement('div');
            victoryFlash.style.position = 'absolute';
            victoryFlash.style.top = '0';
            victoryFlash.style.left = '0';
            victoryFlash.style.width = '100%';
            victoryFlash.style.height = '100%';
            victoryFlash.style.backgroundColor = 'rgba(76, 175, 80, 0.2)';
            victoryFlash.style.opacity = '0';
            victoryFlash.style.transition = 'opacity 0.5s ease-in-out';
            victoryFlash.style.pointerEvents = 'none';
            victoryFlash.style.zIndex = '990';
            document.getElementById('game-container').appendChild(victoryFlash);
            
            setTimeout(() => {
                victoryFlash.style.opacity = '1';
                setTimeout(() => {
                    victoryFlash.style.opacity = '0';
                    setTimeout(() => {
                        if (victoryFlash.parentNode) {
                            victoryFlash.parentNode.removeChild(victoryFlash);
                        }
                    }, 500);
                }, 1000);
            }, 10);
        } else {
            this.showMessage('YOU LOSE!', 2000);
            this.messageOverlay.classList.add('quick-draw-loser');
            
            // Add a defeat flash for the loser
            const defeatFlash = document.createElement('div');
            defeatFlash.style.position = 'absolute';
            defeatFlash.style.top = '0';
            defeatFlash.style.left = '0';
            defeatFlash.style.width = '100%';
            defeatFlash.style.height = '100%';
            defeatFlash.style.backgroundColor = 'rgba(244, 67, 54, 0.2)';
            defeatFlash.style.opacity = '0';
            defeatFlash.style.transition = 'opacity 0.5s ease-in-out';
            defeatFlash.style.pointerEvents = 'none';
            defeatFlash.style.zIndex = '990';
            document.getElementById('game-container').appendChild(defeatFlash);
            
            setTimeout(() => {
                defeatFlash.style.opacity = '1';
                setTimeout(() => {
                    defeatFlash.style.opacity = '0';
                    setTimeout(() => {
                        if (defeatFlash.parentNode) {
                            defeatFlash.parentNode.removeChild(defeatFlash);
                        }
                    }, 500);
                }, 1000);
            }, 10);
        }
        
        // Store the current arena index before resetting
        const endedArenaIndex = this.activeArenaIndex;
        
        // Reset duel state
        this.duelState = 'none';
        this.inDuel = false;
        this.duelOpponentId = null;
        this.updateStatusIndicator();
        
        // Clean up the physics boundary
        this.removeQuickDrawArenaBoundary(endedArenaIndex);
        
        // Clear any timers
        if (this.countdownTimer) clearTimeout(this.countdownTimer);
        if (this.drawTimer) clearTimeout(this.drawTimer);
        if (this.penaltyTimer) clearTimeout(this.penaltyTimer);
        
        // Hide the active duel area and teleport back to spawn after delay
        setTimeout(() => {
            // Make sure we're hiding the correct duel area
            if (endedArenaIndex >= 0 && endedArenaIndex < this.maxArenas) {
                const config = this.arenaConfigs[endedArenaIndex];
                if (config.duelArea) {
                    config.duelArea.visible = false;
                    config.duelAreaActive = false;
                }
            }
            
            // Teleport back to normal spawn
            this.localPlayer.spawnPlayerRandomly();
            
            // Re-enable normal controls
            this.localPlayer.canAim = this.originalCanAim;
            this.gunLocked = false;
            
            // Reset health
            this.localPlayer.health = 100;
            if (typeof window.updateHealthUI === 'function') {
                window.updateHealthUI(this.localPlayer);
            }
            
            // Reset message styling
            this.messageOverlay.classList.remove('quick-draw-winner', 'quick-draw-loser');
            
            // Reset active arena and Quick Draw lobby
            this.activeArenaIndex = -1;
            this.localPlayer.setQuickDrawLobby(-1);
        }, 2000);
    }
    
    /**
     * Helper to show a message in the center of the screen.
     */
    showMessage(message, duration = 0) {
        this.messageOverlay.textContent = message;
        this.messageOverlay.style.display = 'block';
        
        if (duration > 0) {
            setTimeout(() => {
                this.hideMessage();
            }, duration);
        }
    }
    
    /**
     * Hide the message overlay.
     */
    hideMessage() {
        this.messageOverlay.style.display = 'none';
    }
    
    /**
     * Cleanup resources.
     */
    cleanup() {
        // Remove the portal group
        if (this.portalGroup) {
            this.scene.remove(this.portalGroup);
            this.portalGroup.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        // Remove duel areas
        for (let i = 0; i < this.maxArenas; i++) {
            const config = this.arenaConfigs[i];
            
            // Remove duel area
            if (config.duelArea) {
                this.scene.remove(config.duelArea);
                config.duelArea.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            }
            
            // Remove physics boundary
            this.removeQuickDrawArenaBoundary(i);
        }
        
        // Remove instruction elements
        if (this.instructionsElement && this.instructionsElement.parentNode) {
            this.instructionsElement.parentNode.removeChild(this.instructionsElement);
        }
        
        // Clean up physics
        if (this.physics) {
            this.physics.cleanup();
        }
        
        // Remove UI elements
        if (this.messageOverlay && this.messageOverlay.parentNode) {
            this.messageOverlay.parentNode.removeChild(this.messageOverlay);
        }
        
        if (this.drawCircle && this.drawCircle.parentNode) {
            this.drawCircle.parentNode.removeChild(this.drawCircle);
        }
        
        if (this.statusIndicator && this.statusIndicator.parentNode) {
            this.statusIndicator.parentNode.removeChild(this.statusIndicator);
        }
        
        if (this.lobbyIndicator && this.lobbyIndicator.parentNode) {
            this.lobbyIndicator.parentNode.removeChild(this.lobbyIndicator);
        }
        
        // Clear timers
        if (this.countdownTimer) clearTimeout(this.countdownTimer);
        if (this.drawTimer) clearTimeout(this.drawTimer);
        if (this.penaltyTimer) clearTimeout(this.penaltyTimer);
    }
}

================================================
File: /public/js/revolver.js
================================================
/**
 * A simple Revolver class that loads a low-poly gun model (GLB) for first-person view.
 */
export class Revolver {
  constructor() {
    this.group = new THREE.Group();

    // Internal flag to log the barrel lookup only once.
    this._barrelLogged = false;
    // This will be our anchor attached to the barrel, used for muzzle flash and bullet spawn.
    this.muzzleFlashAnchor = null;

    // Use GLTFLoader to load the .glb gun model
    const loader = new THREE.GLTFLoader();
    loader.load(
      'models/lowpolygun.glb',
      (gltf) => {
        const gunModel = gltf.scene;
        gunModel.scale.set(0.5, 0.5, 0.5);
        gunModel.position.set(0, 0, 0);
        // Flip the model 180° so it points forward
        gunModel.rotation.set(0, Math.PI, 0);

        // Optional: log all child names for debugging purposes
        // gunModel.traverse(child => console.log(child.name));

        this.group.add(gunModel);
        this.gunModel = gunModel;

        // Attempt to find the barrel by its name in the imported model
        const barrel = gunModel.getObjectByName("Magnum_Barrel_Magnum_mat_0");
        if (!this._barrelLogged) {
          if (barrel) {
            console.log('Revolver barrel found: "Magnum_Barrel_Magnum_mat_0".');
          } else {
            console.warn('Revolver barrel "Magnum_Barrel_Magnum_mat_0" not found. Muzzle flash anchor will not be attached.');
          }
          this._barrelLogged = true;
        }
        if (barrel) {
          // Create a muzzle flash anchor and attach it to the barrel.
          this.muzzleFlashAnchor = new THREE.Object3D();
          // Set an upward offset on the anchor (adjust as necessary)
          this.muzzleFlashAnchor.position.set(-2, 8, -10);
          barrel.add(this.muzzleFlashAnchor);
          console.log('Muzzle flash anchor attached to barrel.');
        }
      },
      undefined,
      (error) => {
        console.error('Error loading revolver model:', error);
      }
    );

    // Initially hidden until the player aims
    this.group.visible = false;
  }

  /**
   * Returns the world position of the gun barrel tip.
   * If a muzzle flash anchor was attached to the barrel, its world position is returned,
   * ensuring that the emission point remains fixed relative to the barrel.
   * Otherwise, it falls back to a default local offset relative to the revolver group.
   *
   * @returns {THREE.Vector3} The world position for spawning bullets and muzzle flash effects.
   */
  getBarrelTipWorldPosition() {
    if (this.muzzleFlashAnchor) {
      const worldPos = new THREE.Vector3();
      this.muzzleFlashAnchor.getWorldPosition(worldPos);
      return worldPos;
    }
    // Fallback: use a default local offset relative to the revolver group
    return this.group.localToWorld(new THREE.Vector3(0, 0, -0.7));
  }
}


================================================
File: /public/js/scene.js
================================================
// /public/js/scene.js
export let scene;

/**
 * Initializes the Three.js scene, camera, and renderer.
 * @returns {Object} - Contains the camera and renderer.
 */
export function initScene() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.Fog(0x87CEEB, 10, 100); // Reduced fog distance for smaller world

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  // Set output encoding for consistent lighting and color reproduction.
  renderer.outputEncoding = THREE.sRGBEncoding;

  const gameContainer = document.getElementById('game-container');
  if (!gameContainer) {
    throw new Error("Game container not found in HTML.");
  }
  gameContainer.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  const ambientLight = new THREE.AmbientLight(0x404040);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(1, 1, 0.5).normalize();
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);

  // Create the western town instead of just a ground plane
  createWesternTown();

  return { camera, renderer };
}

/**
 * Creates a western town with a main street and buildings
 */
function createWesternTown() {
  // Town dimensions
  const TOWN_WIDTH = 60;  // Width of the town (X-axis)
  const TOWN_LENGTH = 100; // Length of the town (Z-axis)
  const STREET_WIDTH = 15; // Width of the main street

  // Create the ground (smaller than the original 1000x1000)
  const groundGeometry = new THREE.PlaneGeometry(TOWN_WIDTH, TOWN_LENGTH);
  const groundMaterial = new THREE.MeshStandardMaterial({
    color: 0xCD853F, // Sandy color
    roughness: 0.8,
    metalness: 0.2
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Create the main street
  const streetGeometry = new THREE.PlaneGeometry(STREET_WIDTH, TOWN_LENGTH);
  const streetMaterial = new THREE.MeshStandardMaterial({
    color: 0xA0522D, // Brown street
    roughness: 0.9,
    metalness: 0.1
  });
  const street = new THREE.Mesh(streetGeometry, streetMaterial);
  street.rotation.x = -Math.PI / 2;
  street.position.y = 0.01; // Slightly above ground to prevent z-fighting
  street.receiveShadow = true;
  scene.add(street);

  // Add buildings on both sides of the street
  const buildingCount = 5; // Number of buildings on each side
  const buildingSpacing = TOWN_LENGTH / (buildingCount + 1);
  
  // Left side buildings (negative X)
  for (let i = 1; i <= buildingCount; i++) {
    const offset = i * buildingSpacing - TOWN_LENGTH / 2 + buildingSpacing / 2;
    createWesternBuilding(-STREET_WIDTH / 2 - 5, 0, offset);
  }
  
  // Right side buildings (positive X)
  for (let i = 1; i <= buildingCount; i++) {
    const offset = i * buildingSpacing - TOWN_LENGTH / 2 + buildingSpacing / 2;
    createWesternBuilding(STREET_WIDTH / 2 + 5, 0, offset);
  }

  // Create a visible border around the town
  createTownBorder(TOWN_WIDTH, TOWN_LENGTH);
  
  // Store these values in a global variable for access in other files
  window.townDimensions = {
    width: TOWN_WIDTH,
    length: TOWN_LENGTH,
    streetWidth: STREET_WIDTH
  };
}

/**
 * Creates a simple western-style building
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {number} z - Z position
 */
function createWesternBuilding(x, y, z) {
  // Randomize building dimensions
  const width = 8 + Math.random() * 4;
  const height = 5 + Math.random() * 3;
  const depth = 6 + Math.random() * 4;
  
  const buildingGroup = new THREE.Group();
  
  // Building body
  const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
  const buildingMaterial = new THREE.MeshStandardMaterial({
    color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D, // Brown variations
    roughness: 0.8,
    metalness: 0.2
  });
  const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
  building.position.set(0, height / 2, 0);
  building.castShadow = true;
  building.receiveShadow = true;
  buildingGroup.add(building);
  
  // Roof (simple triangular prism)
  const roofHeight = 2;
  const roofGeometry = new THREE.BufferGeometry();
  
  const vertices = new Float32Array([
    // Front triangle
    -width/2, height, -depth/2,
    width/2, height, -depth/2,
    0, height + roofHeight, -depth/2,
    
    // Back triangle
    -width/2, height, depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, depth/2,
    
    // Left side
    -width/2, height, -depth/2,
    -width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2,
    
    // Right side
    width/2, height, -depth/2,
    width/2, height, depth/2,
    0, height + roofHeight, -depth/2,
    0, height + roofHeight, depth/2
  ]);
  
  const indices = [
    // Front triangle
    0, 1, 2,
    
    // Back triangle
    3, 5, 4,
    
    // Left side
    6, 8, 7,
    7, 8, 9,
    
    // Right side
    10, 11, 12,
    11, 13, 12
  ];
  
  roofGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
  roofGeometry.setIndex(indices);
  roofGeometry.computeVertexNormals();
  
  const roofMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Dark brown
    roughness: 0.9,
    metalness: 0.1
  });
  
  const roof = new THREE.Mesh(roofGeometry, roofMaterial);
  roof.castShadow = true;
  buildingGroup.add(roof);
  
  // Door
  const doorWidth = 1.5;
  const doorHeight = 3;
  const doorGeometry = new THREE.PlaneGeometry(doorWidth, doorHeight);
  const doorMaterial = new THREE.MeshStandardMaterial({
    color: 0x4d2600, // Dark brown
    roughness: 0.8,
    metalness: 0.2
  });
  const door = new THREE.Mesh(doorGeometry, doorMaterial);
  door.position.set(0, doorHeight / 2, depth / 2 + 0.01);
  buildingGroup.add(door);
  
  // Windows (1-3 random windows)
  const windowCount = 1 + Math.floor(Math.random() * 3);
  for (let i = 0; i < windowCount; i++) {
    const windowWidth = 1;
    const windowHeight = 1;
    const windowGeometry = new THREE.PlaneGeometry(windowWidth, windowHeight);
    const windowMaterial = new THREE.MeshStandardMaterial({
      color: 0xECF0F1, // White-ish
      roughness: 0.4,
      metalness: 0.6
    });
    const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
    
    // Position windows randomly on the front face
    let wxPos = -width / 3 + i * width / 3;
    if (windowCount === 1) wxPos = 0;
    
    windowMesh.position.set(
      wxPos,
      height / 2 + 0.5,
      depth / 2 + 0.01
    );
    buildingGroup.add(windowMesh);
  }
  
  // Position the whole building
  buildingGroup.position.set(x, y, z);
  
  // Rotate the building to face the street
  if (x < 0) {
    buildingGroup.rotation.y = Math.PI / 2;
  } else {
    buildingGroup.rotation.y = -Math.PI / 2;
  }
  
  scene.add(buildingGroup);
}

/**
 * Creates a visible border around the town
 * @param {number} width - Width of the town
 * @param {number} length - Length of the town
 */
function createTownBorder(width, length) {
  const borderHeight = 0.5;
  const borderWidth = 0.5;
  
  // Border material
  const borderMaterial = new THREE.MeshStandardMaterial({
    color: 0x8B4513, // Brown
    roughness: 0.8,
    metalness: 0.2
  });
  
  // Create four border segments
  const createBorderSegment = (x, z, sizeX, sizeZ) => {
    const geometry = new THREE.BoxGeometry(sizeX, borderHeight, sizeZ);
    const border = new THREE.Mesh(geometry, borderMaterial);
    border.position.set(x, borderHeight / 2, z);
    border.castShadow = true;
    border.receiveShadow = true;
    scene.add(border);
    return border;
  };
  
  // Left border (negative X)
  const leftBorder = createBorderSegment(-width / 2, 0, borderWidth, length);
  
  // Right border (positive X)
  const rightBorder = createBorderSegment(width / 2, 0, borderWidth, length);
  
  // Front border (negative Z)
  const frontBorder = createBorderSegment(0, -length / 2, width, borderWidth);
  
  // Back border (positive Z)
  const backBorder = createBorderSegment(0, length / 2, width, borderWidth);
  
  // Store border references in a global variable
  window.townBorders = {
    left: leftBorder,
    right: rightBorder,
    front: frontBorder,
    back: backBorder,
    width: width,
    length: length,
    height: borderHeight
  };
}

/**
 * Creates a simple NPC target.
 * @param {THREE.Scene} scene - The scene to add the NPC.
 * @returns {THREE.Group} - The NPC group.
 */
export function createNPC(scene) {
  const npcGroup = new THREE.Group();
  const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.9;
  npcGroup.add(body);
  const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
  const headMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 1.8;
  npcGroup.add(head);
  const hatGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8);
  const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
  const hat = new THREE.Mesh(hatGeometry, hatMaterial);
  hat.position.y = 2.0;
  npcGroup.add(hat);

  // Position the NPC within the town instead of at (0, 0, -10)
  if (window.townDimensions) {
    // Place NPC at a random position in the town
    const x = (Math.random() - 0.5) * window.townDimensions.streetWidth * 0.8;
    const z = -window.townDimensions.length * 0.3; // Towards the front of the town
    npcGroup.position.set(x, 0, z);
  } else {
    // Default position as fallback
    npcGroup.position.set(0, 0, -10);
  }
  
  scene.add(npcGroup);
  return npcGroup;
}

/**
 * Updates the NPC's position.
 * @param {THREE.Group} npc - The NPC group.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateNPC(npc, deltaTime) {
  if (npc) {
    npc.userData.direction = npc.userData.direction || 1;
    
    // Adjust the movement range to be appropriate for the town size
    const movementRange = window.townDimensions ? 
      window.townDimensions.streetWidth * 0.4 : // 40% of street width if town exists
      15; // Original value as fallback
    
    npc.position.x += npc.userData.direction * 2 * deltaTime;
    
    if (npc.position.x > movementRange) {
      npc.userData.direction = -1;
      npc.rotation.y = Math.PI / 2;
    } else if (npc.position.x < -movementRange) {
      npc.userData.direction = 1;
      npc.rotation.y = -Math.PI / 2;
    }
  }
}

/**
 * Updates the FPS counter.
 * @param {THREE.WebGLRenderer} renderer - The renderer.
 * @param {THREE.Camera} camera - The camera.
 * @param {number} deltaTime - Time elapsed since last frame.
 */
export function updateFPS(renderer, camera, deltaTime) {
  const fpsCounter = document.getElementById('fps-counter');
  if (fpsCounter) {
    const currentFPS = deltaTime > 0 ? Math.round(1 / deltaTime) : 0;
    fpsCounter.textContent = `FPS: ${currentFPS}`;
  }
}

================================================
File: /public/js/smokeRingEffect.js
================================================
/**
 * Smoke Ring Effect implementation for the Western Shooter game
 * Creates a stylized low-poly smoke ring when firing
 */
export class SmokeRingEffect {
    constructor(scene) {
        this.scene = scene;
        this.group = new THREE.Group();
        this.scene.add(this.group);
        
        this.puffs = [];
        this.active = false;
        
        // Create smoke material - using PhongMaterial with flatShading
        this.smokeMaterial = new THREE.MeshPhongMaterial({
            color: 0xCCCCCC, // Light gray
            flatShading: true,
            shininess: 0,
            transparent: true
        });
    }
    
    /**
     * Create a smoke ring effect at the specified position and direction
     * @param {THREE.Vector3} position - The position to create the smoke ring
     * @param {THREE.Vector3} direction - The direction the weapon is firing
     */
    create(position, direction) {
        // Clear any existing puffs
        while(this.group.children.length > 0) {
            let mesh = this.group.children[0];
            this.group.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        }
        this.puffs = [];
        
        // Position the smoke ring at the muzzle
        this.group.position.copy(position);
        this.group.lookAt(position.clone().add(direction));
        
        // Create the smoke ring effect
        this._createSmokeRing();
        
        this.active = true;
    }
    
    /**
     * Create a smoke ring with proper radial particles
     * @private
     */
    _createSmokeRing() {
        // Main ring particles
        const numRingParticles = 20; // Adjusted for revolver (smaller than blunderbuss)
        const initialRingRadius = 0.15; // Smaller initial radius for revolver
        
        for (let i = 0; i < numRingParticles; i++) {
            const angle = (i / numRingParticles) * Math.PI * 2;
            
            // Slightly randomize the ring radius for a less perfect circle
            const radiusVariation = initialRingRadius * (0.9 + Math.random() * 0.2);
            
            // Create puff with low-poly icosahedron
            const geometry = new THREE.IcosahedronGeometry(0.05 + Math.random() * 0.03, 0);
            const material = this.smokeMaterial.clone();
            
            // Compute normals for flat shading
            geometry.computeVertexNormals();
            
            const puffMesh = new THREE.Mesh(geometry, material);
            
            // Position in ring formation
            puffMesh.position.x = Math.cos(angle) * radiusVariation;
            puffMesh.position.y = Math.sin(angle) * radiusVariation;
            puffMesh.position.z = 0.05 + Math.random() * 0.1; // Slight forward offset
            
            // Random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            // Start with small scale
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            this.group.add(puffMesh);
            
            // Outward velocity along the ring angle
            const outwardSpeed = 1.8 + Math.random() * 0.7; // Slightly slower for revolver
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.6 + Math.random() * 0.3, // Shorter lifespan for revolver
                velocity: new THREE.Vector3(
                    Math.cos(angle) * outwardSpeed,
                    Math.sin(angle) * outwardSpeed,
                    0.2 + Math.random() * 0.4 // Slight forward movement
                ),
                rotationSpeed: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                ),
                initialSize: 0.05 + Math.random() * 0.03
            });
        }
        
        // Add just a few particles near origin for muzzle blast effect
        for (let i = 0; i < 3; i++) {
            const geometry = new THREE.IcosahedronGeometry(0.06 + Math.random() * 0.04, 0);
            const material = this.smokeMaterial.clone();
            geometry.computeVertexNormals();
            
            const puffMesh = new THREE.Mesh(geometry, material);
            
            // Position very close to origin with minimal spread
            const smallOffset = 0.08;
            puffMesh.position.set(
                (Math.random() - 0.5) * smallOffset,
                (Math.random() - 0.5) * smallOffset,
                0
            );
            
            // Random rotation
            puffMesh.rotation.x = Math.random() * Math.PI * 2;
            puffMesh.rotation.y = Math.random() * Math.PI * 2;
            puffMesh.rotation.z = Math.random() * Math.PI * 2;
            
            puffMesh.scale.set(0.05, 0.05, 0.05);
            
            this.group.add(puffMesh);
            
            // Random outward direction
            const angle = Math.random() * Math.PI * 2;
            const speed = 1.5 + Math.random() * 0.6;
            
            this.puffs.push({
                mesh: puffMesh,
                age: 0,
                lifespan: 0.4 + Math.random() * 0.2, // Shorter lifespan
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    0.3 + Math.random() * 0.3
                ),
                rotationSpeed: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                ),
                initialSize: 0.06 + Math.random() * 0.04
            });
        }
    }
    
    /**
     * Update the smoke ring effect
     * @param {number} deltaTime - Time elapsed since last frame
     * @returns {boolean} - Whether the effect is still active
     */
    update(deltaTime) {
        if (!this.active) return false;
        
        let allExpired = true;
        
        for (let i = 0; i < this.puffs.length; i++) {
            const puff = this.puffs[i];
            puff.age += deltaTime;
            
            if (puff.age < puff.lifespan) {
                allExpired = false;
                
                // Calculate life ratio
                const lifeRatio = puff.age / puff.lifespan;
                
                // Update position based on velocity
                puff.mesh.position.x += puff.velocity.x * deltaTime;
                puff.mesh.position.y += puff.velocity.y * deltaTime;
                puff.mesh.position.z += puff.velocity.z * deltaTime;
                
                // Update rotation
                puff.mesh.rotation.x += puff.rotationSpeed.x;
                puff.mesh.rotation.y += puff.rotationSpeed.y;
                puff.mesh.rotation.z += puff.rotationSpeed.z;
                
                // Modified scale curve - quick growth, plateau, then fade
                let scaleFactor;
                
                if (lifeRatio < 0.2) {
                    // Quick growth phase - 0 to 0.2
                    scaleFactor = lifeRatio / 0.2;
                } else if (lifeRatio < 0.7) {
                    // Maintain size with slight growth - 0.2 to 0.7
                    scaleFactor = 1.0 + (lifeRatio - 0.2) * 0.3;
                } else {
                    // Shrink phase - 0.7 to 1.0
                    scaleFactor = 1.3 - (lifeRatio - 0.7) * (1.3 / 0.3);
                }
                
                puff.mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                // Handle transparency in final phase
                if (lifeRatio > 0.7) {
                    const opacity = 1 - ((lifeRatio - 0.7) / 0.3);
                    puff.mesh.material.opacity = opacity;
                }
                
                // Adjust drag based on life stage
                const dragFactor = lifeRatio < 0.5 ? 0.98 : 0.96;
                puff.velocity.multiplyScalar(dragFactor);
            } else {
                // Make expired puffs invisible
                puff.mesh.visible = false;
            }
        }
        
        // If all puffs have expired, clean up and set active to false
        if (allExpired) {
            // Clean up
            while(this.group.children.length > 0) {
                let mesh = this.group.children[0];
                this.group.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            }
            this.puffs = [];
            this.active = false;
            return false;
        }
        
        return true;
    }
    
    /**
     * Clean up resources
     */
    dispose() {
        // Clean up all meshes and materials
        while(this.group.children.length > 0) {
            let mesh = this.group.children[0];
            this.group.remove(mesh);
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) mesh.material.dispose();
        }
        this.puffs = [];
        
        // Remove group from scene
        if (this.group.parent) {
            this.group.parent.remove(this.group);
        }
    }
}

================================================
File: /public/js/soundManager.js
================================================
export class SoundManager {
  constructor() {
    // For non-positional playback
    this.sounds = {};
    // For positional playback using Web Audio API
    this.buffers = {};
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  
  /**
   * Loads an audio file and caches it.
   * Loads both as an HTMLAudioElement (for simple playback)
   * and as an AudioBuffer (for positional audio).
   * @param {string} name - Sound key.
   * @param {string} url - Audio file URL.
   */
  loadSound(name, url) {
    try {
      // Load using HTMLAudioElement for non-positional playback
      const audio = new Audio();
      audio.src = url;
      audio.load();
      this.sounds[name] = audio;
    } catch (error) {
      console.error(`Error loading sound "${name}" from ${url}:`, error);
    }
    
    // Also load using fetch for positional audio
    fetch(url)
      .then(response => response.arrayBuffer())
      .then(arrayBuffer => this.audioContext.decodeAudioData(arrayBuffer))
      .then(audioBuffer => {
        this.buffers[name] = audioBuffer;
      })
      .catch(error => {
        console.error(`Error loading sound buffer "${name}" from ${url}:`, error);
      });
  }
  
  /**
   * Plays a cached sound by cloning the HTMLAudioElement.
   * @param {string} name - Sound key.
   */
  playSound(name) {
    if (this.sounds[name]) {
      const audioClone = this.sounds[name].cloneNode();
      audioClone.play().catch(error => {
        console.error(`Error playing sound "${name}":`, error);
      });
    } else {
      console.error(`Sound "${name}" not found in cache.`);
    }
  }
  
  /**
   * Plays a sound at a given 3D position using the Web Audio API.
   * @param {string} name - Sound key.
   * @param {THREE.Vector3} position - 3D position for the sound.
   */
  playSoundAt(name, position) {
    if (!this.buffers[name]) {
      console.error(`Positional sound "${name}" not found in buffers.`);
      return;
    }
    try {
      const source = this.audioContext.createBufferSource();
      source.buffer = this.buffers[name];
      
      const panner = this.audioContext.createPanner();
      panner.panningModel = 'HRTF';
      panner.distanceModel = 'inverse';
      panner.refDistance = 1;
      panner.maxDistance = 10000;
      panner.rolloffFactor = 1;
      panner.coneInnerAngle = 360;
      panner.coneOuterAngle = 0;
      panner.coneOuterGain = 0;
      panner.setPosition(position.x, position.y, position.z);
      
      source.connect(panner);
      panner.connect(this.audioContext.destination);
      source.start(0);
    } catch (error) {
      console.error(`Error playing positional sound "${name}":`, error);
    }
  }
  
  /**
   * Plays a sequence: after sound1 ends, sound2 plays.
   * @param {string} sound1 - First sound key.
   * @param {string} sound2 - Second sound key.
   */
  playSoundSequence(sound1, sound2) {
    if (this.sounds[sound1]) {
      const audioClone = this.sounds[sound1].cloneNode();
      audioClone.play().then(() => {
        audioClone.addEventListener('ended', () => {
          this.playSound(sound2);
        });
      }).catch(error => {
        console.error(`Error playing sound "${sound1}":`, error);
      });
    } else {
      console.error(`Sound "${sound1}" not found in cache.`);
    }
  }
}


================================================
File: /public/js/ui.js
================================================
/**
 * Updates the ammo counter in the UI.
 * @param {Player} player - The player instance.
 */
export function updateAmmoUI(player) {
    const ammoCounter = document.getElementById('ammo-counter');
    if (ammoCounter && player) {
      ammoCounter.textContent = `Bullets: ${player.bullets}/${player.maxBullets}`;
    }
}

/**
 * Updates the health counter in the UI.
 * @param {Player|ThirdPersonModel} player - The player instance.
 */
export function updateHealthUI(player) {
    const healthCounter = document.getElementById('health-counter');
    if (healthCounter && player) {
      healthCounter.textContent = `Health: ${player.health}`;
    }
}


================================================
File: /server.js
================================================
// server.js
const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const url = require('url');
const app = express();

// Port default 8080 to match your previous Cloudflare Tunnel config
const PORT = process.env.PORT || 8080;

// Serve static files from "public"
app.use(express.static('public'));

const server = http.createServer(app);
const wss = new WebSocket.Server({ server, clientTracking: true });

// Track connected players
const players = new Map();    // playerId -> { ws, sessionId, position, rotation, health, ... }
const sessions = new Set();   // tracks sessionIds to prevent duplicate connections
let nextPlayerId = 1;

// Track Quick Draw game mode queues and active duels
// Support for 5 concurrent lobbies
const MAX_ARENAS = 5;
const quickDrawQueues = Array(MAX_ARENAS).fill(null).map(() => []);  // Array of queues for each arena
const quickDrawDuels = new Map(); // Map of duelId -> { player1Id, player2Id, state, arenaIndex, ... }

// On new connection
wss.on('connection', (ws, req) => {
  // Parse sessionId from query string
  const parameters = url.parse(req.url, true).query;
  const sessionId = parameters.sessionId;

  // If we already have this sessionId, reject as duplicate
  if (sessionId && sessions.has(sessionId)) {
    console.log(`Rejecting duplicate connection with sessionId: ${sessionId}`);
    ws.send(JSON.stringify({
      type: 'error',
      message: 'Duplicate connection detected',
      fatal: true
    }));
    return ws.close(1008, 'Duplicate connection');
  }

  if (sessionId) {
    sessions.add(sessionId);
  }

  const playerId = nextPlayerId++;
  console.log(`Player ${playerId} connected (sessionId: ${sessionId || 'none'})`);

  // Create initial player data with health and QuickDraw info
  players.set(playerId, {
    ws,
    sessionId,
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { y: 0 },
    isAiming: false,
    isShooting: false,
    isReloading: false,
    health: 100,
    lastActivity: Date.now(),
    quickDrawLobbyIndex: -1, // -1 means not in any lobby
    inQuickDrawQueue: false,
    inQuickDrawDuel: false,
    quickDrawDuelId: null
  });

  // Send init data to this client (their ID + existing players)
  ws.send(JSON.stringify({
    type: 'init',
    id: playerId,
    players: Array.from(players.entries())
      .filter(([pid]) => pid !== playerId)
      .map(([pid, p]) => ({
        id: pid,
        position: p.position,
        rotation: p.rotation,
        isAiming: p.isAiming,
        isShooting: p.isShooting,
        isReloading: p.isReloading,
        health: p.health,
        quickDrawLobbyIndex: p.quickDrawLobbyIndex
      }))
  }));

  // Notify others that a new player joined
  broadcastToOthers(playerId, {
    type: 'playerJoined',
    id: playerId,
    position: players.get(playerId).position,
    rotation: players.get(playerId).rotation,
    health: players.get(playerId).health,
    quickDrawLobbyIndex: players.get(playerId).quickDrawLobbyIndex
  });

  // Handle incoming messages
  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);

      // Update lastActivity
      const player = players.get(playerId);
      if (player) {
        player.lastActivity = Date.now();
      }

      switch (data.type) {
        case 'update':
          // Update local state (do not allow client to change health directly)
          if (player) {
            player.position = data.position || player.position;
            player.rotation = data.rotation || player.rotation;
            player.isAiming = data.isAiming !== undefined ? data.isAiming : player.isAiming;
            player.isShooting = data.isShooting !== undefined ? data.isShooting : player.isShooting;
            player.isReloading = data.isReloading !== undefined ? data.isReloading : player.isReloading;
            
            // Update QuickDraw lobby index if provided
            if (data.quickDrawLobbyIndex !== undefined) {
              player.quickDrawLobbyIndex = data.quickDrawLobbyIndex;
            }
            
            // Broadcast to others including current health and Quick Draw info
            broadcastToOthers(playerId, {
              type: 'playerUpdate',
              id: playerId,
              position: player.position,
              rotation: player.rotation,
              isAiming: player.isAiming,
              isShooting: player.isShooting,
              isReloading: player.isReloading,
              health: player.health,
              quickDrawLobbyIndex: player.quickDrawLobbyIndex
            });
          }
          break;

        case 'shoot':
          // Notify others that this player fired
          broadcastToOthers(playerId, {
            type: 'playerShoot',
            id: playerId,
            bulletData: data.bulletData
          });
          break;

        case 'playerHit':
          // data.targetId, data.hitData
          const targetId = parseInt(data.targetId);
          console.log(`Player ${targetId} was hit by player ${playerId}`);
          const targetPlayer = players.get(targetId);
          if (targetPlayer && targetPlayer.ws.readyState === WebSocket.OPEN) {
            // Reduce health by a fixed amount (e.g., 20)
            targetPlayer.health = Math.max(targetPlayer.health - 20, 0);
            // Inform the target
            targetPlayer.ws.send(JSON.stringify({
              type: 'hit',
              sourceId: playerId,
              hitData: data.hitData,
              health: targetPlayer.health
            }));
          }
          // Broadcast a "playerHit" to everyone with updated health
          broadcastToAll({
            type: 'playerHit',
            targetId: data.targetId,
            sourceId: playerId,
            hitPosition: data.hitData.position,
            health: targetPlayer ? targetPlayer.health : 0
          });
          break;

        case 'ping':
          // respond
          ws.send(JSON.stringify({ type: 'pong' }));
          break;
          
        case 'quickDrawJoin':
          handleQuickDrawJoin(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawLeave':
          handleQuickDrawLeave(playerId);
          break;
          
        case 'quickDrawReady':
          handleQuickDrawReady(playerId, data.arenaIndex);
          break;
          
        case 'quickDrawShoot':
          handleQuickDrawShoot(playerId, data.opponentId, data.arenaIndex);
          break;

        default:
          break;
      }
    } catch (err) {
      console.error('Error processing message:', err);
    }
  });

  // On close
  ws.on('close', () => {
    cleanupPlayer(playerId);
  });

  // On error
  ws.on('error', (err) => {
    console.error(`WebSocket error for player ${playerId}:`, err);
    cleanupPlayer(playerId);
  });

  // Update the global player count UI
  updatePlayerCount();
});

// Cleanup a disconnected or stale player
function cleanupPlayer(playerId) {
  const player = players.get(playerId);
  if (player) {
    console.log(`Player ${playerId} disconnected`);
    if (player.sessionId) {
      sessions.delete(player.sessionId);
    }
    
    // Quick Draw cleanup
    if (player.inQuickDrawQueue && player.quickDrawLobbyIndex >= 0) {
      // Remove from the appropriate queue
      const queueIndex = player.quickDrawLobbyIndex;
      if (queueIndex >= 0 && queueIndex < MAX_ARENAS) {
        const queue = quickDrawQueues[queueIndex];
        const index = queue.indexOf(playerId);
        if (index !== -1) {
          queue.splice(index, 1);
        }
      }
    }
    
    if (player.inQuickDrawDuel && player.quickDrawDuelId) {
      // End any active duel
      const duel = quickDrawDuels.get(player.quickDrawDuelId);
      if (duel) {
        // The other player wins by default
        const winnerId = duel.player1Id === playerId ? duel.player2Id : duel.player1Id;
        endQuickDrawDuel(player.quickDrawDuelId, winnerId);
      }
    }
    
    players.delete(playerId);

    // Notify all that the player left
    broadcastToAll({
      type: 'playerLeft',
      id: playerId
    });

    updatePlayerCount();
  }
}

// Broadcast a "playerCount" update to all
function updatePlayerCount() {
  broadcastToAll({
    type: 'playerCount',
    count: players.size
  });
}

// Broadcast to all except a given playerId
function broadcastToOthers(excludeId, data) {
  for (const [pid, pl] of players.entries()) {
    if (pid === excludeId) continue;
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

// Broadcast to all players
function broadcastToAll(data) {
  for (const [pid, pl] of players.entries()) {
    if (pl.ws.readyState === WebSocket.OPEN) {
      pl.ws.send(JSON.stringify(data));
    }
  }
}

/**
 * Handle a player joining a specific Quick Draw queue.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index to join (0-4)
 */
function handleQuickDrawJoin(playerId, arenaIndex) {
  // Validate arena index
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    console.error(`Invalid arena index: ${arenaIndex}`);
    return;
  }
  
  console.log(`Player ${playerId} joined Quick Draw queue for arena ${arenaIndex + 1}`);
  const playerData = players.get(playerId);
  
  if (!playerData || playerData.inQuickDrawQueue || playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  // Add to the specific queue
  playerData.inQuickDrawQueue = true;
  playerData.quickDrawLobbyIndex = arenaIndex;
  quickDrawQueues[arenaIndex].push(playerId);
  
  // Notify the player they joined the queue
  playerData.ws.send(JSON.stringify({
    type: 'quickDrawJoin',
    arenaIndex: arenaIndex
  }));
  
  // Check if we have enough players in this queue to start a match
  checkQuickDrawQueue(arenaIndex);
}

/**
 * Handle a player leaving the Quick Draw queue.
 * @param {number} playerId - The player's ID
 */
function handleQuickDrawLeave(playerId) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawQueue) {
    return; // Invalid state
  }
  
  // Get the arena index
  const arenaIndex = playerData.quickDrawLobbyIndex;
  if (arenaIndex >= 0 && arenaIndex < MAX_ARENAS) {
    console.log(`Player ${playerId} left Quick Draw queue for arena ${arenaIndex + 1}`);
    
    // Remove from appropriate queue
    const index = quickDrawQueues[arenaIndex].indexOf(playerId);
    if (index !== -1) {
      quickDrawQueues[arenaIndex].splice(index, 1);
    }
  }
  
  // Reset player state
  playerData.inQuickDrawQueue = false;
  playerData.quickDrawLobbyIndex = -1;
}

/**
 * Check if we have enough players in a specific Quick Draw queue to start a match.
 * @param {number} arenaIndex - The arena index to check
 */
function checkQuickDrawQueue(arenaIndex) {
  if (arenaIndex < 0 || arenaIndex >= MAX_ARENAS) {
    return; // Invalid arena index
  }
  
  const queue = quickDrawQueues[arenaIndex];
  
  if (queue.length < 2) {
    return; // Not enough players in this queue
  }
  
  // Get the two players who have been waiting the longest
  const player1Id = queue.shift();
  const player2Id = queue.shift();
  
  // Make sure both players are still connected
  const player1 = players.get(player1Id);
  const player2 = players.get(player2Id);
  
  if (!player1 || !player2) {
    // Put the valid player back in the queue
    if (player1) queue.push(player1Id);
    if (player2) queue.push(player2Id);
    return;
  }
  
  // Create a new duel
  const duelId = `duel_${arenaIndex}_${player1Id}_${player2Id}`;
  quickDrawDuels.set(duelId, {
    id: duelId,
    arenaIndex: arenaIndex,
    player1Id,
    player2Id,
    state: 'starting',
    startTime: Date.now()
  });
  
  // Mark players as in a duel
  player1.inQuickDrawQueue = false;
  player1.inQuickDrawDuel = true;
  player1.quickDrawDuelId = duelId;
  
  player2.inQuickDrawQueue = false;
  player2.inQuickDrawDuel = true;
  player2.quickDrawDuelId = duelId;
  
  // Notify players of the match
  player1.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player2Id,
    position: 'left', // Player 1 spawns on the left
    arenaIndex: arenaIndex
  }));
  
  player2.ws.send(JSON.stringify({
    type: 'quickDrawMatch',
    opponentId: player1Id,
    position: 'right', // Player 2 spawns on the right
    arenaIndex: arenaIndex
  }));
  
  console.log(`Started Quick Draw duel ${duelId} between players ${player1Id} and ${player2Id} in arena ${arenaIndex + 1}`);
}

/**
 * Handle a player being ready in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} arenaIndex - The arena index for the duel
 */
function handleQuickDrawReady(playerId, arenaIndex) {
  const playerData = players.get(playerId);
  
  if (!playerData || !playerData.inQuickDrawDuel) {
    return; // Invalid state
  }
  
  const duelId = playerData.quickDrawDuelId;
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  // Verify arena index matches
  if (arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
    console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
    return;
  }
  
  // Mark this player as ready
  if (duel.player1Id === playerId) {
    duel.player1Ready = true;
  } else if (duel.player2Id === playerId) {
    duel.player2Ready = true;
  }
  
  // If both players are ready, start the duel sequence
  if (duel.player1Ready && duel.player2Ready) {
    startQuickDrawDuel(duelId);
  }
}

/**
 * Start the Quick Draw duel sequence.
 * @param {string} duelId - The duel ID
 */
function startQuickDrawDuel(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'ready';
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Show "READY?" message to both players
  player1.ws.send(JSON.stringify({ type: 'quickDrawReady' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawReady' }));
  
  // After 1 second, start the countdown
  setTimeout(() => {
    if (quickDrawDuels.has(duelId)) {
      duel.state = 'countdown';
      player1.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
      player2.ws.send(JSON.stringify({ type: 'quickDrawCountdown' }));
      
      // Set a random time for the draw signal (1-8 seconds)
      const drawTime = 1000 + Math.floor(Math.random() * 7000);
      duel.drawTimeout = setTimeout(() => {
        if (quickDrawDuels.has(duelId)) {
          sendDrawSignal(duelId);
        }
      }, drawTime);
    }
  }, 1000);
}

/**
 * Send the "DRAW!" signal to both players.
 * @param {string} duelId - The duel ID
 */
function sendDrawSignal(duelId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  duel.state = 'draw';
  duel.drawTime = Date.now();
  
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  if (!player1 || !player2) {
    endQuickDrawDuel(duelId, null); // End duel if either player disconnected
    return;
  }
  
  // Send draw signal to both players
  player1.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  player2.ws.send(JSON.stringify({ type: 'quickDrawDraw' }));
  
  console.log(`Draw signal sent for duel ${duelId} in arena ${duel.arenaIndex + 1}`);
}

/**
 * Handle a player shooting in a Quick Draw duel.
 * @param {number} playerId - The player's ID
 * @param {number} targetId - The target player's ID
 * @param {number} arenaIndex - The arena index for the duel
 */
function handleQuickDrawShoot(playerId, targetId, arenaIndex) {
    playerId = Number(playerId);
    targetId = Number(targetId);
    
    console.log(`Quick Draw shoot: Player ${playerId} shot player ${targetId} in arena ${arenaIndex + 1}`);
    
    const playerData = players.get(playerId);
    
    if (!playerData || !playerData.inQuickDrawDuel) {
        console.log(`Quick Draw shoot rejected: Player ${playerId} not in a duel`);
        return; // Invalid state
    }
    
    const duelId = playerData.quickDrawDuelId;
    const duel = quickDrawDuels.get(duelId);
    
    if (!duel) {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not found`);
        return; // Invalid duel
    }
    
    // Verify arena index matches
    if (arenaIndex !== undefined && duel.arenaIndex !== arenaIndex) {
        console.error(`Arena index mismatch: expected ${duel.arenaIndex}, got ${arenaIndex}`);
        return;
    }
    
    if (duel.state !== 'draw') {
        console.log(`Quick Draw shoot rejected: Duel ${duelId} not in 'draw' state, current state: ${duel.state}`);
        return; // Can only shoot in 'draw' state
    }
    
    // Make sure the target is the opponent in this duel
    const isValidTarget = (duel.player1Id === playerId && duel.player2Id === targetId) ||
                          (duel.player2Id === playerId && duel.player1Id === targetId);
    
    if (!isValidTarget) {
        console.log(`Quick Draw shoot rejected: Invalid target ${targetId} for player ${playerId} in duel ${duelId}`);
        return; // Not shooting at the opponent
    }
    
    console.log(`Quick Draw shoot ACCEPTED: Player ${playerId} hit player ${targetId}. Ending duel ${duelId} with ${playerId} as winner`);
    
    // End the duel with this player as the winner
    endQuickDrawDuel(duelId, playerId);
}

/**
 * End a Quick Draw duel.
 * @param {string} duelId - The ID of the duel to end
 * @param {number|null} winnerId - The ID of the winning player or null if draw/aborted
 */
function endQuickDrawDuel(duelId, winnerId) {
  const duel = quickDrawDuels.get(duelId);
  
  if (!duel) {
    return; // Invalid duel
  }
  
  const arenaIndex = duel.arenaIndex;
  console.log(`Ending duel ${duelId} in arena ${arenaIndex + 1} with winner ${winnerId || 'none'}`);
  
  // Clear any pending timeouts
  if (duel.drawTimeout) {
    clearTimeout(duel.drawTimeout);
  }
  
  // Get the players
  const player1 = players.get(duel.player1Id);
  const player2 = players.get(duel.player2Id);
  
  // Update player states
  if (player1) {
    player1.inQuickDrawDuel = false;
    player1.quickDrawDuelId = null;
    
    // Notify player 1 of the result
    player1.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId
    }));
    
    // If player 1 lost, set their health to 0
    if (winnerId && winnerId !== duel.player1Id) {
      player1.health = 0;
    }
  }
  
  if (player2) {
    player2.inQuickDrawDuel = false;
    player2.quickDrawDuelId = null;
    
    // Notify player 2 of the result
    player2.ws.send(JSON.stringify({
      type: 'quickDrawEnd',
      winnerId: winnerId
    }));
    
    // If player 2 lost, set their health to 0
    if (winnerId && winnerId !== duel.player2Id) {
      player2.health = 0;
    }
  }
  
  // Remove the duel
  quickDrawDuels.delete(duelId);
}

// Heartbeat to remove stale connections
const HEARTBEAT_INTERVAL = 30000; // 30s
const CONNECTION_TIMEOUT = 60000; // 60s

setInterval(() => {
  const now = Date.now();
  for (const [id, player] of players.entries()) {
    if (now - player.lastActivity > CONNECTION_TIMEOUT) {
      console.log(`Removing stale connection for player ${id}`);
      if (player.ws.readyState === WebSocket.OPEN) {
        player.ws.close(1000, 'Connection timeout');
      }
      cleanupPlayer(id);
    } else if (player.ws.readyState === WebSocket.OPEN) {
      // keep alive
      player.ws.send(JSON.stringify({ type: 'ping' }));
    }
  }
}, HEARTBEAT_INTERVAL);

// Start server
server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  
  // If the environment variable USE_NGROK is set to 'true', start an ngrok tunnel.
  if (process.env.USE_NGROK === 'true') {
    // Dynamically require ngrok so it is only used when needed.
    const ngrok = require('ngrok');
    (async function() {
      try {
        // Connect ngrok to the same port that the server is running on.
        const url = await ngrok.connect({
          addr: PORT,
          // You can add additional ngrok options here (e.g., authtoken, subdomain, region)
        });
        console.log(`ngrok tunnel established at ${url}`);
      } catch (error) {
        console.error('Error starting ngrok tunnel:', error);
      }
    })();
  }
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('Server shutting down...');
  
  // End all Quick Draw duels
  for (const duelId of quickDrawDuels.keys()) {
    endQuickDrawDuel(duelId, null);
  }
  
  for (const [id, player] of players.entries()) {
    if (player.ws.readyState === WebSocket.OPEN) {
      player.ws.close(1000, 'Server shutting down');
    }
  }
  server.close(() => {
    console.log('Server shutdown complete.');
    process.exit(0);
  });
});
    </codebase>
</context>
